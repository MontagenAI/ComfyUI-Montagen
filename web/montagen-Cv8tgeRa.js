(function() {
  "use strict";
  try {
    if (typeof document != "undefined") {
      var elementStyle = document.createElement("style");
      elementStyle.appendChild(document.createTextNode('@charset "UTF-8";:root{--el-color-white:#ffffff;--el-color-black:#000000;--el-color-primary-rgb:64,158,255;--el-color-success-rgb:103,194,58;--el-color-warning-rgb:230,162,60;--el-color-danger-rgb:245,108,108;--el-color-error-rgb:245,108,108;--el-color-info-rgb:144,147,153;--el-font-size-extra-large:20px;--el-font-size-large:18px;--el-font-size-medium:16px;--el-font-size-base:14px;--el-font-size-small:13px;--el-font-size-extra-small:12px;--el-font-family:"Helvetica Neue",Helvetica,"PingFang SC","Hiragino Sans GB","Microsoft YaHei","微软雅黑",Arial,sans-serif;--el-font-weight-primary:500;--el-font-line-height-primary:24px;--el-index-normal:1;--el-index-top:1000;--el-index-popper:2000;--el-border-radius-base:4px;--el-border-radius-small:2px;--el-border-radius-round:20px;--el-border-radius-circle:100%;--el-transition-duration:0.3s;--el-transition-duration-fast:0.2s;--el-transition-function-ease-in-out-bezier:cubic-bezier(0.645,0.045,0.355,1);--el-transition-function-fast-bezier:cubic-bezier(0.23,1,0.32,1);--el-transition-all:all var(--el-transition-duration) var(--el-transition-function-ease-in-out-bezier);--el-transition-fade:opacity var(--el-transition-duration) var(--el-transition-function-fast-bezier);--el-transition-md-fade:transform var(--el-transition-duration) var(--el-transition-function-fast-bezier),opacity var(--el-transition-duration) var(--el-transition-function-fast-bezier);--el-transition-fade-linear:opacity var(--el-transition-duration-fast) linear;--el-transition-border:border-color var(--el-transition-duration-fast) var(--el-transition-function-ease-in-out-bezier);--el-transition-box-shadow:box-shadow var(--el-transition-duration-fast) var(--el-transition-function-ease-in-out-bezier);--el-transition-color:color var(--el-transition-duration-fast) var(--el-transition-function-ease-in-out-bezier);--el-component-size-large:40px;--el-component-size:32px;--el-component-size-small:24px;color-scheme:light;--el-color-primary:#409eff;--el-color-primary-light-3:rgb(121.3,187.1,255);--el-color-primary-light-5:rgb(159.5,206.5,255);--el-color-primary-light-7:rgb(197.7,225.9,255);--el-color-primary-light-8:rgb(216.8,235.6,255);--el-color-primary-light-9:rgb(235.9,245.3,255);--el-color-primary-dark-2:rgb(51.2,126.4,204);--el-color-success:#67c23a;--el-color-success-light-3:rgb(148.6,212.3,117.1);--el-color-success-light-5:rgb(179,224.5,156.5);--el-color-success-light-7:rgb(209.4,236.7,195.9);--el-color-success-light-8:rgb(224.6,242.8,215.6);--el-color-success-light-9:rgb(239.8,248.9,235.3);--el-color-success-dark-2:rgb(82.4,155.2,46.4);--el-color-warning:#e6a23c;--el-color-warning-light-3:rgb(237.5,189.9,118.5);--el-color-warning-light-5:rgb(242.5,208.5,157.5);--el-color-warning-light-7:rgb(247.5,227.1,196.5);--el-color-warning-light-8:rgb(250,236.4,216);--el-color-warning-light-9:rgb(252.5,245.7,235.5);--el-color-warning-dark-2:rgb(184,129.6,48);--el-color-danger:#f56c6c;--el-color-danger-light-3:rgb(248,152.1,152.1);--el-color-danger-light-5:rgb(250,181.5,181.5);--el-color-danger-light-7:rgb(252,210.9,210.9);--el-color-danger-light-8:rgb(253,225.6,225.6);--el-color-danger-light-9:rgb(254,240.3,240.3);--el-color-danger-dark-2:rgb(196,86.4,86.4);--el-color-error:#f56c6c;--el-color-error-light-3:rgb(248,152.1,152.1);--el-color-error-light-5:rgb(250,181.5,181.5);--el-color-error-light-7:rgb(252,210.9,210.9);--el-color-error-light-8:rgb(253,225.6,225.6);--el-color-error-light-9:rgb(254,240.3,240.3);--el-color-error-dark-2:rgb(196,86.4,86.4);--el-color-info:#909399;--el-color-info-light-3:rgb(177.3,179.4,183.6);--el-color-info-light-5:rgb(199.5,201,204);--el-color-info-light-7:rgb(221.7,222.6,224.4);--el-color-info-light-8:rgb(232.8,233.4,234.6);--el-color-info-light-9:rgb(243.9,244.2,244.8);--el-color-info-dark-2:rgb(115.2,117.6,122.4);--el-bg-color:#ffffff;--el-bg-color-page:#f2f3f5;--el-bg-color-overlay:#ffffff;--el-text-color-primary:#303133;--el-text-color-regular:#606266;--el-text-color-secondary:#909399;--el-text-color-placeholder:#a8abb2;--el-text-color-disabled:#c0c4cc;--el-border-color:#dcdfe6;--el-border-color-light:#e4e7ed;--el-border-color-lighter:#ebeef5;--el-border-color-extra-light:#f2f6fc;--el-border-color-dark:#d4d7de;--el-border-color-darker:#cdd0d6;--el-fill-color:#f0f2f5;--el-fill-color-light:#f5f7fa;--el-fill-color-lighter:#fafafa;--el-fill-color-extra-light:#fafcff;--el-fill-color-dark:#ebedf0;--el-fill-color-darker:#e6e8eb;--el-fill-color-blank:#ffffff;--el-box-shadow:0px 12px 32px 4px rgba(0,0,0,0.04),0px 8px 20px rgba(0,0,0,0.08);--el-box-shadow-light:0px 0px 12px rgba(0,0,0,0.12);--el-box-shadow-lighter:0px 0px 6px rgba(0,0,0,0.12);--el-box-shadow-dark:0px 16px 48px 16px rgba(0,0,0,0.08),0px 12px 32px rgba(0,0,0,0.12),0px 8px 16px -8px rgba(0,0,0,0.16);--el-disabled-bg-color:var(--el-fill-color-light);--el-disabled-text-color:var(--el-text-color-placeholder);--el-disabled-border-color:var(--el-border-color-light);--el-overlay-color:rgba(0,0,0,0.8);--el-overlay-color-light:rgba(0,0,0,0.7);--el-overlay-color-lighter:rgba(0,0,0,0.5);--el-mask-color:rgba(255,255,255,0.9);--el-mask-color-extra-light:rgba(255,255,255,0.3);--el-border-width:1px;--el-border-style:solid;--el-border-color-hover:var(--el-text-color-disabled);--el-border:var(--el-border-width) var(--el-border-style) var(--el-border-color);--el-svg-monochrome-grey:var(--el-border-color)}.fade-in-linear-enter-active,.fade-in-linear-leave-active{transition:var(--el-transition-fade-linear)}.fade-in-linear-enter-from,.fade-in-linear-leave-to{opacity:0}.el-fade-in-linear-enter-active,.el-fade-in-linear-leave-active{transition:var(--el-transition-fade-linear)}.el-fade-in-linear-enter-from,.el-fade-in-linear-leave-to{opacity:0}.el-fade-in-enter-active,.el-fade-in-leave-active{transition:all var(--el-transition-duration) cubic-bezier(.55,0,.1,1)}.el-fade-in-enter-from,.el-fade-in-leave-active{opacity:0}.el-zoom-in-center-enter-active,.el-zoom-in-center-leave-active{transition:all var(--el-transition-duration) cubic-bezier(.55,0,.1,1)}.el-zoom-in-center-enter-from,.el-zoom-in-center-leave-active{opacity:0;transform:scaleX(0)}.el-zoom-in-top-enter-active,.el-zoom-in-top-leave-active{opacity:1;transform:scaleY(1);transform-origin:center top;transition:var(--el-transition-md-fade)}.el-zoom-in-top-enter-active[data-popper-placement^=top],.el-zoom-in-top-leave-active[data-popper-placement^=top]{transform-origin:center bottom}.el-zoom-in-top-enter-from,.el-zoom-in-top-leave-active{opacity:0;transform:scaleY(0)}.el-zoom-in-bottom-enter-active,.el-zoom-in-bottom-leave-active{opacity:1;transform:scaleY(1);transform-origin:center bottom;transition:var(--el-transition-md-fade)}.el-zoom-in-bottom-enter-from,.el-zoom-in-bottom-leave-active{opacity:0;transform:scaleY(0)}.el-zoom-in-left-enter-active,.el-zoom-in-left-leave-active{opacity:1;transform:scale(1);transform-origin:top left;transition:var(--el-transition-md-fade)}.el-zoom-in-left-enter-from,.el-zoom-in-left-leave-active{opacity:0;transform:scale(.45)}.collapse-transition{transition:var(--el-transition-duration) height ease-in-out,var(--el-transition-duration) padding-top ease-in-out,var(--el-transition-duration) padding-bottom ease-in-out}.el-collapse-transition-enter-active,.el-collapse-transition-leave-active{transition:var(--el-transition-duration) max-height ease-in-out,var(--el-transition-duration) padding-top ease-in-out,var(--el-transition-duration) padding-bottom ease-in-out}.horizontal-collapse-transition{transition:var(--el-transition-duration) width ease-in-out,var(--el-transition-duration) padding-left ease-in-out,var(--el-transition-duration) padding-right ease-in-out}.el-list-enter-active,.el-list-leave-active{transition:all 1s}.el-list-enter-from,.el-list-leave-to{opacity:0;transform:translateY(-30px)}.el-list-leave-active{position:absolute!important}.el-opacity-transition{transition:opacity var(--el-transition-duration) cubic-bezier(.55,0,.1,1)}.el-icon-loading{animation:rotating 2s linear infinite}.el-icon--right{margin-left:5px}.el-icon--left{margin-right:5px}@keyframes rotating{0%{transform:rotate(0deg)}to{transform:rotate(1turn)}}.el-icon{--color:inherit;align-items:center;display:inline-flex;height:1em;justify-content:center;line-height:1em;position:relative;width:1em;fill:currentColor;color:var(--color);font-size:inherit}.el-icon.is-loading{animation:rotating 2s linear infinite}.el-icon svg{height:1em;width:1em}.el-form{--el-form-label-font-size:var(--el-font-size-base);--el-form-inline-content-width:220px}.el-form--inline .el-form-item{display:inline-flex;margin-right:32px;vertical-align:middle}.el-form--inline.el-form--label-top{display:flex;flex-wrap:wrap}.el-form--inline.el-form--label-top .el-form-item{display:block}.el-form-item{display:flex;--font-size:14px;margin-bottom:18px}.el-form-item .el-form-item{margin-bottom:0}.el-form-item .el-input__validateIcon{display:none}.el-form-item--large{--font-size:14px;--el-form-label-font-size:var(--font-size);margin-bottom:22px}.el-form-item--large .el-form-item__label{height:40px;line-height:40px}.el-form-item--large .el-form-item__content{line-height:40px}.el-form-item--large .el-form-item__error{padding-top:4px}.el-form-item--default{--font-size:14px;--el-form-label-font-size:var(--font-size);margin-bottom:18px}.el-form-item--default .el-form-item__label{height:32px;line-height:32px}.el-form-item--default .el-form-item__content{line-height:32px}.el-form-item--default .el-form-item__error{padding-top:2px}.el-form-item--small{--font-size:12px;--el-form-label-font-size:var(--font-size);margin-bottom:18px}.el-form-item--small .el-form-item__label{height:24px;line-height:24px}.el-form-item--small .el-form-item__content{line-height:24px}.el-form-item--small .el-form-item__error{padding-top:2px}.el-form-item--label-left .el-form-item__label{justify-content:flex-start}.el-form-item--label-top{display:block}.el-form-item--label-top .el-form-item__label{display:inline-block;height:auto;line-height:22px;margin-bottom:8px;text-align:left;vertical-align:middle}.el-form-item__label-wrap{display:flex}.el-form-item__label{align-items:flex-start;box-sizing:border-box;color:var(--el-text-color-regular);display:inline-flex;flex:0 0 auto;font-size:var(--el-form-label-font-size);height:32px;justify-content:flex-end;line-height:32px;padding:0 12px 0 0}.el-form-item__content{align-items:center;display:flex;flex:1;flex-wrap:wrap;font-size:var(--font-size);line-height:32px;min-width:0;position:relative}.el-form-item__content .el-input-group{vertical-align:top}.el-form-item__error{color:var(--el-color-danger);font-size:12px;left:0;line-height:1;padding-top:2px;position:absolute;top:100%}.el-form-item__error--inline{display:inline-block;left:auto;margin-left:10px;position:relative;top:auto}.el-form-item.is-required:not(.is-no-asterisk).asterisk-left>.el-form-item__label-wrap>.el-form-item__label:before,.el-form-item.is-required:not(.is-no-asterisk).asterisk-left>.el-form-item__label:before{color:var(--el-color-danger);content:"*";margin-right:4px}.el-form-item.is-required:not(.is-no-asterisk).asterisk-right>.el-form-item__label-wrap>.el-form-item__label:after,.el-form-item.is-required:not(.is-no-asterisk).asterisk-right>.el-form-item__label:after{color:var(--el-color-danger);content:"*";margin-left:4px}.el-form-item.is-error .el-input-tag__wrapper,.el-form-item.is-error .el-input-tag__wrapper.is-focus,.el-form-item.is-error .el-input-tag__wrapper:focus,.el-form-item.is-error .el-input-tag__wrapper:hover,.el-form-item.is-error .el-input__wrapper,.el-form-item.is-error .el-input__wrapper.is-focus,.el-form-item.is-error .el-input__wrapper:focus,.el-form-item.is-error .el-input__wrapper:hover,.el-form-item.is-error .el-select__wrapper,.el-form-item.is-error .el-select__wrapper.is-focus,.el-form-item.is-error .el-select__wrapper:focus,.el-form-item.is-error .el-select__wrapper:hover,.el-form-item.is-error .el-textarea__inner,.el-form-item.is-error .el-textarea__inner.is-focus,.el-form-item.is-error .el-textarea__inner:focus,.el-form-item.is-error .el-textarea__inner:hover{box-shadow:0 0 0 1px var(--el-color-danger) inset}.el-form-item.is-error .el-input-group__append .el-input__wrapper,.el-form-item.is-error .el-input-group__prepend .el-input__wrapper{box-shadow:inset 0 0 0 1px transparent}.el-form-item.is-error .el-input-group__append .el-input__validateIcon,.el-form-item.is-error .el-input-group__prepend .el-input__validateIcon{display:none}.el-form-item.is-error .el-input__validateIcon{color:var(--el-color-danger)}.el-form-item--feedback .el-input__validateIcon{display:inline-flex}.el-textarea{--el-input-text-color:var(--el-text-color-regular);--el-input-border:var(--el-border);--el-input-hover-border:var(--el-border-color-hover);--el-input-focus-border:var(--el-color-primary);--el-input-transparent-border:0 0 0 1px transparent inset;--el-input-border-color:var(--el-border-color);--el-input-border-radius:var(--el-border-radius-base);--el-input-bg-color:var(--el-fill-color-blank);--el-input-icon-color:var(--el-text-color-placeholder);--el-input-placeholder-color:var(--el-text-color-placeholder);--el-input-hover-border-color:var(--el-border-color-hover);--el-input-clear-hover-color:var(--el-text-color-secondary);--el-input-focus-border-color:var(--el-color-primary);--el-input-width:100%;display:inline-block;font-size:var(--el-font-size-base);position:relative;vertical-align:bottom;width:100%}.el-textarea__inner{-webkit-appearance:none;background-color:var(--el-input-bg-color,var(--el-fill-color-blank));background-image:none;border:none;border-radius:var(--el-input-border-radius,var(--el-border-radius-base));box-shadow:0 0 0 1px var(--el-input-border-color,var(--el-border-color)) inset;box-sizing:border-box;color:var(--el-input-text-color,var(--el-text-color-regular));display:block;font-family:inherit;font-size:inherit;line-height:1.5;padding:5px 11px;position:relative;resize:vertical;transition:var(--el-transition-box-shadow);width:100%}.el-textarea__inner::-moz-placeholder{color:var(--el-input-placeholder-color,var(--el-text-color-placeholder))}.el-textarea__inner::placeholder{color:var(--el-input-placeholder-color,var(--el-text-color-placeholder))}.el-textarea__inner:hover{box-shadow:0 0 0 1px var(--el-input-hover-border-color) inset}.el-textarea__inner:focus{box-shadow:0 0 0 1px var(--el-input-focus-border-color) inset;outline:none}.el-textarea .el-input__count{background:var(--el-fill-color-blank);bottom:5px;color:var(--el-color-info);font-size:12px;line-height:14px;position:absolute;right:10px}.el-textarea.is-disabled .el-textarea__inner{background-color:var(--el-disabled-bg-color);box-shadow:0 0 0 1px var(--el-disabled-border-color) inset;color:var(--el-disabled-text-color);cursor:not-allowed}.el-textarea.is-disabled .el-textarea__inner::-moz-placeholder{color:var(--el-text-color-placeholder)}.el-textarea.is-disabled .el-textarea__inner::placeholder{color:var(--el-text-color-placeholder)}.el-textarea.is-exceed .el-textarea__inner{box-shadow:0 0 0 1px var(--el-color-danger) inset}.el-textarea.is-exceed .el-input__count{color:var(--el-color-danger)}.el-input{--el-input-text-color:var(--el-text-color-regular);--el-input-border:var(--el-border);--el-input-hover-border:var(--el-border-color-hover);--el-input-focus-border:var(--el-color-primary);--el-input-transparent-border:0 0 0 1px transparent inset;--el-input-border-color:var(--el-border-color);--el-input-border-radius:var(--el-border-radius-base);--el-input-bg-color:var(--el-fill-color-blank);--el-input-icon-color:var(--el-text-color-placeholder);--el-input-placeholder-color:var(--el-text-color-placeholder);--el-input-hover-border-color:var(--el-border-color-hover);--el-input-clear-hover-color:var(--el-text-color-secondary);--el-input-focus-border-color:var(--el-color-primary);--el-input-width:100%;--el-input-height:var(--el-component-size);box-sizing:border-box;display:inline-flex;font-size:var(--el-font-size-base);line-height:var(--el-input-height);position:relative;vertical-align:middle;width:var(--el-input-width)}.el-input::-webkit-scrollbar{width:6px;z-index:11}.el-input::-webkit-scrollbar:horizontal{height:6px}.el-input::-webkit-scrollbar-thumb{background:var(--el-text-color-disabled);border-radius:5px;width:6px}.el-input::-webkit-scrollbar-corner,.el-input::-webkit-scrollbar-track{background:var(--el-fill-color-blank)}.el-input::-webkit-scrollbar-track-piece{background:var(--el-fill-color-blank);width:6px}.el-input .el-input__clear,.el-input .el-input__password{color:var(--el-input-icon-color);cursor:pointer;font-size:14px}.el-input .el-input__clear:hover,.el-input .el-input__password:hover{color:var(--el-input-clear-hover-color)}.el-input .el-input__count{align-items:center;color:var(--el-color-info);display:inline-flex;font-size:12px;height:100%}.el-input .el-input__count .el-input__count-inner{background:var(--el-fill-color-blank);display:inline-block;line-height:normal;padding-left:8px}.el-input__wrapper{align-items:center;background-color:var(--el-input-bg-color,var(--el-fill-color-blank));background-image:none;border-radius:var(--el-input-border-radius,var(--el-border-radius-base));box-shadow:0 0 0 1px var(--el-input-border-color,var(--el-border-color)) inset;cursor:text;display:inline-flex;flex-grow:1;justify-content:center;padding:1px 11px;transform:translateZ(0);transition:var(--el-transition-box-shadow)}.el-input__wrapper:hover{box-shadow:0 0 0 1px var(--el-input-hover-border-color) inset}.el-input__wrapper.is-focus{box-shadow:0 0 0 1px var(--el-input-focus-border-color) inset}.el-input__inner{--el-input-inner-height:calc(var(--el-input-height, 32px) - 2px);-webkit-appearance:none;background:none;border:none;box-sizing:border-box;color:var(--el-input-text-color,var(--el-text-color-regular));flex-grow:1;font-size:inherit;height:var(--el-input-inner-height);line-height:var(--el-input-inner-height);outline:none;padding:0;width:100%}.el-input__inner:focus{outline:none}.el-input__inner::-moz-placeholder{color:var(--el-input-placeholder-color,var(--el-text-color-placeholder))}.el-input__inner::placeholder{color:var(--el-input-placeholder-color,var(--el-text-color-placeholder))}.el-input__inner[type=password]::-ms-reveal{display:none}.el-input__inner[type=number]{line-height:1}.el-input__prefix{color:var(--el-input-icon-color,var(--el-text-color-placeholder));display:inline-flex;flex-shrink:0;flex-wrap:nowrap;height:100%;pointer-events:none;text-align:center;transition:all var(--el-transition-duration);white-space:nowrap}.el-input__prefix-inner{align-items:center;display:inline-flex;justify-content:center;pointer-events:all}.el-input__prefix-inner>:last-child{margin-right:8px}.el-input__prefix-inner>:first-child,.el-input__prefix-inner>:first-child.el-input__icon{margin-left:0}.el-input__suffix{color:var(--el-input-icon-color,var(--el-text-color-placeholder));display:inline-flex;flex-shrink:0;flex-wrap:nowrap;height:100%;pointer-events:none;text-align:center;transition:all var(--el-transition-duration);white-space:nowrap}.el-input__suffix-inner{align-items:center;display:inline-flex;justify-content:center;pointer-events:all}.el-input__suffix-inner>:first-child{margin-left:8px}.el-input .el-input__icon{align-items:center;display:flex;height:inherit;justify-content:center;line-height:inherit;margin-left:8px;transition:all var(--el-transition-duration)}.el-input__validateIcon{pointer-events:none}.el-input.is-active .el-input__wrapper{box-shadow:0 0 0 1px var(--el-input-focus-color, ) inset}.el-input.is-disabled{cursor:not-allowed}.el-input.is-disabled .el-input__wrapper{background-color:var(--el-disabled-bg-color);box-shadow:0 0 0 1px var(--el-disabled-border-color) inset;cursor:not-allowed}.el-input.is-disabled .el-input__inner{color:var(--el-disabled-text-color);-webkit-text-fill-color:var(--el-disabled-text-color);cursor:not-allowed}.el-input.is-disabled .el-input__inner::-moz-placeholder{color:var(--el-text-color-placeholder)}.el-input.is-disabled .el-input__inner::placeholder{color:var(--el-text-color-placeholder)}.el-input.is-disabled .el-input__icon{cursor:not-allowed}.el-input.is-exceed .el-input__wrapper{box-shadow:0 0 0 1px var(--el-color-danger) inset}.el-input.is-exceed .el-input__suffix .el-input__count{color:var(--el-color-danger)}.el-input--large{--el-input-height:var(--el-component-size-large);font-size:14px}.el-input--large .el-input__wrapper{padding:1px 15px}.el-input--large .el-input__inner{--el-input-inner-height:calc(var(--el-input-height, 40px) - 2px)}.el-input--small{--el-input-height:var(--el-component-size-small);font-size:12px}.el-input--small .el-input__wrapper{padding:1px 7px}.el-input--small .el-input__inner{--el-input-inner-height:calc(var(--el-input-height, 24px) - 2px)}.el-input-group{align-items:stretch;display:inline-flex;width:100%}.el-input-group__append,.el-input-group__prepend{align-items:center;background-color:var(--el-fill-color-light);border-radius:var(--el-input-border-radius);color:var(--el-color-info);display:inline-flex;justify-content:center;min-height:100%;padding:0 20px;position:relative;white-space:nowrap}.el-input-group__append:focus,.el-input-group__prepend:focus{outline:none}.el-input-group__append .el-button,.el-input-group__append .el-select,.el-input-group__prepend .el-button,.el-input-group__prepend .el-select{display:inline-block;margin:0 -20px}.el-input-group__append button.el-button,.el-input-group__append button.el-button:hover,.el-input-group__append div.el-select .el-select__wrapper,.el-input-group__append div.el-select:hover .el-select__wrapper,.el-input-group__prepend button.el-button,.el-input-group__prepend button.el-button:hover,.el-input-group__prepend div.el-select .el-select__wrapper,.el-input-group__prepend div.el-select:hover .el-select__wrapper{background-color:transparent;border-color:transparent;color:inherit}.el-input-group__append .el-button,.el-input-group__append .el-input,.el-input-group__prepend .el-button,.el-input-group__prepend .el-input{font-size:inherit}.el-input-group__prepend{border-bottom-right-radius:0;border-right:0;border-top-right-radius:0;box-shadow:1px 0 0 0 var(--el-input-border-color) inset,0 1px 0 0 var(--el-input-border-color) inset,0 -1px 0 0 var(--el-input-border-color) inset}.el-input-group__append{border-left:0;box-shadow:0 1px 0 0 var(--el-input-border-color) inset,0 -1px 0 0 var(--el-input-border-color) inset,-1px 0 0 0 var(--el-input-border-color) inset}.el-input-group--prepend>.el-input__wrapper,.el-input-group__append{border-bottom-left-radius:0;border-top-left-radius:0}.el-input-group--prepend .el-input-group__prepend .el-select .el-select__wrapper{border-bottom-right-radius:0;border-top-right-radius:0;box-shadow:1px 0 0 0 var(--el-input-border-color) inset,0 1px 0 0 var(--el-input-border-color) inset,0 -1px 0 0 var(--el-input-border-color) inset}.el-input-group--append>.el-input__wrapper{border-bottom-right-radius:0;border-top-right-radius:0}.el-input-group--append .el-input-group__append .el-select .el-select__wrapper{border-bottom-left-radius:0;border-top-left-radius:0;box-shadow:0 1px 0 0 var(--el-input-border-color) inset,0 -1px 0 0 var(--el-input-border-color) inset,-1px 0 0 0 var(--el-input-border-color) inset}.el-input-hidden{display:none!important}.el-row{box-sizing:border-box;display:flex;flex-wrap:wrap;position:relative}.el-row.is-justify-center{justify-content:center}.el-row.is-justify-end{justify-content:flex-end}.el-row.is-justify-space-between{justify-content:space-between}.el-row.is-justify-space-around{justify-content:space-around}.el-row.is-justify-space-evenly{justify-content:space-evenly}.el-row.is-align-top{align-items:flex-start}.el-row.is-align-middle{align-items:center}.el-row.is-align-bottom{align-items:flex-end}[class*=el-col-]{box-sizing:border-box}[class*=el-col-].is-guttered{display:block;min-height:1px}.el-col-0{flex:0 0 0%;max-width:0}.el-col-0,.el-col-0.is-guttered{display:none}.el-col-offset-0{margin-left:0}.el-col-pull-0{position:relative;right:0}.el-col-push-0{left:0;position:relative}.el-col-1{flex:0 0 4.1666666667%;max-width:4.1666666667%}.el-col-1,.el-col-1.is-guttered{display:block}.el-col-offset-1{margin-left:4.1666666667%}.el-col-pull-1{position:relative;right:4.1666666667%}.el-col-push-1{left:4.1666666667%;position:relative}.el-col-2{flex:0 0 8.3333333333%;max-width:8.3333333333%}.el-col-2,.el-col-2.is-guttered{display:block}.el-col-offset-2{margin-left:8.3333333333%}.el-col-pull-2{position:relative;right:8.3333333333%}.el-col-push-2{left:8.3333333333%;position:relative}.el-col-3{flex:0 0 12.5%;max-width:12.5%}.el-col-3,.el-col-3.is-guttered{display:block}.el-col-offset-3{margin-left:12.5%}.el-col-pull-3{position:relative;right:12.5%}.el-col-push-3{left:12.5%;position:relative}.el-col-4{flex:0 0 16.6666666667%;max-width:16.6666666667%}.el-col-4,.el-col-4.is-guttered{display:block}.el-col-offset-4{margin-left:16.6666666667%}.el-col-pull-4{position:relative;right:16.6666666667%}.el-col-push-4{left:16.6666666667%;position:relative}.el-col-5{flex:0 0 20.8333333333%;max-width:20.8333333333%}.el-col-5,.el-col-5.is-guttered{display:block}.el-col-offset-5{margin-left:20.8333333333%}.el-col-pull-5{position:relative;right:20.8333333333%}.el-col-push-5{left:20.8333333333%;position:relative}.el-col-6{flex:0 0 25%;max-width:25%}.el-col-6,.el-col-6.is-guttered{display:block}.el-col-offset-6{margin-left:25%}.el-col-pull-6{position:relative;right:25%}.el-col-push-6{left:25%;position:relative}.el-col-7{flex:0 0 29.1666666667%;max-width:29.1666666667%}.el-col-7,.el-col-7.is-guttered{display:block}.el-col-offset-7{margin-left:29.1666666667%}.el-col-pull-7{position:relative;right:29.1666666667%}.el-col-push-7{left:29.1666666667%;position:relative}.el-col-8{flex:0 0 33.3333333333%;max-width:33.3333333333%}.el-col-8,.el-col-8.is-guttered{display:block}.el-col-offset-8{margin-left:33.3333333333%}.el-col-pull-8{position:relative;right:33.3333333333%}.el-col-push-8{left:33.3333333333%;position:relative}.el-col-9{flex:0 0 37.5%;max-width:37.5%}.el-col-9,.el-col-9.is-guttered{display:block}.el-col-offset-9{margin-left:37.5%}.el-col-pull-9{position:relative;right:37.5%}.el-col-push-9{left:37.5%;position:relative}.el-col-10{flex:0 0 41.6666666667%;max-width:41.6666666667%}.el-col-10,.el-col-10.is-guttered{display:block}.el-col-offset-10{margin-left:41.6666666667%}.el-col-pull-10{position:relative;right:41.6666666667%}.el-col-push-10{left:41.6666666667%;position:relative}.el-col-11{flex:0 0 45.8333333333%;max-width:45.8333333333%}.el-col-11,.el-col-11.is-guttered{display:block}.el-col-offset-11{margin-left:45.8333333333%}.el-col-pull-11{position:relative;right:45.8333333333%}.el-col-push-11{left:45.8333333333%;position:relative}.el-col-12{flex:0 0 50%;max-width:50%}.el-col-12,.el-col-12.is-guttered{display:block}.el-col-offset-12{margin-left:50%}.el-col-pull-12{position:relative;right:50%}.el-col-push-12{left:50%;position:relative}.el-col-13{flex:0 0 54.1666666667%;max-width:54.1666666667%}.el-col-13,.el-col-13.is-guttered{display:block}.el-col-offset-13{margin-left:54.1666666667%}.el-col-pull-13{position:relative;right:54.1666666667%}.el-col-push-13{left:54.1666666667%;position:relative}.el-col-14{flex:0 0 58.3333333333%;max-width:58.3333333333%}.el-col-14,.el-col-14.is-guttered{display:block}.el-col-offset-14{margin-left:58.3333333333%}.el-col-pull-14{position:relative;right:58.3333333333%}.el-col-push-14{left:58.3333333333%;position:relative}.el-col-15{flex:0 0 62.5%;max-width:62.5%}.el-col-15,.el-col-15.is-guttered{display:block}.el-col-offset-15{margin-left:62.5%}.el-col-pull-15{position:relative;right:62.5%}.el-col-push-15{left:62.5%;position:relative}.el-col-16{flex:0 0 66.6666666667%;max-width:66.6666666667%}.el-col-16,.el-col-16.is-guttered{display:block}.el-col-offset-16{margin-left:66.6666666667%}.el-col-pull-16{position:relative;right:66.6666666667%}.el-col-push-16{left:66.6666666667%;position:relative}.el-col-17{flex:0 0 70.8333333333%;max-width:70.8333333333%}.el-col-17,.el-col-17.is-guttered{display:block}.el-col-offset-17{margin-left:70.8333333333%}.el-col-pull-17{position:relative;right:70.8333333333%}.el-col-push-17{left:70.8333333333%;position:relative}.el-col-18{flex:0 0 75%;max-width:75%}.el-col-18,.el-col-18.is-guttered{display:block}.el-col-offset-18{margin-left:75%}.el-col-pull-18{position:relative;right:75%}.el-col-push-18{left:75%;position:relative}.el-col-19{flex:0 0 79.1666666667%;max-width:79.1666666667%}.el-col-19,.el-col-19.is-guttered{display:block}.el-col-offset-19{margin-left:79.1666666667%}.el-col-pull-19{position:relative;right:79.1666666667%}.el-col-push-19{left:79.1666666667%;position:relative}.el-col-20{flex:0 0 83.3333333333%;max-width:83.3333333333%}.el-col-20,.el-col-20.is-guttered{display:block}.el-col-offset-20{margin-left:83.3333333333%}.el-col-pull-20{position:relative;right:83.3333333333%}.el-col-push-20{left:83.3333333333%;position:relative}.el-col-21{flex:0 0 87.5%;max-width:87.5%}.el-col-21,.el-col-21.is-guttered{display:block}.el-col-offset-21{margin-left:87.5%}.el-col-pull-21{position:relative;right:87.5%}.el-col-push-21{left:87.5%;position:relative}.el-col-22{flex:0 0 91.6666666667%;max-width:91.6666666667%}.el-col-22,.el-col-22.is-guttered{display:block}.el-col-offset-22{margin-left:91.6666666667%}.el-col-pull-22{position:relative;right:91.6666666667%}.el-col-push-22{left:91.6666666667%;position:relative}.el-col-23{flex:0 0 95.8333333333%;max-width:95.8333333333%}.el-col-23,.el-col-23.is-guttered{display:block}.el-col-offset-23{margin-left:95.8333333333%}.el-col-pull-23{position:relative;right:95.8333333333%}.el-col-push-23{left:95.8333333333%;position:relative}.el-col-24{flex:0 0 100%;max-width:100%}.el-col-24,.el-col-24.is-guttered{display:block}.el-col-offset-24{margin-left:100%}.el-col-pull-24{position:relative;right:100%}.el-col-push-24{left:100%;position:relative}@media only screen and (max-width:767px){.el-col-xs-0{display:none;flex:0 0 0%;max-width:0}.el-col-xs-0.is-guttered{display:none}.el-col-xs-offset-0{margin-left:0}.el-col-xs-pull-0{position:relative;right:0}.el-col-xs-push-0{left:0;position:relative}.el-col-xs-1{flex:0 0 4.1666666667%;max-width:4.1666666667%}.el-col-xs-1,.el-col-xs-1.is-guttered{display:block}.el-col-xs-offset-1{margin-left:4.1666666667%}.el-col-xs-pull-1{position:relative;right:4.1666666667%}.el-col-xs-push-1{left:4.1666666667%;position:relative}.el-col-xs-2{flex:0 0 8.3333333333%;max-width:8.3333333333%}.el-col-xs-2,.el-col-xs-2.is-guttered{display:block}.el-col-xs-offset-2{margin-left:8.3333333333%}.el-col-xs-pull-2{position:relative;right:8.3333333333%}.el-col-xs-push-2{left:8.3333333333%;position:relative}.el-col-xs-3{flex:0 0 12.5%;max-width:12.5%}.el-col-xs-3,.el-col-xs-3.is-guttered{display:block}.el-col-xs-offset-3{margin-left:12.5%}.el-col-xs-pull-3{position:relative;right:12.5%}.el-col-xs-push-3{left:12.5%;position:relative}.el-col-xs-4{flex:0 0 16.6666666667%;max-width:16.6666666667%}.el-col-xs-4,.el-col-xs-4.is-guttered{display:block}.el-col-xs-offset-4{margin-left:16.6666666667%}.el-col-xs-pull-4{position:relative;right:16.6666666667%}.el-col-xs-push-4{left:16.6666666667%;position:relative}.el-col-xs-5{flex:0 0 20.8333333333%;max-width:20.8333333333%}.el-col-xs-5,.el-col-xs-5.is-guttered{display:block}.el-col-xs-offset-5{margin-left:20.8333333333%}.el-col-xs-pull-5{position:relative;right:20.8333333333%}.el-col-xs-push-5{left:20.8333333333%;position:relative}.el-col-xs-6{flex:0 0 25%;max-width:25%}.el-col-xs-6,.el-col-xs-6.is-guttered{display:block}.el-col-xs-offset-6{margin-left:25%}.el-col-xs-pull-6{position:relative;right:25%}.el-col-xs-push-6{left:25%;position:relative}.el-col-xs-7{flex:0 0 29.1666666667%;max-width:29.1666666667%}.el-col-xs-7,.el-col-xs-7.is-guttered{display:block}.el-col-xs-offset-7{margin-left:29.1666666667%}.el-col-xs-pull-7{position:relative;right:29.1666666667%}.el-col-xs-push-7{left:29.1666666667%;position:relative}.el-col-xs-8{flex:0 0 33.3333333333%;max-width:33.3333333333%}.el-col-xs-8,.el-col-xs-8.is-guttered{display:block}.el-col-xs-offset-8{margin-left:33.3333333333%}.el-col-xs-pull-8{position:relative;right:33.3333333333%}.el-col-xs-push-8{left:33.3333333333%;position:relative}.el-col-xs-9{flex:0 0 37.5%;max-width:37.5%}.el-col-xs-9,.el-col-xs-9.is-guttered{display:block}.el-col-xs-offset-9{margin-left:37.5%}.el-col-xs-pull-9{position:relative;right:37.5%}.el-col-xs-push-9{left:37.5%;position:relative}.el-col-xs-10{display:block;flex:0 0 41.6666666667%;max-width:41.6666666667%}.el-col-xs-10.is-guttered{display:block}.el-col-xs-offset-10{margin-left:41.6666666667%}.el-col-xs-pull-10{position:relative;right:41.6666666667%}.el-col-xs-push-10{left:41.6666666667%;position:relative}.el-col-xs-11{display:block;flex:0 0 45.8333333333%;max-width:45.8333333333%}.el-col-xs-11.is-guttered{display:block}.el-col-xs-offset-11{margin-left:45.8333333333%}.el-col-xs-pull-11{position:relative;right:45.8333333333%}.el-col-xs-push-11{left:45.8333333333%;position:relative}.el-col-xs-12{display:block;flex:0 0 50%;max-width:50%}.el-col-xs-12.is-guttered{display:block}.el-col-xs-offset-12{margin-left:50%}.el-col-xs-pull-12{position:relative;right:50%}.el-col-xs-push-12{left:50%;position:relative}.el-col-xs-13{display:block;flex:0 0 54.1666666667%;max-width:54.1666666667%}.el-col-xs-13.is-guttered{display:block}.el-col-xs-offset-13{margin-left:54.1666666667%}.el-col-xs-pull-13{position:relative;right:54.1666666667%}.el-col-xs-push-13{left:54.1666666667%;position:relative}.el-col-xs-14{display:block;flex:0 0 58.3333333333%;max-width:58.3333333333%}.el-col-xs-14.is-guttered{display:block}.el-col-xs-offset-14{margin-left:58.3333333333%}.el-col-xs-pull-14{position:relative;right:58.3333333333%}.el-col-xs-push-14{left:58.3333333333%;position:relative}.el-col-xs-15{display:block;flex:0 0 62.5%;max-width:62.5%}.el-col-xs-15.is-guttered{display:block}.el-col-xs-offset-15{margin-left:62.5%}.el-col-xs-pull-15{position:relative;right:62.5%}.el-col-xs-push-15{left:62.5%;position:relative}.el-col-xs-16{display:block;flex:0 0 66.6666666667%;max-width:66.6666666667%}.el-col-xs-16.is-guttered{display:block}.el-col-xs-offset-16{margin-left:66.6666666667%}.el-col-xs-pull-16{position:relative;right:66.6666666667%}.el-col-xs-push-16{left:66.6666666667%;position:relative}.el-col-xs-17{display:block;flex:0 0 70.8333333333%;max-width:70.8333333333%}.el-col-xs-17.is-guttered{display:block}.el-col-xs-offset-17{margin-left:70.8333333333%}.el-col-xs-pull-17{position:relative;right:70.8333333333%}.el-col-xs-push-17{left:70.8333333333%;position:relative}.el-col-xs-18{display:block;flex:0 0 75%;max-width:75%}.el-col-xs-18.is-guttered{display:block}.el-col-xs-offset-18{margin-left:75%}.el-col-xs-pull-18{position:relative;right:75%}.el-col-xs-push-18{left:75%;position:relative}.el-col-xs-19{display:block;flex:0 0 79.1666666667%;max-width:79.1666666667%}.el-col-xs-19.is-guttered{display:block}.el-col-xs-offset-19{margin-left:79.1666666667%}.el-col-xs-pull-19{position:relative;right:79.1666666667%}.el-col-xs-push-19{left:79.1666666667%;position:relative}.el-col-xs-20{display:block;flex:0 0 83.3333333333%;max-width:83.3333333333%}.el-col-xs-20.is-guttered{display:block}.el-col-xs-offset-20{margin-left:83.3333333333%}.el-col-xs-pull-20{position:relative;right:83.3333333333%}.el-col-xs-push-20{left:83.3333333333%;position:relative}.el-col-xs-21{display:block;flex:0 0 87.5%;max-width:87.5%}.el-col-xs-21.is-guttered{display:block}.el-col-xs-offset-21{margin-left:87.5%}.el-col-xs-pull-21{position:relative;right:87.5%}.el-col-xs-push-21{left:87.5%;position:relative}.el-col-xs-22{display:block;flex:0 0 91.6666666667%;max-width:91.6666666667%}.el-col-xs-22.is-guttered{display:block}.el-col-xs-offset-22{margin-left:91.6666666667%}.el-col-xs-pull-22{position:relative;right:91.6666666667%}.el-col-xs-push-22{left:91.6666666667%;position:relative}.el-col-xs-23{display:block;flex:0 0 95.8333333333%;max-width:95.8333333333%}.el-col-xs-23.is-guttered{display:block}.el-col-xs-offset-23{margin-left:95.8333333333%}.el-col-xs-pull-23{position:relative;right:95.8333333333%}.el-col-xs-push-23{left:95.8333333333%;position:relative}.el-col-xs-24{display:block;flex:0 0 100%;max-width:100%}.el-col-xs-24.is-guttered{display:block}.el-col-xs-offset-24{margin-left:100%}.el-col-xs-pull-24{position:relative;right:100%}.el-col-xs-push-24{left:100%;position:relative}}@media only screen and (min-width:768px){.el-col-sm-0{display:none;flex:0 0 0%;max-width:0}.el-col-sm-0.is-guttered{display:none}.el-col-sm-offset-0{margin-left:0}.el-col-sm-pull-0{position:relative;right:0}.el-col-sm-push-0{left:0;position:relative}.el-col-sm-1{flex:0 0 4.1666666667%;max-width:4.1666666667%}.el-col-sm-1,.el-col-sm-1.is-guttered{display:block}.el-col-sm-offset-1{margin-left:4.1666666667%}.el-col-sm-pull-1{position:relative;right:4.1666666667%}.el-col-sm-push-1{left:4.1666666667%;position:relative}.el-col-sm-2{flex:0 0 8.3333333333%;max-width:8.3333333333%}.el-col-sm-2,.el-col-sm-2.is-guttered{display:block}.el-col-sm-offset-2{margin-left:8.3333333333%}.el-col-sm-pull-2{position:relative;right:8.3333333333%}.el-col-sm-push-2{left:8.3333333333%;position:relative}.el-col-sm-3{flex:0 0 12.5%;max-width:12.5%}.el-col-sm-3,.el-col-sm-3.is-guttered{display:block}.el-col-sm-offset-3{margin-left:12.5%}.el-col-sm-pull-3{position:relative;right:12.5%}.el-col-sm-push-3{left:12.5%;position:relative}.el-col-sm-4{flex:0 0 16.6666666667%;max-width:16.6666666667%}.el-col-sm-4,.el-col-sm-4.is-guttered{display:block}.el-col-sm-offset-4{margin-left:16.6666666667%}.el-col-sm-pull-4{position:relative;right:16.6666666667%}.el-col-sm-push-4{left:16.6666666667%;position:relative}.el-col-sm-5{flex:0 0 20.8333333333%;max-width:20.8333333333%}.el-col-sm-5,.el-col-sm-5.is-guttered{display:block}.el-col-sm-offset-5{margin-left:20.8333333333%}.el-col-sm-pull-5{position:relative;right:20.8333333333%}.el-col-sm-push-5{left:20.8333333333%;position:relative}.el-col-sm-6{flex:0 0 25%;max-width:25%}.el-col-sm-6,.el-col-sm-6.is-guttered{display:block}.el-col-sm-offset-6{margin-left:25%}.el-col-sm-pull-6{position:relative;right:25%}.el-col-sm-push-6{left:25%;position:relative}.el-col-sm-7{flex:0 0 29.1666666667%;max-width:29.1666666667%}.el-col-sm-7,.el-col-sm-7.is-guttered{display:block}.el-col-sm-offset-7{margin-left:29.1666666667%}.el-col-sm-pull-7{position:relative;right:29.1666666667%}.el-col-sm-push-7{left:29.1666666667%;position:relative}.el-col-sm-8{flex:0 0 33.3333333333%;max-width:33.3333333333%}.el-col-sm-8,.el-col-sm-8.is-guttered{display:block}.el-col-sm-offset-8{margin-left:33.3333333333%}.el-col-sm-pull-8{position:relative;right:33.3333333333%}.el-col-sm-push-8{left:33.3333333333%;position:relative}.el-col-sm-9{flex:0 0 37.5%;max-width:37.5%}.el-col-sm-9,.el-col-sm-9.is-guttered{display:block}.el-col-sm-offset-9{margin-left:37.5%}.el-col-sm-pull-9{position:relative;right:37.5%}.el-col-sm-push-9{left:37.5%;position:relative}.el-col-sm-10{display:block;flex:0 0 41.6666666667%;max-width:41.6666666667%}.el-col-sm-10.is-guttered{display:block}.el-col-sm-offset-10{margin-left:41.6666666667%}.el-col-sm-pull-10{position:relative;right:41.6666666667%}.el-col-sm-push-10{left:41.6666666667%;position:relative}.el-col-sm-11{display:block;flex:0 0 45.8333333333%;max-width:45.8333333333%}.el-col-sm-11.is-guttered{display:block}.el-col-sm-offset-11{margin-left:45.8333333333%}.el-col-sm-pull-11{position:relative;right:45.8333333333%}.el-col-sm-push-11{left:45.8333333333%;position:relative}.el-col-sm-12{display:block;flex:0 0 50%;max-width:50%}.el-col-sm-12.is-guttered{display:block}.el-col-sm-offset-12{margin-left:50%}.el-col-sm-pull-12{position:relative;right:50%}.el-col-sm-push-12{left:50%;position:relative}.el-col-sm-13{display:block;flex:0 0 54.1666666667%;max-width:54.1666666667%}.el-col-sm-13.is-guttered{display:block}.el-col-sm-offset-13{margin-left:54.1666666667%}.el-col-sm-pull-13{position:relative;right:54.1666666667%}.el-col-sm-push-13{left:54.1666666667%;position:relative}.el-col-sm-14{display:block;flex:0 0 58.3333333333%;max-width:58.3333333333%}.el-col-sm-14.is-guttered{display:block}.el-col-sm-offset-14{margin-left:58.3333333333%}.el-col-sm-pull-14{position:relative;right:58.3333333333%}.el-col-sm-push-14{left:58.3333333333%;position:relative}.el-col-sm-15{display:block;flex:0 0 62.5%;max-width:62.5%}.el-col-sm-15.is-guttered{display:block}.el-col-sm-offset-15{margin-left:62.5%}.el-col-sm-pull-15{position:relative;right:62.5%}.el-col-sm-push-15{left:62.5%;position:relative}.el-col-sm-16{display:block;flex:0 0 66.6666666667%;max-width:66.6666666667%}.el-col-sm-16.is-guttered{display:block}.el-col-sm-offset-16{margin-left:66.6666666667%}.el-col-sm-pull-16{position:relative;right:66.6666666667%}.el-col-sm-push-16{left:66.6666666667%;position:relative}.el-col-sm-17{display:block;flex:0 0 70.8333333333%;max-width:70.8333333333%}.el-col-sm-17.is-guttered{display:block}.el-col-sm-offset-17{margin-left:70.8333333333%}.el-col-sm-pull-17{position:relative;right:70.8333333333%}.el-col-sm-push-17{left:70.8333333333%;position:relative}.el-col-sm-18{display:block;flex:0 0 75%;max-width:75%}.el-col-sm-18.is-guttered{display:block}.el-col-sm-offset-18{margin-left:75%}.el-col-sm-pull-18{position:relative;right:75%}.el-col-sm-push-18{left:75%;position:relative}.el-col-sm-19{display:block;flex:0 0 79.1666666667%;max-width:79.1666666667%}.el-col-sm-19.is-guttered{display:block}.el-col-sm-offset-19{margin-left:79.1666666667%}.el-col-sm-pull-19{position:relative;right:79.1666666667%}.el-col-sm-push-19{left:79.1666666667%;position:relative}.el-col-sm-20{display:block;flex:0 0 83.3333333333%;max-width:83.3333333333%}.el-col-sm-20.is-guttered{display:block}.el-col-sm-offset-20{margin-left:83.3333333333%}.el-col-sm-pull-20{position:relative;right:83.3333333333%}.el-col-sm-push-20{left:83.3333333333%;position:relative}.el-col-sm-21{display:block;flex:0 0 87.5%;max-width:87.5%}.el-col-sm-21.is-guttered{display:block}.el-col-sm-offset-21{margin-left:87.5%}.el-col-sm-pull-21{position:relative;right:87.5%}.el-col-sm-push-21{left:87.5%;position:relative}.el-col-sm-22{display:block;flex:0 0 91.6666666667%;max-width:91.6666666667%}.el-col-sm-22.is-guttered{display:block}.el-col-sm-offset-22{margin-left:91.6666666667%}.el-col-sm-pull-22{position:relative;right:91.6666666667%}.el-col-sm-push-22{left:91.6666666667%;position:relative}.el-col-sm-23{display:block;flex:0 0 95.8333333333%;max-width:95.8333333333%}.el-col-sm-23.is-guttered{display:block}.el-col-sm-offset-23{margin-left:95.8333333333%}.el-col-sm-pull-23{position:relative;right:95.8333333333%}.el-col-sm-push-23{left:95.8333333333%;position:relative}.el-col-sm-24{display:block;flex:0 0 100%;max-width:100%}.el-col-sm-24.is-guttered{display:block}.el-col-sm-offset-24{margin-left:100%}.el-col-sm-pull-24{position:relative;right:100%}.el-col-sm-push-24{left:100%;position:relative}}@media only screen and (min-width:992px){.el-col-md-0{display:none;flex:0 0 0%;max-width:0}.el-col-md-0.is-guttered{display:none}.el-col-md-offset-0{margin-left:0}.el-col-md-pull-0{position:relative;right:0}.el-col-md-push-0{left:0;position:relative}.el-col-md-1{flex:0 0 4.1666666667%;max-width:4.1666666667%}.el-col-md-1,.el-col-md-1.is-guttered{display:block}.el-col-md-offset-1{margin-left:4.1666666667%}.el-col-md-pull-1{position:relative;right:4.1666666667%}.el-col-md-push-1{left:4.1666666667%;position:relative}.el-col-md-2{flex:0 0 8.3333333333%;max-width:8.3333333333%}.el-col-md-2,.el-col-md-2.is-guttered{display:block}.el-col-md-offset-2{margin-left:8.3333333333%}.el-col-md-pull-2{position:relative;right:8.3333333333%}.el-col-md-push-2{left:8.3333333333%;position:relative}.el-col-md-3{flex:0 0 12.5%;max-width:12.5%}.el-col-md-3,.el-col-md-3.is-guttered{display:block}.el-col-md-offset-3{margin-left:12.5%}.el-col-md-pull-3{position:relative;right:12.5%}.el-col-md-push-3{left:12.5%;position:relative}.el-col-md-4{flex:0 0 16.6666666667%;max-width:16.6666666667%}.el-col-md-4,.el-col-md-4.is-guttered{display:block}.el-col-md-offset-4{margin-left:16.6666666667%}.el-col-md-pull-4{position:relative;right:16.6666666667%}.el-col-md-push-4{left:16.6666666667%;position:relative}.el-col-md-5{flex:0 0 20.8333333333%;max-width:20.8333333333%}.el-col-md-5,.el-col-md-5.is-guttered{display:block}.el-col-md-offset-5{margin-left:20.8333333333%}.el-col-md-pull-5{position:relative;right:20.8333333333%}.el-col-md-push-5{left:20.8333333333%;position:relative}.el-col-md-6{flex:0 0 25%;max-width:25%}.el-col-md-6,.el-col-md-6.is-guttered{display:block}.el-col-md-offset-6{margin-left:25%}.el-col-md-pull-6{position:relative;right:25%}.el-col-md-push-6{left:25%;position:relative}.el-col-md-7{flex:0 0 29.1666666667%;max-width:29.1666666667%}.el-col-md-7,.el-col-md-7.is-guttered{display:block}.el-col-md-offset-7{margin-left:29.1666666667%}.el-col-md-pull-7{position:relative;right:29.1666666667%}.el-col-md-push-7{left:29.1666666667%;position:relative}.el-col-md-8{flex:0 0 33.3333333333%;max-width:33.3333333333%}.el-col-md-8,.el-col-md-8.is-guttered{display:block}.el-col-md-offset-8{margin-left:33.3333333333%}.el-col-md-pull-8{position:relative;right:33.3333333333%}.el-col-md-push-8{left:33.3333333333%;position:relative}.el-col-md-9{flex:0 0 37.5%;max-width:37.5%}.el-col-md-9,.el-col-md-9.is-guttered{display:block}.el-col-md-offset-9{margin-left:37.5%}.el-col-md-pull-9{position:relative;right:37.5%}.el-col-md-push-9{left:37.5%;position:relative}.el-col-md-10{display:block;flex:0 0 41.6666666667%;max-width:41.6666666667%}.el-col-md-10.is-guttered{display:block}.el-col-md-offset-10{margin-left:41.6666666667%}.el-col-md-pull-10{position:relative;right:41.6666666667%}.el-col-md-push-10{left:41.6666666667%;position:relative}.el-col-md-11{display:block;flex:0 0 45.8333333333%;max-width:45.8333333333%}.el-col-md-11.is-guttered{display:block}.el-col-md-offset-11{margin-left:45.8333333333%}.el-col-md-pull-11{position:relative;right:45.8333333333%}.el-col-md-push-11{left:45.8333333333%;position:relative}.el-col-md-12{display:block;flex:0 0 50%;max-width:50%}.el-col-md-12.is-guttered{display:block}.el-col-md-offset-12{margin-left:50%}.el-col-md-pull-12{position:relative;right:50%}.el-col-md-push-12{left:50%;position:relative}.el-col-md-13{display:block;flex:0 0 54.1666666667%;max-width:54.1666666667%}.el-col-md-13.is-guttered{display:block}.el-col-md-offset-13{margin-left:54.1666666667%}.el-col-md-pull-13{position:relative;right:54.1666666667%}.el-col-md-push-13{left:54.1666666667%;position:relative}.el-col-md-14{display:block;flex:0 0 58.3333333333%;max-width:58.3333333333%}.el-col-md-14.is-guttered{display:block}.el-col-md-offset-14{margin-left:58.3333333333%}.el-col-md-pull-14{position:relative;right:58.3333333333%}.el-col-md-push-14{left:58.3333333333%;position:relative}.el-col-md-15{display:block;flex:0 0 62.5%;max-width:62.5%}.el-col-md-15.is-guttered{display:block}.el-col-md-offset-15{margin-left:62.5%}.el-col-md-pull-15{position:relative;right:62.5%}.el-col-md-push-15{left:62.5%;position:relative}.el-col-md-16{display:block;flex:0 0 66.6666666667%;max-width:66.6666666667%}.el-col-md-16.is-guttered{display:block}.el-col-md-offset-16{margin-left:66.6666666667%}.el-col-md-pull-16{position:relative;right:66.6666666667%}.el-col-md-push-16{left:66.6666666667%;position:relative}.el-col-md-17{display:block;flex:0 0 70.8333333333%;max-width:70.8333333333%}.el-col-md-17.is-guttered{display:block}.el-col-md-offset-17{margin-left:70.8333333333%}.el-col-md-pull-17{position:relative;right:70.8333333333%}.el-col-md-push-17{left:70.8333333333%;position:relative}.el-col-md-18{display:block;flex:0 0 75%;max-width:75%}.el-col-md-18.is-guttered{display:block}.el-col-md-offset-18{margin-left:75%}.el-col-md-pull-18{position:relative;right:75%}.el-col-md-push-18{left:75%;position:relative}.el-col-md-19{display:block;flex:0 0 79.1666666667%;max-width:79.1666666667%}.el-col-md-19.is-guttered{display:block}.el-col-md-offset-19{margin-left:79.1666666667%}.el-col-md-pull-19{position:relative;right:79.1666666667%}.el-col-md-push-19{left:79.1666666667%;position:relative}.el-col-md-20{display:block;flex:0 0 83.3333333333%;max-width:83.3333333333%}.el-col-md-20.is-guttered{display:block}.el-col-md-offset-20{margin-left:83.3333333333%}.el-col-md-pull-20{position:relative;right:83.3333333333%}.el-col-md-push-20{left:83.3333333333%;position:relative}.el-col-md-21{display:block;flex:0 0 87.5%;max-width:87.5%}.el-col-md-21.is-guttered{display:block}.el-col-md-offset-21{margin-left:87.5%}.el-col-md-pull-21{position:relative;right:87.5%}.el-col-md-push-21{left:87.5%;position:relative}.el-col-md-22{display:block;flex:0 0 91.6666666667%;max-width:91.6666666667%}.el-col-md-22.is-guttered{display:block}.el-col-md-offset-22{margin-left:91.6666666667%}.el-col-md-pull-22{position:relative;right:91.6666666667%}.el-col-md-push-22{left:91.6666666667%;position:relative}.el-col-md-23{display:block;flex:0 0 95.8333333333%;max-width:95.8333333333%}.el-col-md-23.is-guttered{display:block}.el-col-md-offset-23{margin-left:95.8333333333%}.el-col-md-pull-23{position:relative;right:95.8333333333%}.el-col-md-push-23{left:95.8333333333%;position:relative}.el-col-md-24{display:block;flex:0 0 100%;max-width:100%}.el-col-md-24.is-guttered{display:block}.el-col-md-offset-24{margin-left:100%}.el-col-md-pull-24{position:relative;right:100%}.el-col-md-push-24{left:100%;position:relative}}@media only screen and (min-width:1200px){.el-col-lg-0{display:none;flex:0 0 0%;max-width:0}.el-col-lg-0.is-guttered{display:none}.el-col-lg-offset-0{margin-left:0}.el-col-lg-pull-0{position:relative;right:0}.el-col-lg-push-0{left:0;position:relative}.el-col-lg-1{flex:0 0 4.1666666667%;max-width:4.1666666667%}.el-col-lg-1,.el-col-lg-1.is-guttered{display:block}.el-col-lg-offset-1{margin-left:4.1666666667%}.el-col-lg-pull-1{position:relative;right:4.1666666667%}.el-col-lg-push-1{left:4.1666666667%;position:relative}.el-col-lg-2{flex:0 0 8.3333333333%;max-width:8.3333333333%}.el-col-lg-2,.el-col-lg-2.is-guttered{display:block}.el-col-lg-offset-2{margin-left:8.3333333333%}.el-col-lg-pull-2{position:relative;right:8.3333333333%}.el-col-lg-push-2{left:8.3333333333%;position:relative}.el-col-lg-3{flex:0 0 12.5%;max-width:12.5%}.el-col-lg-3,.el-col-lg-3.is-guttered{display:block}.el-col-lg-offset-3{margin-left:12.5%}.el-col-lg-pull-3{position:relative;right:12.5%}.el-col-lg-push-3{left:12.5%;position:relative}.el-col-lg-4{flex:0 0 16.6666666667%;max-width:16.6666666667%}.el-col-lg-4,.el-col-lg-4.is-guttered{display:block}.el-col-lg-offset-4{margin-left:16.6666666667%}.el-col-lg-pull-4{position:relative;right:16.6666666667%}.el-col-lg-push-4{left:16.6666666667%;position:relative}.el-col-lg-5{flex:0 0 20.8333333333%;max-width:20.8333333333%}.el-col-lg-5,.el-col-lg-5.is-guttered{display:block}.el-col-lg-offset-5{margin-left:20.8333333333%}.el-col-lg-pull-5{position:relative;right:20.8333333333%}.el-col-lg-push-5{left:20.8333333333%;position:relative}.el-col-lg-6{flex:0 0 25%;max-width:25%}.el-col-lg-6,.el-col-lg-6.is-guttered{display:block}.el-col-lg-offset-6{margin-left:25%}.el-col-lg-pull-6{position:relative;right:25%}.el-col-lg-push-6{left:25%;position:relative}.el-col-lg-7{flex:0 0 29.1666666667%;max-width:29.1666666667%}.el-col-lg-7,.el-col-lg-7.is-guttered{display:block}.el-col-lg-offset-7{margin-left:29.1666666667%}.el-col-lg-pull-7{position:relative;right:29.1666666667%}.el-col-lg-push-7{left:29.1666666667%;position:relative}.el-col-lg-8{flex:0 0 33.3333333333%;max-width:33.3333333333%}.el-col-lg-8,.el-col-lg-8.is-guttered{display:block}.el-col-lg-offset-8{margin-left:33.3333333333%}.el-col-lg-pull-8{position:relative;right:33.3333333333%}.el-col-lg-push-8{left:33.3333333333%;position:relative}.el-col-lg-9{flex:0 0 37.5%;max-width:37.5%}.el-col-lg-9,.el-col-lg-9.is-guttered{display:block}.el-col-lg-offset-9{margin-left:37.5%}.el-col-lg-pull-9{position:relative;right:37.5%}.el-col-lg-push-9{left:37.5%;position:relative}.el-col-lg-10{display:block;flex:0 0 41.6666666667%;max-width:41.6666666667%}.el-col-lg-10.is-guttered{display:block}.el-col-lg-offset-10{margin-left:41.6666666667%}.el-col-lg-pull-10{position:relative;right:41.6666666667%}.el-col-lg-push-10{left:41.6666666667%;position:relative}.el-col-lg-11{display:block;flex:0 0 45.8333333333%;max-width:45.8333333333%}.el-col-lg-11.is-guttered{display:block}.el-col-lg-offset-11{margin-left:45.8333333333%}.el-col-lg-pull-11{position:relative;right:45.8333333333%}.el-col-lg-push-11{left:45.8333333333%;position:relative}.el-col-lg-12{display:block;flex:0 0 50%;max-width:50%}.el-col-lg-12.is-guttered{display:block}.el-col-lg-offset-12{margin-left:50%}.el-col-lg-pull-12{position:relative;right:50%}.el-col-lg-push-12{left:50%;position:relative}.el-col-lg-13{display:block;flex:0 0 54.1666666667%;max-width:54.1666666667%}.el-col-lg-13.is-guttered{display:block}.el-col-lg-offset-13{margin-left:54.1666666667%}.el-col-lg-pull-13{position:relative;right:54.1666666667%}.el-col-lg-push-13{left:54.1666666667%;position:relative}.el-col-lg-14{display:block;flex:0 0 58.3333333333%;max-width:58.3333333333%}.el-col-lg-14.is-guttered{display:block}.el-col-lg-offset-14{margin-left:58.3333333333%}.el-col-lg-pull-14{position:relative;right:58.3333333333%}.el-col-lg-push-14{left:58.3333333333%;position:relative}.el-col-lg-15{display:block;flex:0 0 62.5%;max-width:62.5%}.el-col-lg-15.is-guttered{display:block}.el-col-lg-offset-15{margin-left:62.5%}.el-col-lg-pull-15{position:relative;right:62.5%}.el-col-lg-push-15{left:62.5%;position:relative}.el-col-lg-16{display:block;flex:0 0 66.6666666667%;max-width:66.6666666667%}.el-col-lg-16.is-guttered{display:block}.el-col-lg-offset-16{margin-left:66.6666666667%}.el-col-lg-pull-16{position:relative;right:66.6666666667%}.el-col-lg-push-16{left:66.6666666667%;position:relative}.el-col-lg-17{display:block;flex:0 0 70.8333333333%;max-width:70.8333333333%}.el-col-lg-17.is-guttered{display:block}.el-col-lg-offset-17{margin-left:70.8333333333%}.el-col-lg-pull-17{position:relative;right:70.8333333333%}.el-col-lg-push-17{left:70.8333333333%;position:relative}.el-col-lg-18{display:block;flex:0 0 75%;max-width:75%}.el-col-lg-18.is-guttered{display:block}.el-col-lg-offset-18{margin-left:75%}.el-col-lg-pull-18{position:relative;right:75%}.el-col-lg-push-18{left:75%;position:relative}.el-col-lg-19{display:block;flex:0 0 79.1666666667%;max-width:79.1666666667%}.el-col-lg-19.is-guttered{display:block}.el-col-lg-offset-19{margin-left:79.1666666667%}.el-col-lg-pull-19{position:relative;right:79.1666666667%}.el-col-lg-push-19{left:79.1666666667%;position:relative}.el-col-lg-20{display:block;flex:0 0 83.3333333333%;max-width:83.3333333333%}.el-col-lg-20.is-guttered{display:block}.el-col-lg-offset-20{margin-left:83.3333333333%}.el-col-lg-pull-20{position:relative;right:83.3333333333%}.el-col-lg-push-20{left:83.3333333333%;position:relative}.el-col-lg-21{display:block;flex:0 0 87.5%;max-width:87.5%}.el-col-lg-21.is-guttered{display:block}.el-col-lg-offset-21{margin-left:87.5%}.el-col-lg-pull-21{position:relative;right:87.5%}.el-col-lg-push-21{left:87.5%;position:relative}.el-col-lg-22{display:block;flex:0 0 91.6666666667%;max-width:91.6666666667%}.el-col-lg-22.is-guttered{display:block}.el-col-lg-offset-22{margin-left:91.6666666667%}.el-col-lg-pull-22{position:relative;right:91.6666666667%}.el-col-lg-push-22{left:91.6666666667%;position:relative}.el-col-lg-23{display:block;flex:0 0 95.8333333333%;max-width:95.8333333333%}.el-col-lg-23.is-guttered{display:block}.el-col-lg-offset-23{margin-left:95.8333333333%}.el-col-lg-pull-23{position:relative;right:95.8333333333%}.el-col-lg-push-23{left:95.8333333333%;position:relative}.el-col-lg-24{display:block;flex:0 0 100%;max-width:100%}.el-col-lg-24.is-guttered{display:block}.el-col-lg-offset-24{margin-left:100%}.el-col-lg-pull-24{position:relative;right:100%}.el-col-lg-push-24{left:100%;position:relative}}@media only screen and (min-width:1920px){.el-col-xl-0{display:none;flex:0 0 0%;max-width:0}.el-col-xl-0.is-guttered{display:none}.el-col-xl-offset-0{margin-left:0}.el-col-xl-pull-0{position:relative;right:0}.el-col-xl-push-0{left:0;position:relative}.el-col-xl-1{flex:0 0 4.1666666667%;max-width:4.1666666667%}.el-col-xl-1,.el-col-xl-1.is-guttered{display:block}.el-col-xl-offset-1{margin-left:4.1666666667%}.el-col-xl-pull-1{position:relative;right:4.1666666667%}.el-col-xl-push-1{left:4.1666666667%;position:relative}.el-col-xl-2{flex:0 0 8.3333333333%;max-width:8.3333333333%}.el-col-xl-2,.el-col-xl-2.is-guttered{display:block}.el-col-xl-offset-2{margin-left:8.3333333333%}.el-col-xl-pull-2{position:relative;right:8.3333333333%}.el-col-xl-push-2{left:8.3333333333%;position:relative}.el-col-xl-3{flex:0 0 12.5%;max-width:12.5%}.el-col-xl-3,.el-col-xl-3.is-guttered{display:block}.el-col-xl-offset-3{margin-left:12.5%}.el-col-xl-pull-3{position:relative;right:12.5%}.el-col-xl-push-3{left:12.5%;position:relative}.el-col-xl-4{flex:0 0 16.6666666667%;max-width:16.6666666667%}.el-col-xl-4,.el-col-xl-4.is-guttered{display:block}.el-col-xl-offset-4{margin-left:16.6666666667%}.el-col-xl-pull-4{position:relative;right:16.6666666667%}.el-col-xl-push-4{left:16.6666666667%;position:relative}.el-col-xl-5{flex:0 0 20.8333333333%;max-width:20.8333333333%}.el-col-xl-5,.el-col-xl-5.is-guttered{display:block}.el-col-xl-offset-5{margin-left:20.8333333333%}.el-col-xl-pull-5{position:relative;right:20.8333333333%}.el-col-xl-push-5{left:20.8333333333%;position:relative}.el-col-xl-6{flex:0 0 25%;max-width:25%}.el-col-xl-6,.el-col-xl-6.is-guttered{display:block}.el-col-xl-offset-6{margin-left:25%}.el-col-xl-pull-6{position:relative;right:25%}.el-col-xl-push-6{left:25%;position:relative}.el-col-xl-7{flex:0 0 29.1666666667%;max-width:29.1666666667%}.el-col-xl-7,.el-col-xl-7.is-guttered{display:block}.el-col-xl-offset-7{margin-left:29.1666666667%}.el-col-xl-pull-7{position:relative;right:29.1666666667%}.el-col-xl-push-7{left:29.1666666667%;position:relative}.el-col-xl-8{flex:0 0 33.3333333333%;max-width:33.3333333333%}.el-col-xl-8,.el-col-xl-8.is-guttered{display:block}.el-col-xl-offset-8{margin-left:33.3333333333%}.el-col-xl-pull-8{position:relative;right:33.3333333333%}.el-col-xl-push-8{left:33.3333333333%;position:relative}.el-col-xl-9{flex:0 0 37.5%;max-width:37.5%}.el-col-xl-9,.el-col-xl-9.is-guttered{display:block}.el-col-xl-offset-9{margin-left:37.5%}.el-col-xl-pull-9{position:relative;right:37.5%}.el-col-xl-push-9{left:37.5%;position:relative}.el-col-xl-10{display:block;flex:0 0 41.6666666667%;max-width:41.6666666667%}.el-col-xl-10.is-guttered{display:block}.el-col-xl-offset-10{margin-left:41.6666666667%}.el-col-xl-pull-10{position:relative;right:41.6666666667%}.el-col-xl-push-10{left:41.6666666667%;position:relative}.el-col-xl-11{display:block;flex:0 0 45.8333333333%;max-width:45.8333333333%}.el-col-xl-11.is-guttered{display:block}.el-col-xl-offset-11{margin-left:45.8333333333%}.el-col-xl-pull-11{position:relative;right:45.8333333333%}.el-col-xl-push-11{left:45.8333333333%;position:relative}.el-col-xl-12{display:block;flex:0 0 50%;max-width:50%}.el-col-xl-12.is-guttered{display:block}.el-col-xl-offset-12{margin-left:50%}.el-col-xl-pull-12{position:relative;right:50%}.el-col-xl-push-12{left:50%;position:relative}.el-col-xl-13{display:block;flex:0 0 54.1666666667%;max-width:54.1666666667%}.el-col-xl-13.is-guttered{display:block}.el-col-xl-offset-13{margin-left:54.1666666667%}.el-col-xl-pull-13{position:relative;right:54.1666666667%}.el-col-xl-push-13{left:54.1666666667%;position:relative}.el-col-xl-14{display:block;flex:0 0 58.3333333333%;max-width:58.3333333333%}.el-col-xl-14.is-guttered{display:block}.el-col-xl-offset-14{margin-left:58.3333333333%}.el-col-xl-pull-14{position:relative;right:58.3333333333%}.el-col-xl-push-14{left:58.3333333333%;position:relative}.el-col-xl-15{display:block;flex:0 0 62.5%;max-width:62.5%}.el-col-xl-15.is-guttered{display:block}.el-col-xl-offset-15{margin-left:62.5%}.el-col-xl-pull-15{position:relative;right:62.5%}.el-col-xl-push-15{left:62.5%;position:relative}.el-col-xl-16{display:block;flex:0 0 66.6666666667%;max-width:66.6666666667%}.el-col-xl-16.is-guttered{display:block}.el-col-xl-offset-16{margin-left:66.6666666667%}.el-col-xl-pull-16{position:relative;right:66.6666666667%}.el-col-xl-push-16{left:66.6666666667%;position:relative}.el-col-xl-17{display:block;flex:0 0 70.8333333333%;max-width:70.8333333333%}.el-col-xl-17.is-guttered{display:block}.el-col-xl-offset-17{margin-left:70.8333333333%}.el-col-xl-pull-17{position:relative;right:70.8333333333%}.el-col-xl-push-17{left:70.8333333333%;position:relative}.el-col-xl-18{display:block;flex:0 0 75%;max-width:75%}.el-col-xl-18.is-guttered{display:block}.el-col-xl-offset-18{margin-left:75%}.el-col-xl-pull-18{position:relative;right:75%}.el-col-xl-push-18{left:75%;position:relative}.el-col-xl-19{display:block;flex:0 0 79.1666666667%;max-width:79.1666666667%}.el-col-xl-19.is-guttered{display:block}.el-col-xl-offset-19{margin-left:79.1666666667%}.el-col-xl-pull-19{position:relative;right:79.1666666667%}.el-col-xl-push-19{left:79.1666666667%;position:relative}.el-col-xl-20{display:block;flex:0 0 83.3333333333%;max-width:83.3333333333%}.el-col-xl-20.is-guttered{display:block}.el-col-xl-offset-20{margin-left:83.3333333333%}.el-col-xl-pull-20{position:relative;right:83.3333333333%}.el-col-xl-push-20{left:83.3333333333%;position:relative}.el-col-xl-21{display:block;flex:0 0 87.5%;max-width:87.5%}.el-col-xl-21.is-guttered{display:block}.el-col-xl-offset-21{margin-left:87.5%}.el-col-xl-pull-21{position:relative;right:87.5%}.el-col-xl-push-21{left:87.5%;position:relative}.el-col-xl-22{display:block;flex:0 0 91.6666666667%;max-width:91.6666666667%}.el-col-xl-22.is-guttered{display:block}.el-col-xl-offset-22{margin-left:91.6666666667%}.el-col-xl-pull-22{position:relative;right:91.6666666667%}.el-col-xl-push-22{left:91.6666666667%;position:relative}.el-col-xl-23{display:block;flex:0 0 95.8333333333%;max-width:95.8333333333%}.el-col-xl-23.is-guttered{display:block}.el-col-xl-offset-23{margin-left:95.8333333333%}.el-col-xl-pull-23{position:relative;right:95.8333333333%}.el-col-xl-push-23{left:95.8333333333%;position:relative}.el-col-xl-24{display:block;flex:0 0 100%;max-width:100%}.el-col-xl-24.is-guttered{display:block}.el-col-xl-offset-24{margin-left:100%}.el-col-xl-pull-24{position:relative;right:100%}.el-col-xl-push-24{left:100%;position:relative}}[data-v-c6f966d9] .cus-input .el-input__wrapper {\n  background-color: #3b3b3b;\n  color: #e0e0e0;\n  box-shadow: none;\n}\n.hover-file[data-v-612919f2]:hover {\r\n  background: #3b3b3b;\r\n  border-radius: 4px;\n}\n.selected-file[data-v-612919f2] {\r\n  background: #3b3b3b;\r\n  border-radius: 4px;\r\n  box-shadow: 0 0 0 2px #3b3b3b;\n}\n.checked-icon[data-v-612919f2] {\r\n  position: absolute;\r\n  right: 5px;\r\n  top: 5px;\r\n  display: none;\n}\n.selected-file .checked-icon[data-v-612919f2] {\r\n  display: block;\n}\r\n\n.video-bg[data-v-b985c45b] {\r\n  background-color: #000;\n}\r\n.card[data-v-6302cf21] {\n  width: 100vw;\n}\n.imagen-box[data-v-6302cf21] {\n  position: fixed;\n  width: 100%;\n  height: 100vh;\n  z-index: 600;\n  bottom: 0;\n  left: 0;\n}\n.tracks[data-v-6302cf21],\n.player[data-v-6302cf21] {\n  width: 100%;\n  height: 100%;\n}\n.tracks[data-v-6302cf21] {\n  background-color: #262626;\n  background-position: center;\n  background-repeat: no-repeat;\n}\n[data-v-6302cf21] .split-container {\n  border: none;\n  border-radius: 0;\n}\n[data-v-6302cf21] .split-gutter {\n  background-color: #141414;\n}'));
      document.head.appendChild(elementStyle);
    }
  } catch (e) {
    console.error("vite-plugin-css-injected-by-js", e);
  }
})();
import { u as useMenuStore, a as app$1 } from "./assets/extensions-DduUW6TS.js";
import { r as ref$3, o as openBlock, c as createElementBlock, a as createBaseVNode, D as createVNode, d as defineComponent, x as computed, f as reactive, e as onMounted, E as withCtx, Q as unref, B as resolveComponent, z as createBlock, K as normalizeClass, P as toDisplayString, a7 as pushScopeId, a8 as popScopeId, M as Fragment, N as renderList$1, w as watch, A as createCommentVNode, G as withDirectives, a9 as createApp } from "./assets/vue-CfhKyhF1.js";
import { d as defineStore, s as storeToRefs, u as useToast, a as script, E as ElInput, b as ElFormItem, c as ElForm, e as ElIcon, f as ElCol, g as ElRow, h as script$1, i as script$2, j as script$3, T as Tooltip, C as ConfirmationService, k as ToastService, D as DialogService, l as createPinia } from "./assets/vendor-MNiR10Nx.js";
import "./assets/lodash-BQcLy69B.js";
import { j as definePreset, k as index$3, P as PrimeVue } from "./assets/primevue-B9MRtlbm.js";
import { E as ElementPlusIconsVue } from "./assets/element-plus-xoP6L-7N.js";
import "./assets/primeuix-DckMl_2U.js";
import "./assets/vueuse-DrVR0D6g.js";
const useFileStore = defineStore("fileStore", {
  state: (_) => ({
    selectFiles: [],
    outPutFormat: {
      height: "1280",
      // 图片高度
      width: "720",
      // 图片宽度
      imageLen: 1,
      // 图片张数
      fps: 60
    },
    selectClip: {},
    // 当前选中的clip项
    PlayerInstance: null
    // 初始话收的editor实例对象
  }),
  actions: {
    addFile(file) {
      this.selectFiles.push(file);
      console.log(this.selectFiles);
    },
    removeFile(file) {
      this.selectFiles = this.selectFiles.filter((item) => item.id !== file.id);
      console.log(this.selectFiles);
    },
    clearFiles() {
      this.selectFiles = [];
    },
    setOutFormat(key2, value2) {
      if (key2 in this.outPutFormat) {
        this.outPutFormat[key2] = value2;
      }
    },
    setSelectClip(clip2) {
      this.selectClip = clip2;
    },
    setPlayerInstance(player2) {
      this.PlayerInstance = player2;
    }
  }
});
const _hoisted_1$4 = { class: "w-full h-full p-2 flex" };
const _hoisted_2$2 = {
  class: "px-2 flex",
  style: { "align-items": "center" }
};
const _hoisted_3$1 = /* @__PURE__ */ createBaseVNode("div", { class: "flex-1" }, null, -1);
const _sfc_main$5 = {
  __name: "ImagenHeader",
  emits: ["validateForm"],
  setup(__props, { expose: __expose, emit: __emit }) {
    const fileStore = useFileStore();
    const menuStore = useMenuStore();
    const { outPutFormat, selectFiles, PlayerInstance } = storeToRefs(fileStore);
    const toast = useToast();
    const backMainPage = () => {
      menuStore.changeShow(false);
      fileStore.clearFiles();
    };
    let json = {};
    const loadingFlag = ref$3(false);
    const combinVideo = async () => {
      json.output = outPutFormat.value.output;
      let params = json;
      console.log(params, "需要合成的json文件");
      loadingFlag.value = true;
      try {
        let response = await app$1.api.fetchApi("/Montagen/outputs", {
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify(params)
        });
        const json2 = await response.json();
        console.log(json2);
        if (json2.success) {
          let url2 = `${window.location.origin}/view?filename=${params.output}`;
          downloadFile(url2);
        } else {
          toast.add({ severity: "error", summary: "提示", detail: "导出失败", life: 6e3 });
        }
      } catch (err) {
      } finally {
        loadingFlag.value = false;
      }
    };
    const downloadFile = (url2) => {
      const link = document.createElement("a");
      link.href = url2;
      link.download = url2.substring(url2.lastIndexOf("/") + 1);
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    };
    __expose({
      combinVideo
    });
    return (_ctx, _cache) => {
      const _component_Button = script;
      return openBlock(), createElementBlock("div", _hoisted_1$4, [
        createBaseVNode("div", _hoisted_2$2, [
          createVNode(_component_Button, {
            style: { "max-height": "42px" },
            class: "p-button-text",
            label: "BACK HOME",
            variant: "text",
            onClick: backMainPage
          })
        ]),
        _hoisted_3$1
      ]);
    };
  }
};
const _hoisted_1$3 = { class: "w-full my-2 px-4" };
const _sfc_main$4 = /* @__PURE__ */ defineComponent({
  __name: "outPutForm",
  setup(__props, { expose: __expose }) {
    const fileStore = useFileStore();
    console.log(fileStore);
    const { outPutFormat, selectClip } = storeToRefs(fileStore);
    computed(() => {
      return Object.keys(selectClip.value).length === 0;
    });
    const formLabelAlign = reactive({
      output: "",
      resolution: "",
      videoBitrate: "",
      frameRate: ""
    });
    const ruleFormRef = ref$3();
    const validateForm = async () => {
      console.log("输出表单完整性验证");
      if (!ruleFormRef.value) return;
      return new Promise((resolve, reject) => {
        var _a;
        (_a = ruleFormRef.value) == null ? void 0 : _a.validate((valid, fields) => {
          if (valid) {
            updateForm();
            resolve(true);
          } else {
            reject(false);
          }
        });
      });
    };
    const updateForm = () => {
      for (let key2 in formLabelAlign) {
        console.log(key2, formLabelAlign[key2]);
        fileStore.setOutFormat(key2, formLabelAlign[key2]);
      }
    };
    onMounted(() => {
      console.log(outPutFormat.value);
      formLabelAlign.output = outPutFormat.value.output;
      formLabelAlign.resolution = outPutFormat.value.resolution;
      formLabelAlign.videoBitrate = outPutFormat.value.videoBitrate;
      formLabelAlign.frameRate = outPutFormat.value.frameRate;
    });
    __expose({
      validateForm
    });
    return (_ctx, _cache) => {
      const _component_el_input = ElInput;
      const _component_el_form_item = ElFormItem;
      const _component_el_form = ElForm;
      return openBlock(), createElementBlock("div", _hoisted_1$3, [
        createBaseVNode("div", null, [
          createVNode(_component_el_form, {
            "label-position": "top",
            "label-width": "auto"
          }, {
            default: withCtx(() => [
              createVNode(_component_el_form_item, { label: "width" }, {
                default: withCtx(() => [
                  createVNode(_component_el_input, {
                    class: "cus-input",
                    modelValue: unref(outPutFormat).width,
                    "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => unref(outPutFormat).width = $event)
                  }, null, 8, ["modelValue"])
                ]),
                _: 1
              }),
              createVNode(_component_el_form_item, { label: "height" }, {
                default: withCtx(() => [
                  createVNode(_component_el_input, {
                    class: "cus-input",
                    modelValue: unref(outPutFormat).height,
                    "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => unref(outPutFormat).height = $event)
                  }, null, 8, ["modelValue"])
                ]),
                _: 1
              }),
              createVNode(_component_el_form_item, { label: "frames" }, {
                default: withCtx(() => [
                  createVNode(_component_el_input, {
                    class: "cus-input",
                    modelValue: unref(outPutFormat).imageLen,
                    "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => unref(outPutFormat).imageLen = $event)
                  }, null, 8, ["modelValue"])
                ]),
                _: 1
              }),
              createVNode(_component_el_form_item, { label: "fps" }, {
                default: withCtx(() => [
                  createVNode(_component_el_input, {
                    class: "cus-input",
                    modelValue: unref(outPutFormat).fps,
                    "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => unref(outPutFormat).fps = $event)
                  }, null, 8, ["modelValue"])
                ]),
                _: 1
              })
            ]),
            _: 1
          })
        ])
      ]);
    };
  }
});
const _export_sfc = (sfc, props2) => {
  const target2 = sfc.__vccOpts || sfc;
  for (const [key2, val] of props2) {
    target2[key2] = val;
  }
  return target2;
};
const outPutForm = /* @__PURE__ */ _export_sfc(_sfc_main$4, [["__scopeId", "data-v-c6f966d9"]]);
const _withScopeId = (n2) => (pushScopeId("data-v-612919f2"), n2 = n2(), popScopeId(), n2);
const _hoisted_1$2 = { class: "truncate w-full text-center mt-2" };
const _hoisted_2$1 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("img", {
  style: { "width": "60px", "height": "64px" },
  src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAAAXNSR0IArs4c6QAAAoxJREFUaEPtmt1twyAQgEEM0uYxEp6hySSNJ2kySd1J6s5gpDwmHSSiPQQRYGwoDj+pkqcKY7jv/jhzxejOf/jO5UdegOPx+FwScr1en+f2dwIMw7DBGL8hhDYlhZd7CwDO+UfTNHtbnhEAY+zTI3jngNppY7Bh75kDz23NgqV1hcEcW4EdpbTV1zYAGGMgyLtGfpB/X8copStbOAv6bM8BN7xcLrCGEmgkiJxz0tZuKaWdHAelKlcW42qeDQALwMSrEFML6xDS5WAT8eOcb5umMawwDMNeuiVMGUHC4JQiLIieUrqdAuAuAVJqOFQRmpIM+KsFdE1TSg3LpNawgnC4i+FqjDHhIYSQlcpOLoCRfzrMG+zDoRpW8+ZcTXlCLIAR4LmDWSoREsEuCqCGYGaMxQPMZQnLh6PSZYirhQKc4dRzncAY4ycwofas45x/GwcLxi9avneuhTF+1fL6aI5jn/43NX9hubbPhVyyVzXmAwBadQJXJbiqz3wAzjRaA0loDDwAUlnrYYEpzUKtZFefKayQzAKMMahiO0LIwfcJuAQsNYCo86c+/ZYIrt7NAaD2SgKSEyAJSAkAHaRdGuglARTIokCvAWBRoNcCEB0ftQEIayCEDvo9z1y6rQoASnbXVeE9APSEkDbmxC5tATjcFqXSUgB/8vOaXOjm5UQ2C8QEaEixlwMgOkBLA5yWBugtAYz795CFc80JdSFn8yGXkJ4sNH29Di/KT0Nnh6U0gN6j0PsXdotJNfiqs4JqbkADca7FZPQAcgSmz7JS83DjLZp8dv9t1Ga1OiSqYoTTdLbh7BMk4rnddoUlRgnG2eiW7Va4Aq+m0T1Vdv/PfzWIMHexV7wWKCZZ4MY/jRCBXupsSLsAAAAASUVORK5CYII=",
  alt: ""
}, null, -1));
const _hoisted_3 = [
  _hoisted_2$1
];
const _sfc_main$3 = {
  __name: "FileItem",
  props: {
    item: Object
  },
  emits: ["select", "openfile"],
  setup(__props, { emit: __emit }) {
    const emit = __emit;
    const openFile = (item) => {
      emit("openfile", item);
    };
    const onSelect = (item) => {
    };
    return (_ctx, _cache) => {
      const _component_FolderOpened = resolveComponent("FolderOpened");
      const _component_el_icon = ElIcon;
      const _component_el_col = ElCol;
      return openBlock(), createBlock(_component_el_col, { span: 8 }, {
        default: withCtx(() => [
          createBaseVNode("div", {
            class: normalizeClass(["mb-3 p-2 cursor-pointer hover-file relative selected-file", { "selected-file": __props.item.selected }])
          }, [
            __props.item.children ? (openBlock(), createElementBlock("div", {
              key: 0,
              class: "w-full flex flex-col justify-center items-center",
              onClick: _cache[0] || (_cache[0] = ($event) => openFile(__props.item))
            }, [
              createVNode(_component_el_icon, {
                size: "40",
                color: "#FED659"
              }, {
                default: withCtx(() => [
                  createVNode(_component_FolderOpened)
                ]),
                _: 1
              }),
              createBaseVNode("div", _hoisted_1$2, toDisplayString(__props.item.name), 1)
            ])) : (openBlock(), createElementBlock("div", {
              key: 1,
              class: "w-full flex flex-col justify-center items-center px-2",
              onClick: _cache[1] || (_cache[1] = ($event) => onSelect(__props.item))
            }, _hoisted_3))
          ], 2)
        ]),
        _: 1
      });
    };
  }
};
const FileItem = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["__scopeId", "data-v-612919f2"]]);
const _hoisted_1$1 = { class: "file-manager w-full h-full p-2" };
const _hoisted_2 = { class: "px-2" };
const _sfc_main$2 = {
  __name: "fileManager",
  setup(__props) {
    const fileStore = useFileStore();
    const { selectFiles } = storeToRefs(fileStore);
    let fileList = ref$3([]);
    let fileManagerList = ref$3([]);
    console.log(selectFiles.value, "selectFiles.value");
    fileManagerList.value = selectFiles.value;
    const handleSelect = (item) => {
      item.selected = !item.selected;
      if (item.selected) {
        fileStore.addFile(item);
      } else {
        fileStore.removeFile(item);
      }
    };
    const fileMap = {};
    const openFile = (item) => {
      console.log(item, "打开文件夹目录");
      if (!fileMap[item.id]) {
        fileMap[item.id] = item.children;
      }
      items.value.push({ label: item.name, id: item.id, command: (e) => breadClick(e) });
      fileManagerList.value = fileMap[item.id];
    };
    const breadClick = (e) => {
      console.log(e, "点击面包屑");
      let index2 = items.value.findIndex((item) => item.id === e.item.id);
      items.value = items.value.slice(0, index2 + 1);
      fileManagerList.value = fileMap[e.item.id];
    };
    ref$3({
      icon: "pi pi-home",
      label: "首页",
      command: (e) => {
        if (!items.value.length) return;
        fileManagerList.value = fileList.value;
        items.value = [];
      }
    });
    const items = ref$3([
      // { label: '测试一下', id: 12311, command: (e) => breadClick(e) },
      // { label: '喝酒上头' },
    ]);
    onMounted(() => {
    });
    return (_ctx, _cache) => {
      const _component_el_row = ElRow;
      return openBlock(), createElementBlock("div", _hoisted_1$1, [
        createBaseVNode("div", _hoisted_2, [
          createVNode(_component_el_row, { gutter: 8 }, {
            default: withCtx(() => [
              (openBlock(true), createElementBlock(Fragment, null, renderList$1(unref(fileManagerList), (item) => {
                return openBlock(), createBlock(FileItem, {
                  key: item.name,
                  item,
                  onSelect: handleSelect,
                  onOpenfile: openFile
                }, null, 8, ["item"]);
              }), 128))
            ]),
            _: 1
          })
        ])
      ]);
    };
  }
};
var define_process_env_default = {};
var $m = Object.defineProperty;
var jm = (i2, e, t) => e in i2 ? $m(i2, e, { enumerable: true, configurable: true, writable: true, value: t }) : i2[e] = t;
var Ct = (i2, e, t) => jm(i2, typeof e != "symbol" ? e + "" : e, t);
const hasOwnProperty$1 = Object.prototype.hasOwnProperty, prefix = "~";
class Events {
}
class Listener {
  constructor(e, t, r = false) {
    this.fn = e, this.context = t, this.once = r;
  }
}
function addListener(i2, e, t, r, a) {
  if (typeof t != "function")
    throw new TypeError("The listener must be a function");
  const s = new Listener(t, r || i2, a), u = prefix + e;
  return i2._events[u] ? i2._events[u].fn ? i2._events[u] = [i2._events[u], s] : i2._events[u].push(s) : (i2._events[u] = s, i2._eventsCount++), i2;
}
function removeListener(i2, e) {
  --i2._eventsCount === 0 ? i2._events = new Events() : delete i2._events[e];
}
let EventEmitter$1 = class {
  constructor() {
    this._events = new Events(), this._eventsCount = 0;
  }
  eventNames() {
    const e = [];
    if (this._eventsCount === 0) return e;
    for (const t in this._events)
      hasOwnProperty$1.call(this._events, t) && e.push(t.slice(1));
    return Object.getOwnPropertySymbols && e.push(...Object.getOwnPropertySymbols(this._events)), e;
  }
  listeners(e) {
    const t = prefix + e, r = this._events[t];
    return r ? r.fn ? [r.fn] : r.map((a) => a.fn) : [];
  }
  listenerCount(e) {
    const t = prefix + e, r = this._events[t];
    return r ? r.fn ? 1 : r.length : 0;
  }
  emit(e, ...t) {
    const r = prefix + e;
    if (!this._events[r]) return false;
    const a = this._events[r];
    if (a.fn)
      a.once && this.removeListener(e, a.fn, void 0, true), a.fn.apply(a.context, t);
    else
      for (let s = 0; s < a.length; s++) {
        const u = a[s];
        u.once && this.removeListener(e, u.fn, void 0, true), u.fn.apply(u.context, t);
      }
    return true;
  }
  on(e, t, r) {
    return addListener(this, e, t, r, false);
  }
  once(e, t, r) {
    return addListener(this, e, t, r, true);
  }
  removeListener(e, t, r, a) {
    const s = prefix + e;
    if (!this._events[s]) return this;
    if (!t)
      return removeListener(this, s), this;
    const u = this._events[s];
    if (u.fn) {
      if (u.fn !== t || a && !u.once || r && u.context !== r)
        return this;
      removeListener(this, s);
    } else {
      const l = u.filter(
        (c) => c.fn !== t || a && !c.once || r && c.context !== r
      );
      l.length ? this._events[s] = l.length === 1 ? l[0] : l : removeListener(this, s);
    }
    return this;
  }
  removeAllListeners(e) {
    if (e) {
      const t = prefix + e;
      this._events[t] && removeListener(this, t);
    } else
      this._events = new Events(), this._eventsCount = 0;
    return this;
  }
  off(e, t, r) {
    return this.removeListener(e, t, r);
  }
  addListener(e, t, r) {
    return this.on(e, t, r);
  }
};
EventEmitter$1.prefixed = prefix;
EventEmitter$1.EventEmitter = EventEmitter$1;
class ExtendedEventEmitter extends EventEmitter$1 {
  emit(e, t = {}) {
    t.preventDefault ? super.emit(e, t) : super.emit(e, { ...t, type: e });
  }
}
const CHANGING = "changing", CHANGED = "changed", SELECT = "select", HOVER = "hover", RESIZE = "resize", CROPFRAME = "crop-frame", OP_ADD = "op_add", OP_SPLIT = "op_split", OP_MOVE = "op_move", OP_DELETE = "op_del", OP_END = "op_end", OP_START = "op_start", OP_CHANGE = "op_change", OP_CLEAR_CACHE = "clear_cache", MAX = 99999999, TYPE_SPINE = "spine", TYPE_PLACEHOLDER = "placeholder", TYPE_VIDEO = "video", TYPE_AUDIO = "audio", TYPE_STICKER = "sticker", TYPE_TEXT = "text", VERSION$1 = "1.0.0", mixin$3 = ({ src: i2, dst: e }) => {
  const t = Object.keys(i2);
  for (let r = 0; r < t.length; ++r) {
    const a = t[r], s = Object.getOwnPropertyDescriptor(i2, a);
    Object.getOwnPropertyDescriptor(e.prototype, a) !== s && Object.defineProperty(e.prototype, a, s);
  }
}, wrap = (i2, e) => {
  const t = i2[e], r = { before: [], after: [] };
  i2[e] = function(...s) {
    r.before.forEach((l) => {
      const c = l.call(this, s);
      c !== void 0 && (s = c);
    });
    let u = t.call(this, ...s);
    return r.after.forEach((l) => {
      const c = l.call(this, s, u);
      c !== void 0 && (u = c);
    }), u;
  };
  const a = {
    before: (s) => (r.before.push(s), a),
    after: (s) => (r.after.push(s), a),
    revoke: () => {
      r.before = [], r.after = [];
    }
  };
  return a;
};
class Vector {
  constructor(...e) {
    let t, r;
    if (e.length === 1 && typeof e[0] == "object" && (e[0].nodeType === 1 ? e = this.getDomCoord(e[0]) : e[0].pageX !== void 0 && (e = [e[0].pageX, e[0].pageY])), e.length === 1 && Array.isArray(e[0]) && (e = e[0]), e.length === 2 && Array.isArray(e) && ([t, r] = e), typeof e[0] == "object") {
      this.x = e[0].x, this.y = e[0].y;
      return;
    }
    this.x = t, this.y = r;
  }
  getDomCoord(e) {
    let [t, r] = [e.offsetLeft, e.offsetTop], a = e.offsetParent;
    for (; a !== null; )
      t += a.offsetLeft, r += a.offsetTop, a = a.offsetParent;
    return [t, r];
  }
  offset(e) {
    return e = new Vector(e), new Vector({ x: this.x + e.x, y: this.y + e.y });
  }
  rebase(e) {
    return e = new Vector(e), this.offset({ x: -e.x, y: -e.y });
  }
  scale(e) {
    const t = isNaN(e) ? new Vector(e) : new Vector(e, e);
    return new Vector({ x: this.x * t.x, y: this.y * t.y });
  }
  rotate(e) {
    const [t, r] = [this.x, -this.y], a = Math.sin(e), s = Math.cos(e);
    return new Vector({ x: t * s + r * a, y: -(r * s - t * a) });
  }
  format(e = 3) {
    return { x: this.x.toFixed(e), y: this.y.toFixed(e) };
  }
}
const PositionUtils = {
  intersect: (i2, e) => {
    if (e.left > i2.right || e.right < i2.left || e.top > i2.bottom || e.bottom < i2.top)
      return;
    const [t, r] = ["left", "top"].map(
      (u) => Math.max(i2[u], e[u])
    ), [a, s] = ["right", "bottom"].map(
      (u) => Math.min(i2[u], e[u])
    );
    return new Metrics({ top: r, bottom: s, left: t, right: a });
  },
  center: (i2) => {
    const { left: e, right: t, top: r, bottom: a } = i2;
    return new Vector({ x: (e + t) / 2, y: (r + a) / 2 });
  },
  bounds: (i2) => {
    const e = { top: MAX, left: MAX, bottom: 0, right: 0 };
    return i2.forEach((t) => {
      t instanceof Vector || (t = new Vector(t));
      const { x: r, y: a } = t;
      e.top = Math.min(e.top, a), e.bottom = Math.max(e.bottom, a), e.left = Math.min(e.left, r), e.right = Math.max(e.right, r);
    }), PositionUtils.from(e);
  },
  from: (i2) => new Metrics(i2)
}, MetricsMixin = {
  get center() {
    return PositionUtils.center(this);
  },
  get position() {
    return new Vector(this.x, this.y);
  },
  xs(i2 = true) {
    return this.ss([this.left, this.right], i2);
  },
  ys(i2 = true) {
    return this.ss([this.top, this.bottom], i2);
  },
  ss(i2, e = true) {
    return e && i2.splice(1, 0, (i2[0] + i2[1]) / 2), i2;
  },
  offset(i2) {
    return this.move(i2, "offset");
  },
  rebase(i2) {
    return this.move(i2, "rebase");
  },
  move(i2, e) {
    const { x: t, y: r } = this.position[e](i2);
    return PositionUtils.from({
      x: t,
      y: r,
      width: this.width,
      height: this.height
    });
  },
  expand(i2) {
    return this.x -= i2, this.y -= i2, this.width += 2 * i2, this.height += 2 * i2, this;
  }
};
class Metrics extends DOMRect {
  constructor(...e) {
    if (e.length > 1)
      super(...e);
    else {
      const { top: t, bottom: r, left: a, right: s, x: u, y: l, width: c, height: d, w: f, h: p } = e[0], m = u !== void 0 ? u : a, y = l !== void 0 ? l : t, x = f !== void 0 ? f : c, g = x !== void 0 ? x : s - m, _ = p !== void 0 ? p : d, T = _ !== void 0 ? _ : r - y;
      super(m || 0, y || 0, g, T);
    }
  }
}
mixin$3({ src: MetricsMixin, dst: DOMRectReadOnly });
let idCounter = 0, VNode$1 = class Am extends ExtendedEventEmitter {
  constructor(e) {
    super(), this.conf = e || {}, this.type = this.conf.type || "vnode", this.id = `vn_${this.type}_${idCounter++}`, this.scale = 1, this._rotation = 0, this._anchor = { x: 0.5, y: 0.5 }, this._size = { w: 0, h: 0 }, this._position = { x: 0, y: 0 }, this._proxy = new Proxy(this, {});
  }
  static from(e) {
    return new Am().syncWith(e);
  }
  groupSelect(e) {
    return !e.groupId || e.groupId === "NULL" || !this.nodes ? (e.creator().allNodes.forEach((t) => {
      t.groupId === e.groupId && (this.nodes[t.id] = t);
    }), this.id = e.groupId, false) : true;
  }
  get display() {
    return this._proxy;
  }
  annotate() {
  }
  addEventsTo(e, t) {
    e.apply({
      node: this,
      enable: t,
      recursive: false,
      types: { group: true }
    });
  }
  creator() {
    return this.parent ? this.parent.creator() : this._proxy;
  }
  emit(e, t = {}) {
    super.emit(e, { ...t, target: this });
  }
  getAnchor() {
    return this._anchor;
  }
  getRotation() {
    return this._rotation;
  }
  getX() {
    return this.getXY()[0];
  }
  getY() {
    return this.getXY()[1];
  }
  getXY() {
    return this.metrcs().position;
  }
  getWH() {
    return this.metrcs().size;
  }
  metrcs() {
    return {
      position: [this._position.x, this._position.y],
      size: [this._size.w, this._size.h]
    };
  }
  setRotate(e) {
    return this._rotation = e, this;
  }
  setXY(e, t) {
    return this._position.x = e, this._position.y = t, this;
  }
  setWH(e, t) {
    return this._size.w = e, this._size.h = t, this;
  }
  fitSize() {
  }
  fitTexture() {
  }
  points() {
    const { w: e, h: t } = this._size, r = -e * this._anchor.x, a = -t * this._anchor.y;
    return [
      [r, a],
      [r + e, a],
      [r, a + t],
      [r + e, a + t]
    ].map(
      (s) => new Vector(s).rotate(this._rotation).offset(this._position)
    );
  }
  bounds() {
    return PositionUtils.bounds(this.points());
  }
  syncWith(e) {
    this._rotation = e.getRotation();
    const [t, r] = e.getXY(), { x: a, y: s } = e.getAnchor(), [u, l] = e.getWH();
    return this._size = { w: u, h: l }, this._anchor = { x: a, y: s }, this._position = { x: t, y: r }, this;
  }
  remove() {
    return this.parent && this.parent.removeChild(this), this;
  }
  destroy() {
    this._proxy = null, this.removeAllListeners();
  }
};
function insertStyleElement$1(i2) {
  const e = document.createElement("style");
  return i2.setAttributes(e, i2.attributes), i2.insert(e, i2.options), e;
}
function domAPI$1(i2) {
  const e = i2.insertStyleElement(i2);
  return {
    update: function(t) {
      let r = "";
      t.supports && (r += `@supports (${t.supports}) {`), t.media && (r += `@media ${t.media} {`);
      const a = t.layer !== void 0;
      a && (r += `@layer${t.layer.length > 0 ? ` ${t.layer}` : ""} {`), r += t.css, a && (r += "}"), t.media && (r += "}"), t.supports && (r += "}");
      const s = t.sourceMap;
      s && typeof btoa < "u" && (r += `
/*# sourceMappingURL=data:application/json;base64,${btoa(
        unescape(encodeURIComponent(JSON.stringify(s)))
      )} */`), i2.styleTagTransform(r, e, i2.options);
    },
    remove: function() {
      e.parentNode && e.parentNode.removeChild(e);
    }
  };
}
function styleTagTransform$1(i2, e) {
  if (e.styleSheet)
    e.styleSheet.cssText = i2;
  else {
    for (; e.firstChild; )
      e.removeChild(e.firstChild);
    e.appendChild(document.createTextNode(i2));
  }
}
function setAttributes$1(i2, e) {
  Object.keys(e).forEach((t) => {
    i2.setAttribute(t, e[t]);
  });
}
const styleTargets$1 = {};
function insert$1(i2, e) {
  const r = ((a) => {
    if (styleTargets$1[a] === void 0) {
      let s = document.querySelector(a);
      if (window.HTMLIFrameElement && s instanceof window.HTMLIFrameElement)
        try {
          s = s.contentDocument.head;
        } catch {
          s = null;
        }
      styleTargets$1[a] = s;
    }
    return styleTargets$1[a];
  })(i2);
  if (!r)
    throw new Error(
      "Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid."
    );
  r.appendChild(e);
}
function createStyleOption$1(i2 = {}) {
  const e = {
    attributes: { mira: "editor" },
    ...i2
  };
  return e.styleTagTransform = styleTagTransform$1, e.setAttributes = setAttributes$1, e.insert = insert$1.bind(null, "head"), e.domAPI = domAPI$1, e.insertStyleElement = insertStyleElement$1, e;
}
const styleCache$1 = [];
function findStyleIndex$1(i2) {
  for (let e = 0; e < styleCache$1.length; e++)
    if (styleCache$1[e].identifier === i2)
      return e;
  return -1;
}
function updateStyles$1(i2, e) {
  const t = [], r = {};
  for (let a = 0; a < i2.length; a++) {
    const s = i2[a], u = e.base ? s[0] + e.base : s[0], l = r[u] || 0, c = `${u} ${l}`;
    r[u] = l + 1;
    const d = {
      css: s[1],
      media: s[2],
      sourceMap: s[3],
      supports: s[4],
      layer: s[5]
    }, f = findStyleIndex$1(c);
    if (f !== -1)
      styleCache$1[f].references++, styleCache$1[f].updater(d);
    else {
      const p = createStyleUpdater$1(d, e);
      e.byIndex = a, styleCache$1.splice(a, 0, { identifier: c, updater: p, references: 1 });
    }
    t.push(c);
  }
  return t;
}
function createStyleUpdater$1(i2, e) {
  const t = e.domAPI(e);
  return t.update(i2), function(r) {
    if (r) {
      if (r.css === i2.css && r.media === i2.media && r.sourceMap === i2.sourceMap && r.supports === i2.supports && r.layer === i2.layer)
        return;
      t.update(i2 = r);
    } else
      t.remove();
  };
}
function createStyleManager$1(i2, e) {
  i2 = i2 || [], e = e || {};
  let t = updateStyles$1(i2, e);
  return function(r) {
    r = r || [];
    for (let s = 0; s < t.length; s++) {
      const u = findStyleIndex$1(t[s]);
      u !== -1 && styleCache$1[u].references--;
    }
    const a = updateStyles$1(r, e);
    for (let s = 0; s < t.length; s++) {
      const u = findStyleIndex$1(t[s]);
      u !== -1 && styleCache$1[u].references === 0 && (styleCache$1[u].updater(), styleCache$1.splice(u, 1));
    }
    t = a;
  };
}
function extractCss$1(i2) {
  return i2[1];
}
function createStyleListInner$1(i2) {
  const e = [];
  return e.toString = function() {
    return this.map((t) => {
      let r = "";
      return t[4] && (r += `@supports (${t[4]}) {`), t[2] && (r += `@media ${t[2]} {`), t[5] !== void 0 && (r += `@layer${t[5].length > 0 ? ` ${t[5]}` : ""} {`), r += i2(t), t[5] !== void 0 && (r += "}"), t[2] && (r += "}"), t[4] && (r += "}"), r;
    }).join("");
  }, e.i = function(t, r, a, s, u) {
    typeof t == "string" && (t = [[null, t, void 0]]);
    const l = {};
    if (s)
      for (let c = 0; c < this.length; c++) {
        const d = this[c][0];
        d !== null && (l[d] = true);
      }
    for (let c = 0; c < t.length; c++) {
      const d = [...t[c]];
      (!s || !l[d[0]]) && (u !== void 0 && (d[5] !== void 0 && (d[1] = `@layer${d[5].length > 0 ? ` ${d[5]}` : ""} {${d[1]}}`), d[5] = u), r && (d[2] && (d[1] = `@media ${d[2]} {${d[1]}}`), d[2] = r), a && (d[4] && (d[1] = `@supports (${d[4]}) {${d[1]}}`), d[4] = a), e.push(d));
    }
  }, e;
}
function createStyleList$1() {
  return createStyleListInner$1(extractCss$1);
}
const styleList$c = createStyleList$1();
styleList$c.push([
  19,
  `
  *[mira-editor-el] {
    position: absolute;
    box-sizing: border-box;
    pointer-events: none;
    margin: 0;
    padding: 0;
  }
  *[mira-editor-el] .hide {
    opacity: 0 !important;
    pointer-events: none !important;
    cursor: default !important;
  }
  *[mira-editor-el] .hide:after {
    opacity: 0 !important;
    transition-property: opacity, width, height;
    transition-duration: 0.3s;
  }
  .mira-editor[mira-editor-el] {
    position: relative;
    user-select: none;
  }
  .mirae-debug-box[mira-editor-el] {
    border: 1px dotted #C00 !important;
  }
  .mirae-center-cross[mira-editor-el] {
    margin: 0;
  }
  .mirae-center-cross[mira-editor-el]:before {
    left: 50%;
    top: 0;
    bottom: 0;
    width: 1px;
  }
  .mirae-center-cross[mira-editor-el]:after {
    top: 50%;
    left: 0;
    right: 0;
    height: 1px;
  }
  .mirae-center-cross[mira-editor-el]:before,
  .mirae-center-cross[mira-editor-el]:after {
    content: '';
    position: absolute;
    background: red;
  }
  .mirae-box[mira-editor-el] {
    border: 2px solid var(--miraeBorderColor);
    display: flex;
    align-items: center;
    justify-content: center;
    transform: translate(var(--x), var(--y)) rotate(var(--rotate));
    /* <- order matters!! */
    transition-duration: 0;
  }
  .mirae-box[mira-editor-el].mirae-box-none[mira-editor-el] {
    border: 0px;
  }
  .mirae-box[mira-editor-el].editMode {
    border: 2px dashed var(--miraeBorderColor) !important;
  }
  .mirae-box[mira-editor-el] .mira-editor-group[mira-editor-el] {
    width: 0px;
    height: 0px;
    border-radius: 0px;
    transform-origin: 50% 50%;
  }
  .mirae-box[mira-editor-el].group {
    border-style: dashed!important;
  }
  .mirae-box[mira-editor-el].copy {
    background-color: rgba(0, 0, 0, 0.5);
  }
  .mirae-box[mira-editor-el].ani {
    transition-duration: 0.3s;
    transition-property: width, height, transform;
  }
  .mirae-box[mira-editor-el] * {
    pointer-events: none;
    box-sizing: border-box;
    margin: 0;
    padding: 0;
  }
  .mirae-box[mira-editor-el].mirae-selected {
    border-color: var(--miraeSelBorderColor);
    z-index: 2!important;
  }
  .mirae-box[mira-editor-el] .mirae-box-handles[mira-editor-el] {
    border: 0;
    position: relative;
    /*background: #000;*/
    display: flex;
    width: 128px;
    height: 32px;
    align-items: center;
    justify-content: center;
    pointer-events: none;
  }
  .mirae-box[mira-editor-el] .side {
    transform: rotate(90deg);
  }
  .mirae-box[mira-editor-el] .mirae-box-handles.top {
    top: -50%;
    margin-top: -48px;
  }
  .mirae-box[mira-editor-el] .mirae-box-handles.bottom {
    bottom: -50%;
    margin-bottom: -48px;
  }
  .mirae-box[mira-editor-el] .mirae-box-handles.left {
    left: -50%;
    margin-left: -48px;
    transform: rotate(90deg);
  }
  .mirae-box[mira-editor-el] .mirae-box-handles.right {
    right: -50%;
    margin-right: -48px;
    transform: rotate(90deg);
  }
  `,
  ""
]);
createStyleManager$1(styleList$c, createStyleOption$1());
styleList$c.locals && styleList$c.locals;
const Utils$1 = {
  zip: (i2, e) => Object.assign(...i2.map((t, r) => ({ [t]: e[r] }))),
  ucfirst: (i2) => i2 ? i2.charAt(0).toUpperCase() + i2.slice(1) : "",
  dmap: (i2, e, t = []) => {
    if (typeof i2 != "object") return e(i2);
    const r = Array.isArray(i2) ? [] : {}, a = Array.isArray(i2) ? i2.map((s, u) => [u, s]) : Object.entries(i2);
    for (const [s, u] of a) {
      const l = [...t, s];
      r[s] = typeof u == "object" ? Utils$1.dmap(u, e, l) : e(u, s, l);
    }
    return r;
  },
  uuid: () => {
    let i2 = (/* @__PURE__ */ new Date()).getTime(), e = typeof performance < "u" && performance.now && 1e3 * performance.now() || 0;
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(t) {
      let r = 16 * Math.random();
      return i2 > 0 ? (r = (i2 + r) % 16 | 0, i2 = Math.floor(i2 / 16)) : (r = (e + r) % 16 | 0, e = Math.floor(e / 16)), (t === "x" ? r : 3 & r | 8).toString(16);
    }).toUpperCase();
  },
  short: (i2, e, t = 0) => {
    if (!i2) return i2;
    const r = Array.from(i2);
    if (r.length < e || e < t) return i2;
    const a = t > 0 ? r.slice(-t).join("") : "";
    return `${r.slice(0, e - t - 3).join("")}...${a}`;
  }
}, zip = Utils$1.zip, ucfirst = Utils$1.ucfirst, dmap = Utils$1.dmap, uuid = Utils$1.uuid, short = Utils$1.short, MathUtils = {
  deg: (i2, e = 0) => {
    for (; i2 < 0; ) i2 += 2 * Math.PI;
    for (; i2 > Math.PI; ) i2 -= 2 * Math.PI;
    return MathUtils.round(i2 * (180 / Math.PI) % 360, e);
  },
  rad: (i2, e = 9) => MathUtils.round(i2 * (Math.PI / 180), e),
  round: (i2, e = 0) => typeof i2 == "object" ? dmap(i2, (t) => MathUtils.round(t, e)) : isNaN(i2) ? i2 : Number(i2.toFixed(e)),
  floor: (i2, e = 0) => MathUtils.apply(Math.floor, i2, e),
  ceil: (i2, e = 0) => MathUtils.apply(Math.ceil, i2, e),
  apply: (i2, e, t = 0) => {
    const r = Math.pow(10, t);
    return Number((i2(e * r) / r).toFixed(t));
  },
  theta: (i2, e) => {
    const t = new Vector(i2), r = new Vector(e);
    return Math.acos(
      MathUtils.dot(t, r) / (MathUtils.norm2d(t) * MathUtils.norm2d(r))
    ) * (MathUtils.cross(t, r) > 0 ? 1 : -1);
  },
  norm2d: (i2) => {
    const { x: e, y: t } = new Vector(i2);
    return Math.hypot(e, t);
  },
  cross: (i2, e) => {
    const t = new Vector(i2), r = new Vector(e);
    return t.x * r.y - r.x * t.y;
  },
  dot: (i2, e) => MathUtils.sum(MathUtils.arrMulti(i2, e)),
  sum: (i2) => typeof i2 != "object" ? i2 : Object.values(i2).reduce((e, t) => e + t),
  arrMulti: (i2, e) => MathUtils.arrMap(i2, e, (t, r) => t * r),
  arrAnd: (i2, e) => MathUtils.arrMap(i2, e, (t, r) => t & r),
  arrFill: (i2, e) => new Array(e).fill(i2),
  arrMap: (i2, e, t) => {
    if (typeof i2 == "object" && (i2 = Object.values(i2)), typeof e == "object" && (e = Object.values(e)), Array.isArray(i2) || (i2 = MathUtils.arrFill(i2, e.length)), Array.isArray(e) || (e = MathUtils.arrFill(e, i2.length)), i2.length !== e.length)
      throw new Error(`length not match when array apply ${t}`);
    return i2.map((r, a) => t(i2[a], e[a]));
  }
}, deg = MathUtils.deg, rad = MathUtils.rad, round$2 = MathUtils.round, floor$2 = MathUtils.floor, ceil = MathUtils.ceil, theta = MathUtils.theta, norm2d = MathUtils.norm2d, cross = MathUtils.cross, dot = MathUtils.dot, sum = MathUtils.sum, arrMulti = MathUtils.arrMulti, styleList$b = createStyleList$1();
styleList$b.push([
  24,
  `
    *[mira-editor-el] {
      position: absolute;
      box-sizing: border-box;
      pointer-events: none;
      margin: 0;
      padding: 0;
    }
    *[mira-editor-el] .hide {
      opacity: 0 !important;
      pointer-events: none !important;
      cursor: default !important;
    }
    *[mira-editor-el] .hide:after {
      opacity: 0 !important;
      transition-property: opacity, width, height;
      transition-duration: 0.3s;
    }
    .mira-editor[mira-editor-el] {
      position: relative;
      user-select: none;
    }
    .mirae-debug-box[mira-editor-el] {
      border: 1px dotted #C00 !important;
    }
    .mirae-center-cross[mira-editor-el] {
      margin: 0;
    }
    .mirae-center-cross[mira-editor-el]:before {
      left: 50%;
      top: 0;
      bottom: 0;
      width: 1px;
    }
    .mirae-center-cross[mira-editor-el]:after {
      top: 50%;
      left: 0;
      right: 0;
      height: 1px;
    }
    .mirae-center-cross[mira-editor-el]:before,
    .mirae-center-cross[mira-editor-el]:after {
      content: '';
      position: absolute;
      background: red;
    }
  `,
  ""
]);
createStyleManager$1(styleList$b, createStyleOption$1());
styleList$b.locals && styleList$b.locals;
class CustomHtmlElementBase extends HTMLElement {
  constructor() {
    super(), this.lockTimer = {};
  }
  scrollToVisible(e = { center: false, top: false, smooth: true }) {
    typeof e == "boolean" && (e = { center: e, top: false, smooth: true });
    const t = e.smooth ? "smooth" : "auto", r = e.center ? "center" : "nearest", a = e.top ? "center" : "nearest";
    return this.scrollIntoView({ behavior: t, block: r, inline: a }), this;
  }
  clear() {
    this.dragstart && (this.dragstart = false, this.moveListener && this.moveListener.onMoveEnd && this.moveListener.onMoveEnd({
      target: this,
      position: { x: 0, y: 0 },
      moved: this.moved > 5,
      event: null
    }));
  }
  locked(e = "default") {
    return !!this.lockTimer[e];
  }
  lock(e, t, r = "default") {
    return this.lockTimer[r] && (clearTimeout(this.lockTimer[r]), this.lockTimer[r] = null), this.lockTimer[r] = setTimeout(() => {
      this.lockTimer[r] = null, t && t();
    }, e), this;
  }
  get(e) {
    return this.getAttribute(e);
  }
  set(e, t) {
    return this.setAttribute(e, t), this;
  }
  show(e) {
    return e ? this.removeClass("hide") : this.addClass("hide");
  }
  setStyleVars(e = {}) {
    for (const [t, r] of Object.entries(e))
      this.style.setProperty(t, r);
    return this;
  }
  setStyle(e = {}) {
    return this.setAttr("style", e);
  }
  setAttr(e, t = {}) {
    for (const [r, a] of Object.entries(t))
      this[e][r] = a;
    return this;
  }
  toggleClass(e, t = null) {
    return t === null && (t = !this.classList.contains(e)), t ? this.addClass(e) : this.removeClass(e), t;
  }
  addClass(e, t = 0) {
    return Array.isArray(e) || (e = [e]), this.classList.add(...e), t > 0 && this.lock(
      t,
      () => this.removeClass(e),
      `class.${e}`
    ), this;
  }
  removeClass(e) {
    return Array.isArray(e) || (e = [e]), this.classList.remove(...e), this;
  }
  hasClass(e) {
    return Array.isArray(e) || (e = [e]), e.filter((t) => this.classList.contains(t)).length > 0;
  }
  appendTo(e) {
    return e && e.append(this), this;
  }
  remove() {
    this.cbs && this.bindEvents(false), Object.values(this.lockTimer).forEach(
      (e) => e && clearTimeout(e)
    ), this.lockTimer = {}, this.onClick = null, this.moveListener = null, super.remove();
  }
  hide() {
    super.remove();
  }
  onDragStart() {
    return (e) => {
      if (this.dragstart || e.button !== 0) return;
      this.bindBodyEvents(true), e.stopPropagation(), this.dragstart = true, this.moved = 0;
      const { clientX: t, clientY: r } = e;
      this.lastPosition = { x: t, y: r }, this.moveListener && this.moveListener.onMoveStart && this.moveListener.onMoveStart({
        target: this,
        position: this.lastPosition,
        event: e
      });
    };
  }
  onDragMove() {
    return (e) => {
      const { clientX: t, clientY: r } = e, a = { x: t, y: r };
      if (this.moveListener && this.moveListener.onCursor && this.moveListener.onCursor({
        target: this,
        position: a,
        event: e
      }), !this.dragstart) return false;
      e.stopPropagation();
      const { x: s, y: u } = this.lastPosition;
      this.move = { x: t - s, y: r - u }, this.moved += norm2d(this.move), this.lastPosition = a, this.moveListener && this.moveListener.onMove && (this.move.x !== 0 || this.move.y !== 0) && this.moveListener.onMove({
        target: this,
        position: a,
        moved: this.moved > 5,
        delta: this.move,
        event: e
      });
    };
  }
  onDragEnd() {
    return (e) => {
      var a, s;
      if (!this.dragstart) return false;
      e.stopPropagation(), this.bindBodyEvents(false), this.dragstart = false, this.move = null, this.lastPosition = null;
      const { clientX: t, clientY: r } = e;
      if (this.moved <= 5) {
        const u = Date.now();
        (a = this.moveListener) != null && a.onDblClick && this.lastClickTime && u - this.lastClickTime < 600 && this.moveListener.onDblClick({
          target: this,
          position: { x: t, y: r },
          event: e
        }), this.onClick && this.onClick(e), this.lastClickTime = u;
      }
      (s = this.moveListener) != null && s.onMoveEnd && this.moveListener.onMoveEnd({
        target: this,
        position: { x: t, y: r },
        moved: this.moved > 5,
        event: e
      });
    };
  }
  onHover() {
    return (e) => {
      if (this.moveListener && this.moveListener.onHover) {
        const { clientX: t, clientY: r } = e;
        this.moveListener.onHover({
          target: this,
          position: { x: t, y: r },
          drag: this.dragstart,
          moved: this.moved,
          event: e
        });
      }
      this.toggleClass("hover", e.type === "mouseover");
    };
  }
  onDblClick() {
    return (e) => {
      if (this.moveListener && this.moveListener.onDblClick) {
        const { clientX: t, clientY: r } = e;
        this.moveListener.onDblClick({
          target: this,
          position: { x: t, y: r },
          event: e
        });
      }
    };
  }
  addMoveListener(e) {
    return this.moveListener = e, this.cbs || this.bindEvents(), this;
  }
  events() {
    return {
      hover: ["mouseover", "mouseout"],
      start: ["mousedown", "touchstart"],
      move: ["mousemove", "touchmove"],
      end: ["mouseup", "mouseupoutside", "touchend", "touchendoutside"],
      dblclick: ["dblclick"]
    };
  }
  eventCallbacks() {
    return {
      hover: this.onHover(),
      dblclick: this.onDblClick(),
      start: this.onDragStart(),
      move: this.onDragMove(),
      end: this.onDragEnd()
    };
  }
  bindEvents(e = true) {
    e && (this.cbs = this.eventCallbacks());
    for (const [t, r] of Object.entries(this.events())) {
      const a = this.cbs[t];
      for (const s of r)
        e ? this.addEventListener(s, a) : this.removeEventListener(s, a);
    }
    e || (this.cbs = null);
  }
  bindBodyEvents(e = true, t = ["move", "end"]) {
    if (!this.cbs) return;
    const r = this.events();
    for (const a of t)
      for (const s of r[a])
        e ? document.body.addEventListener(s, this.cbs[a]) : document.body.removeEventListener(s, this.cbs[a]);
  }
  init() {
    return this.setAttribute("mira-editor-el", ""), this;
  }
  static create(e) {
    return document.createElement(this.TAG).init().appendTo(e);
  }
  static register() {
    customElements.get(this.TAG) || customElements.define(this.TAG, this);
  }
}
Ct(CustomHtmlElementBase, "TAG", "div");
class EditorBoxElement extends CustomHtmlElementBase {
  init() {
    return this.addClass("mirae-box"), this.scale = 1, super.init();
  }
  bind(e) {
    return this.node = e, e.cropMode && this.addClass("mirae-box-none"), this;
  }
  setAnchor(e) {
    const { x: t, y: r } = e || this.node.getAnchor();
    return this.anchor = { x: t, y: r }, this.setStyle({
      "transform-origin": `${round$2(100 * t, 1)}% ${round$2(100 * r, 1)}%`
    }), this;
  }
  setRotate(e) {
    e === void 0 && (e = this.node.getRotation()), this.rotation = e % (2 * Math.PI);
    const t = deg(this.rotation, 1);
    return this.setStyleVars({
      "--rotate": `${t}deg`,
      "--revert-rot": `-${t}deg`
    }), this;
  }
  setXY(e) {
    let [t, r] = e || this.node.getXY();
    this.position = new Vector({ x: t, y: r });
    const { width: a, height: s } = this.size;
    return t = (t - a * this.anchor.x) * this.scale, r = (r - s * this.anchor.y) * this.scale, this.setStyleVars({
      "--x": `${floor$2(t - 1)}px`,
      "--y": `${floor$2(r - 1)}px`
    }), this;
  }
  setWH(e) {
    let [t, r] = e || this.node.getWH();
    return this.size = { width: t, height: r }, t = `${ceil(t * this.scale + 2)}px`, r = `${ceil(r * this.scale + 2)}px`, this.setStyle({ width: t, height: r }), this;
  }
  crop() {
    return this;
  }
  move() {
    return this.setXY().refreshHandle();
  }
  resize() {
    return this.setWH().move();
  }
  rotate() {
    return this.setRotate();
  }
  fit(e) {
    return this.scale = e || 1, this.setAnchor().setRotate().resize();
  }
  select(e) {
    e && this.addHandleBox();
    const t = "mirae-selected";
    return e ? this.addClass(t) : this.removeClass(t);
  }
  points() {
    const { width: e, height: t } = this.size, r = -e * this.anchor.x, a = -t * this.anchor.y;
    return [
      [r, a],
      [r + e, a],
      [r, a + t],
      [r + e, a + t]
    ].map(
      (s) => new Vector(s).rotate(this.rotation).offset(this.position)
    );
  }
  bounds() {
    return PositionUtils.bounds(this.points());
  }
  addHandleBox() {
    this.handleBox || (this.handleBox = document.createElement("div"), this.handleBox.setAttribute("mira-editor-el", ""), this.handleBox.classList.add("mirae-box-handles", "left"), this.append(this.handleBox));
  }
  refreshHandle() {
    const e = this.parentNode;
    if (!this.handleBox || !e || !e.classList.contains("mira-editor"))
      return this;
    const t = e.getBoundingClientRect(), a = this.getBoundingClientRect().center.rebase(t.center);
    let s = "left";
    if (Math.abs(a.x) + Math.abs(a.y) > 10) {
      const u = deg(
        theta(a, { x: t.width, y: t.height }) - this.rotation
      ), l = deg(
        theta(a, { x: t.width, y: -t.height }) - this.rotation
      );
      s = u < 0 && l < 0 ? "top" : u < 0 && l > 0 ? "right" : u > 0 && l < 0 ? "left" : "bottom";
    }
    return this.handleBox.classList.contains(s) || (this.handleBox.classList.remove("left", "right", "top", "bottom"), this.handleBox.classList.add(s), this.setRotate()), this;
  }
  remove() {
    return this.handleBox && this.handleBox.remove(), super.remove();
  }
  static create({ node: e, scale: t, container: r, selected: a }) {
    return super.create(r).bind(e).select(a).fit(t || 1);
  }
}
Ct(EditorBoxElement, "TAG", "mira-editor-box");
EditorBoxElement.register();
const svgDataURL = "data:image/svg+xml;charset=utf-8,%3Csvg width=%2724%27 height=%2724%27 fill=%27none%27 xmlns=%27http://www.w3.org/2000/svg%27%3E%3Cpath fill-rule=%27evenodd%27 clip-rule=%27evenodd%27 d=%27M14.22 6.573a.75.75 0 1 0 1.06-1.06l-2.145-2.146a1.25 1.25 0 0 0-1.77 0L9.22 5.513a.75.75 0 0 0 1.06 1.06l1.22-1.22v5.899H5.602l1.22-1.22a.75.75 0 0 0-1.06-1.06l-2.147 2.145a1.251 1.251 0 0 0 0 1.77l2.146 2.145a.75.75 0 1 0 1.06-1.06l-1.219-1.22H11.5v5.897l-1.22-1.22a.75.75 0 1 0-1.06 1.061l2.145 2.146a1.248 1.248 0 0 0 0 1.77l2.145-2.146a.75.75 0 1 0-1.06-1.06L13 18.65v-5.898h5.898l-1.22 1.22a.75.75 0 0 0 1.06 1.06l2.147-2.146a1.252 1.252 0 0 0 0-1.77l-2.146-2.145a.75.75 0 0 0-1.06 1.06l1.219 1.22H13V5.354l1.22 1.22z%27 fill=%27currentColor%27/%3E%3C/svg%3E", styleList$a = createStyleList$1();
styleList$a.push([
  28,
  `
  .mirae-move.box[mira-editor-el] {
      width: 100%;
      height: 100%;
      cursor: move;
      pointer-events: auto;
      background: rgba(0, 0, 0, 0.2);
    }
    .mirae-move.box[mira-editor-el].hide {
      pointer-events: none;
    }
    .mirae-move.box[mira-editor-el].editMode {
      background: transparent !important;
      cursor: text !important;
    }
    .mirae-move.box[mira-editor-el] .mirae-text-cursor[mira-editor-el] {
      position: absolute;
      width: 2px;
      height: 1px;
      background-color: #FFF;
      overflow: hidden;
      pointer-events: none;
      cursor: text !important;
    }
    @keyframes flash {
      0% {
        opacity: 0;
      }
      49% {
        opacity: 0;
      }
      50% {
        opacity: 1;
      }
      100% {
        opacity: 1;
      }
    }
    .mirae-move.box[mira-editor-el] .mirae-text-cursor[mira-editor-el].mirae-text-cursor-flash {
      animation: flash 1s linear infinite;
    }
    .mirae-move.box[mira-editor-el] .mirae-text-cursor[mira-editor-el] textarea[mira-editor-el] {
      opacity: 0;
      width: 1px;
      height: 1px;
      pointer-events: none;
      resize: none;
      border: none;
      overflow: auto;
      outline: none;
      -webkit-box-shadow: none;
      -moz-box-shadow: none;
      box-shadow: none;
      cursor: text !important;
    }
    .mirae-move.handle[mira-editor-el] {
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: auto;
      z-index: 3;
      cursor: move;
      position: relative;
    }
    .mirae-move.handle[mira-editor-el].hide {
      width: 0px;
      height: 0px;
      pointer-events: none;
    }
    .mirae-move.handle[mira-editor-el]:after {
      width: 20px;
      height: 20px;
      content: "";
      transition-property: opacity, width, height;
      transition-duration: 0.3s;
      position: relative;
      border-radius: 10px;
      box-shadow: 0 0 5px 1px rgba(57, 76, 96, 0.15), 0 0 0 1px rgba(53, 71, 90, 0.2);
      opacity: 1;
      background: #FFF 2px no-repeat;
      background-size: 16px;
      z-index: 9;
      transform: rotate(var(--revert-rot));
      background-image: url("${svgDataURL}");
    }
  `,
  ""
]);
createStyleManager$1(styleList$a, createStyleOption$1());
styleList$a.locals && styleList$a.locals;
class EditorMoveElement extends CustomHtmlElementBase {
  init() {
    return this.addClass(this.constructor.STYLE_CLASS), super.init();
  }
  setOpts({ styleClass: e }) {
    return this.styleClass = e, this.addClass(e), this;
  }
  start(e) {
    var t;
    (t = this.cbs) != null && t.start && this.cbs.start(e);
  }
  static create(e) {
    const { box: t, moveListener: r } = e;
    return super.create(t).setOpts(e).addMoveListener(r);
  }
}
Ct(EditorMoveElement, "TAG", "mira-editor-move"), Ct(EditorMoveElement, "STYLE_CLASS", "mirae-move");
EditorMoveElement.register();
const POSITION_KEYS = ["start", "duration", "end", "ss", "to"], SIZE_KEYS = ["width", "height", "x", "y", "object-fit"], CHROMA_KEYS = [
  "chromaSimilarity",
  "chromaSmoothness",
  "chromaSaturation",
  "chromaShadowness"
], MATERIAL_KEYS = [
  ...POSITION_KEYS,
  ...SIZE_KEYS,
  "chromaKey",
  "src",
  "cachedSrc",
  "blend",
  "outerKey"
], ALL_KEYS = [
  "type",
  "changed",
  "name",
  "opacity",
  "volume",
  "speed",
  "pitch",
  "audio",
  "fadeIn",
  "fadeOut",
  "cropStart",
  "cropEnd",
  "text",
  "fontFamily",
  "cachedFontFamily",
  "fontSize",
  "color",
  "backgroundColor",
  "wrap",
  "valign",
  "align",
  "lineHeight",
  "letterSpacing",
  "stroke",
  "shadow",
  ...MATERIAL_KEYS
];
class ComponentBase extends ExtendedEventEmitter {
  constructor(e) {
    super(), this.lockTimer = {}, this._wrappers = [], this.editor = e, this.bindEvents(true);
  }
  toast(e, t) {
    return this.editor && this.editor.toast(e, t), this;
  }
  lock(e, t, r = "default") {
    return this.lockTimer[r] && (clearTimeout(this.lockTimer[r]), this.lockTimer[r] = null), this.lockTimer[r] = setTimeout(() => {
      this.lockTimer[r] = null, t && t();
    }, e), this;
  }
  locked(e = "default") {
    return !!this.lockTimer[e];
  }
  wrap(e, t) {
    const r = wrap(e, t);
    return this._wrappers.push(r), r;
  }
  events() {
    return {};
  }
  canvasCoord(e, t = 1) {
    const r = this.editor.canvas.getBoundingClientRect();
    return new Vector(e.position ? e.position : e).rebase(r).scale(t);
  }
  cachedEvents() {
    return this.cacheEvents ? this.cacheEvents : this.cacheEvents = this.events();
  }
  bindEvents(e) {
    for (const [t, r] of Object.entries(
      this.cachedEvents()
    ))
      e ? this.editor.on(t, r) : this.editor.off(t, r);
  }
  static async set(e, t, r, a = null) {
    var d, f;
    const s = {}, u = (p) => {
      if (e[p] === void 0)
        return 0;
      {
        let m = t[p], y = e[p];
        return (isNaN(Number(m)) ? y : Number(m)) - y;
      }
    }, l = {
      position: ["x", "y"],
      size: ["width", "height"],
      rotation: "rotation",
      anchor: ["anchorX", "anchorY"]
    };
    for (const [p, m] of Object.entries(l)) {
      const y = Array.isArray(m) ? m.map((x) => u(x)) : u(m);
      sum(y) !== 0 && (Array.isArray(y) ? s[p] = zip(m, y) : s[p] = y);
    }
    for (const p of CHROMA_KEYS)
      t[p] !== void 0 && (s.chroma || (s.chroma = {}), s.chroma[p] = t[p] - e[p]);
    const c = {};
    for (const p of ALL_KEYS)
      t[p] !== void 0 && (c[p] = t[p]);
    for (const [p, m] of Object.entries(t))
      (p.includes(".") || p.startsWith("data-")) && (c[p] = m);
    return Object.keys(c).length > 0 && (s.to = c), (d = s.to) != null && d.src && ((f = s.to) == null ? void 0 : f.cachedSrc) === void 0 && (s.to.cachedSrc = "NULL"), new Promise((p, m) => {
      try {
        this.apply(e, s, r, {
          callback: (y) => {
            p(y);
          },
          onprogress: a
        });
      } catch (y) {
        console.error(y), m(y);
      }
    });
  }
  static apply(e, t, r = null, a = {}) {
    var T, E, b, C, w, A, S, F, M, U, B;
    const { sourceAction: s, relativeNodes: u, callback: l, onprogress: c } = a;
    if (e.type === TYPE_PLACEHOLDER)
      return l && l(t), t;
    let d = false, f = null;
    const p = e.type, m = e.creator();
    m.playing && m.pause();
    const y = r || this.type;
    if (t.to) {
      const q = {}, z = t.to.parent !== void 0, D = e.active;
      z && D && e.disable();
      let X = false;
      for (let [k, I] of Object.entries(t.to)) {
        if (k.includes(".")) {
          q[k] = e.getParam(k), q[k] === void 0 ? q[k] = "NULL" : q[k] = q[k], q[k] !== I && (X = true);
          continue;
        }
        POSITION_KEYS.includes(k) ? (I = round$2(I, 3), t.to[k] = I) : SIZE_KEYS.includes(k) && (d = true);
        let P = MATERIAL_KEYS.includes(k) ? e.conf : e;
        P[k] === void 0 ? q[k] = "NULL" : q[k] = P[k], q[k] !== I && (X = true);
      }
      if (!X)
        return z && D && e.enable(), l && l(t), t;
      for (let [k, I] of Object.entries(t.to))
        k.includes(".") ? e.setParam(k, I === "NULL" ? void 0 : I) : I === "NULL" ? (MATERIAL_KEYS.includes(k) ? e.conf : e)[k] = void 0 : (MATERIAL_KEYS.includes(k) ? e.conf : e)[k] = I;
      t.from || (t.from = q), t.to.active !== void 0 && (t.to.active ? e.enable() : e.disable()), (t.to.cropStart !== void 0 || t.to.cropEnd !== void 0) && (e.conf.cropStart = t.to.cropStart, e.conf.cropEnd = t.to.cropEnd), z && ((T = t.from.parent) != null && T.removeChild && t.from.parent.removeChild(e), (E = t.to.parent) != null && E.addChild && t.to.parent.addChild(e, e.nextSibling), (b = t.from.parent) != null && b.refreshSibling && t.from.parent.refreshSibling(), (C = t.to.parent) != null && C.refreshSibling ? t.to.parent.refreshSibling() : (e.nextSibling = null, e.prevSibling = null), D && e.enable()), e.type === "text" && (d = true), (p === "speech" || e.type === "speech") && (((w = t.to.parent) == null ? void 0 : w.type) === "text" ? f = t.to.parent : ((A = t.from.parent) == null ? void 0 : A.type) === "text" ? f = t.from.parent : ((S = e.parent) == null ? void 0 : S.type) === "text" && (f = e.parent), !e.trackId && f && (e.trackId = f.trackId)), (t.to.ss !== void 0 || t.to.to !== void 0) && e.updateMaterialTime(), e.parent && e.annotate();
    }
    if (t.frame && e.setFrame && e.material) {
      let [q, z] = [
        e.material.width(),
        e.material.height()
      ];
      const D = e.getFrame();
      let { x: X, y: k, w: I, h: P } = t.frame;
      D.x += X, D.y += k, D.w += I, D.h += P, e.setFrame(
        D.x,
        D.y,
        Math.min(D.w, q - D.x),
        Math.min(D.h, z - D.y)
      ), d = true;
    }
    if (t.chroma)
      for (const q of Object.keys(t.chroma))
        e.conf[q] = Math.max(
          e[q] + t.chroma[q],
          1e-3
        );
    if (t.anchor) {
      let { x: q, y: z } = e.getAnchor();
      q += t.anchor.x, z += t.anchor.y, e.setAnchor(q, z);
    }
    if (t.position) {
      const q = e.getX() + t.position.x, z = e.getY() + t.position.y;
      e.setXY(q, z);
    }
    if (t.size) {
      let [q, z] = e.getWH();
      q += t.size.width, z += t.size.height, e.setWH(q, z), d = true;
    }
    if (t.rotation) {
      const q = e.getRotation() + t.rotation;
      e.setRotate(q);
    }
    if (d && (e.fitSize(), e.fitTexture()), (t.chroma || (F = t.to) != null && F.chromaKey) && e.setChromaKey(), !e.refresh)
      return t;
    e.refresh(t);
    const x = (M = e.parents) == null ? void 0 : M.filter(
      (q) => q.type === "scene"
    );
    x && x.length > 0 && x.map((q) => {
      q.emit(CHANGING, {
        action: OP_CLEAR_CACHE
      });
    });
    const g = (m == null ? void 0 : m.currentTime) / 1e3, _ = () => {
      e.emit(CHANGING, {
        action: y,
        delta: t,
        time: g,
        sourceAction: s,
        relativeNodes: u
      }), f && f.emit(CHANGING, {
        action: y,
        delta: {
          to: {
            changed: true
          }
        }
      }), l && l(t);
    };
    return ((U = t.to) == null ? void 0 : U.src) !== void 0 ? (async () => {
      try {
        await e.preProcessing(c), e.annotate(), await e.prepareMaterial();
      } catch (q) {
        console.error(q);
      }
      _();
    })() : ((B = t.to) == null ? void 0 : B.fontFamily) !== void 0 && e.queuedFitSize ? (t.to.cachedFontFamily || (e.cachedFontFamily = null), (async () => (await e.queuedFitSize(), _()))()) : e.type === "mixin" ? (async () => (await e.update(), _()))() : _(), t;
  }
  destroy() {
    this.cacheEvents && this.bindEvents(false), this._wrappers && this._wrappers.map((e) => e.revoke()), this.lockTimer && Object.values(this.lockTimer).map(
      (e) => e && clearTimeout(e)
    ), this.editor = null, this.cacheEvents = null, this._wrappers = null, this.lockTimer = null;
  }
}
Ct(ComponentBase, "type", "base");
class ViewComponentBase extends ComponentBase {
  destroy() {
    super.destroy(), this.view && this.view.remove();
  }
}
const properties = [
  "frame",
  "position",
  "rotation",
  "size",
  "anchor",
  "chroma"
];
class Record extends ExtendedEventEmitter {
  constructor(e, t, r) {
    super(), this.id = uuid(), this.parent = null, this.action = e, this.targets = t, this.attributes = {}, Array.isArray(t) && Array.isArray(r) ? t.forEach((a, s) => {
      this.attributes[a.id] = r[s];
    }) : t && !Array.isArray(t) ? (this.targets = [t], this.attributes = { [t.id]: r }) : this.attributes = r, this.ops = [], this.useOps() && this.ops.push(this.attributes);
  }
  contains(e) {
    return !this.targets || this.targets.length === 0 ? false : this.mapAttr((t) => (t == null ? void 0 : t.id) === e).filter(Boolean).length > 0;
  }
  useOps() {
    return [OP_SPLIT, OP_ADD, OP_DELETE].includes(this.action);
  }
  addTarget(e) {
    this.targets ? this.targets.push(e) : (this.targets = [e], this.attributes = {}, this.ops = []);
  }
  mapAttr(e, t = null) {
    return t = t || this.attributes, this.targets.map(
      (r) => e(r, t[r.id])
    );
  }
  mergeNext(e) {
    if (e.time - this.time < 100 && e.action === OP_MOVE && [OP_ADD, OP_MOVE].includes(this.action))
      this.ops.push(e.attributes);
    else if (!(e.time - this.time < 1e4 && ["move", "number"].includes(e.action) && this.mergeId === e.mergeId))
      return false;
    return Record.mergeAttr(e.attributes, this.attributes), this;
  }
  merge(e, t = false) {
    if (!t && e instanceof Record && this.mergeId !== e.mergeId)
      return this;
    let r = e;
    return e instanceof Record && (r = e.attributes, e.targets.forEach((a) => {
      this.contains(a.id) || this.addTarget(a);
    })), this.useOps() && this.ops.push(r), Record.mergeAttr(r, this.attributes), this;
  }
  async applyOp(e, t) {
    const r = t === "undo" ? "from" : "to";
    await Promise.all(
      this.mapAttr(async (a, s) => {
        if (!s) return;
        const u = {};
        return s[r] && (u.to = s[r]), properties.forEach((l) => {
          s[l] !== void 0 && (u[l] = t === "undo" ? dmap(s[l], (c) => -c) : s[l]);
        }), new Promise((l) => {
          ViewComponentBase.apply(a, u, t, {
            sourceAction: this.action,
            relativeNodes: this.targets,
            callback: l
          });
        });
      }, e)
    );
  }
  async apply(e = null, t = "redo") {
    return this.useOps() ? (e = e || this.ops, await Promise.all(e.map((r) => this.applyOp(r, t)))) : (this.targets.sort((r, a) => a.absStartTime - r.absStartTime), await this.applyOp(null, t)), this;
  }
  async revoke() {
    const e = this.useOps() ? [...this.ops].reverse() : null;
    return await this.apply(e, "undo");
  }
  empty() {
    if (this.targets.filter((t) => t.type !== TYPE_PLACEHOLDER).length <= 0)
      return true;
    let e = true;
    return this.mapAttr((t, r) => {
      r && (r.to && Object.keys(r.to).length > 0 || properties.some((a) => r[a])) && (e = false);
    }), e;
  }
  get mergeId() {
    let e = this.action.toString() + ";";
    return Array.isArray(this.targets) ? e += this.targets.map((t) => t.id).sort().join(",") : e += this.targets.id, e;
  }
  get attrs() {
    return this.attributes;
  }
  destroy() {
    this.parent = null, this.targets = null, this.attributes = null;
  }
  static mergeAttr(e, t = {}) {
    t = t || {};
    for (const [r, a] of Object.entries(e))
      if (r !== "time")
        if (r === "from")
          t[r] = { ...a, ...t[r] };
        else if (r === "to")
          t[r] = { ...t[r], ...a };
        else if (Array.isArray(a))
          t[r] = Array.isArray(t[r]) ? t[r].concat(a) : a;
        else if (typeof a == "object")
          t[r] = Record.mergeAttr(a, t[r]);
        else if (isNaN(Number(a))) {
          if (t[r] && r !== "op")
            throw new Error(
              `Can not merge record! [${r}]${a} => ${t[r]}`
            );
          t[r] = a;
        } else
          t[r] = (Number(t[r]) || 0) + Number(a);
    return t;
  }
}
const es = class es2 extends ExtendedEventEmitter {
  constructor(e) {
    super(), this._records = [], this._index = 0, this._editor = e;
  }
  append(e) {
    if (e.empty())
      return;
    this.length > this._index && this._records.splice(this._index).forEach((a) => a.destroy()), e.time = Date.now();
    const t = this._records[this._index - 1];
    if (t && t.mergeNext(e))
      return;
    e.parent = this, this._records.push(e), this._index++;
    const r = (a, s) => {
      var u, l;
      s && ((u = s.to) != null && u.trackId) && a.trackId !== ((l = s.to) == null ? void 0 : l.trackId) && (s.to.trackId = a.trackId);
    };
    return e.useOps() ? e.ops.forEach((a) => e.mapAttr(r, a)) : e.mapAttr(r), this.emit(es2.EVENTS.change, { record: e }), this;
  }
  redo(e = 1) {
    const t = this._records[this._index];
    return e <= 0 || !t ? [] : (this._index++, (async () => (await t.apply(), this.emit(es2.EVENTS.redo, { record: t })))(), [...this.redo(e - 1), t]);
  }
  undo(e = 1) {
    const t = this._records[this._index - 1];
    return e <= 0 || !t ? [] : (this._index--, (async () => (await t.revoke(), this.emit(es2.EVENTS.undo, { record: t })))(), [...this.undo(e - 1), t]);
  }
  seekTime(e) {
    this._editor.currentTime = e;
  }
  get length() {
    return this._records.length;
  }
  get currentIndex() {
    return this._index;
  }
  get records() {
    return [...this._records];
  }
  destroy() {
    this._editor = null, this._records = null;
  }
};
Ct(es, "EVENTS", { change: "change", undo: "undo", redo: "redo" });
let History = es;
const Ka = class Ka2 extends ComponentBase {
  constructor(e) {
    super(e), this.uuid = uuid(), this.selector = e.controls.select, this._controls = {}, this.wrap(this.selector, "createBox").after(
      (t, r) => {
        const [a, s] = t;
        s && r && this.setNode().appendControl(r).show();
      }
    ), this.wrap(this.selector, "enableMulti").after(() => {
      this.show();
    }), this.wrap(this.selector, "hideSelect").after(() => {
      this.remove();
    }), this.constructor.type === "move" && this.wrap(this.selector, "fit").after(() => {
      this.updateCursor(false);
    });
  }
  show(e = !this.selector.withMulti) {
    return this.view && this.view.show(e), this;
  }
  events() {
    const e = {
      keydown: this.onKeyDown(),
      keyup: this.onKeyUp()
    };
    return this.constructor.type === "move" && (e[SELECT] = this.onSelect()), e;
  }
  onKeyDown() {
    return (e) => {
      if (this.constructor.type !== "move" || !this.box || !this.view.hasClass("hover") && !this.editMode)
        return;
      if (this.editMode) {
        if (e.key === "Backspace")
          return this.updateText(this.node.delete());
        if (e.key === "Escape")
          return this.remove();
        if (e.key.toLowerCase() === "z" && e.mctrlKey)
          return e.preventDefault(), this.opHistory(e.shiftKey);
        if (e.key.toLowerCase() === "y" && e.mctrlKey)
          return e.preventDefault(), this.opHistory(true);
        if (e.key.toLowerCase() === "c" && e.mctrlKey)
          return this.copyText();
        if (e.key.toLowerCase() === "x" && e.mctrlKey)
          return this.copyText(), this.updateText(this.node.delete());
      }
      const t = this.constructor.KEY_MAP[e.key];
      if (!t)
        return;
      e.preventDefault();
      const [r, a] = arrMulti(
        t,
        e.shiftKey ? this.box.scale * 10 : this.box.scale
      );
      this.onMove({
        delta: {
          x: r,
          y: a
        },
        type: "keyboard",
        event: e
      });
    };
  }
  onKeyUp() {
    return (e) => {
      this.constructor.type === "move" && this.constructor.KEY_MAP[e.key] && this.node && !this.editMode && this.node.emit(CHANGING, {
        action: `${this.constructor.type}end`
      });
    };
  }
  setNode() {
    return this.node = this.selector.selected, this;
  }
  controls(e) {
    return this.node.cropMode ? {} : {
      move: {
        box: e,
        styleClass: "box"
      },
      moveHandle: {
        box: e.handleBox,
        styleClass: "handle"
      }
    };
  }
  appendControl(e) {
    if (!this.node)
      return this;
    this.box = e, this._controls && Object.values(this._controls).map((t) => t.remove()), this._controls = {};
    for (const [t, r] of Object.entries(this.controls(e))) {
      r.box || (r.box = e), typeof r.box == "string" && this._controls[r.box] && (r.box = this._controls[r.box]), r.moveListener = this;
      const a = r.tag || this.constructor.TAG;
      this._controls[t] = a.create(r);
    }
    return this.boxWrapper && this.boxWrapper.revoke(), this.boxWrapper = this.wrap(e, this.constructor.CHG_HOOK).after(
      () => {
        this.updateShow(e);
      }
    ), this.node.cropMode !== "time" && this.updateShow(e), this;
  }
  updateShow(e) {
    const t = Math.min(e.size.width, e.size.height) * e.scale < 50;
    this._controls.moveHandle && this._controls.moveHandle.show(t);
  }
  onSelect() {
    return (e) => {
      e.action === "start" && this.view && this.view.start(e.event.data.originalEvent);
    };
  }
  get canMove() {
    return this.node && this.box && !this.node.cropMode;
  }
  getDelta(e) {
    return {
      position: dmap(
        e.delta,
        (t) => t / this.box.scale
      )
    };
  }
  point(e) {
    const t = this.box.points()[0];
    return this.canvasCoord(e, 1 / this.box.scale).rebase(t).rotate(-this.box.rotation);
  }
  onMove(e) {
    if (!this.canMove)
      return;
    if (this.editMode) {
      e.type === "keyboard" ? (this.node.selectMove(
        e.delta,
        e.event.shiftKey,
        e.event.mctrlKey
      ), this.updateCursor()) : this.textSelect(e);
      return;
    }
    Ka2.apply(this.node, this.getDelta(e)), this.box.move();
    const { x: t, y: r } = round$2(
      this.box.position,
      0
    );
    this.toast(`X:${t} Y:${r}`, 3e3);
  }
  onMoveStart(e) {
    if (this.canMove)
      return this.editMode ? this.node.selectStart(this.point(e)) : (this.node.emit(CHANGING, {
        action: `${this.constructor.type}start`
      }), this.selector.showHover(this.node, e), this);
  }
  onMoveEnd(e) {
    if (!this.canMove)
      return;
    if (this.node.emit(CHANGING, {
      action: `${this.constructor.type}end`
    }), this.editMode)
      return this.textSelect(e);
    if (e.moved)
      return this.selector.hideHover();
    this.selector.toggleSelect();
    const t = Date.now();
    return t - this.lastClickTime < 600 && this.node.id === this.lastClickNodeId && this.onDblClick(e), this.lastClickTime = t, this.lastClickNodeId = this.node.id, this;
  }
  onDblClick(e) {
    var t;
    ((t = this.node) == null ? void 0 : t.type) === "text" && this.textEditStart(e);
  }
  textEditStart(e) {
    this.view && (this.view.addClass("editMode"), this.box.addClass("editMode"), this.node.editMode = true, this.node.selectionBgColor = this.editor.opts.textSelectionColor, this.node.selectStart(this.point(e)), this.selector.hideHover(), this.selector.enableMulti(false), this.textSelect(e));
  }
  textSelect(e) {
    this.locked("updateText") || this.node.selectEnd(this.point(e)), this.updateCursor();
  }
  updateCursor(e = true) {
    if (!this.view)
      return;
    if (!this.cursorView) {
      if (!e)
        return;
      this.cursorView = document.createElement("div"), this.cursorView.setAttribute("mira-editor-el", ""), this.cursorView.classList.add("mirae-text-cursor"), this.cursorView.style.backgroundColor = this.editor.opts.textCursorColor, this.textView = document.createElement("textarea"), this.textView.setAttribute("mira-editor-el", ""), this.textView.addEventListener(
        "compositionstart",
        this.onCompStart.bind(this)
      ), this.textView.addEventListener(
        "compositionend",
        this.onCompEnd.bind(this)
      ), this.textView.addEventListener("input", this.onInputChar.bind(this));
      const u = this.cachedEvents();
      this.textView.addEventListener("keyup", u.keyup), this.textView.addEventListener("keydown", u.keydown), this.cursorView.append(this.textView);
    }
    const t = this.node.cursor(), r = this.box.scale, a = new Vector(t).scale(r), s = t.height * r;
    this.cursorView.style.transform = `translate(${a.x}px, ${a.y + s * 0.5 - 1}px) scaleY(${s + 2})`, e && (this.cursorView.parentNode !== this.view && this.view.append(this.cursorView), this.textView.focus(), this.cursorView.classList.remove("mirae-text-cursor-flash"), this.lock(
      500,
      () => {
        this.cursorView.classList.add("mirae-text-cursor-flash");
      },
      "cursor"
    ), this.editor.enableKeyboard(false));
  }
  onCompStart(e) {
    this.inputStatus = "COMP_START";
  }
  onCompEnd(e) {
    setTimeout(() => {
      this.input(), this.inputStatus = "COMP_END";
    }, 100);
  }
  onInputChar(e) {
    this.inputStatus !== "COMP_START" && (this.inputStatus = "INPUT", this.input());
  }
  clearTextValue() {
    this.textView.value = "";
  }
  input() {
    const e = this.textView.value;
    this.updateText(this.node.input(e), e), this.clearTextValue();
  }
  updateText(e, t) {
    if (e.text === this.node.text)
      return;
    const r = ComponentBase.apply(
      this.node,
      {
        to: e
      },
      OP_CHANGE
    ), a = new Record(
      OP_CHANGE,
      this.node,
      r
    );
    t ? a.editType = "add" : a.editType = "del", t != null && t.includes(`
`) && (this.record = null), this.box.resize(), this.updateCursor(), this.lock(500, null, "updateText"), this.record && this.record.editType === a.editType ? (this.record.merge(a, true), this.editor._history.emit("change", {
      record: a
    })) : (this.record = a, this.editor._history.append(a));
  }
  copyText() {
    const e = this.node.selection();
    navigator.clipboard.writeText(e);
  }
  get editMode() {
    var e;
    return !!((e = this.node) != null && e.editMode);
  }
  get view() {
    var e;
    return (e = this._controls) == null ? void 0 : e.move;
  }
  opHistory(e = true) {
    const t = e ? "redo" : "undo";
    this.editor[t](1, false), this.box.resize(), this.updateCursor(), this.record = null;
  }
  remove() {
    this.constructor.type === "move" && (this.view && this.view.remove(), this.cursorView && this.cursorView.remove(), this.textView && this.textView.remove(), this.cursorView = null, this.editMode && (this.node.editMode = false, this.node.selectClean(), this.editor.enableKeyboard(true), this.selector.enableMulti(false)));
  }
  destroy() {
    return this.selector = null, this.remove(), super.destroy();
  }
};
Ct(Ka, "type", "move"), Ct(Ka, "TAG", EditorMoveElement), Ct(Ka, "CHG_HOOK", "setWH"), Ct(Ka, "KEY_MAP", {
  ArrowUp: [0, -1],
  ArrowDown: [0, 1],
  ArrowLeft: [-1, 0],
  ArrowRight: [1, 0]
});
let EditorMoveComponent = Ka;
const svgDataURL1$3 = '"data:image/svg+xml;charset=utf-8,%3Csvg xmlns=%27http://www.w3.org/2000/svg%27 width=%2724%27 height=%2724%27%3E%3Cdefs%3E%3Cfilter id=%27a%27 width=%27150%25%27 height=%27150%25%27 x=%27-25%25%27 y=%27-17.9%25%27 filterUnits=%27objectBoundingBox%27%3E%3CfeOffset dy=%271%27 in=%27SourceAlpha%27 result=%27shadowOffsetOuter1%27/%3E%3CfeGaussianBlur in=%27shadowOffsetOuter1%27 result=%27shadowBlurOuter1%27 stdDeviation=%271%27/%3E%3CfeColorMatrix in=%27shadowBlurOuter1%27 result=%27shadowMatrixOuter1%27 values=%270 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.2 0%27/%3E%3CfeMerge%3E%3CfeMergeNode in=%27shadowMatrixOuter1%27/%3E%3CfeMergeNode in=%27SourceGraphic%27/%3E%3C/feMerge%3E%3C/filter%3E%3C/defs%3E%3Cg fill=%27none%27 fill-rule=%27evenodd%27%3E%3Cpath d=%27M0 0h24v24H0z%27/%3E%3Cg filter=%27url%28%23a%29%27 transform=%27scale%28-1 1%29 rotate%2845 -8.536 -13.435%29%27%3E%3Cpath fill=%27%23FFF%27 d=%27M4.257 7.087l4.072 4.068L5.5 13.983l8.473-.013.013-8.47-2.841 2.842L7.07 4.274 5.656 2.859 8.5.017H.014v8.484l2.829-2.827z%27/%3E%3Cpath fill=%27%23000%27 d=%27M5.317 6.733l4.427 4.424-1.828 1.828 5.056-.016.014-5.054-1.842 1.841-4.428-4.422-2.474-2.475 1.844-1.843H1.013v5.071l1.83-1.828z%27/%3E%3C/g%3E%3C/g%3E%3C/svg%3E"', svgDataURL2$3 = '"data:image/svg+xml;charset=utf-8,%3Csvg xmlns=%27http://www.w3.org/2000/svg%27 width=%2724%27 height=%2724%27%3E%3Cdefs%3E%3Cfilter id=%27a%27 width=%27150%25%27 height=%27150%25%27 x=%27-25%25%27 y=%27-17.9%25%27 filterUnits=%27objectBoundingBox%27%3E%3CfeOffset dy=%271%27 in=%27SourceAlpha%27 result=%27shadowOffsetOuter1%27/%3E%3CfeGaussianBlur in=%27shadowOffsetOuter1%27 result=%27shadowBlurOuter1%27 stdDeviation=%271%27/%3E%3CfeColorMatrix in=%27shadowBlurOuter1%27 result=%27shadowMatrixOuter1%27 values=%270 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.2 0%27/%3E%3CfeMerge%3E%3CfeMergeNode in=%27shadowMatrixOuter1%27/%3E%3CfeMergeNode in=%27SourceGraphic%27/%3E%3C/feMerge%3E%3C/filter%3E%3C/defs%3E%3Cg fill=%27none%27 fill-rule=%27evenodd%27%3E%3Cpath d=%27M0 0h24v24H0z%27/%3E%3Cg filter=%27url%28%23a%29%27 transform=%27scale%28-1 1%29 rotate%2830 -11.83 -25.954%29%27%3E%3Cpath fill=%27%23FFF%27 d=%27M4.257 7.087l4.072 4.068L5.5 13.983l8.473-.013.013-8.47-2.841 2.842L7.07 4.274 5.656 2.859 8.5.017H.014v8.484l2.829-2.827z%27/%3E%3Cpath fill=%27%23000%27 d=%27M5.317 6.733l4.427 4.424-1.828 1.828 5.056-.016.014-5.054-1.842 1.841-4.428-4.422-2.474-2.475 1.844-1.843H1.013v5.071l1.83-1.828z%27/%3E%3C/g%3E%3C/g%3E%3C/svg%3E"', svgDataURL3$3 = '"data:image/svg+xml;charset=utf-8,%3Csvg xmlns=%27http://www.w3.org/2000/svg%27 width=%2724%27 height=%2724%27%3E%3Cdefs%3E%3Cfilter id=%27a%27 width=%27150%25%27 height=%27150%25%27 x=%27-25%25%27 y=%27-17.9%25%27 filterUnits=%27objectBoundingBox%27%3E%3CfeOffset dy=%271%27 in=%27SourceAlpha%27 result=%27shadowOffsetOuter1%27/%3E%3CfeGaussianBlur in=%27shadowOffsetOuter1%27 result=%27shadowBlurOuter1%27 stdDeviation=%271%27/%3E%3CfeColorMatrix in=%27shadowBlurOuter1%27 result=%27shadowMatrixOuter1%27 values=%270 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.2 0%27/%3E%3CfeMerge%3E%3CfeMergeNode in=%27shadowMatrixOuter1%27/%3E%3CfeMergeNode in=%27SourceGraphic%27/%3E%3C/feMerge%3E%3C/filter%3E%3C/defs%3E%3Cg fill=%27none%27 fill-rule=%27evenodd%27%3E%3Cpath d=%27M0 0h24v24H0z%27/%3E%3Cg filter=%27url%28%23a%29%27 transform=%27scale%28-1 1%29 rotate%2815, -21.49, -62.66%29%27%3E%3Cpath fill=%27%23FFF%27 d=%27M4.257 7.087l4.072 4.068L5.5 13.983l8.473-.013.013-8.47-2.841 2.842L7.07 4.274 5.656 2.859 8.5.017H.014v8.484l2.829-2.827z%27/%3E%3Cpath fill=%27%23000%27 d=%27M5.317 6.733l4.427 4.424-1.828 1.828 5.056-.016.014-5.054-1.842 1.841-4.428-4.422-2.474-2.475 1.844-1.843H1.013v5.071l1.83-1.828z%27/%3E%3C/g%3E%3C/g%3E%3C/svg%3E"', svgDataURL4$3 = '"data:image/svg+xml;charset=utf-8,%3Csvg xmlns=%27http://www.w3.org/2000/svg%27 width=%2724%27 height=%2724%27%3E%3Cdefs%3E%3Cfilter id=%27a%27 width=%27150%25%27 height=%27150%25%27 x=%27-25%25%27 y=%27-17.9%25%27 filterUnits=%27objectBoundingBox%27%3E%3CfeOffset dy=%271%27 in=%27SourceAlpha%27 result=%27shadowOffsetOuter1%27/%3E%3CfeGaussianBlur in=%27shadowOffsetOuter1%27 result=%27shadowBlurOuter1%27 stdDeviation=%271%27/%3E%3CfeColorMatrix in=%27shadowBlurOuter1%27 result=%27shadowMatrixOuter1%27 values=%270 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.2 0%27/%3E%3CfeMerge%3E%3CfeMergeNode in=%27shadowMatrixOuter1%27/%3E%3CfeMergeNode in=%27SourceGraphic%27/%3E%3C/feMerge%3E%3C/filter%3E%3C/defs%3E%3Cg fill=%27none%27 fill-rule=%27evenodd%27%3E%3Cpath d=%27M0 0h24v24H0z%27/%3E%3Cg filter=%27url%28%23a%29%27 transform=%27matrix%28-1 0 0 1 19 5%29%27%3E%3Cpath fill=%27%23FFF%27 d=%27M4.257 7.087l4.072 4.068L5.5 13.983l8.473-.013.013-8.47-2.841 2.842L7.07 4.274 5.656 2.859 8.5.017H.014v8.484l2.829-2.827z%27/%3E%3Cpath fill=%27%23000%27 d=%27M5.317 6.733l4.427 4.424-1.828 1.828 5.056-.016.014-5.054-1.842 1.841-4.428-4.422-2.474-2.475 1.844-1.843H1.013v5.071l1.83-1.828z%27/%3E%3C/g%3E%3C/g%3E%3C/svg%3E"', svgDataURL5$2 = '"data:image/svg+xml;charset=utf-8,%3Csvg xmlns=%27http://www.w3.org/2000/svg%27 width=%2724%27 height=%2724%27%3E%3Cdefs%3E%3Cfilter id=%27a%27 width=%27150%25%27 height=%27150%25%27 x=%27-25%25%27 y=%27-17.9%25%27 filterUnits=%27objectBoundingBox%27%3E%3CfeOffset dy=%271%27 in=%27SourceAlpha%27 result=%27shadowOffsetOuter1%27/%3E%3CfeGaussianBlur in=%27shadowOffsetOuter1%27 result=%27shadowBlurOuter1%27 stdDeviation=%271%27/%3E%3CfeColorMatrix in=%27shadowBlurOuter1%27 result=%27shadowMatrixOuter1%27 values=%270 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.2 0%27/%3E%3CfeMerge%3E%3CfeMergeNode in=%27shadowMatrixOuter1%27/%3E%3CfeMergeNode in=%27SourceGraphic%27/%3E%3C/feMerge%3E%3C/filter%3E%3C/defs%3E%3Cg fill=%27none%27 fill-rule=%27evenodd%27%3E%3Cpath d=%27M0 0h24v24H0z%27/%3E%3Cg filter=%27url%28%23a%29%27 transform=%27scale%28-1 1%29 rotate%28-15, 16.49, 81.66%29%27%3E%3Cpath fill=%27%23FFF%27 d=%27M4.257 7.087l4.072 4.068L5.5 13.983l8.473-.013.013-8.47-2.841 2.842L7.07 4.274 5.656 2.859 8.5.017H.014v8.484l2.829-2.827z%27/%3E%3Cpath fill=%27%23000%27 d=%27M5.317 6.733l4.427 4.424-1.828 1.828 5.056-.016.014-5.054-1.842 1.841-4.428-4.422-2.474-2.475 1.844-1.843H1.013v5.071l1.83-1.828z%27/%3E%3C/g%3E%3C/g%3E%3C/svg%3E"', svgDataURL6$2 = '"data:image/svg+xml;charset=utf-8,%3Csvg xmlns=%27http://www.w3.org/2000/svg%27 width=%2724%27 height=%2724%27%3E%3Cdefs%3E%3Cfilter id=%27a%27 width=%27150%25%27 height=%27150%25%27 x=%27-25%25%27 y=%27-17.9%25%27 filterUnits=%27objectBoundingBox%27%3E%3CfeOffset dy=%271%27 in=%27SourceAlpha%27 result=%27shadowOffsetOuter1%27/%3E%3CfeGaussianBlur in=%27shadowOffsetOuter1%27 result=%27shadowBlurOuter1%27 stdDeviation=%271%27/%3E%3CfeColorMatrix in=%27shadowBlurOuter1%27 result=%27shadowMatrixOuter1%27 values=%270 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.2 0%27/%3E%3CfeMerge%3E%3CfeMergeNode in=%27shadowMatrixOuter1%27/%3E%3CfeMergeNode in=%27SourceGraphic%27/%3E%3C/feMerge%3E%3C/filter%3E%3C/defs%3E%3Cg fill=%27none%27 fill-rule=%27evenodd%27%3E%3Cpath d=%27M0 0h24v24H0z%27/%3E%3Cg filter=%27url%28%23a%29%27 transform=%27scale%28-1 1%29 rotate%28-30, 6.83, 44.954%29%27%3E%3Cpath fill=%27%23FFF%27 d=%27M4.257 7.087l4.072 4.068L5.5 13.983l8.473-.013.013-8.47-2.841 2.842L7.07 4.274 5.656 2.859 8.5.017H.014v8.484l2.829-2.827z%27/%3E%3Cpath fill=%27%23000%27 d=%27M5.317 6.733l4.427 4.424-1.828 1.828 5.056-.016.014-5.054-1.842 1.841-4.428-4.422-2.474-2.475 1.844-1.843H1.013v5.071l1.83-1.828z%27/%3E%3C/g%3E%3C/g%3E%3C/svg%3E"', svgDataURL7$2 = '"data:image/svg+xml;charset=utf-8,%3Csvg xmlns=%27http://www.w3.org/2000/svg%27 width=%2724%27 height=%2724%27%3E%3Cdefs%3E%3Cfilter id=%27a%27 width=%27150%25%27 height=%27150%25%27 x=%27-25%25%27 y=%27-17.9%25%27 filterUnits=%27objectBoundingBox%27%3E%3CfeOffset dy=%271%27 in=%27SourceAlpha%27 result=%27shadowOffsetOuter1%27/%3E%3CfeGaussianBlur in=%27shadowOffsetOuter1%27 result=%27shadowBlurOuter1%27 stdDeviation=%271%27/%3E%3CfeColorMatrix in=%27shadowBlurOuter1%27 result=%27shadowMatrixOuter1%27 values=%270 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.2 0%27/%3E%3CfeMerge%3E%3CfeMergeNode in=%27shadowMatrixOuter1%27/%3E%3CfeMergeNode in=%27SourceGraphic%27/%3E%3C/feMerge%3E%3C/filter%3E%3C/defs%3E%3Cg fill=%27none%27 fill-rule=%27evenodd%27%3E%3Cpath d=%27M0 0h24v24H0z%27/%3E%3Cg filter=%27url%28%23a%29%27 transform=%27scale%28-1 1%29 rotate%28-45, 3.536, 32.435%29%27%3E%3Cpath fill=%27%23FFF%27 d=%27M4.257 7.087l4.072 4.068L5.5 13.983l8.473-.013.013-8.47-2.841 2.842L7.07 4.274 5.656 2.859 8.5.017H.014v8.484l2.829-2.827z%27/%3E%3Cpath fill=%27%23000%27 d=%27M5.317 6.733l4.427 4.424-1.828 1.828 5.056-.016.014-5.054-1.842 1.841-4.428-4.422-2.474-2.475 1.844-1.843H1.013v5.071l1.83-1.828z%27/%3E%3C/g%3E%3C/g%3E%3C/svg%3E"', svgDataURL8$2 = '"data:image/svg+xml;charset=utf-8,%3Csvg xmlns=%27http://www.w3.org/2000/svg%27 width=%2724%27 height=%2724%27%3E%3Cdefs%3E%3Cfilter id=%27a%27 width=%27150%25%27 height=%27150%25%27 x=%27-25%25%27 y=%27-17.9%25%27 filterUnits=%27objectBoundingBox%27%3E%3CfeOffset dy=%271%27 in=%27SourceAlpha%27 result=%27shadowOffsetOuter1%27/%3E%3CfeGaussianBlur in=%27shadowOffsetOuter1%27 result=%27shadowBlurOuter1%27 stdDeviation=%271%27/%3E%3CfeColorMatrix in=%27shadowBlurOuter1%27 result=%27shadowMatrixOuter1%27 values=%270 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.2 0%27/%3E%3CfeMerge%3E%3CfeMergeNode in=%27shadowMatrixOuter1%27/%3E%3CfeMergeNode in=%27SourceGraphic%27/%3E%3C/feMerge%3E%3C/filter%3E%3C/defs%3E%3Cg fill=%27none%27 fill-rule=%27evenodd%27%3E%3Cpath d=%27M0 0h24v24H0z%27/%3E%3Cg filter=%27url%28%23a%29%27 transform=%27rotate%28-30 18.83 .17%29%27%3E%3Cpath fill=%27%23FFF%27 d=%27M4.257 7.087l4.072 4.068L5.5 13.983l8.473-.013.013-8.47-2.841 2.842L7.07 4.274 5.656 2.859 8.5.017H.014v8.484l2.829-2.827z%27/%3E%3Cpath fill=%27%23000%27 d=%27M5.317 6.733l4.427 4.424-1.828 1.828 5.056-.016.014-5.054-1.842 1.841-4.428-4.422-2.474-2.475 1.844-1.843H1.013v5.071l1.83-1.828z%27/%3E%3C/g%3E%3C/g%3E%3C/svg%3E"', svgDataURL9$2 = '"data:image/svg+xml;charset=utf-8,%3Csvg xmlns=%27http://www.w3.org/2000/svg%27 width=%2724%27 height=%2724%27%3E%3Cdefs%3E%3Cfilter id=%27a%27 width=%27150%25%27 height=%27150%25%27 x=%27-25%25%27 y=%27-17.9%25%27 filterUnits=%27objectBoundingBox%27%3E%3CfeOffset dy=%271%27 in=%27SourceAlpha%27 result=%27shadowOffsetOuter1%27/%3E%3CfeGaussianBlur in=%27shadowOffsetOuter1%27 result=%27shadowBlurOuter1%27 stdDeviation=%271%27/%3E%3CfeColorMatrix in=%27shadowBlurOuter1%27 result=%27shadowMatrixOuter1%27 values=%270 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.2 0%27/%3E%3CfeMerge%3E%3CfeMergeNode in=%27shadowMatrixOuter1%27/%3E%3CfeMergeNode in=%27SourceGraphic%27/%3E%3C/feMerge%3E%3C/filter%3E%3C/defs%3E%3Cg fill=%27none%27 fill-rule=%27evenodd%27%3E%3Cpath d=%27M0 0h24v24H0z%27/%3E%3Cg filter=%27url%28%23a%29%27 transform=%27rotate%28-15 28.49 -9.49%29%27%3E%3Cpath fill=%27%23FFF%27 d=%27M4.257 7.087l4.072 4.068L5.5 13.983l8.473-.013.013-8.47-2.841 2.842L7.07 4.274 5.656 2.859 8.5.017H.014v8.484l2.829-2.827z%27/%3E%3Cpath fill=%27%23000%27 d=%27M5.317 6.733l4.427 4.424-1.828 1.828 5.056-.016.014-5.054-1.842 1.841-4.428-4.422-2.474-2.475 1.844-1.843H1.013v5.071l1.83-1.828z%27/%3E%3C/g%3E%3C/g%3E%3C/svg%3E"', svgDataURL10$2 = '"data:image/svg+xml;charset=utf-8,%3Csvg xmlns=%27http://www.w3.org/2000/svg%27 width=%2724%27 height=%2724%27%3E%3Cdefs%3E%3Cfilter id=%27a%27 width=%27150%25%27 height=%27150%25%27 x=%27-25%25%27 y=%27-17.9%25%27 filterUnits=%27objectBoundingBox%27%3E%3CfeOffset dy=%271%27 in=%27SourceAlpha%27 result=%27shadowOffsetOuter1%27/%3E%3CfeGaussianBlur in=%27shadowOffsetOuter1%27 result=%27shadowBlurOuter1%27 stdDeviation=%271%27/%3E%3CfeColorMatrix in=%27shadowBlurOuter1%27 result=%27shadowMatrixOuter1%27 values=%270 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.2 0%27/%3E%3CfeMerge%3E%3CfeMergeNode in=%27shadowMatrixOuter1%27/%3E%3CfeMergeNode in=%27SourceGraphic%27/%3E%3C/feMerge%3E%3C/filter%3E%3C/defs%3E%3Cg fill=%27none%27 fill-rule=%27evenodd%27%3E%3Cpath d=%27M0 0h24v24H0z%27/%3E%3Cg filter=%27url%28%23a%29%27 transform=%27translate%285 5%29%27%3E%3Cpath fill=%27%23FFF%27 d=%27M4.257 7.087l4.072 4.068L5.5 13.983l8.473-.013.013-8.47-2.841 2.842L7.07 4.274 5.656 2.859 8.5.017H.014v8.484l2.829-2.827z%27/%3E%3Cpath fill=%27%23000%27 d=%27M5.317 6.733l4.427 4.424-1.828 1.828 5.056-.016.014-5.054-1.842 1.841-4.428-4.422-2.474-2.475 1.844-1.843H1.013v5.071l1.83-1.828z%27/%3E%3C/g%3E%3C/g%3E%3C/svg%3E"', svgDataURL11$1 = '"data:image/svg+xml;charset=utf-8,%3Csvg xmlns=%27http://www.w3.org/2000/svg%27 width=%2724%27 height=%2724%27%3E%3Cdefs%3E%3Cfilter id=%27a%27 width=%27150%25%27 height=%27150%25%27 x=%27-25%25%27 y=%27-17.9%25%27 filterUnits=%27objectBoundingBox%27%3E%3CfeOffset dy=%271%27 in=%27SourceAlpha%27 result=%27shadowOffsetOuter1%27/%3E%3CfeGaussianBlur in=%27shadowOffsetOuter1%27 result=%27shadowBlurOuter1%27 stdDeviation=%271%27/%3E%3CfeColorMatrix in=%27shadowBlurOuter1%27 result=%27shadowMatrixOuter1%27 values=%270 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.2 0%27/%3E%3CfeMerge%3E%3CfeMergeNode in=%27shadowMatrixOuter1%27/%3E%3CfeMergeNode in=%27SourceGraphic%27/%3E%3C/feMerge%3E%3C/filter%3E%3C/defs%3E%3Cg fill=%27none%27 fill-rule=%27evenodd%27%3E%3Cpath d=%27M0 0h24v24H0z%27/%3E%3Cg filter=%27url%28%23a%29%27 transform=%27rotate%2815 -9.49 28.49%29%27%3E%3Cpath fill=%27%23FFF%27 d=%27M4.257 7.087l4.072 4.068L5.5 13.983l8.473-.013.013-8.47-2.841 2.842L7.07 4.274 5.656 2.859 8.5.017H.014v8.484l2.829-2.827z%27/%3E%3Cpath fill=%27%23000%27 d=%27M5.317 6.733l4.427 4.424-1.828 1.828 5.056-.016.014-5.054-1.842 1.841-4.428-4.422-2.474-2.475 1.844-1.843H1.013v5.071l1.83-1.828z%27/%3E%3C/g%3E%3C/g%3E%3C/svg%3E"', svgDataURL12$1 = '"data:image/svg+xml;charset=utf-8,%3Csvg xmlns=%27http://www.w3.org/2000/svg%27 width=%2724%27 height=%2724%27%3E%3Cdefs%3E%3Cfilter id=%27a%27 width=%27150%25%27 height=%27150%25%27 x=%27-25%25%27 y=%27-17.9%25%27 filterUnits=%27objectBoundingBox%27%3E%3CfeOffset dy=%271%27 in=%27SourceAlpha%27 result=%27shadowOffsetOuter1%27/%3E%3CfeGaussianBlur in=%27shadowOffsetOuter1%27 result=%27shadowBlurOuter1%27 stdDeviation=%271%27/%3E%3CfeColorMatrix in=%27shadowBlurOuter1%27 result=%27shadowMatrixOuter1%27 values=%270 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.2 0%27/%3E%3CfeMerge%3E%3CfeMergeNode in=%27shadowMatrixOuter1%27/%3E%3CfeMergeNode in=%27SourceGraphic%27/%3E%3C/feMerge%3E%3C/filter%3E%3C/defs%3E%3Cg fill=%27none%27 fill-rule=%27evenodd%27%3E%3Cpath d=%27M0 0h24v24H0z%27/%3E%3Cg filter=%27url%28%23a%29%27 transform=%27rotate%2830 .17 18.83%29%27%3E%3Cpath fill=%27%23FFF%27 d=%27M4.257 7.087l4.072 4.068L5.5 13.983l8.473-.013.013-8.47-2.841 2.842L7.07 4.274 5.656 2.859 8.5.017H.014v8.484l2.829-2.827z%27/%3E%3Cpath fill=%27%23000%27 d=%27M5.317 6.733l4.427 4.424-1.828 1.828 5.056-.016.014-5.054-1.842 1.841-4.428-4.422-2.474-2.475 1.844-1.843H1.013v5.071l1.83-1.828z%27/%3E%3C/g%3E%3C/g%3E%3C/svg%3E"', styleList$9 = createStyleList$1();
styleList$9.push([
  66,
  `.mirae-resize[mira-editor-el] {
    width: 32px;
    height: 32px;
    display: flex;
    align-items: center;
    justify-content: center;
    pointer-events: auto;
  }
  .mirae-resize[mira-editor-el].hide {
    pointer-events: none;
  }
  .mirae-resize[mira-editor-el].dot:after {
    width: 12px;
    height: 12px;
    content: "";
    transition-property: opacity, width, height;
    transition-duration: 0.3s;
    position: relative;
    border-radius: 7px;
    box-shadow: 0 0 5px 1px rgba(57, 76, 96, 0.15), 0 0 0 1px rgba(53, 71, 90, 0.2);
    opacity: 1;
    background: #FFF 2px no-repeat;
    background-size: 16px;
    z-index: 9;
  }
  .mirae-resize[mira-editor-el].hor {
    width: 100%;
    height: 32px;
  }
  .mirae-resize[mira-editor-el].hor:after {
    width: 16px;
    height: 4px;
    content: "";
    transition-property: opacity, width, height;
    transition-duration: 0.3s;
    position: relative;
    border-radius: 2px;
    box-shadow: 0 0 5px 1px rgba(57, 76, 96, 0.15), 0 0 0 1px rgba(53, 71, 90, 0.2);
    opacity: 1;
    background: #FFF 2px no-repeat;
    background-size: 16px;
    z-index: 9;
  }
  .mirae-resize[mira-editor-el].ver {
    width: 32px;
    height: 100%;
  }
  .mirae-resize[mira-editor-el].ver:after {
    width: 4px;
    height: 16px;
    content: "";
    transition-property: opacity, width, height;
    transition-duration: 0.3s;
    position: relative;
    border-radius: 2px;
    box-shadow: 0 0 5px 1px rgba(57, 76, 96, 0.15), 0 0 0 1px rgba(53, 71, 90, 0.2);
    opacity: 1;
    background: #FFF 2px no-repeat;
    background-size: 16px;
    z-index: 9;
  }
  .mirae-resize[mira-editor-el].top {
    top: 0;
    margin-top: -16px;
  }
  .mirae-resize[mira-editor-el].top:after {
    margin-top: -2px;
  }
  .mirae-resize[mira-editor-el].bottom {
    bottom: 0;
    margin-bottom: -16px;
  }
  .mirae-resize[mira-editor-el].bottom:after {
    margin-bottom: -2px;
  }
  .mirae-resize[mira-editor-el].left {
    left: 0;
    margin-left: -16px;
  }
  .mirae-resize[mira-editor-el].left:after {
    margin-left: -2px;
  }
  .mirae-resize[mira-editor-el].right {
    right: 0;
    margin-right: -16px;
  }
  .mirae-resize[mira-editor-el].right:after {
    margin-right: -2px;
  }
  .mirae-rze-cursor[r="0"] {
    cursor: url(${svgDataURL1$3}) 12 12, auto;
  }
  .mirae-rze-cursor[r="1"] {
    cursor: url(${svgDataURL2$3}) 12 12, auto;
  }
  .mirae-rze-cursor[r="2"] {
    cursor: url(${svgDataURL3$3}) 12 12, auto;
  }
  .mirae-rze-cursor[r="3"] {
    cursor: url(${svgDataURL4$3}) 12 12, auto;
  }
  .mirae-rze-cursor[r="4"] {
    cursor: url(${svgDataURL5$2}) 12 12, auto;
  }
  .mirae-rze-cursor[r="5"] {
    cursor: url(${svgDataURL6$2}) 12 12, auto;
  }
  .mirae-rze-cursor[r="6"] {
    cursor: url(${svgDataURL7$2}) 12 12, auto;
  }
  .mirae-rze-cursor[r="7"] {
    cursor: url(${svgDataURL8$2}) 12 12, auto;
  }
  .mirae-rze-cursor[r="8"] {
    cursor: url(${svgDataURL9$2}) 12 12, auto;
  }
  .mirae-rze-cursor[r="9"] {
    cursor: url(${svgDataURL10$2}) 12 12, auto;
  }
  .mirae-rze-cursor[r="10"] {
    cursor: url(${svgDataURL11$1}) 12 12, auto;
  }
  .mirae-rze-cursor[r="11"] {
    cursor: url(${svgDataURL12$1}) 12 12, auto;
  }
  `,
  ""
]);
createStyleManager$1(styleList$9, createStyleOption$1());
styleList$9.locals && styleList$9.locals;
const svgDataURL1$2 = '"data:image/svg+xml;charset=utf-8,%3Csvg xmlns=%27http://www.w3.org/2000/svg%27 width=%2724%27 height=%2724%27%3E%3Cpath fill=%27currentColor%27 d=%27M15.25 18.48V15a.75.75 0 1 0-1.5 0v4c0 .97.78 1.75 1.75 1.75h4a.75.75 0 1 0 0-1.5h-2.6a8.75 8.75 0 0 0-2.07-15.53.75.75 0 1 0-.49 1.42 7.25 7.25 0 0 1 .91 13.34zM8.75 5.52V9a.75.75 0 0 0 1.5 0V5c0-.97-.78-1.75-1.75-1.75h-4a.75.75 0 0 0 0 1.5h2.6a8.75 8.75 0 0 0 2.18 15.57.75.75 0 0 0 .47-1.43 7.25 7.25 0 0 1-1-13.37z%27/%3E%3C/svg%3E"', svgDataURL2$2 = '"data:image/svg+xml;charset=utf-8,%3Csvg xmlns=%27http://www.w3.org/2000/svg%27 xmlns:xlink=%27http://www.w3.org/1999/xlink%27 width=%2724%27 height=%2724%27%3E%3Cdefs%3E%3Cfilter id=%27a%27 width=%27266.7%25%27 height=%27156.2%25%27 x=%27-75%25%27 y=%27-21.9%25%27 filterUnits=%27objectBoundingBox%27%3E%3CfeOffset dy=%271%27 in=%27SourceAlpha%27 result=%27shadowOffsetOuter1%27/%3E%3CfeGaussianBlur in=%27shadowOffsetOuter1%27 result=%27shadowBlurOuter1%27 stdDeviation=%271%27/%3E%3CfeColorMatrix in=%27shadowBlurOuter1%27 result=%27shadowMatrixOuter1%27 values=%270 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.2 0%27/%3E%3CfeMerge%3E%3CfeMergeNode in=%27shadowMatrixOuter1%27/%3E%3CfeMergeNode in=%27SourceGraphic%27/%3E%3C/feMerge%3E%3C/filter%3E%3Cpath id=%27b%27 d=%27M1.67 12.67a7.7 7.7 0 0 0 0-9.34L0 5V0h5L3.24 1.76a9.9 9.9 0 0 1 0 12.48L5 16H0v-5l1.67 1.67z%27/%3E%3C/defs%3E%3Cg fill=%27none%27 fill-rule=%27evenodd%27%3E%3Cpath d=%27M0 24V0h24v24z%27/%3E%3Cg fill-rule=%27nonzero%27 filter=%27url%28%23a%29%27 transform=%27rotate%28-90 9.25 5.25%29%27%3E%3Cuse fill=%27%23000%27 fill-rule=%27evenodd%27 xlink:href=%27%23b%27/%3E%3Cpath stroke=%27%23FFF%27 d=%27M1.6 11.9a7.21 7.21 0 0 0 0-7.8L-.5 6.2V-.5h6.7L3.9 1.8a10.4 10.4 0 0 1 0 12.4l2.3 2.3H-.5V9.8l2.1 2.1z%27/%3E%3C/g%3E%3C/g%3E%3C/svg%3E"', svgDataURL3$2 = '"data:image/svg+xml;charset=utf-8,%3Csvg xmlns=%27http://www.w3.org/2000/svg%27 xmlns:xlink=%27http://www.w3.org/1999/xlink%27 width=%2724%27 height=%2724%27%3E%3Cdefs%3E%3Cfilter id=%27a%27 width=%27266.7%25%27 height=%27156.2%25%27 x=%27-75%25%27 y=%27-21.9%25%27 filterUnits=%27objectBoundingBox%27%3E%3CfeOffset dy=%271%27 in=%27SourceAlpha%27 result=%27shadowOffsetOuter1%27/%3E%3CfeGaussianBlur in=%27shadowOffsetOuter1%27 result=%27shadowBlurOuter1%27 stdDeviation=%271%27/%3E%3CfeColorMatrix in=%27shadowBlurOuter1%27 result=%27shadowMatrixOuter1%27 values=%270 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.2 0%27/%3E%3CfeMerge%3E%3CfeMergeNode in=%27shadowMatrixOuter1%27/%3E%3CfeMergeNode in=%27SourceGraphic%27/%3E%3C/feMerge%3E%3C/filter%3E%3Cpath id=%27b%27 d=%27M1.67 12.67a7.7 7.7 0 0 0 0-9.34L0 5V0h5L3.24 1.76a9.9 9.9 0 0 1 0 12.48L5 16H0v-5l1.67 1.67z%27/%3E%3C/defs%3E%3Cg fill=%27none%27 fill-rule=%27evenodd%27%3E%3Cpath d=%27M0 24V0h24v24z%27/%3E%3Cg fill-rule=%27nonzero%27 filter=%27url%28%23a%29%27 transform=%27rotate%28-75 9.972 3.863%29%27%3E%3Cuse fill=%27%23000%27 fill-rule=%27evenodd%27 xlink:href=%27%23b%27/%3E%3Cpath stroke=%27%23FFF%27 d=%27M1.6 11.9a7.21 7.21 0 0 0 0-7.8L-.5 6.2V-.5h6.7L3.9 1.8a10.4 10.4 0 0 1 0 12.4l2.3 2.3H-.5V9.8l2.1 2.1z%27/%3E%3C/g%3E%3C/g%3E%3C/svg%3E"', svgDataURL4$2 = '"data:image/svg+xml;charset=utf-8,%3Csvg xmlns=%27http://www.w3.org/2000/svg%27 xmlns:xlink=%27http://www.w3.org/1999/xlink%27 width=%2724%27 height=%2724%27%3E%3Cdefs%3E%3Cfilter id=%27a%27 width=%27266.7%25%27 height=%27156.2%25%27 x=%27-75%25%27 y=%27-21.9%25%27 filterUnits=%27objectBoundingBox%27%3E%3CfeOffset dy=%271%27 in=%27SourceAlpha%27 result=%27shadowOffsetOuter1%27/%3E%3CfeGaussianBlur in=%27shadowOffsetOuter1%27 result=%27shadowBlurOuter1%27 stdDeviation=%271%27/%3E%3CfeColorMatrix in=%27shadowBlurOuter1%27 result=%27shadowMatrixOuter1%27 values=%270 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.2 0%27/%3E%3CfeMerge%3E%3CfeMergeNode in=%27shadowMatrixOuter1%27/%3E%3CfeMergeNode in=%27SourceGraphic%27/%3E%3C/feMerge%3E%3C/filter%3E%3Cpath id=%27b%27 d=%27M1.67 12.67a7.7 7.7 0 0 0 0-9.34L0 5V0h5L3.24 1.76a9.9 9.9 0 0 1 0 12.48L5 16H0v-5l1.67 1.67z%27/%3E%3C/defs%3E%3Cg fill=%27none%27 fill-rule=%27evenodd%27%3E%3Cpath d=%27M0 24V0h24v24z%27/%3E%3Cg fill-rule=%27nonzero%27 filter=%27url%28%23a%29%27 transform=%27rotate%28-60 10.84 1.756%29%27%3E%3Cuse fill=%27%23000%27 fill-rule=%27evenodd%27 xlink:href=%27%23b%27/%3E%3Cpath stroke=%27%23FFF%27 d=%27M1.6 11.9a7.21 7.21 0 0 0 0-7.8L-.5 6.2V-.5h6.7L3.9 1.8a10.4 10.4 0 0 1 0 12.4l2.3 2.3H-.5V9.8l2.1 2.1z%27/%3E%3C/g%3E%3C/g%3E%3C/svg%3E"', svgDataURL5$1 = '"data:image/svg+xml;charset=utf-8,%3Csvg xmlns=%27http://www.w3.org/2000/svg%27 xmlns:xlink=%27http://www.w3.org/1999/xlink%27 width=%2724%27 height=%2724%27%3E%3Cdefs%3E%3Cfilter id=%27a%27 width=%27266.7%25%27 height=%27156.2%25%27 x=%27-75%25%27 y=%27-21.9%25%27 filterUnits=%27objectBoundingBox%27%3E%3CfeOffset dy=%271%27 in=%27SourceAlpha%27 result=%27shadowOffsetOuter1%27/%3E%3CfeGaussianBlur in=%27shadowOffsetOuter1%27 result=%27shadowBlurOuter1%27 stdDeviation=%271%27/%3E%3CfeColorMatrix in=%27shadowBlurOuter1%27 result=%27shadowMatrixOuter1%27 values=%270 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.2 0%27/%3E%3CfeMerge%3E%3CfeMergeNode in=%27shadowMatrixOuter1%27/%3E%3CfeMergeNode in=%27SourceGraphic%27/%3E%3C/feMerge%3E%3C/filter%3E%3Cpath id=%27b%27 d=%27M1.67 12.67a7.7 7.7 0 0 0 0-9.34L0 5V0h5L3.24 1.76a9.9 9.9 0 0 1 0 12.48L5 16H0v-5l1.67 1.67z%27/%3E%3C/defs%3E%3Cg fill=%27none%27 fill-rule=%27evenodd%27%3E%3Cpath d=%27M0 24V0h24v24z%27/%3E%3Cg fill-rule=%27nonzero%27 filter=%27url%28%23a%29%27 transform=%27rotate%28-45 11.972 -1.716%29%27%3E%3Cuse fill=%27%23000%27 fill-rule=%27evenodd%27 xlink:href=%27%23b%27/%3E%3Cpath stroke=%27%23FFF%27 d=%27M1.6 11.9a7.21 7.21 0 0 0 0-7.8L-.5 6.2V-.5h6.7L3.9 1.8a10.4 10.4 0 0 1 0 12.4l2.3 2.3H-.5V9.8l2.1 2.1z%27/%3E%3C/g%3E%3C/g%3E%3C/svg%3E"', svgDataURL6$1 = '"data:image/svg+xml;charset=utf-8,%3Csvg xmlns=%27http://www.w3.org/2000/svg%27 xmlns:xlink=%27http://www.w3.org/1999/xlink%27 width=%2724%27 height=%2724%27%3E%3Cdefs%3E%3Cfilter id=%27a%27 width=%27266.7%25%27 height=%27156.2%25%27 x=%27-75%25%27 y=%27-21.9%25%27 filterUnits=%27objectBoundingBox%27%3E%3CfeOffset dy=%271%27 in=%27SourceAlpha%27 result=%27shadowOffsetOuter1%27/%3E%3CfeGaussianBlur in=%27shadowOffsetOuter1%27 result=%27shadowBlurOuter1%27 stdDeviation=%271%27/%3E%3CfeColorMatrix in=%27shadowBlurOuter1%27 result=%27shadowMatrixOuter1%27 values=%270 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.2 0%27/%3E%3CfeMerge%3E%3CfeMergeNode in=%27shadowMatrixOuter1%27/%3E%3CfeMergeNode in=%27SourceGraphic%27/%3E%3C/feMerge%3E%3C/filter%3E%3Cpath id=%27b%27 d=%27M1.67 12.67a7.7 7.7 0 0 0 0-9.34L0 5V0h5L3.24 1.76a9.9 9.9 0 0 1 0 12.48L5 16H0v-5l1.67 1.67z%27/%3E%3C/defs%3E%3Cg fill=%27none%27 fill-rule=%27evenodd%27%3E%3Cpath d=%27M0 24V0h24v24z%27/%3E%3Cg fill-rule=%27nonzero%27 filter=%27url%28%23a%29%27 transform=%27rotate%28-30 14.508 -7.572%29%27%3E%3Cuse fill=%27%23000%27 fill-rule=%27evenodd%27 xlink:href=%27%23b%27/%3E%3Cpath stroke=%27%23FFF%27 d=%27M1.6 11.9a7.21 7.21 0 0 0 0-7.8L-.5 6.2V-.5h6.7L3.9 1.8a10.4 10.4 0 0 1 0 12.4l2.3 2.3H-.5V9.8l2.1 2.1z%27/%3E%3C/g%3E%3C/g%3E%3C/svg%3E"', svgDataURL7$1 = '"data:image/svg+xml;charset=utf-8,%3Csvg xmlns=%27http://www.w3.org/2000/svg%27 xmlns:xlink=%27http://www.w3.org/1999/xlink%27 width=%2724%27 height=%2724%27%3E%3Cdefs%3E%3Cfilter id=%27a%27 width=%27266.7%25%27 height=%27156.2%25%27 x=%27-75%25%27 y=%27-21.9%25%27 filterUnits=%27objectBoundingBox%27%3E%3CfeOffset dy=%271%27 in=%27SourceAlpha%27 result=%27shadowOffsetOuter1%27/%3E%3CfeGaussianBlur in=%27shadowOffsetOuter1%27 result=%27shadowBlurOuter1%27 stdDeviation=%271%27/%3E%3CfeColorMatrix in=%27shadowBlurOuter1%27 result=%27shadowMatrixOuter1%27 values=%270 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.2 0%27/%3E%3CfeMerge%3E%3CfeMergeNode in=%27shadowMatrixOuter1%27/%3E%3CfeMergeNode in=%27SourceGraphic%27/%3E%3C/feMerge%3E%3C/filter%3E%3Cpath id=%27b%27 d=%27M1.67 12.67a7.7 7.7 0 0 0 0-9.34L0 5V0h5L3.24 1.76a9.9 9.9 0 0 1 0 12.48L5 16H0v-5l1.67 1.67z%27/%3E%3C/defs%3E%3Cg fill=%27none%27 fill-rule=%27evenodd%27%3E%3Cpath d=%27M0 24V0h24v24z%27/%3E%3Cg fill-rule=%27nonzero%27 filter=%27url%28%23a%29%27 transform=%27rotate%28-15 21.933 -22.997%29%27%3E%3Cuse fill=%27%23000%27 fill-rule=%27evenodd%27 xlink:href=%27%23b%27/%3E%3Cpath stroke=%27%23FFF%27 d=%27M1.6 11.9a7.21 7.21 0 0 0 0-7.8L-.5 6.2V-.5h6.7L3.9 1.8a10.4 10.4 0 0 1 0 12.4l2.3 2.3H-.5V9.8l2.1 2.1z%27/%3E%3C/g%3E%3C/g%3E%3C/svg%3E"', svgDataURL8$1 = '"data:image/svg+xml;charset=utf-8,%3Csvg xmlns=%27http://www.w3.org/2000/svg%27 xmlns:xlink=%27http://www.w3.org/1999/xlink%27 width=%2724%27 height=%2724%27%3E%3Cdefs%3E%3Cfilter id=%27a%27 width=%27266.7%25%27 height=%27156.2%25%27 x=%27-75%25%27 y=%27-21.9%25%27 filterUnits=%27objectBoundingBox%27%3E%3CfeOffset dy=%271%27 in=%27SourceAlpha%27 result=%27shadowOffsetOuter1%27/%3E%3CfeGaussianBlur in=%27shadowOffsetOuter1%27 result=%27shadowBlurOuter1%27 stdDeviation=%271%27/%3E%3CfeColorMatrix in=%27shadowBlurOuter1%27 result=%27shadowMatrixOuter1%27 values=%270 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.2 0%27/%3E%3CfeMerge%3E%3CfeMergeNode in=%27shadowMatrixOuter1%27/%3E%3CfeMergeNode in=%27SourceGraphic%27/%3E%3C/feMerge%3E%3C/filter%3E%3Cpath id=%27b%27 d=%27M1.67 12.67a7.7 7.7 0 0 0 0-9.34L0 5V0h5L3.24 1.76a9.9 9.9 0 0 1 0 12.48L5 16H0v-5l1.67 1.67z%27/%3E%3C/defs%3E%3Cg fill=%27none%27 fill-rule=%27evenodd%27%3E%3Cpath d=%27M0 24V0h24v24z%27/%3E%3Cg fill-rule=%27nonzero%27 filter=%27url%28%23a%29%27 transform=%27translate%289.5 3.5%29%27%3E%3Cuse fill=%27%23000%27 fill-rule=%27evenodd%27 xlink:href=%27%23b%27/%3E%3Cpath stroke=%27%23FFF%27 d=%27M1.6 11.9a7.21 7.21 0 0 0 0-7.8L-.5 6.2V-.5h6.7L3.9 1.8a10.4 10.4 0 0 1 0 12.4l2.3 2.3H-.5V9.8l2.1 2.1z%27/%3E%3C/g%3E%3C/g%3E%3C/svg%3E"', svgDataURL9$1 = '"data:image/svg+xml;charset=utf-8,%3Csvg xmlns=%27http://www.w3.org/2000/svg%27 xmlns:xlink=%27http://www.w3.org/1999/xlink%27 width=%2724%27 height=%2724%27%3E%3Cdefs%3E%3Cfilter id=%27a%27 width=%27266.7%25%27 height=%27156.2%25%27 x=%27-75%25%27 y=%27-21.9%25%27 filterUnits=%27objectBoundingBox%27%3E%3CfeOffset dy=%271%27 in=%27SourceAlpha%27 result=%27shadowOffsetOuter1%27/%3E%3CfeGaussianBlur in=%27shadowOffsetOuter1%27 result=%27shadowBlurOuter1%27 stdDeviation=%271%27/%3E%3CfeColorMatrix in=%27shadowBlurOuter1%27 result=%27shadowMatrixOuter1%27 values=%270 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.2 0%27/%3E%3CfeMerge%3E%3CfeMergeNode in=%27shadowMatrixOuter1%27/%3E%3CfeMergeNode in=%27SourceGraphic%27/%3E%3C/feMerge%3E%3C/filter%3E%3Cpath id=%27b%27 d=%27M1.67 12.67a7.7 7.7 0 0 0 0-9.34L0 5V0h5L3.24 1.76a9.9 9.9 0 0 1 0 12.48L5 16H0v-5l1.67 1.67z%27/%3E%3C/defs%3E%3Cg fill=%27none%27 fill-rule=%27evenodd%27%3E%3Cpath d=%27M0 24V0h24v24z%27/%3E%3Cg fill-rule=%27nonzero%27 filter=%27url%28%23a%29%27 transform=%27rotate%2815 -7.985 46.77%29%27%3E%3Cuse fill=%27%23000%27 fill-rule=%27evenodd%27 xlink:href=%27%23b%27/%3E%3Cpath stroke=%27%23FFF%27 d=%27M1.6 11.9a7.21 7.21 0 0 0 0-7.8L-.5 6.2V-.5h6.7L3.9 1.8a10.4 10.4 0 0 1 0 12.4l2.3 2.3H-.5V9.8l2.1 2.1z%27/%3E%3C/g%3E%3C/g%3E%3C/svg%3E"', svgDataURL10$1 = '"data:image/svg+xml;charset=utf-8,%3Csvg xmlns=%27http://www.w3.org/2000/svg%27 xmlns:xlink=%27http://www.w3.org/1999/xlink%27 width=%2724%27 height=%2724%27%3E%3Cdefs%3E%3Cfilter id=%27a%27 width=%27266.7%25%27 height=%27156.2%25%27 x=%27-75%25%27 y=%27-21.9%25%27 filterUnits=%27objectBoundingBox%27%3E%3CfeOffset dy=%271%27 in=%27SourceAlpha%27 result=%27shadowOffsetOuter1%27/%3E%3CfeGaussianBlur in=%27shadowOffsetOuter1%27 result=%27shadowBlurOuter1%27 stdDeviation=%271%27/%3E%3CfeColorMatrix in=%27shadowBlurOuter1%27 result=%27shadowMatrixOuter1%27 values=%270 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.2 0%27/%3E%3CfeMerge%3E%3CfeMergeNode in=%27shadowMatrixOuter1%27/%3E%3CfeMergeNode in=%27SourceGraphic%27/%3E%3C/feMerge%3E%3C/filter%3E%3Cpath id=%27b%27 d=%27M1.67 12.67a7.7 7.7 0 0 0 0-9.34L0 5V0h5L3.24 1.76a9.9 9.9 0 0 1 0 12.48L5 16H0v-5l1.67 1.67z%27/%3E%3C/defs%3E%3Cg fill=%27none%27 fill-rule=%27evenodd%27%3E%3Cpath d=%27M0 24V0h24v24z%27/%3E%3Cg fill-rule=%27nonzero%27 filter=%27url%28%23a%29%27 transform=%27rotate%2830 -.415 27.57%29%27%3E%3Cuse fill=%27%23000%27 fill-rule=%27evenodd%27 xlink:href=%27%23b%27/%3E%3Cpath stroke=%27%23FFF%27 d=%27M1.6 11.9a7.21 7.21 0 0 0 0-7.8L-.5 6.2V-.5h6.7L3.9 1.8a10.4 10.4 0 0 1 0 12.4l2.3 2.3H-.5V9.8l2.1 2.1z%27/%3E%3C/g%3E%3C/g%3E%3C/svg%3E"', svgDataURL11 = '"data:image/svg+xml;charset=utf-8,%3Csvg xmlns=%27http://www.w3.org/2000/svg%27 xmlns:xlink=%27http://www.w3.org/1999/xlink%27 width=%2724%27 height=%2724%27%3E%3Cdefs%3E%3Cfilter id=%27a%27 width=%27266.7%25%27 height=%27156.2%25%27 x=%27-75%25%27 y=%27-21.9%25%27 filterUnits=%27objectBoundingBox%27%3E%3CfeOffset dy=%271%27 in=%27SourceAlpha%27 result=%27shadowOffsetOuter1%27/%3E%3CfeGaussianBlur in=%27shadowOffsetOuter1%27 result=%27shadowBlurOuter1%27 stdDeviation=%271%27/%3E%3CfeColorMatrix in=%27shadowBlurOuter1%27 result=%27shadowMatrixOuter1%27 values=%270 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.2 0%27/%3E%3CfeMerge%3E%3CfeMergeNode in=%27shadowMatrixOuter1%27/%3E%3CfeMergeNode in=%27SourceGraphic%27/%3E%3C/feMerge%3E%3C/filter%3E%3Cpath id=%27b%27 d=%27M1.67 12.67a7.7 7.7 0 0 0 0-9.34L0 5V0h5L3.24 1.76a9.9 9.9 0 0 1 0 12.48L5 16H0v-5l1.67 1.67z%27/%3E%3C/defs%3E%3Cg fill=%27none%27 fill-rule=%27evenodd%27%3E%3Cpath d=%27M0 24V0h24v24z%27/%3E%3Cg fill-rule=%27nonzero%27 filter=%27url%28%23a%29%27 transform=%27rotate%2845 2.32 21.713%29%27%3E%3Cuse fill=%27%23000%27 fill-rule=%27evenodd%27 xlink:href=%27%23b%27/%3E%3Cpath stroke=%27%23FFF%27 d=%27M1.6 11.9a7.21 7.21 0 0 0 0-7.8L-.5 6.2V-.5h6.7L3.9 1.8a10.4 10.4 0 0 1 0 12.4l2.3 2.3H-.5V9.8l2.1 2.1z%27/%3E%3C/g%3E%3C/g%3E%3C/svg%3E"', svgDataURL12 = '"data:image/svg+xml;charset=utf-8,%3Csvg xmlns=%27http://www.w3.org/2000/svg%27 xmlns:xlink=%27http://www.w3.org/1999/xlink%27 width=%2724%27 height=%2724%27%3E%3Cdefs%3E%3Cfilter id=%27a%27 width=%27266.7%25%27 height=%27156.2%25%27 x=%27-75%25%27 y=%27-21.9%25%27 filterUnits=%27objectBoundingBox%27%3E%3CfeOffset dy=%271%27 in=%27SourceAlpha%27 result=%27shadowOffsetOuter1%27/%3E%3CfeGaussianBlur in=%27shadowOffsetOuter1%27 result=%27shadowBlurOuter1%27 stdDeviation=%271%27/%3E%3CfeColorMatrix in=%27shadowBlurOuter1%27 result=%27shadowMatrixOuter1%27 values=%270 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.2 0%27/%3E%3CfeMerge%3E%3CfeMergeNode in=%27shadowMatrixOuter1%27/%3E%3CfeMergeNode in=%27SourceGraphic%27/%3E%3C/feMerge%3E%3C/filter%3E%3Cpath id=%27b%27 d=%27M1.67 12.67a7.7 7.7 0 0 0 0-9.34L0 5V0h5L3.24 1.76a9.9 9.9 0 0 1 0 12.48L5 16H0v-5l1.67 1.67z%27/%3E%3C/defs%3E%3Cg fill=%27none%27 fill-rule=%27evenodd%27%3E%3Cpath d=%27M0 24V0h24v24z%27/%3E%3Cg fill-rule=%27nonzero%27 filter=%27url%28%23a%29%27 transform=%27rotate%2860 3.916 18.243%29%27%3E%3Cuse fill=%27%23000%27 fill-rule=%27evenodd%27 xlink:href=%27%23b%27/%3E%3Cpath stroke=%27%23FFF%27 d=%27M1.6 11.9a7.21 7.21 0 0 0 0-7.8L-.5 6.2V-.5h6.7L3.9 1.8a10.4 10.4 0 0 1 0 12.4l2.3 2.3H-.5V9.8l2.1 2.1z%27/%3E%3C/g%3E%3C/g%3E%3C/svg%3E"', svgDataURL13 = '"data:image/svg+xml;charset=utf-8,%3Csvg xmlns=%27http://www.w3.org/2000/svg%27 xmlns:xlink=%27http://www.w3.org/1999/xlink%27 width=%2724%27 height=%2724%27%3E%3Cdefs%3E%3Cfilter id=%27a%27 width=%27266.7%25%27 height=%27156.2%25%27 x=%27-75%25%27 y=%27-21.9%25%27 filterUnits=%27objectBoundingBox%27%3E%3CfeOffset dy=%271%27 in=%27SourceAlpha%27 result=%27shadowOffsetOuter1%27/%3E%3CfeGaussianBlur in=%27shadowOffsetOuter1%27 result=%27shadowBlurOuter1%27 stdDeviation=%271%27/%3E%3CfeColorMatrix in=%27shadowBlurOuter1%27 result=%27shadowMatrixOuter1%27 values=%270 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.2 0%27/%3E%3CfeMerge%3E%3CfeMergeNode in=%27shadowMatrixOuter1%27/%3E%3CfeMergeNode in=%27SourceGraphic%27/%3E%3C/feMerge%3E%3C/filter%3E%3Cpath id=%27b%27 d=%27M1.67 12.67a7.7 7.7 0 0 0 0-9.34L0 5V0h5L3.24 1.76a9.9 9.9 0 0 1 0 12.48L5 16H0v-5l1.67 1.67z%27/%3E%3C/defs%3E%3Cg fill=%27none%27 fill-rule=%27evenodd%27%3E%3Cpath d=%27M0 24V0h24v24z%27/%3E%3Cg fill-rule=%27nonzero%27 filter=%27url%28%23a%29%27 transform=%27rotate%2875 4.762 16.135%29%27%3E%3Cuse fill=%27%23000%27 fill-rule=%27evenodd%27 xlink:href=%27%23b%27/%3E%3Cpath stroke=%27%23FFF%27 d=%27M1.6 11.9a7.21 7.21 0 0 0 0-7.8L-.5 6.2V-.5h6.7L3.9 1.8a10.4 10.4 0 0 1 0 12.4l2.3 2.3H-.5V9.8l2.1 2.1z%27/%3E%3C/g%3E%3C/g%3E%3C/svg%3E"', svgDataURL14 = '"data:image/svg+xml;charset=utf-8,%3Csvg xmlns=%27http://www.w3.org/2000/svg%27 xmlns:xlink=%27http://www.w3.org/1999/xlink%27 width=%2724%27 height=%2724%27%3E%3Cdefs%3E%3Cfilter id=%27a%27 width=%27266.7%25%27 height=%27156.2%25%27 x=%27-75%25%27 y=%27-21.9%25%27 filterUnits=%27objectBoundingBox%27%3E%3CfeOffset dy=%271%27 in=%27SourceAlpha%27 result=%27shadowOffsetOuter1%27/%3E%3CfeGaussianBlur in=%27shadowOffsetOuter1%27 result=%27shadowBlurOuter1%27 stdDeviation=%271%27/%3E%3CfeColorMatrix in=%27shadowBlurOuter1%27 result=%27shadowMatrixOuter1%27 values=%270 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.2 0%27/%3E%3CfeMerge%3E%3CfeMergeNode in=%27shadowMatrixOuter1%27/%3E%3CfeMergeNode in=%27SourceGraphic%27/%3E%3C/feMerge%3E%3C/filter%3E%3Cpath id=%27b%27 d=%27M1.67 12.67a7.7 7.7 0 0 0 0-9.34L0 5V0h5L3.24 1.76a9.9 9.9 0 0 1 0 12.48L5 16H0v-5l1.67 1.67z%27/%3E%3C/defs%3E%3Cg fill=%27none%27 fill-rule=%27evenodd%27%3E%3Cpath d=%27M0 24V0h24v24z%27/%3E%3Cg fill-rule=%27nonzero%27 filter=%27url%28%23a%29%27 transform=%27rotate%2890 5.25 14.75%29%27%3E%3Cuse fill=%27%23000%27 fill-rule=%27evenodd%27 xlink:href=%27%23b%27/%3E%3Cpath stroke=%27%23FFF%27 d=%27M1.6 11.9a7.21 7.21 0 0 0 0-7.8L-.5 6.2V-.5h6.7L3.9 1.8a10.4 10.4 0 0 1 0 12.4l2.3 2.3H-.5V9.8l2.1 2.1z%27/%3E%3C/g%3E%3C/g%3E%3C/svg%3E"', svgDataURL15 = '"data:image/svg+xml;charset=utf-8,%3Csvg xmlns=%27http://www.w3.org/2000/svg%27 xmlns:xlink=%27http://www.w3.org/1999/xlink%27 width=%2724%27 height=%2724%27%3E%3Cdefs%3E%3Cfilter id=%27a%27 width=%27266.7%25%27 height=%27156.2%25%27 x=%27-75%25%27 y=%27-21.9%25%27 filterUnits=%27objectBoundingBox%27%3E%3CfeOffset dy=%271%27 in=%27SourceAlpha%27 result=%27shadowOffsetOuter1%27/%3E%3CfeGaussianBlur in=%27shadowOffsetOuter1%27 result=%27shadowBlurOuter1%27 stdDeviation=%271%27/%3E%3CfeColorMatrix in=%27shadowBlurOuter1%27 result=%27shadowMatrixOuter1%27 values=%270 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.2 0%27/%3E%3CfeMerge%3E%3CfeMergeNode in=%27shadowMatrixOuter1%27/%3E%3CfeMergeNode in=%27SourceGraphic%27/%3E%3C/feMerge%3E%3C/filter%3E%3Cpath id=%27b%27 d=%27M1.67 12.67a7.7 7.7 0 0 0 0-9.34L0 5V0h5L3.24 1.76a9.9 9.9 0 0 1 0 12.48L5 16H0v-5l1.67 1.67z%27/%3E%3C/defs%3E%3Cg fill=%27none%27 fill-rule=%27evenodd%27%3E%3Cpath d=%27M0 24V0h24v24z%27/%3E%3Cg fill-rule=%27nonzero%27 filter=%27url%28%23a%29%27 transform=%27rotate%28105 5.84 13.617%29%27%3E%3Cuse fill=%27%23000%27 fill-rule=%27evenodd%27 xlink:href=%27%23b%27/%3E%3Cpath stroke=%27%23FFF%27 d=%27M1.6 11.9a7.21 7.21 0 0 0 0-7.8L-.5 6.2V-.5h6.7L3.9 1.8a10.4 10.4 0 0 1 0 12.4l2.3 2.3H-.5V9.8l2.1 2.1z%27/%3E%3C/g%3E%3C/g%3E%3C/svg%3E"', svgDataURL16 = '"data:image/svg+xml;charset=utf-8,%3Csvg xmlns=%27http://www.w3.org/2000/svg%27 xmlns:xlink=%27http://www.w3.org/1999/xlink%27 width=%2724%27 height=%2724%27%3E%3Cdefs%3E%3Cfilter id=%27a%27 width=%27266.7%25%27 height=%27156.2%25%27 x=%27-75%25%27 y=%27-21.9%25%27 filterUnits=%27objectBoundingBox%27%3E%3CfeOffset dy=%271%27 in=%27SourceAlpha%27 result=%27shadowOffsetOuter1%27/%3E%3CfeGaussianBlur in=%27shadowOffsetOuter1%27 result=%27shadowBlurOuter1%27 stdDeviation=%271%27/%3E%3CfeColorMatrix in=%27shadowBlurOuter1%27 result=%27shadowMatrixOuter1%27 values=%270 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.2 0%27/%3E%3CfeMerge%3E%3CfeMergeNode in=%27shadowMatrixOuter1%27/%3E%3CfeMergeNode in=%27SourceGraphic%27/%3E%3C/feMerge%3E%3C/filter%3E%3Cpath id=%27b%27 d=%27M1.67 12.67a7.7 7.7 0 0 0 0-9.34L0 5V0h5L3.24 1.76a9.9 9.9 0 0 1 0 12.48L5 16H0v-5l1.67 1.67z%27/%3E%3C/defs%3E%3Cg fill=%27none%27 fill-rule=%27evenodd%27%3E%3Cpath d=%27M0 24V0h24v24z%27/%3E%3Cg fill-rule=%27nonzero%27 filter=%27url%28%23a%29%27 transform=%27rotate%28120 6.084 12.666%29%27%3E%3Cuse fill=%27%23000%27 fill-rule=%27evenodd%27 xlink:href=%27%23b%27/%3E%3Cpath stroke=%27%23FFF%27 d=%27M1.6 11.9a7.21 7.21 0 0 0 0-7.8L-.5 6.2V-.5h6.7L3.9 1.8a10.4 10.4 0 0 1 0 12.4l2.3 2.3H-.5V9.8l2.1 2.1z%27/%3E%3C/g%3E%3C/g%3E%3C/svg%3E"', svgDataURL17 = '"data:image/svg+xml;charset=utf-8,%3Csvg xmlns=%27http://www.w3.org/2000/svg%27 xmlns:xlink=%27http://www.w3.org/1999/xlink%27 width=%2724%27 height=%2724%27%3E%3Cdefs%3E%3Cfilter id=%27a%27 width=%27266.7%25%27 height=%27156.2%25%27 x=%27-75%25%27 y=%27-21.9%25%27 filterUnits=%27objectBoundingBox%27%3E%3CfeOffset dy=%271%27 in=%27SourceAlpha%27 result=%27shadowOffsetOuter1%27/%3E%3CfeGaussianBlur in=%27shadowOffsetOuter1%27 result=%27shadowBlurOuter1%27 stdDeviation=%271%27/%3E%3CfeColorMatrix in=%27shadowBlurOuter1%27 result=%27shadowMatrixOuter1%27 values=%270 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.2 0%27/%3E%3CfeMerge%3E%3CfeMergeNode in=%27shadowMatrixOuter1%27/%3E%3CfeMergeNode in=%27SourceGraphic%27/%3E%3C/feMerge%3E%3C/filter%3E%3Cpath id=%27b%27 d=%27M1.67 12.67a7.7 7.7 0 0 0 0-9.34L0 5V0h5L3.24 1.76a9.9 9.9 0 0 1 0 12.48L5 16H0v-5l1.67 1.67z%27/%3E%3C/defs%3E%3Cg fill=%27none%27 fill-rule=%27evenodd%27%3E%3Cpath d=%27M0 24V0h24v24z%27/%3E%3Cg fill-rule=%27nonzero%27 filter=%27url%28%23a%29%27 transform=%27rotate%28135 6.317 12.01%29%27%3E%3Cuse fill=%27%23000%27 fill-rule=%27evenodd%27 xlink:href=%27%23b%27/%3E%3Cpath stroke=%27%23FFF%27 d=%27M1.6 11.9a7.21 7.21 0 0 0 0-7.8L-.5 6.2V-.5h6.7L3.9 1.8a10.4 10.4 0 0 1 0 12.4l2.3 2.3H-.5V9.8l2.1 2.1z%27/%3E%3C/g%3E%3C/g%3E%3C/svg%3E"', svgDataURL18 = '"data:image/svg+xml;charset=utf-8,%3Csvg xmlns=%27http://www.w3.org/2000/svg%27 xmlns:xlink=%27http://www.w3.org/1999/xlink%27 width=%2724%27 height=%2724%27%3E%3Cdefs%3E%3Cfilter id=%27a%27 width=%27266.7%25%27 height=%27156.2%25%27 x=%27-75%25%27 y=%27-21.9%25%27 filterUnits=%27objectBoundingBox%27%3E%3CfeOffset dy=%271%27 in=%27SourceAlpha%27 result=%27shadowOffsetOuter1%27/%3E%3CfeGaussianBlur in=%27shadowOffsetOuter1%27 result=%27shadowBlurOuter1%27 stdDeviation=%271%27/%3E%3CfeColorMatrix in=%27shadowBlurOuter1%27 result=%27shadowMatrixOuter1%27 values=%270 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.2 0%27/%3E%3CfeMerge%3E%3CfeMergeNode in=%27shadowMatrixOuter1%27/%3E%3CfeMergeNode in=%27SourceGraphic%27/%3E%3C/feMerge%3E%3C/filter%3E%3Cpath id=%27b%27 d=%27M1.67 12.67a7.7 7.7 0 0 0 0-9.34L0 5V0h5L3.24 1.76a9.9 9.9 0 0 1 0 12.48L5 16H0v-5l1.67 1.67z%27/%3E%3C/defs%3E%3Cg fill=%27none%27 fill-rule=%27evenodd%27%3E%3Cpath d=%27M0 24V0h24v24z%27/%3E%3Cg fill-rule=%27nonzero%27 filter=%27url%28%23a%29%27 transform=%27rotate%28150 6.754 11.325%29%27%3E%3Cuse fill=%27%23000%27 fill-rule=%27evenodd%27 xlink:href=%27%23b%27/%3E%3Cpath stroke=%27%23FFF%27 d=%27M1.6 11.9a7.21 7.21 0 0 0 0-7.8L-.5 6.2V-.5h6.7L3.9 1.8a10.4 10.4 0 0 1 0 12.4l2.3 2.3H-.5V9.8l2.1 2.1z%27/%3E%3C/g%3E%3C/g%3E%3C/svg%3E"', svgDataURL19 = '"data:image/svg+xml;charset=utf-8,%3Csvg xmlns=%27http://www.w3.org/2000/svg%27 xmlns:xlink=%27http://www.w3.org/1999/xlink%27 width=%2724%27 height=%2724%27%3E%3Cdefs%3E%3Cfilter id=%27a%27 width=%27266.7%25%27 height=%27156.2%25%27 x=%27-75%25%27 y=%27-21.9%25%27 filterUnits=%27objectBoundingBox%27%3E%3CfeOffset dy=%271%27 in=%27SourceAlpha%27 result=%27shadowOffsetOuter1%27/%3E%3CfeGaussianBlur in=%27shadowOffsetOuter1%27 result=%27shadowBlurOuter1%27 stdDeviation=%271%27/%3E%3CfeColorMatrix in=%27shadowBlurOuter1%27 result=%27shadowMatrixOuter1%27 values=%270 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.2 0%27/%3E%3CfeMerge%3E%3CfeMergeNode in=%27shadowMatrixOuter1%27/%3E%3CfeMergeNode in=%27SourceGraphic%27/%3E%3C/feMerge%3E%3C/filter%3E%3Cpath id=%27b%27 d=%27M1.67 12.67a7.7 7.7 0 0 0 0-9.34L0 5V0h5L3.24 1.76a9.9 9.9 0 0 1 0 12.48L5 16H0v-5l1.67 1.67z%27/%3E%3C/defs%3E%3Cg fill=%27none%27 fill-rule=%27evenodd%27%3E%3Cpath d=%27M0 24V0h24v24z%27/%3E%3Cg fill-rule=%27nonzero%27 filter=%27url%28%23a%29%27 transform=%27rotate%28165 7.06 10.653%29%27%3E%3Cuse fill=%27%23000%27 fill-rule=%27evenodd%27 xlink:href=%27%23b%27/%3E%3Cpath stroke=%27%23FFF%27 d=%27M1.6 11.9a7.21 7.21 0 0 0 0-7.8L-.5 6.2V-.5h6.7L3.9 1.8a10.4 10.4 0 0 1 0 12.4l2.3 2.3H-.5V9.8l2.1 2.1z%27/%3E%3C/g%3E%3C/g%3E%3C/svg%3E"', svgDataURL20 = '"data:image/svg+xml;charset=utf-8,%3Csvg xmlns=%27http://www.w3.org/2000/svg%27 xmlns:xlink=%27http://www.w3.org/1999/xlink%27 width=%2724%27 height=%2724%27%3E%3Cdefs%3E%3Cfilter id=%27a%27 width=%27266.7%25%27 height=%27156.2%25%27 x=%27-75%25%27 y=%27-21.9%25%27 filterUnits=%27objectBoundingBox%27%3E%3CfeOffset dy=%271%27 in=%27SourceAlpha%27 result=%27shadowOffsetOuter1%27/%3E%3CfeGaussianBlur in=%27shadowOffsetOuter1%27 result=%27shadowBlurOuter1%27 stdDeviation=%271%27/%3E%3CfeColorMatrix in=%27shadowBlurOuter1%27 result=%27shadowMatrixOuter1%27 values=%270 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.2 0%27/%3E%3CfeMerge%3E%3CfeMergeNode in=%27shadowMatrixOuter1%27/%3E%3CfeMergeNode in=%27SourceGraphic%27/%3E%3C/feMerge%3E%3C/filter%3E%3Cpath id=%27b%27 d=%27M1.67 12.67a7.7 7.7 0 0 0 0-9.34L0 5V0h5L3.24 1.76a9.9 9.9 0 0 1 0 12.48L5 16H0v-5l1.67 1.67z%27/%3E%3C/defs%3E%3Cg fill=%27none%27 fill-rule=%27evenodd%27%3E%3Cpath d=%27M0 24V0h24v24z%27/%3E%3Cg fill-rule=%27nonzero%27 filter=%27url%28%23a%29%27 transform=%27rotate%28-180 7.25 10%29%27%3E%3Cuse fill=%27%23000%27 fill-rule=%27evenodd%27 xlink:href=%27%23b%27/%3E%3Cpath stroke=%27%23FFF%27 d=%27M1.6 11.9a7.21 7.21 0 0 0 0-7.8L-.5 6.2V-.5h6.7L3.9 1.8a10.4 10.4 0 0 1 0 12.4l2.3 2.3H-.5V9.8l2.1 2.1z%27/%3E%3C/g%3E%3C/g%3E%3C/svg%3E"', svgDataURL21 = '"data:image/svg+xml;charset=utf-8,%3Csvg xmlns=%27http://www.w3.org/2000/svg%27 xmlns:xlink=%27http://www.w3.org/1999/xlink%27 width=%2724%27 height=%2724%27%3E%3Cdefs%3E%3Cfilter id=%27a%27 width=%27266.7%25%27 height=%27156.2%25%27 x=%27-75%25%27 y=%27-21.9%25%27 filterUnits=%27objectBoundingBox%27%3E%3CfeOffset dy=%271%27 in=%27SourceAlpha%27 result=%27shadowOffsetOuter1%27/%3E%3CfeGaussianBlur in=%27shadowOffsetOuter1%27 result=%27shadowBlurOuter1%27 stdDeviation=%271%27/%3E%3CfeColorMatrix in=%27shadowBlurOuter1%27 result=%27shadowMatrixOuter1%27 values=%270 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.2 0%27/%3E%3CfeMerge%3E%3CfeMergeNode in=%27shadowMatrixOuter1%27/%3E%3CfeMergeNode in=%27SourceGraphic%27/%3E%3C/feMerge%3E%3C/filter%3E%3Cpath id=%27b%27 d=%27M1.67 12.67a7.7 7.7 0 0 0 0-9.34L0 5V0h5L3.24 1.76a9.9 9.9 0 0 1 0 12.48L5 16H0v-5l1.67 1.67z%27/%3E%3C/defs%3E%3Cg fill=%27none%27 fill-rule=%27evenodd%27%3E%3Cpath d=%27M0 24V0h24v24z%27/%3E%3Cg fill-rule=%27nonzero%27 filter=%27url%28%23a%29%27 transform=%27rotate%28-165 7.597 9.43%29%27%3E%3Cuse fill=%27%23000%27 fill-rule=%27evenodd%27 xlink:href=%27%23b%27/%3E%3Cpath stroke=%27%23FFF%27 d=%27M1.6 11.9a7.21 7.21 0 0 0 0-7.8L-.5 6.2V-.5h6.7L3.9 1.8a10.4 10.4 0 0 1 0 12.4l2.3 2.3H-.5V9.8l2.1 2.1z%27/%3E%3C/g%3E%3C/g%3E%3C/svg%3E"', svgDataURL23 = '"data:image/svg+xml;charset=utf-8,%3Csvg xmlns=%27http://www.w3.org/2000/svg%27 xmlns:xlink=%27http://www.w3.org/1999/xlink%27 width=%2724%27 height=%2724%27%3E%3Cdefs%3E%3Cfilter id=%27a%27 width=%27266.7%25%27 height=%27156.2%25%27 x=%27-75%25%27 y=%27-21.9%25%27 filterUnits=%27objectBoundingBox%27%3E%3CfeOffset dy=%271%27 in=%27SourceAlpha%27 result=%27shadowOffsetOuter1%27/%3E%3CfeGaussianBlur in=%27shadowOffsetOuter1%27 result=%27shadowBlurOuter1%27 stdDeviation=%271%27/%3E%3CfeColorMatrix in=%27shadowBlurOuter1%27 result=%27shadowMatrixOuter1%27 values=%270 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.2 0%27/%3E%3CfeMerge%3E%3CfeMergeNode in=%27shadowMatrixOuter1%27/%3E%3CfeMergeNode in=%27SourceGraphic%27/%3E%3C/feMerge%3E%3C/filter%3E%3Cpath id=%27b%27 d=%27M1.67 12.67a7.7 7.7 0 0 0 0-9.34L0 5V0h5L3.24 1.76a9.9 9.9 0 0 1 0 12.48L5 16H0v-5l1.67 1.67z%27/%3E%3C/defs%3E%3Cg fill=%27none%27 fill-rule=%27evenodd%27%3E%3Cpath d=%27M0 24V0h24v24z%27/%3E%3Cg fill-rule=%27nonzero%27 filter=%27url%28%23a%29%27 transform=%27rotate%28-135 7.974 7.99%29%27%3E%3Cuse fill=%27%23000%27 fill-rule=%27evenodd%27 xlink:href=%27%23b%27/%3E%3Cpath stroke=%27%23FFF%27 d=%27M1.6 11.9a7.21 7.21 0 0 0 0-7.8L-.5 6.2V-.5h6.7L3.9 1.8a10.4 10.4 0 0 1 0 12.4l2.3 2.3H-.5V9.8l2.1 2.1z%27/%3E%3C/g%3E%3C/g%3E%3C/svg%3E"', svgDataURL24 = '"data:image/svg+xml;charset=utf-8,%3Csvg xmlns=%27http://www.w3.org/2000/svg%27 xmlns:xlink=%27http://www.w3.org/1999/xlink%27 width=%2724%27 height=%2724%27%3E%3Cdefs%3E%3Cfilter id=%27a%27 width=%27266.7%25%27 height=%27156.2%25%27 x=%27-75%25%27 y=%27-21.9%25%27 filterUnits=%27objectBoundingBox%27%3E%3CfeOffset dy=%271%27 in=%27SourceAlpha%27 result=%27shadowOffsetOuter1%27/%3E%3CfeGaussianBlur in=%27shadowOffsetOuter1%27 result=%27shadowBlurOuter1%27 stdDeviation=%271%27/%3E%3CfeColorMatrix in=%27shadowBlurOuter1%27 result=%27shadowMatrixOuter1%27 values=%270 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.2 0%27/%3E%3CfeMerge%3E%3CfeMergeNode in=%27shadowMatrixOuter1%27/%3E%3CfeMergeNode in=%27SourceGraphic%27/%3E%3C/feMerge%3E%3C/filter%3E%3Cpath id=%27b%27 d=%27M1.67 12.67a7.7 7.7 0 0 0 0-9.34L0 5V0h5L3.24 1.76a9.9 9.9 0 0 1 0 12.48L5 16H0v-5l1.67 1.67z%27/%3E%3C/defs%3E%3Cg fill=%27none%27 fill-rule=%27evenodd%27%3E%3Cpath d=%27M0 24V0h24v24z%27/%3E%3Cg fill-rule=%27nonzero%27 filter=%27url%28%23a%29%27 transform=%27rotate%28-120 8.393 7.332%29%27%3E%3Cuse fill=%27%23000%27 fill-rule=%27evenodd%27 xlink:href=%27%23b%27/%3E%3Cpath stroke=%27%23FFF%27 d=%27M1.6 11.9a7.21 7.21 0 0 0 0-7.8L-.5 6.2V-.5h6.7L3.9 1.8a10.4 10.4 0 0 1 0 12.4l2.3 2.3H-.5V9.8l2.1 2.1z%27/%3E%3C/g%3E%3C/g%3E%3C/svg%3E"', svgDataURL25 = '"data:image/svg+xml;charset=utf-8,%3Csvg xmlns=%27http://www.w3.org/2000/svg%27 xmlns:xlink=%27http://www.w3.org/1999/xlink%27 width=%2724%27 height=%2724%27%3E%3Cdefs%3E%3Cfilter id=%27a%27 width=%27266.7%25%27 height=%27156.2%25%27 x=%27-75%25%27 y=%27-21.9%25%27 filterUnits=%27objectBoundingBox%27%3E%3CfeOffset dy=%271%27 in=%27SourceAlpha%27 result=%27shadowOffsetOuter1%27/%3E%3CfeGaussianBlur in=%27shadowOffsetOuter1%27 result=%27shadowBlurOuter1%27 stdDeviation=%271%27/%3E%3CfeColorMatrix in=%27shadowBlurOuter1%27 result=%27shadowMatrixOuter1%27 values=%270 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.2 0%27/%3E%3CfeMerge%3E%3CfeMergeNode in=%27shadowMatrixOuter1%27/%3E%3CfeMergeNode in=%27SourceGraphic%27/%3E%3C/feMerge%3E%3C/filter%3E%3Cpath id=%27b%27 d=%27M1.67 12.67a7.7 7.7 0 0 0 0-9.34L0 5V0h5L3.24 1.76a9.9 9.9 0 0 1 0 12.48L5 16H0v-5l1.67 1.67z%27/%3E%3C/defs%3E%3Cg fill=%27none%27 fill-rule=%27evenodd%27%3E%3Cpath d=%27M0 24V0h24v24z%27/%3E%3Cg fill-rule=%27nonzero%27 filter=%27url%28%23a%29%27 transform=%27rotate%28-105 8.83 6.441%29%27%3E%3Cuse fill=%27%23000%27 fill-rule=%27evenodd%27 xlink:href=%27%23b%27/%3E%3Cpath stroke=%27%23FFF%27 d=%27M1.6 11.9a7.21 7.21 0 0 0 0-7.8L-.5 6.2V-.5h6.7L3.9 1.8a10.4 10.4 0 0 1 0 12.4l2.3 2.3H-.5V9.8l2.1 2.1z%27/%3E%3C/g%3E%3C/g%3E%3C/svg%3E"', styleList$8 = createStyleList$1();
styleList$8.push([
  37,
  `.mirae-rotate.handle[mira-editor-el] {
  width: 32px;
  height: 32px;
  display: flex;
  align-items: center;
  justify-content: center;
  pointer-events: auto;
  position: relative;
  z-index: 3;
}
.mirae-rotate.handle[mira-editor-el]:after {
  width: 20px;
  height: 20px;
  content: "";
  transition-property: opacity, width, height;
  transition-duration: 0.3s;
  position: relative;
  border-radius: 10px;
  box-shadow: 0 0 5px 1px rgba(57, 76, 96, 0.15), 0 0 0 1px rgba(53, 71, 90, 0.2);
  opacity: 1;
  background: #FFF 2px no-repeat;
  background-size: 16px;
  z-index: 9;
  background-image: url(` + svgDataURL1$2 + `);
}
.mirae-rot-cursor[rr="0"] {
  cursor: url(` + svgDataURL2$2 + `) 12 12, auto;
}
.mirae-rot-cursor[rr="1"] {
  cursor: url(` + svgDataURL3$2 + `) 12 12, auto;
}
.mirae-rot-cursor[rr="2"] {
  cursor: url(` + svgDataURL4$2 + `) 12 12, auto;
}
.mirae-rot-cursor[rr="3"] {
  cursor: url(` + svgDataURL5$1 + `) 12 12, auto;
}
.mirae-rot-cursor[rr="4"] {
  cursor: url(` + svgDataURL6$1 + `) 12 12, auto;
}
.mirae-rot-cursor[rr="5"] {
  cursor: url(` + svgDataURL7$1 + `) 12 12, auto;
}
.mirae-rot-cursor[rr="6"] {
  cursor: url(` + svgDataURL8$1 + `) 12 12, auto;
}
.mirae-rot-cursor[rr="7"] {
  cursor: url(` + svgDataURL9$1 + `) 12 12, auto;
}
.mirae-rot-cursor[rr="8"] {
  cursor: url(` + svgDataURL10$1 + `) 12 12, auto;
}
.mirae-rot-cursor[rr="9"] {
  cursor: url(` + svgDataURL11 + `) 12 12, auto;
}
.mirae-rot-cursor[rr="10"] {
  cursor: url(` + svgDataURL12 + `) 12 12, auto;
}
.mirae-rot-cursor[rr="11"] {
  cursor: url(` + svgDataURL13 + `) 12 12, auto;
}
.mirae-rot-cursor[rr="12"] {
  cursor: url(` + svgDataURL14 + `) 12 12, auto;
}
.mirae-rot-cursor[rr="13"] {
  cursor: url(` + svgDataURL15 + `) 12 12, auto;
}
.mirae-rot-cursor[rr="14"] {
  cursor: url(` + svgDataURL16 + `) 12 12, auto;
}
.mirae-rot-cursor[rr="15"] {
  cursor: url(` + svgDataURL17 + `) 12 12, auto;
}
.mirae-rot-cursor[rr="16"] {
  cursor: url(` + svgDataURL18 + `) 12 12, auto;
}
.mirae-rot-cursor[rr="17"] {
  cursor: url(` + svgDataURL19 + `) 12 12, auto;
}
.mirae-rot-cursor[rr="18"] {
  cursor: url(` + svgDataURL20 + `) 12 12, auto;
}
.mirae-rot-cursor[rr="19"] {
  cursor: url(` + svgDataURL21 + `) 12 12, auto;
}
.mirae-rot-cursor[rr="20"] {
  cursor: url(` + svgDataURL23 + `) 12 12, auto;
}
.mirae-rot-cursor[rr="21"] {
  cursor: url(` + svgDataURL23 + `) 12 12, auto;
}
.mirae-rot-cursor[rr="22"] {
  cursor: url(` + svgDataURL24 + `) 12 12, auto;
}
.mirae-rot-cursor[rr="23"] {
  cursor: url(` + svgDataURL25 + `) 12 12, auto;
}
`,
  ""
]);
createStyleManager$1(styleList$8, createStyleOption$1());
styleList$8.locals && styleList$8.locals;
class EditorRotateElement extends EditorMoveElement {
  box() {
    var e;
    return (e = this.parentElement) == null ? void 0 : e.parentElement;
  }
  setOpts(e) {
    super.setOpts(e);
    const t = this.box();
    return t ? (this.wrapper = wrap(t, "setRotate").after(
      (r, a) => this.setRotate(t.rotation) && a
    ), this.addClass(this.constructor.CURSOR_CLASS).setRotate(
      t.rotation
    )) : this;
  }
  raOffset() {
    return parseInt(1.5 * this.constructor.RA_NUM);
  }
  setRotate(e) {
    var s;
    const t = (s = this.box()) == null ? void 0 : s.handleBox, r = (this.raOffset() + (parseInt(deg(e)) + 7.5) / 15 >> 0) % this.constructor.RA_NUM;
    if (document.body.setAttribute("r", r.toString()), this.set("r", r.toString()), !(t != null && t.classList))
      return this;
    t.classList.contains("left") ? e += Math.PI / 2 : t.classList.contains("right") ? e -= Math.PI / 2 : t.classList.contains("top") && (e += Math.PI);
    const a = (this.raOffset() + (parseInt(deg(e)) + 7.5) / 15 >> 0) % this.constructor.RA_NUM;
    return document.body.setAttribute("rr", a.toString()), this.set("rr", a.toString()), this;
  }
  remove() {
    this.wrapper && (this.wrapper.revoke(), this.wrapper = null), super.remove();
  }
  bindBodyEvents(e, t) {
    super.bindBodyEvents(e, t), e ? (document.body.setAttribute("r", this.getAttribute("r") || "0"), document.body.setAttribute("rr", this.getAttribute("rr") || "0"), document.body.classList.add(this.constructor.CURSOR_CLASS)) : document.body.classList.remove(this.constructor.CURSOR_CLASS);
  }
}
Ct(EditorRotateElement, "TAG", "mira-editor-rotate"), Ct(EditorRotateElement, "STYLE_CLASS", "mirae-rotate"), Ct(EditorRotateElement, "CURSOR_CLASS", "mirae-rot-cursor"), Ct(EditorRotateElement, "RA_NUM", 24);
EditorRotateElement.register();
class EditorResizeElement extends EditorRotateElement {
  init() {
    return super.init();
  }
  has(e, t) {
    return (e & t) >> Math.log2(t);
  }
  mat(e) {
    const { LEFT: t, TOP: r, RIGHT: a, BOTTOM: s } = this.constructor;
    this._mat = [t, r, a, s].map((l) => this.has(e, l)), this.fixRatio = sum(this._mat) > 1;
    const u = arrMulti([-1, -1, 1, 1], this._mat);
    return this.direction = [
      u[0] + u[2],
      u[1] + u[3]
    ], this;
  }
  boundingConstraint() {
    const e = this.parentElement, t = arrMulti(this.direction, [
      e.size.width,
      e.size.height
    ]), r = new Vector({
      x: t[0],
      y: t[1]
    }).rotate(e.rotation);
    return {
      x: [r.x < 0, false, r.x > 0],
      y: [r.y < 0, false, r.y > 0]
    };
  }
  reverse(e, t = false) {
    const r = this.parentElement;
    if (e = { x: 0, y: 0, ...e }, e.x * e.y !== 0) return;
    const a = arrMulti(this.direction, [
      r.size.width,
      r.size.height
    ]), s = new Vector({ x: a[0], y: 0 }).rotate(
      r.rotation
    ), u = new Vector({ x: 0, y: a[1] }).rotate(
      r.rotation
    ), l = theta({ x: 0, y: -1 }, a) + r.rotation;
    for (const [c, d] of Object.entries(e)) {
      if (d === 0) continue;
      s[c] * u[c] < 0 && (e[c] = Math.max(e[c] / s[c], e[c] / u[c]) * Math.abs(s[c] + u[c]));
      const f = Math.abs(
        r.scale * e[c] / (c === "x" ? Math.sin(l) : Math.cos(l))
      );
      return t ? { r: f, θ: l } : new Vector({ x: 0, y: -f }).rotate(l);
    }
  }
  constraint(e, t = null) {
    const r = this.parentElement;
    if (e = new Vector({
      x: e.x / r.scale,
      y: e.y / r.scale
    }).rotate(-r.rotation), this.fixRatio) {
      const d = arrMulti(this.direction, [
        r.size.width,
        r.size.height
      ]), f = dot(e, d) / Math.pow(norm2d(d), 2);
      e = { x: d[0] * f, y: d[1] * f };
    }
    const a = {
      x: this._mat[0] * e.x,
      y: this._mat[1] * e.y
    }, s = this._mat[2] * e.x, u = this._mat[3] * e.y, l = {
      width: s - a.x,
      height: u - a.y
    };
    t || (t = r.anchor);
    const c = [t.x * l.width, t.y * l.height];
    return {
      position: new Vector(a).offset(c).rotate(r.rotation),
      size: l
    };
  }
  box() {
    return this.parentElement;
  }
  raOffset() {
    return this.constructor.RA_NUM + this.raIdx;
  }
  setOpts(e) {
    this.mat(e.pos), this.addClass(
      ["left", "top", "right", "bottom"].filter(
        (r, a) => this._mat[a]
      )
    );
    const t = this._mat.map((r, a) => r * (a + 1) << 1).filter((r) => r > 0);
    return this.raIdx = (t.length > 1 ? sum(t) >> 1 : t[0]) % 4 * 3, super.setOpts(e);
  }
}
Ct(EditorResizeElement, "TAG", "mira-editor-resize"), Ct(EditorResizeElement, "STYLE_CLASS", "mirae-resize"), Ct(EditorResizeElement, "CURSOR_CLASS", "mirae-rze-cursor"), Ct(EditorResizeElement, "RA_NUM", 12), Ct(EditorResizeElement, "LEFT", 8), Ct(EditorResizeElement, "TOP", 4), Ct(EditorResizeElement, "RIGHT", 2), Ct(EditorResizeElement, "BOTTOM", 1);
EditorResizeElement.register();
var { LEFT, TOP, RIGHT, BOTTOM } = EditorResizeElement;
const bu = class bu2 extends EditorMoveComponent {
  show(e = !this.selector.withMulti) {
    return e ? this.box && this.updateShow(this.box) : Object.values(this._controls).forEach((t) => t.show(e)), this;
  }
  controls() {
    if (this.node.conf.resizeDisable || this.node.cropMode)
      return {};
    const e = {
      topLeft: { pos: TOP | LEFT, styleClass: "dot" },
      topRight: { pos: TOP | RIGHT, styleClass: "dot" },
      bottomRight: { pos: BOTTOM | RIGHT, styleClass: "dot" },
      bottomLeft: { pos: BOTTOM | LEFT, styleClass: "dot" }
    };
    if (this.node.conf.resizeScaleOnly || this.node.type === "richtext")
      return e;
    const t = {
      left: { pos: LEFT, styleClass: "ver" },
      right: { pos: RIGHT, styleClass: "ver" }
    };
    return this.node.type === "group" ? Object.values(this.node.nodes).every(
      (a) => a.type === "text"
    ) ? { ...t, ...e } : e : (this.node.type !== "text" && (t.top = { pos: TOP, styleClass: "hor" }, t.bottom = { pos: BOTTOM, styleClass: "hor" }), { ...t, ...e });
  }
  updateShow(e) {
    var a;
    const t = e.hasClass("editMode"), r = {
      hor: e.size.width * e.scale > 50,
      ver: ["text", "group"].includes((a = this.node) == null ? void 0 : a.type) || e.size.height * e.scale > 50,
      dot: Math.min(e.size.width, e.size.height) * e.scale > 30
    };
    for (const [s, u] of Object.entries(this._controls))
      t ? u.show(false) : u.show(
        s === "bottomRight" || r[u.styleClass]
      );
  }
  getDelta(e) {
    return e.target.constraint(e.delta);
  }
  onMove(e) {
    if (!this.node || !this.box)
      return;
    const t = this.getDelta(e);
    if (round$2(t.size.width) === 0 && round$2(t.size.height) === 0)
      return;
    bu2.apply(this.node, t), this.box.resize();
    const { width: r, height: a } = round$2(this.box.size, 0);
    this.toast(`${r} × ${a}`, 3e3);
  }
};
Ct(bu, "type", "resize"), Ct(bu, "TAG", EditorResizeElement);
let EditorResizeComponent = bu;
class EditorGroup extends VNode$1 {
  constructor(e) {
    super({ type: "group" }), this.visible = true, this.nodes = {}, this.boxes = {}, this.initContainer(), Array.isArray(e) ? e.map((t) => this.toggleNode(t)) : typeof e == "object" && this.toggleNode(e);
  }
  creator() {
    return Object.values(this.nodes)[0].creator();
  }
  initContainer() {
    this.container = document.createElement("div"), this.container.setAttribute("mira-editor-el", ""), this.container.classList.add("mira-editor-group");
  }
  appendTo(e) {
    e.classList.add("group"), e.append(this.container), this.fit(e.scale);
  }
  fit(e) {
    e !== void 0 && (this.scale = e, Object.values(this.boxes).forEach((d) => d && d.fit(e)), this._dirty_ = true);
    const {
      size: [t, r],
      position: [a, s]
    } = this.metrcs(), { x: u, y: l } = new Vector([a, s]).scale(-this.scale).rotate(-this._rotation), c = deg(-this._rotation, 1);
    return this.container.style.transform = `translate(${u}px, ${l}px) rotate(${c}deg)`, this;
  }
  createBox(e) {
    const { scale: t, container: r } = this;
    return e.getAnchor ? EditorBoxElement.create({ node: e, container: r, scale: t, selected: false }) : null;
  }
  toggleNode(e) {
    var t, r;
    if (this.groupSelect(e))
      Object.values(this.nodes).forEach((a) => {
        this.boxes[a.id] || (this.boxes[a.id] = this.createBox(a));
      });
    else if (this.nodes[e.id]) {
      (t = this.boxes[e.id]) == null || t.remove(), delete this.nodes[e.id], delete this.boxes[e.id];
      const a = Object.values(this.nodes);
      if (a.length === 1)
        return (r = this.boxes[a[0].id]) == null || r.remove(), this.boxes = null, this.nodes = null, a[0];
    } else
      this.nodes[e.id] = e, this.boxes[e.id] = this.createBox(e);
    return this._dirty_ = true, this;
  }
  setRotate(e) {
    const t = e - this._rotation;
    this._rotation = e;
    const r = this.metrcs().position;
    return Object.values(this.nodes).forEach((a) => {
      const s = this.boxes[a.id];
      if (!s) return;
      const u = s.position.rebase(r), { x: l, y: c } = u.rotate(t).rebase(u), d = { rotation: t, position: { x: l, y: c } };
      ComponentBase.apply(a, d, "group-rotate"), s.move().rotate();
    }), this.fit();
  }
  setXY(e, t) {
    return e -= this.getX(), t -= this.getY(), Object.values(this.nodes).forEach((r) => {
      var a;
      EditorMoveComponent.apply(r, { position: { x: e, y: t } }), (a = this.boxes[r.id]) == null || a.move();
    }), this._metrcs_.position[0] += e, this._metrcs_.position[1] += t, this.fit();
  }
  setWH(e, t) {
    const [r, a] = this.getWH();
    let s = {
      x: (e - r) / r,
      y: (t - a) / a
    };
    s.x > 0 && s.y > 0 && (s.x = s.y = Math.max(s.x, s.y));
    const u = this.metrcs().position;
    return Object.values(this.nodes).forEach((l) => {
      const c = this.boxes[l.id];
      if (!c) return;
      const d = {
        size: {
          width: c.size.width * s.x,
          height: c.size.height * s.y
        },
        position: c.position.rebase(u).scale(s)
      };
      EditorResizeComponent.apply(l, d), this.boxes[l.id].resize();
    }), this._metrcs_.size[0] += e, this._metrcs_.size[1] += t, this;
  }
  metrcs() {
    if (!this._dirty_) return this._metrcs_;
    this._metrcs_ = {};
    const e = { top: MAX, left: MAX, bottom: 0, right: 0 };
    for (const s of Object.values(this.boxes)) {
      if (!s) continue;
      const { top: u, bottom: l, left: c, right: d } = s.bounds();
      e.top = Math.min(e.top, u), e.bottom = Math.max(e.bottom, l), e.left = Math.min(e.left, c), e.right = Math.max(e.right, d);
    }
    const t = PositionUtils.from(e), { x: r, y: a } = t.center;
    return this._metrcs_.size = [t.width + 2, t.height + 2], this._metrcs_.position = [r, a], this._dirty_ = false, this._metrcs_;
  }
  destroy() {
    super.destroy(), this.nodes = null, this.boxes = null;
  }
}
class TaskQueue {
  constructor() {
    this.queue = [], this.pendingPromise = false;
  }
  enqueue(e) {
    return new Promise((t, r) => {
      this.queue.push({ task: e, resolve: t, reject: r }), this.dequeue();
    });
  }
  dequeue() {
    if (this.pendingPromise) return false;
    const e = this.queue.shift();
    if (!e) return false;
    try {
      this.pendingPromise = true, e.task().then((t) => {
        this.pendingPromise = false, e.resolve(t), this.dequeue();
      }).catch((t) => {
        this.pendingPromise = false, e.reject(t), this.dequeue();
      });
    } catch (t) {
      this.pendingPromise = false, e.reject(t), this.dequeue();
    }
    return true;
  }
}
const TimeUtils$1 = {
  secondsToHmsf: (i2, e) => {
    const t = TimeUtils.secondsToHms(i2, 3);
    if (!e) throw new Error("fps error!");
    const r = Number(t.substring(t.length - 3)) / 1e3;
    return t.substring(0, t.length - 4) + ":" + Math.round(r * e).toString().padStart(2, "0");
  },
  secondsToHms: (i2, e = 0, t = false) => {
    i2 = i2.toFixed(e);
    const r = Math.floor(i2 / 3600).toString();
    let a = Math.floor((i2 - 3600 * r) / 60).toString();
    const s = r > 0 || t;
    s && (a = a.padStart(2, "0"));
    let u = Math.floor(
      i2 - 3600 * r - 60 * a
    ).toString();
    return a.length > 0 && (u = u.padStart(2, "0")), `${s ? r + ":" : ""}${a}:${u}` + (e > 0 ? (i2 - Math.floor(i2)).toFixed(e).replace("0.", ".") : "");
  },
  sleep: (i2) => new Promise((e) => setTimeout(e, i2))
};
/*!
 * @pixi/math - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/math is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var PI_2 = Math.PI * 2, RAD_TO_DEG = 180 / Math.PI, DEG_TO_RAD = Math.PI / 180, SHAPES;
(function(i2) {
  i2[i2.POLY = 0] = "POLY", i2[i2.RECT = 1] = "RECT", i2[i2.CIRC = 2] = "CIRC", i2[i2.ELIP = 3] = "ELIP", i2[i2.RREC = 4] = "RREC";
})(SHAPES || (SHAPES = {}));
var Point$1 = (
  /** @class */
  function() {
    function i2(e, t) {
      e === void 0 && (e = 0), t === void 0 && (t = 0), this.x = 0, this.y = 0, this.x = e, this.y = t;
    }
    return i2.prototype.clone = function() {
      return new i2(this.x, this.y);
    }, i2.prototype.copyFrom = function(e) {
      return this.set(e.x, e.y), this;
    }, i2.prototype.copyTo = function(e) {
      return e.set(this.x, this.y), e;
    }, i2.prototype.equals = function(e) {
      return e.x === this.x && e.y === this.y;
    }, i2.prototype.set = function(e, t) {
      return e === void 0 && (e = 0), t === void 0 && (t = e), this.x = e, this.y = t, this;
    }, i2.prototype.toString = function() {
      return "[@pixi/math:Point x=" + this.x + " y=" + this.y + "]";
    }, i2;
  }()
), tempPoints$1 = [new Point$1(), new Point$1(), new Point$1(), new Point$1()], Rectangle$1 = (
  /** @class */
  function() {
    function i2(e, t, r, a) {
      e === void 0 && (e = 0), t === void 0 && (t = 0), r === void 0 && (r = 0), a === void 0 && (a = 0), this.x = Number(e), this.y = Number(t), this.width = Number(r), this.height = Number(a), this.type = SHAPES.RECT;
    }
    return Object.defineProperty(i2.prototype, "left", {
      /** Returns the left edge of the rectangle. */
      get: function() {
        return this.x;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(i2.prototype, "right", {
      /** Returns the right edge of the rectangle. */
      get: function() {
        return this.x + this.width;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(i2.prototype, "top", {
      /** Returns the top edge of the rectangle. */
      get: function() {
        return this.y;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(i2.prototype, "bottom", {
      /** Returns the bottom edge of the rectangle. */
      get: function() {
        return this.y + this.height;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(i2, "EMPTY", {
      /** A constant empty rectangle. */
      get: function() {
        return new i2(0, 0, 0, 0);
      },
      enumerable: false,
      configurable: true
    }), i2.prototype.clone = function() {
      return new i2(this.x, this.y, this.width, this.height);
    }, i2.prototype.copyFrom = function(e) {
      return this.x = e.x, this.y = e.y, this.width = e.width, this.height = e.height, this;
    }, i2.prototype.copyTo = function(e) {
      return e.x = this.x, e.y = this.y, e.width = this.width, e.height = this.height, e;
    }, i2.prototype.contains = function(e, t) {
      return this.width <= 0 || this.height <= 0 ? false : e >= this.x && e < this.x + this.width && t >= this.y && t < this.y + this.height;
    }, i2.prototype.intersects = function(e, t) {
      if (!t) {
        var r = this.x < e.x ? e.x : this.x, a = this.right > e.right ? e.right : this.right;
        if (a <= r)
          return false;
        var s = this.y < e.y ? e.y : this.y, u = this.bottom > e.bottom ? e.bottom : this.bottom;
        return u > s;
      }
      var l = this.left, c = this.right, d = this.top, f = this.bottom;
      if (c <= l || f <= d)
        return false;
      var p = tempPoints$1[0].set(e.left, e.top), m = tempPoints$1[1].set(e.left, e.bottom), y = tempPoints$1[2].set(e.right, e.top), x = tempPoints$1[3].set(e.right, e.bottom);
      if (y.x <= p.x || m.y <= p.y)
        return false;
      var g = Math.sign(t.a * t.d - t.b * t.c);
      if (g === 0 || (t.apply(p, p), t.apply(m, m), t.apply(y, y), t.apply(x, x), Math.max(p.x, m.x, y.x, x.x) <= l || Math.min(p.x, m.x, y.x, x.x) >= c || Math.max(p.y, m.y, y.y, x.y) <= d || Math.min(p.y, m.y, y.y, x.y) >= f))
        return false;
      var _ = g * (m.y - p.y), T = g * (p.x - m.x), E = _ * l + T * d, b = _ * c + T * d, C = _ * l + T * f, w = _ * c + T * f;
      if (Math.max(E, b, C, w) <= _ * p.x + T * p.y || Math.min(E, b, C, w) >= _ * x.x + T * x.y)
        return false;
      var A = g * (p.y - y.y), S = g * (y.x - p.x), F = A * l + S * d, M = A * c + S * d, U = A * l + S * f, B = A * c + S * f;
      return !(Math.max(F, M, U, B) <= A * p.x + S * p.y || Math.min(F, M, U, B) >= A * x.x + S * x.y);
    }, i2.prototype.pad = function(e, t) {
      return e === void 0 && (e = 0), t === void 0 && (t = e), this.x -= e, this.y -= t, this.width += e * 2, this.height += t * 2, this;
    }, i2.prototype.fit = function(e) {
      var t = Math.max(this.x, e.x), r = Math.min(this.x + this.width, e.x + e.width), a = Math.max(this.y, e.y), s = Math.min(this.y + this.height, e.y + e.height);
      return this.x = t, this.width = Math.max(r - t, 0), this.y = a, this.height = Math.max(s - a, 0), this;
    }, i2.prototype.ceil = function(e, t) {
      e === void 0 && (e = 1), t === void 0 && (t = 1e-3);
      var r = Math.ceil((this.x + this.width - t) * e) / e, a = Math.ceil((this.y + this.height - t) * e) / e;
      return this.x = Math.floor((this.x + t) * e) / e, this.y = Math.floor((this.y + t) * e) / e, this.width = r - this.x, this.height = a - this.y, this;
    }, i2.prototype.enlarge = function(e) {
      var t = Math.min(this.x, e.x), r = Math.max(this.x + this.width, e.x + e.width), a = Math.min(this.y, e.y), s = Math.max(this.y + this.height, e.y + e.height);
      return this.x = t, this.width = r - t, this.y = a, this.height = s - a, this;
    }, i2.prototype.toString = function() {
      return "[@pixi/math:Rectangle x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + "]";
    }, i2;
  }()
), ObservablePoint$1 = (
  /** @class */
  function() {
    function i2(e, t, r, a) {
      r === void 0 && (r = 0), a === void 0 && (a = 0), this._x = r, this._y = a, this.cb = e, this.scope = t;
    }
    return i2.prototype.clone = function(e, t) {
      return e === void 0 && (e = this.cb), t === void 0 && (t = this.scope), new i2(e, t, this._x, this._y);
    }, i2.prototype.set = function(e, t) {
      return e === void 0 && (e = 0), t === void 0 && (t = e), (this._x !== e || this._y !== t) && (this._x = e, this._y = t, this.cb.call(this.scope)), this;
    }, i2.prototype.copyFrom = function(e) {
      return (this._x !== e.x || this._y !== e.y) && (this._x = e.x, this._y = e.y, this.cb.call(this.scope)), this;
    }, i2.prototype.copyTo = function(e) {
      return e.set(this._x, this._y), e;
    }, i2.prototype.equals = function(e) {
      return e.x === this._x && e.y === this._y;
    }, i2.prototype.toString = function() {
      return "[@pixi/math:ObservablePoint x=0 y=0 scope=" + this.scope + "]";
    }, Object.defineProperty(i2.prototype, "x", {
      /** Position of the observable point on the x axis. */
      get: function() {
        return this._x;
      },
      set: function(e) {
        this._x !== e && (this._x = e, this.cb.call(this.scope));
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(i2.prototype, "y", {
      /** Position of the observable point on the y axis. */
      get: function() {
        return this._y;
      },
      set: function(e) {
        this._y !== e && (this._y = e, this.cb.call(this.scope));
      },
      enumerable: false,
      configurable: true
    }), i2;
  }()
), Matrix$1 = (
  /** @class */
  function() {
    function i2(e, t, r, a, s, u) {
      e === void 0 && (e = 1), t === void 0 && (t = 0), r === void 0 && (r = 0), a === void 0 && (a = 1), s === void 0 && (s = 0), u === void 0 && (u = 0), this.array = null, this.a = e, this.b = t, this.c = r, this.d = a, this.tx = s, this.ty = u;
    }
    return i2.prototype.fromArray = function(e) {
      this.a = e[0], this.b = e[1], this.c = e[3], this.d = e[4], this.tx = e[2], this.ty = e[5];
    }, i2.prototype.set = function(e, t, r, a, s, u) {
      return this.a = e, this.b = t, this.c = r, this.d = a, this.tx = s, this.ty = u, this;
    }, i2.prototype.toArray = function(e, t) {
      this.array || (this.array = new Float32Array(9));
      var r = t || this.array;
      return e ? (r[0] = this.a, r[1] = this.b, r[2] = 0, r[3] = this.c, r[4] = this.d, r[5] = 0, r[6] = this.tx, r[7] = this.ty, r[8] = 1) : (r[0] = this.a, r[1] = this.c, r[2] = this.tx, r[3] = this.b, r[4] = this.d, r[5] = this.ty, r[6] = 0, r[7] = 0, r[8] = 1), r;
    }, i2.prototype.apply = function(e, t) {
      t = t || new Point$1();
      var r = e.x, a = e.y;
      return t.x = this.a * r + this.c * a + this.tx, t.y = this.b * r + this.d * a + this.ty, t;
    }, i2.prototype.applyInverse = function(e, t) {
      t = t || new Point$1();
      var r = 1 / (this.a * this.d + this.c * -this.b), a = e.x, s = e.y;
      return t.x = this.d * r * a + -this.c * r * s + (this.ty * this.c - this.tx * this.d) * r, t.y = this.a * r * s + -this.b * r * a + (-this.ty * this.a + this.tx * this.b) * r, t;
    }, i2.prototype.translate = function(e, t) {
      return this.tx += e, this.ty += t, this;
    }, i2.prototype.scale = function(e, t) {
      return this.a *= e, this.d *= t, this.c *= e, this.b *= t, this.tx *= e, this.ty *= t, this;
    }, i2.prototype.rotate = function(e) {
      var t = Math.cos(e), r = Math.sin(e), a = this.a, s = this.c, u = this.tx;
      return this.a = a * t - this.b * r, this.b = a * r + this.b * t, this.c = s * t - this.d * r, this.d = s * r + this.d * t, this.tx = u * t - this.ty * r, this.ty = u * r + this.ty * t, this;
    }, i2.prototype.append = function(e) {
      var t = this.a, r = this.b, a = this.c, s = this.d;
      return this.a = e.a * t + e.b * a, this.b = e.a * r + e.b * s, this.c = e.c * t + e.d * a, this.d = e.c * r + e.d * s, this.tx = e.tx * t + e.ty * a + this.tx, this.ty = e.tx * r + e.ty * s + this.ty, this;
    }, i2.prototype.setTransform = function(e, t, r, a, s, u, l, c, d) {
      return this.a = Math.cos(l + d) * s, this.b = Math.sin(l + d) * s, this.c = -Math.sin(l - c) * u, this.d = Math.cos(l - c) * u, this.tx = e - (r * this.a + a * this.c), this.ty = t - (r * this.b + a * this.d), this;
    }, i2.prototype.prepend = function(e) {
      var t = this.tx;
      if (e.a !== 1 || e.b !== 0 || e.c !== 0 || e.d !== 1) {
        var r = this.a, a = this.c;
        this.a = r * e.a + this.b * e.c, this.b = r * e.b + this.b * e.d, this.c = a * e.a + this.d * e.c, this.d = a * e.b + this.d * e.d;
      }
      return this.tx = t * e.a + this.ty * e.c + e.tx, this.ty = t * e.b + this.ty * e.d + e.ty, this;
    }, i2.prototype.decompose = function(e) {
      var t = this.a, r = this.b, a = this.c, s = this.d, u = e.pivot, l = -Math.atan2(-a, s), c = Math.atan2(r, t), d = Math.abs(l + c);
      return d < 1e-5 || Math.abs(PI_2 - d) < 1e-5 ? (e.rotation = c, e.skew.x = e.skew.y = 0) : (e.rotation = 0, e.skew.x = l, e.skew.y = c), e.scale.x = Math.sqrt(t * t + r * r), e.scale.y = Math.sqrt(a * a + s * s), e.position.x = this.tx + (u.x * t + u.y * a), e.position.y = this.ty + (u.x * r + u.y * s), e;
    }, i2.prototype.invert = function() {
      var e = this.a, t = this.b, r = this.c, a = this.d, s = this.tx, u = e * a - t * r;
      return this.a = a / u, this.b = -t / u, this.c = -r / u, this.d = e / u, this.tx = (r * this.ty - a * s) / u, this.ty = -(e * this.ty - t * s) / u, this;
    }, i2.prototype.identity = function() {
      return this.a = 1, this.b = 0, this.c = 0, this.d = 1, this.tx = 0, this.ty = 0, this;
    }, i2.prototype.clone = function() {
      var e = new i2();
      return e.a = this.a, e.b = this.b, e.c = this.c, e.d = this.d, e.tx = this.tx, e.ty = this.ty, e;
    }, i2.prototype.copyTo = function(e) {
      return e.a = this.a, e.b = this.b, e.c = this.c, e.d = this.d, e.tx = this.tx, e.ty = this.ty, e;
    }, i2.prototype.copyFrom = function(e) {
      return this.a = e.a, this.b = e.b, this.c = e.c, this.d = e.d, this.tx = e.tx, this.ty = e.ty, this;
    }, i2.prototype.toString = function() {
      return "[@pixi/math:Matrix a=" + this.a + " b=" + this.b + " c=" + this.c + " d=" + this.d + " tx=" + this.tx + " ty=" + this.ty + "]";
    }, Object.defineProperty(i2, "IDENTITY", {
      /**
       * A default (identity) matrix
       * @readonly
       */
      get: function() {
        return new i2();
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(i2, "TEMP_MATRIX", {
      /**
       * A temp matrix
       * @readonly
       */
      get: function() {
        return new i2();
      },
      enumerable: false,
      configurable: true
    }), i2;
  }()
), ux = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1], uy = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1], vx = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1], vy = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1], rotationCayley = [], rotationMatrices = [], signum = Math.sign;
function init() {
  for (var i2 = 0; i2 < 16; i2++) {
    var e = [];
    rotationCayley.push(e);
    for (var t = 0; t < 16; t++)
      for (var r = signum(ux[i2] * ux[t] + vx[i2] * uy[t]), a = signum(uy[i2] * ux[t] + vy[i2] * uy[t]), s = signum(ux[i2] * vx[t] + vx[i2] * vy[t]), u = signum(uy[i2] * vx[t] + vy[i2] * vy[t]), l = 0; l < 16; l++)
        if (ux[l] === r && uy[l] === a && vx[l] === s && vy[l] === u) {
          e.push(l);
          break;
        }
  }
  for (var i2 = 0; i2 < 16; i2++) {
    var c = new Matrix$1();
    c.set(ux[i2], uy[i2], vx[i2], vy[i2], 0, 0), rotationMatrices.push(c);
  }
}
init();
var groupD8 = {
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 0°       | East      |
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  E: 0,
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 45°↻     | Southeast |
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  SE: 1,
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 90°↻     | South     |
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  S: 2,
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 135°↻    | Southwest |
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  SW: 3,
  /**
   * | Rotation | Direction |
   * |----------|-----------|
   * | 180°     | West      |
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  W: 4,
  /**
   * | Rotation    | Direction    |
   * |-------------|--------------|
   * | -135°/225°↻ | Northwest    |
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  NW: 5,
  /**
   * | Rotation    | Direction    |
   * |-------------|--------------|
   * | -90°/270°↻  | North        |
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  N: 6,
  /**
   * | Rotation    | Direction    |
   * |-------------|--------------|
   * | -45°/315°↻  | Northeast    |
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  NE: 7,
  /**
   * Reflection about Y-axis.
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  MIRROR_VERTICAL: 8,
  /**
   * Reflection about the main diagonal.
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  MAIN_DIAGONAL: 10,
  /**
   * Reflection about X-axis.
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  MIRROR_HORIZONTAL: 12,
  /**
   * Reflection about reverse diagonal.
   * @memberof PIXI.groupD8
   * @constant {PIXI.GD8Symmetry}
   */
  REVERSE_DIAGONAL: 14,
  /**
   * @memberof PIXI.groupD8
   * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.
   * @returns {PIXI.GD8Symmetry} The X-component of the U-axis
   *    after rotating the axes.
   */
  uX: function(i2) {
    return ux[i2];
  },
  /**
   * @memberof PIXI.groupD8
   * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.
   * @returns {PIXI.GD8Symmetry} The Y-component of the U-axis
   *    after rotating the axes.
   */
  uY: function(i2) {
    return uy[i2];
  },
  /**
   * @memberof PIXI.groupD8
   * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.
   * @returns {PIXI.GD8Symmetry} The X-component of the V-axis
   *    after rotating the axes.
   */
  vX: function(i2) {
    return vx[i2];
  },
  /**
   * @memberof PIXI.groupD8
   * @param {PIXI.GD8Symmetry} ind - sprite rotation angle.
   * @returns {PIXI.GD8Symmetry} The Y-component of the V-axis
   *    after rotating the axes.
   */
  vY: function(i2) {
    return vy[i2];
  },
  /**
   * @memberof PIXI.groupD8
   * @param {PIXI.GD8Symmetry} rotation - symmetry whose opposite
   *   is needed. Only rotations have opposite symmetries while
   *   reflections don't.
   * @returns {PIXI.GD8Symmetry} The opposite symmetry of `rotation`
   */
  inv: function(i2) {
    return i2 & 8 ? i2 & 15 : -i2 & 7;
  },
  /**
   * Composes the two D8 operations.
   *
   * Taking `^` as reflection:
   *
   * |       | E=0 | S=2 | W=4 | N=6 | E^=8 | S^=10 | W^=12 | N^=14 |
   * |-------|-----|-----|-----|-----|------|-------|-------|-------|
   * | E=0   | E   | S   | W   | N   | E^   | S^    | W^    | N^    |
   * | S=2   | S   | W   | N   | E   | S^   | W^    | N^    | E^    |
   * | W=4   | W   | N   | E   | S   | W^   | N^    | E^    | S^    |
   * | N=6   | N   | E   | S   | W   | N^   | E^    | S^    | W^    |
   * | E^=8  | E^  | N^  | W^  | S^  | E    | N     | W     | S     |
   * | S^=10 | S^  | E^  | N^  | W^  | S    | E     | N     | W     |
   * | W^=12 | W^  | S^  | E^  | N^  | W    | S     | E     | N     |
   * | N^=14 | N^  | W^  | S^  | E^  | N    | W     | S     | E     |
   *
   * [This is a Cayley table]{@link https://en.wikipedia.org/wiki/Cayley_table}
   * @memberof PIXI.groupD8
   * @param {PIXI.GD8Symmetry} rotationSecond - Second operation, which
   *   is the row in the above cayley table.
   * @param {PIXI.GD8Symmetry} rotationFirst - First operation, which
   *   is the column in the above cayley table.
   * @returns {PIXI.GD8Symmetry} Composed operation
   */
  add: function(i2, e) {
    return rotationCayley[i2][e];
  },
  /**
   * Reverse of `add`.
   * @memberof PIXI.groupD8
   * @param {PIXI.GD8Symmetry} rotationSecond - Second operation
   * @param {PIXI.GD8Symmetry} rotationFirst - First operation
   * @returns {PIXI.GD8Symmetry} Result
   */
  sub: function(i2, e) {
    return rotationCayley[i2][groupD8.inv(e)];
  },
  /**
   * Adds 180 degrees to rotation, which is a commutative
   * operation.
   * @memberof PIXI.groupD8
   * @param {number} rotation - The number to rotate.
   * @returns {number} Rotated number
   */
  rotate180: function(i2) {
    return i2 ^ 4;
  },
  /**
   * Checks if the rotation angle is vertical, i.e. south
   * or north. It doesn't work for reflections.
   * @memberof PIXI.groupD8
   * @param {PIXI.GD8Symmetry} rotation - The number to check.
   * @returns {boolean} Whether or not the direction is vertical
   */
  isVertical: function(i2) {
    return (i2 & 3) === 2;
  },
  /**
   * Approximates the vector `V(dx,dy)` into one of the
   * eight directions provided by `groupD8`.
   * @memberof PIXI.groupD8
   * @param {number} dx - X-component of the vector
   * @param {number} dy - Y-component of the vector
   * @returns {PIXI.GD8Symmetry} Approximation of the vector into
   *  one of the eight symmetries.
   */
  byDirection: function(i2, e) {
    return Math.abs(i2) * 2 <= Math.abs(e) ? e >= 0 ? groupD8.S : groupD8.N : Math.abs(e) * 2 <= Math.abs(i2) ? i2 > 0 ? groupD8.E : groupD8.W : e > 0 ? i2 > 0 ? groupD8.SE : groupD8.SW : i2 > 0 ? groupD8.NE : groupD8.NW;
  },
  /**
   * Helps sprite to compensate texture packer rotation.
   * @memberof PIXI.groupD8
   * @param {PIXI.Matrix} matrix - sprite world matrix
   * @param {PIXI.GD8Symmetry} rotation - The rotation factor to use.
   * @param {number} tx - sprite anchoring
   * @param {number} ty - sprite anchoring
   */
  matrixAppendRotationInv: function(i2, e, t, r) {
    t === void 0 && (t = 0), r === void 0 && (r = 0);
    var a = rotationMatrices[groupD8.inv(e)];
    a.tx = t, a.ty = r, i2.append(a);
  }
}, Transform$1 = (
  /** @class */
  function() {
    function i2() {
      this.worldTransform = new Matrix$1(), this.localTransform = new Matrix$1(), this.position = new ObservablePoint$1(this.onChange, this, 0, 0), this.scale = new ObservablePoint$1(this.onChange, this, 1, 1), this.pivot = new ObservablePoint$1(this.onChange, this, 0, 0), this.skew = new ObservablePoint$1(this.updateSkew, this, 0, 0), this._rotation = 0, this._cx = 1, this._sx = 0, this._cy = 0, this._sy = 1, this._localID = 0, this._currentLocalID = 0, this._worldID = 0, this._parentID = 0;
    }
    return i2.prototype.onChange = function() {
      this._localID++;
    }, i2.prototype.updateSkew = function() {
      this._cx = Math.cos(this._rotation + this.skew.y), this._sx = Math.sin(this._rotation + this.skew.y), this._cy = -Math.sin(this._rotation - this.skew.x), this._sy = Math.cos(this._rotation - this.skew.x), this._localID++;
    }, i2.prototype.toString = function() {
      return "[@pixi/math:Transform " + ("position=(" + this.position.x + ", " + this.position.y + ") ") + ("rotation=" + this.rotation + " ") + ("scale=(" + this.scale.x + ", " + this.scale.y + ") ") + ("skew=(" + this.skew.x + ", " + this.skew.y + ") ") + "]";
    }, i2.prototype.updateLocalTransform = function() {
      var e = this.localTransform;
      this._localID !== this._currentLocalID && (e.a = this._cx * this.scale.x, e.b = this._sx * this.scale.x, e.c = this._cy * this.scale.y, e.d = this._sy * this.scale.y, e.tx = this.position.x - (this.pivot.x * e.a + this.pivot.y * e.c), e.ty = this.position.y - (this.pivot.x * e.b + this.pivot.y * e.d), this._currentLocalID = this._localID, this._parentID = -1);
    }, i2.prototype.updateTransform = function(e) {
      var t = this.localTransform;
      if (this._localID !== this._currentLocalID && (t.a = this._cx * this.scale.x, t.b = this._sx * this.scale.x, t.c = this._cy * this.scale.y, t.d = this._sy * this.scale.y, t.tx = this.position.x - (this.pivot.x * t.a + this.pivot.y * t.c), t.ty = this.position.y - (this.pivot.x * t.b + this.pivot.y * t.d), this._currentLocalID = this._localID, this._parentID = -1), this._parentID !== e._worldID) {
        var r = e.worldTransform, a = this.worldTransform;
        a.a = t.a * r.a + t.b * r.c, a.b = t.a * r.b + t.b * r.d, a.c = t.c * r.a + t.d * r.c, a.d = t.c * r.b + t.d * r.d, a.tx = t.tx * r.a + t.ty * r.c + r.tx, a.ty = t.tx * r.b + t.ty * r.d + r.ty, this._parentID = e._worldID, this._worldID++;
      }
    }, i2.prototype.setFromMatrix = function(e) {
      e.decompose(this), this._localID++;
    }, Object.defineProperty(i2.prototype, "rotation", {
      /** The rotation of the object in radians. */
      get: function() {
        return this._rotation;
      },
      set: function(e) {
        this._rotation !== e && (this._rotation = e, this.updateSkew());
      },
      enumerable: false,
      configurable: true
    }), i2.IDENTITY = new i2(), i2;
  }()
);
/*!
 * @pixi/constants - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/constants is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var ENV;
(function(i2) {
  i2[i2.WEBGL_LEGACY = 0] = "WEBGL_LEGACY", i2[i2.WEBGL = 1] = "WEBGL", i2[i2.WEBGL2 = 2] = "WEBGL2";
})(ENV || (ENV = {}));
var RENDERER_TYPE;
(function(i2) {
  i2[i2.UNKNOWN = 0] = "UNKNOWN", i2[i2.WEBGL = 1] = "WEBGL", i2[i2.CANVAS = 2] = "CANVAS";
})(RENDERER_TYPE || (RENDERER_TYPE = {}));
var BUFFER_BITS;
(function(i2) {
  i2[i2.COLOR = 16384] = "COLOR", i2[i2.DEPTH = 256] = "DEPTH", i2[i2.STENCIL = 1024] = "STENCIL";
})(BUFFER_BITS || (BUFFER_BITS = {}));
var BLEND_MODES;
(function(i2) {
  i2[i2.NORMAL = 0] = "NORMAL", i2[i2.ADD = 1] = "ADD", i2[i2.MULTIPLY = 2] = "MULTIPLY", i2[i2.SCREEN = 3] = "SCREEN", i2[i2.OVERLAY = 4] = "OVERLAY", i2[i2.DARKEN = 5] = "DARKEN", i2[i2.LIGHTEN = 6] = "LIGHTEN", i2[i2.COLOR_DODGE = 7] = "COLOR_DODGE", i2[i2.COLOR_BURN = 8] = "COLOR_BURN", i2[i2.HARD_LIGHT = 9] = "HARD_LIGHT", i2[i2.SOFT_LIGHT = 10] = "SOFT_LIGHT", i2[i2.DIFFERENCE = 11] = "DIFFERENCE", i2[i2.EXCLUSION = 12] = "EXCLUSION", i2[i2.HUE = 13] = "HUE", i2[i2.SATURATION = 14] = "SATURATION", i2[i2.COLOR = 15] = "COLOR", i2[i2.LUMINOSITY = 16] = "LUMINOSITY", i2[i2.NORMAL_NPM = 17] = "NORMAL_NPM", i2[i2.ADD_NPM = 18] = "ADD_NPM", i2[i2.SCREEN_NPM = 19] = "SCREEN_NPM", i2[i2.NONE = 20] = "NONE", i2[i2.SRC_OVER = 0] = "SRC_OVER", i2[i2.SRC_IN = 21] = "SRC_IN", i2[i2.SRC_OUT = 22] = "SRC_OUT", i2[i2.SRC_ATOP = 23] = "SRC_ATOP", i2[i2.DST_OVER = 24] = "DST_OVER", i2[i2.DST_IN = 25] = "DST_IN", i2[i2.DST_OUT = 26] = "DST_OUT", i2[i2.DST_ATOP = 27] = "DST_ATOP", i2[i2.ERASE = 26] = "ERASE", i2[i2.SUBTRACT = 28] = "SUBTRACT", i2[i2.XOR = 29] = "XOR";
})(BLEND_MODES || (BLEND_MODES = {}));
var DRAW_MODES;
(function(i2) {
  i2[i2.POINTS = 0] = "POINTS", i2[i2.LINES = 1] = "LINES", i2[i2.LINE_LOOP = 2] = "LINE_LOOP", i2[i2.LINE_STRIP = 3] = "LINE_STRIP", i2[i2.TRIANGLES = 4] = "TRIANGLES", i2[i2.TRIANGLE_STRIP = 5] = "TRIANGLE_STRIP", i2[i2.TRIANGLE_FAN = 6] = "TRIANGLE_FAN";
})(DRAW_MODES || (DRAW_MODES = {}));
var FORMATS;
(function(i2) {
  i2[i2.RGBA = 6408] = "RGBA", i2[i2.RGB = 6407] = "RGB", i2[i2.RG = 33319] = "RG", i2[i2.RED = 6403] = "RED", i2[i2.RGBA_INTEGER = 36249] = "RGBA_INTEGER", i2[i2.RGB_INTEGER = 36248] = "RGB_INTEGER", i2[i2.RG_INTEGER = 33320] = "RG_INTEGER", i2[i2.RED_INTEGER = 36244] = "RED_INTEGER", i2[i2.ALPHA = 6406] = "ALPHA", i2[i2.LUMINANCE = 6409] = "LUMINANCE", i2[i2.LUMINANCE_ALPHA = 6410] = "LUMINANCE_ALPHA", i2[i2.DEPTH_COMPONENT = 6402] = "DEPTH_COMPONENT", i2[i2.DEPTH_STENCIL = 34041] = "DEPTH_STENCIL";
})(FORMATS || (FORMATS = {}));
var TARGETS;
(function(i2) {
  i2[i2.TEXTURE_2D = 3553] = "TEXTURE_2D", i2[i2.TEXTURE_CUBE_MAP = 34067] = "TEXTURE_CUBE_MAP", i2[i2.TEXTURE_2D_ARRAY = 35866] = "TEXTURE_2D_ARRAY", i2[i2.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X", i2[i2.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X", i2[i2.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y", i2[i2.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y", i2[i2.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z", i2[i2.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
})(TARGETS || (TARGETS = {}));
var TYPES;
(function(i2) {
  i2[i2.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE", i2[i2.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT", i2[i2.UNSIGNED_SHORT_5_6_5 = 33635] = "UNSIGNED_SHORT_5_6_5", i2[i2.UNSIGNED_SHORT_4_4_4_4 = 32819] = "UNSIGNED_SHORT_4_4_4_4", i2[i2.UNSIGNED_SHORT_5_5_5_1 = 32820] = "UNSIGNED_SHORT_5_5_5_1", i2[i2.UNSIGNED_INT = 5125] = "UNSIGNED_INT", i2[i2.UNSIGNED_INT_10F_11F_11F_REV = 35899] = "UNSIGNED_INT_10F_11F_11F_REV", i2[i2.UNSIGNED_INT_2_10_10_10_REV = 33640] = "UNSIGNED_INT_2_10_10_10_REV", i2[i2.UNSIGNED_INT_24_8 = 34042] = "UNSIGNED_INT_24_8", i2[i2.UNSIGNED_INT_5_9_9_9_REV = 35902] = "UNSIGNED_INT_5_9_9_9_REV", i2[i2.BYTE = 5120] = "BYTE", i2[i2.SHORT = 5122] = "SHORT", i2[i2.INT = 5124] = "INT", i2[i2.FLOAT = 5126] = "FLOAT", i2[i2.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV", i2[i2.HALF_FLOAT = 36193] = "HALF_FLOAT";
})(TYPES || (TYPES = {}));
var SAMPLER_TYPES;
(function(i2) {
  i2[i2.FLOAT = 0] = "FLOAT", i2[i2.INT = 1] = "INT", i2[i2.UINT = 2] = "UINT";
})(SAMPLER_TYPES || (SAMPLER_TYPES = {}));
var SCALE_MODES;
(function(i2) {
  i2[i2.NEAREST = 0] = "NEAREST", i2[i2.LINEAR = 1] = "LINEAR";
})(SCALE_MODES || (SCALE_MODES = {}));
var WRAP_MODES;
(function(i2) {
  i2[i2.CLAMP = 33071] = "CLAMP", i2[i2.REPEAT = 10497] = "REPEAT", i2[i2.MIRRORED_REPEAT = 33648] = "MIRRORED_REPEAT";
})(WRAP_MODES || (WRAP_MODES = {}));
var MIPMAP_MODES;
(function(i2) {
  i2[i2.OFF = 0] = "OFF", i2[i2.POW2 = 1] = "POW2", i2[i2.ON = 2] = "ON", i2[i2.ON_MANUAL = 3] = "ON_MANUAL";
})(MIPMAP_MODES || (MIPMAP_MODES = {}));
var ALPHA_MODES;
(function(i2) {
  i2[i2.NPM = 0] = "NPM", i2[i2.UNPACK = 1] = "UNPACK", i2[i2.PMA = 2] = "PMA", i2[i2.NO_PREMULTIPLIED_ALPHA = 0] = "NO_PREMULTIPLIED_ALPHA", i2[i2.PREMULTIPLY_ON_UPLOAD = 1] = "PREMULTIPLY_ON_UPLOAD", i2[i2.PREMULTIPLY_ALPHA = 2] = "PREMULTIPLY_ALPHA", i2[i2.PREMULTIPLIED_ALPHA = 2] = "PREMULTIPLIED_ALPHA";
})(ALPHA_MODES || (ALPHA_MODES = {}));
var CLEAR_MODES;
(function(i2) {
  i2[i2.NO = 0] = "NO", i2[i2.YES = 1] = "YES", i2[i2.AUTO = 2] = "AUTO", i2[i2.BLEND = 0] = "BLEND", i2[i2.CLEAR = 1] = "CLEAR", i2[i2.BLIT = 2] = "BLIT";
})(CLEAR_MODES || (CLEAR_MODES = {}));
var GC_MODES;
(function(i2) {
  i2[i2.AUTO = 0] = "AUTO", i2[i2.MANUAL = 1] = "MANUAL";
})(GC_MODES || (GC_MODES = {}));
var PRECISION;
(function(i2) {
  i2.LOW = "lowp", i2.MEDIUM = "mediump", i2.HIGH = "highp";
})(PRECISION || (PRECISION = {}));
var MASK_TYPES;
(function(i2) {
  i2[i2.NONE = 0] = "NONE", i2[i2.SCISSOR = 1] = "SCISSOR", i2[i2.STENCIL = 2] = "STENCIL", i2[i2.SPRITE = 3] = "SPRITE", i2[i2.COLOR = 4] = "COLOR";
})(MASK_TYPES || (MASK_TYPES = {}));
var COLOR_MASK_BITS;
(function(i2) {
  i2[i2.RED = 1] = "RED", i2[i2.GREEN = 2] = "GREEN", i2[i2.BLUE = 4] = "BLUE", i2[i2.ALPHA = 8] = "ALPHA";
})(COLOR_MASK_BITS || (COLOR_MASK_BITS = {}));
var MSAA_QUALITY;
(function(i2) {
  i2[i2.NONE = 0] = "NONE", i2[i2.LOW = 2] = "LOW", i2[i2.MEDIUM = 4] = "MEDIUM", i2[i2.HIGH = 8] = "HIGH";
})(MSAA_QUALITY || (MSAA_QUALITY = {}));
var BUFFER_TYPE;
(function(i2) {
  i2[i2.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER", i2[i2.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER", i2[i2.UNIFORM_BUFFER = 35345] = "UNIFORM_BUFFER";
})(BUFFER_TYPE || (BUFFER_TYPE = {}));
/*!
 * @pixi/settings - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/settings is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var BrowserAdapter = {
  /**
   * Creates a canvas element of the given size.
   * This canvas is created using the browser's native canvas element.
   * @param width - width of the canvas
   * @param height - height of the canvas
   */
  createCanvas: function(i2, e) {
    var t = document.createElement("canvas");
    return t.width = i2, t.height = e, t;
  },
  getWebGLRenderingContext: function() {
    return WebGLRenderingContext;
  },
  getNavigator: function() {
    return navigator;
  },
  getBaseUrl: function() {
    var i2;
    return (i2 = document.baseURI) !== null && i2 !== void 0 ? i2 : window.location.href;
  },
  fetch: function(i2, e) {
    return fetch(i2, e);
  }
}, appleIphone = /iPhone/i, appleIpod = /iPod/i, appleTablet = /iPad/i, appleUniversal = /\biOS-universal(?:.+)Mac\b/i, androidPhone = /\bAndroid(?:.+)Mobile\b/i, androidTablet = /Android/i, amazonPhone = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i, amazonTablet = /Silk/i, windowsPhone = /Windows Phone/i, windowsTablet = /\bWindows(?:.+)ARM\b/i, otherBlackBerry = /BlackBerry/i, otherBlackBerry10 = /BB10/i, otherOpera = /Opera Mini/i, otherChrome = /\b(CriOS|Chrome)(?:.+)Mobile/i, otherFirefox = /Mobile(?:.+)Firefox\b/i, isAppleTabletOnIos13 = function(i2) {
  return typeof i2 < "u" && i2.platform === "MacIntel" && typeof i2.maxTouchPoints == "number" && i2.maxTouchPoints > 1 && typeof MSStream > "u";
};
function createMatch(i2) {
  return function(e) {
    return e.test(i2);
  };
}
function isMobile$1(i2) {
  var e = {
    userAgent: "",
    platform: "",
    maxTouchPoints: 0
  };
  !i2 && typeof navigator < "u" ? e = {
    userAgent: navigator.userAgent,
    platform: navigator.platform,
    maxTouchPoints: navigator.maxTouchPoints || 0
  } : typeof i2 == "string" ? e.userAgent = i2 : i2 && i2.userAgent && (e = {
    userAgent: i2.userAgent,
    platform: i2.platform,
    maxTouchPoints: i2.maxTouchPoints || 0
  });
  var t = e.userAgent, r = t.split("[FBAN");
  typeof r[1] < "u" && (t = r[0]), r = t.split("Twitter"), typeof r[1] < "u" && (t = r[0]);
  var a = createMatch(t), s = {
    apple: {
      phone: a(appleIphone) && !a(windowsPhone),
      ipod: a(appleIpod),
      tablet: !a(appleIphone) && (a(appleTablet) || isAppleTabletOnIos13(e)) && !a(windowsPhone),
      universal: a(appleUniversal),
      device: (a(appleIphone) || a(appleIpod) || a(appleTablet) || a(appleUniversal) || isAppleTabletOnIos13(e)) && !a(windowsPhone)
    },
    amazon: {
      phone: a(amazonPhone),
      tablet: !a(amazonPhone) && a(amazonTablet),
      device: a(amazonPhone) || a(amazonTablet)
    },
    android: {
      phone: !a(windowsPhone) && a(amazonPhone) || !a(windowsPhone) && a(androidPhone),
      tablet: !a(windowsPhone) && !a(amazonPhone) && !a(androidPhone) && (a(amazonTablet) || a(androidTablet)),
      device: !a(windowsPhone) && (a(amazonPhone) || a(amazonTablet) || a(androidPhone) || a(androidTablet)) || a(/\bokhttp\b/i)
    },
    windows: {
      phone: a(windowsPhone),
      tablet: a(windowsTablet),
      device: a(windowsPhone) || a(windowsTablet)
    },
    other: {
      blackberry: a(otherBlackBerry),
      blackberry10: a(otherBlackBerry10),
      opera: a(otherOpera),
      firefox: a(otherFirefox),
      chrome: a(otherChrome),
      device: a(otherBlackBerry) || a(otherBlackBerry10) || a(otherOpera) || a(otherFirefox) || a(otherChrome)
    },
    any: false,
    phone: false,
    tablet: false
  };
  return s.any = s.apple.device || s.android.device || s.windows.device || s.other.device, s.phone = s.apple.phone || s.android.phone || s.windows.phone, s.tablet = s.apple.tablet || s.android.tablet || s.windows.tablet, s;
}
var isMobile = isMobile$1(globalThis.navigator);
function canUploadSameBuffer() {
  return !isMobile.apple.device;
}
function maxRecommendedTextures$1(i2) {
  var e = true;
  if (isMobile.tablet || isMobile.phone) {
    if (isMobile.apple.device) {
      var t = navigator.userAgent.match(/OS (\d+)_(\d+)?/);
      if (t) {
        var r = parseInt(t[1], 10);
        r < 11 && (e = false);
      }
    }
    if (isMobile.android.device) {
      var t = navigator.userAgent.match(/Android\s([0-9.]*)/);
      if (t) {
        var r = parseInt(t[1], 10);
        r < 7 && (e = false);
      }
    }
  }
  return e ? i2 : 4;
}
var settings$1 = {
  /**
   * This adapter is used to call methods that are platform dependent.
   * For example `document.createElement` only runs on the web but fails in node environments.
   * This allows us to support more platforms by abstracting away specific implementations per platform.
   *
   * By default the adapter is set to work in the browser. However you can create your own
   * by implementing the `IAdapter` interface. See `IAdapter` for more information.
   * @name ADAPTER
   * @memberof PIXI.settings
   * @type {PIXI.IAdapter}
   * @default PIXI.BrowserAdapter
   */
  ADAPTER: BrowserAdapter,
  /**
   * If set to true WebGL will attempt make textures mimpaped by default.
   * Mipmapping will only succeed if the base texture uploaded has power of two dimensions.
   * @static
   * @name MIPMAP_TEXTURES
   * @memberof PIXI.settings
   * @type {PIXI.MIPMAP_MODES}
   * @default PIXI.MIPMAP_MODES.POW2
   */
  MIPMAP_TEXTURES: MIPMAP_MODES.POW2,
  /**
   * Default anisotropic filtering level of textures.
   * Usually from 0 to 16
   * @static
   * @name ANISOTROPIC_LEVEL
   * @memberof PIXI.settings
   * @type {number}
   * @default 0
   */
  ANISOTROPIC_LEVEL: 0,
  /**
   * Default resolution / device pixel ratio of the renderer.
   * @static
   * @name RESOLUTION
   * @memberof PIXI.settings
   * @type {number}
   * @default 1
   */
  RESOLUTION: 1,
  /**
   * Default filter resolution.
   * @static
   * @name FILTER_RESOLUTION
   * @memberof PIXI.settings
   * @type {number}
   * @default 1
   */
  FILTER_RESOLUTION: 1,
  /**
   * Default filter samples.
   * @static
   * @name FILTER_MULTISAMPLE
   * @memberof PIXI.settings
   * @type {PIXI.MSAA_QUALITY}
   * @default PIXI.MSAA_QUALITY.NONE
   */
  FILTER_MULTISAMPLE: MSAA_QUALITY.NONE,
  /**
   * The maximum textures that this device supports.
   * @static
   * @name SPRITE_MAX_TEXTURES
   * @memberof PIXI.settings
   * @type {number}
   * @default 32
   */
  SPRITE_MAX_TEXTURES: maxRecommendedTextures$1(32),
  // TODO: maybe change to SPRITE.BATCH_SIZE: 2000
  // TODO: maybe add PARTICLE.BATCH_SIZE: 15000
  /**
   * The default sprite batch size.
   *
   * The default aims to balance desktop and mobile devices.
   * @static
   * @name SPRITE_BATCH_SIZE
   * @memberof PIXI.settings
   * @type {number}
   * @default 4096
   */
  SPRITE_BATCH_SIZE: 4096,
  /**
   * The default render options if none are supplied to {@link PIXI.Renderer}
   * or {@link PIXI.CanvasRenderer}.
   * @static
   * @name RENDER_OPTIONS
   * @memberof PIXI.settings
   * @type {object}
   * @property {boolean} [antialias=false] - {@link PIXI.IRendererOptions.antialias}
   * @property {boolean} [autoDensity=false] - {@link PIXI.IRendererOptions.autoDensity}
   * @property {number} [backgroundAlpha=1] - {@link PIXI.IRendererOptions.backgroundAlpha}
   * @property {number} [backgroundColor=0x000000] - {@link PIXI.IRendererOptions.backgroundColor}
   * @property {boolean} [clearBeforeRender=true] - {@link PIXI.IRendererOptions.clearBeforeRender}
   * @property {number} [height=600] - {@link PIXI.IRendererOptions.height}
   * @property {boolean} [preserveDrawingBuffer=false] - {@link PIXI.IRendererOptions.preserveDrawingBuffer}
   * @property {boolean|'notMultiplied'} [useContextAlpha=true] - {@link PIXI.IRendererOptions.useContextAlpha}
   * @property {HTMLCanvasElement} [view=null] - {@link PIXI.IRendererOptions.view}
   * @property {number} [width=800] - {@link PIXI.IRendererOptions.width}
   */
  RENDER_OPTIONS: {
    view: null,
    width: 800,
    height: 600,
    autoDensity: false,
    backgroundColor: 0,
    backgroundAlpha: 1,
    useContextAlpha: true,
    clearBeforeRender: true,
    antialias: false,
    preserveDrawingBuffer: false
  },
  /**
   * Default Garbage Collection mode.
   * @static
   * @name GC_MODE
   * @memberof PIXI.settings
   * @type {PIXI.GC_MODES}
   * @default PIXI.GC_MODES.AUTO
   */
  GC_MODE: GC_MODES.AUTO,
  /**
   * Default Garbage Collection max idle.
   * @static
   * @name GC_MAX_IDLE
   * @memberof PIXI.settings
   * @type {number}
   * @default 3600
   */
  GC_MAX_IDLE: 60 * 60,
  /**
   * Default Garbage Collection maximum check count.
   * @static
   * @name GC_MAX_CHECK_COUNT
   * @memberof PIXI.settings
   * @type {number}
   * @default 600
   */
  GC_MAX_CHECK_COUNT: 60 * 10,
  /**
   * Default wrap modes that are supported by pixi.
   * @static
   * @name WRAP_MODE
   * @memberof PIXI.settings
   * @type {PIXI.WRAP_MODES}
   * @default PIXI.WRAP_MODES.CLAMP
   */
  WRAP_MODE: WRAP_MODES.CLAMP,
  /**
   * Default scale mode for textures.
   * @static
   * @name SCALE_MODE
   * @memberof PIXI.settings
   * @type {PIXI.SCALE_MODES}
   * @default PIXI.SCALE_MODES.LINEAR
   */
  SCALE_MODE: SCALE_MODES.LINEAR,
  /**
   * Default specify float precision in vertex shader.
   * @static
   * @name PRECISION_VERTEX
   * @memberof PIXI.settings
   * @type {PIXI.PRECISION}
   * @default PIXI.PRECISION.HIGH
   */
  PRECISION_VERTEX: PRECISION.HIGH,
  /**
   * Default specify float precision in fragment shader.
   * iOS is best set at highp due to https://github.com/pixijs/pixi.js/issues/3742
   * @static
   * @name PRECISION_FRAGMENT
   * @memberof PIXI.settings
   * @type {PIXI.PRECISION}
   * @default PIXI.PRECISION.MEDIUM
   */
  PRECISION_FRAGMENT: isMobile.apple.device ? PRECISION.HIGH : PRECISION.MEDIUM,
  /**
   * Can we upload the same buffer in a single frame?
   * @static
   * @name CAN_UPLOAD_SAME_BUFFER
   * @memberof PIXI.settings
   * @type {boolean}
   */
  CAN_UPLOAD_SAME_BUFFER: canUploadSameBuffer(),
  /**
   * Enables bitmap creation before image load. This feature is experimental.
   * @static
   * @name CREATE_IMAGE_BITMAP
   * @memberof PIXI.settings
   * @type {boolean}
   * @default false
   */
  CREATE_IMAGE_BITMAP: false,
  /**
   * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.
   * Advantages can include sharper image quality (like text) and faster rendering on canvas.
   * The main disadvantage is movement of objects may appear less smooth.
   * @static
   * @constant
   * @memberof PIXI.settings
   * @type {boolean}
   * @default false
   */
  ROUND_PIXELS: false
};
/*!
 * @pixi/extensions - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/extensions is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var __assign$1 = function() {
  return __assign$1 = Object.assign || function(e) {
    for (var t = arguments, r, a = 1, s = arguments.length; a < s; a++) {
      r = t[a];
      for (var u in r)
        Object.prototype.hasOwnProperty.call(r, u) && (e[u] = r[u]);
    }
    return e;
  }, __assign$1.apply(this, arguments);
}, ExtensionType;
(function(i2) {
  i2.Application = "application", i2.RendererPlugin = "renderer-webgl-plugin", i2.CanvasRendererPlugin = "renderer-canvas-plugin", i2.Loader = "loader", i2.LoadParser = "load-parser", i2.ResolveParser = "resolve-parser", i2.CacheParser = "cache-parser", i2.DetectionParser = "detection-parser";
})(ExtensionType || (ExtensionType = {}));
var normalizeExtension = function(i2) {
  if (typeof i2 == "function" || typeof i2 == "object" && i2.extension) {
    if (!i2.extension)
      throw new Error("Extension class must have an extension object");
    var e = typeof i2.extension != "object" ? { type: i2.extension } : i2.extension;
    i2 = __assign$1(__assign$1({}, e), { ref: i2 });
  }
  if (typeof i2 == "object")
    i2 = __assign$1({}, i2);
  else
    throw new Error("Invalid extension type");
  return typeof i2.type == "string" && (i2.type = [i2.type]), i2;
}, extensions = {
  /** @ignore */
  _addHandlers: null,
  /** @ignore */
  _removeHandlers: null,
  /** @ignore */
  _queue: {},
  /**
   * Remove extensions from PixiJS.
   * @param extensions - Extensions to be removed.
   * @returns {PIXI.extensions} For chaining.
   */
  remove: function() {
    for (var i2 = arguments, e = this, t = [], r = 0; r < arguments.length; r++)
      t[r] = i2[r];
    return t.map(normalizeExtension).forEach(function(a) {
      a.type.forEach(function(s) {
        var u, l;
        return (l = (u = e._removeHandlers)[s]) === null || l === void 0 ? void 0 : l.call(u, a);
      });
    }), this;
  },
  /**
   * Register new extensions with PixiJS.
   * @param extensions - The spread of extensions to add to PixiJS.
   * @returns {PIXI.extensions} For chaining.
   */
  add: function() {
    for (var i2 = arguments, e = this, t = [], r = 0; r < arguments.length; r++)
      t[r] = i2[r];
    return t.map(normalizeExtension).forEach(function(a) {
      a.type.forEach(function(s) {
        var u = e._addHandlers, l = e._queue;
        u[s] ? u[s](a) : (l[s] = l[s] || [], l[s].push(a));
      });
    }), this;
  },
  /**
   * Internal method to handle extensions by name.
   * @param type - The extension type.
   * @param onAdd  - Function for handling when extensions are added/registered passes {@link PIXI.ExtensionFormat}.
   * @param onRemove  - Function for handling when extensions are removed/unregistered passes {@link PIXI.ExtensionFormat}.
   * @returns {PIXI.extensions} For chaining.
   */
  handle: function(i2, e, t) {
    var r = this._addHandlers = this._addHandlers || {}, a = this._removeHandlers = this._removeHandlers || {};
    if (r[i2] || a[i2])
      throw new Error("Extension type " + i2 + " already has a handler");
    r[i2] = e, a[i2] = t;
    var s = this._queue;
    return s[i2] && (s[i2].forEach(function(u) {
      return e(u);
    }), delete s[i2]), this;
  },
  /**
   * Handle a type, but using a map by `name` property.
   * @param type - Type of extension to handle.
   * @param map - The object map of named extensions.
   * @returns {PIXI.extensions} For chaining.
   */
  handleByMap: function(i2, e) {
    return this.handle(i2, function(t) {
      e[t.name] = t.ref;
    }, function(t) {
      delete e[t.name];
    });
  },
  /**
   * Handle a type, but using a list of extensions.
   * @param type - Type of extension to handle.
   * @param list - The list of extensions.
   * @returns {PIXI.extensions} For chaining.
   */
  handleByList: function(i2, e) {
    return this.handle(i2, function(t) {
      var r, a;
      e.includes(t.ref) || (e.push(t.ref), i2 === ExtensionType.Loader && ((a = (r = t.ref).add) === null || a === void 0 || a.call(r)));
    }, function(t) {
      var r = e.indexOf(t.ref);
      r !== -1 && e.splice(r, 1);
    });
  }
};
/*!
 * @pixi/ticker - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/ticker is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
settings$1.TARGET_FPMS = 0.06;
var UPDATE_PRIORITY;
(function(i2) {
  i2[i2.INTERACTION = 50] = "INTERACTION", i2[i2.HIGH = 25] = "HIGH", i2[i2.NORMAL = 0] = "NORMAL", i2[i2.LOW = -25] = "LOW", i2[i2.UTILITY = -50] = "UTILITY";
})(UPDATE_PRIORITY || (UPDATE_PRIORITY = {}));
var TickerListener$1 = (
  /** @class */
  function() {
    function i2(e, t, r, a) {
      t === void 0 && (t = null), r === void 0 && (r = 0), a === void 0 && (a = false), this.next = null, this.previous = null, this._destroyed = false, this.fn = e, this.context = t, this.priority = r, this.once = a;
    }
    return i2.prototype.match = function(e, t) {
      return t === void 0 && (t = null), this.fn === e && this.context === t;
    }, i2.prototype.emit = function(e) {
      this.fn && (this.context ? this.fn.call(this.context, e) : this.fn(e));
      var t = this.next;
      return this.once && this.destroy(true), this._destroyed && (this.next = null), t;
    }, i2.prototype.connect = function(e) {
      this.previous = e, e.next && (e.next.previous = this), this.next = e.next, e.next = this;
    }, i2.prototype.destroy = function(e) {
      e === void 0 && (e = false), this._destroyed = true, this.fn = null, this.context = null, this.previous && (this.previous.next = this.next), this.next && (this.next.previous = this.previous);
      var t = this.next;
      return this.next = e ? null : t, this.previous = null, t;
    }, i2;
  }()
), Ticker$1 = (
  /** @class */
  function() {
    function i2() {
      var e = this;
      this.autoStart = false, this.deltaTime = 1, this.lastTime = -1, this.speed = 1, this.started = false, this._requestId = null, this._maxElapsedMS = 100, this._minElapsedMS = 0, this._protected = false, this._lastFrame = -1, this._head = new TickerListener$1(null, null, 1 / 0), this.deltaMS = 1 / settings$1.TARGET_FPMS, this.elapsedMS = 1 / settings$1.TARGET_FPMS, this._tick = function(t) {
        e._requestId = null, e.started && (e.update(t), e.started && e._requestId === null && e._head.next && (e._requestId = requestAnimationFrame(e._tick)));
      };
    }
    return i2.prototype._requestIfNeeded = function() {
      this._requestId === null && this._head.next && (this.lastTime = performance.now(), this._lastFrame = this.lastTime, this._requestId = requestAnimationFrame(this._tick));
    }, i2.prototype._cancelIfNeeded = function() {
      this._requestId !== null && (cancelAnimationFrame(this._requestId), this._requestId = null);
    }, i2.prototype._startIfPossible = function() {
      this.started ? this._requestIfNeeded() : this.autoStart && this.start();
    }, i2.prototype.add = function(e, t, r) {
      return r === void 0 && (r = UPDATE_PRIORITY.NORMAL), this._addListener(new TickerListener$1(e, t, r));
    }, i2.prototype.addOnce = function(e, t, r) {
      return r === void 0 && (r = UPDATE_PRIORITY.NORMAL), this._addListener(new TickerListener$1(e, t, r, true));
    }, i2.prototype._addListener = function(e) {
      var t = this._head.next, r = this._head;
      if (!t)
        e.connect(r);
      else {
        for (; t; ) {
          if (e.priority > t.priority) {
            e.connect(r);
            break;
          }
          r = t, t = t.next;
        }
        e.previous || e.connect(r);
      }
      return this._startIfPossible(), this;
    }, i2.prototype.remove = function(e, t) {
      for (var r = this._head.next; r; )
        r.match(e, t) ? r = r.destroy() : r = r.next;
      return this._head.next || this._cancelIfNeeded(), this;
    }, Object.defineProperty(i2.prototype, "count", {
      /**
       * The number of listeners on this ticker, calculated by walking through linked list
       * @readonly
       * @member {number}
       */
      get: function() {
        if (!this._head)
          return 0;
        for (var e = 0, t = this._head; t = t.next; )
          e++;
        return e;
      },
      enumerable: false,
      configurable: true
    }), i2.prototype.start = function() {
      this.started || (this.started = true, this._requestIfNeeded());
    }, i2.prototype.stop = function() {
      this.started && (this.started = false, this._cancelIfNeeded());
    }, i2.prototype.destroy = function() {
      if (!this._protected) {
        this.stop();
        for (var e = this._head.next; e; )
          e = e.destroy(true);
        this._head.destroy(), this._head = null;
      }
    }, i2.prototype.update = function(e) {
      e === void 0 && (e = performance.now());
      var t;
      if (e > this.lastTime) {
        if (t = this.elapsedMS = e - this.lastTime, t > this._maxElapsedMS && (t = this._maxElapsedMS), t *= this.speed, this._minElapsedMS) {
          var r = e - this._lastFrame | 0;
          if (r < this._minElapsedMS)
            return;
          this._lastFrame = e - r % this._minElapsedMS;
        }
        this.deltaMS = t, this.deltaTime = this.deltaMS * settings$1.TARGET_FPMS;
        for (var a = this._head, s = a.next; s; )
          s = s.emit(this.deltaTime);
        a.next || this._cancelIfNeeded();
      } else
        this.deltaTime = this.deltaMS = this.elapsedMS = 0;
      this.lastTime = e;
    }, Object.defineProperty(i2.prototype, "FPS", {
      /**
       * The frames per second at which this ticker is running.
       * The default is approximately 60 in most modern browsers.
       * **Note:** This does not factor in the value of
       * {@link PIXI.Ticker#speed}, which is specific
       * to scaling {@link PIXI.Ticker#deltaTime}.
       * @member {number}
       * @readonly
       */
      get: function() {
        return 1e3 / this.elapsedMS;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(i2.prototype, "minFPS", {
      /**
       * Manages the maximum amount of milliseconds allowed to
       * elapse between invoking {@link PIXI.Ticker#update}.
       * This value is used to cap {@link PIXI.Ticker#deltaTime},
       * but does not effect the measured value of {@link PIXI.Ticker#FPS}.
       * When setting this property it is clamped to a value between
       * `0` and `PIXI.settings.TARGET_FPMS * 1000`.
       * @member {number}
       * @default 10
       */
      get: function() {
        return 1e3 / this._maxElapsedMS;
      },
      set: function(e) {
        var t = Math.min(this.maxFPS, e), r = Math.min(Math.max(0, t) / 1e3, settings$1.TARGET_FPMS);
        this._maxElapsedMS = 1 / r;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(i2.prototype, "maxFPS", {
      /**
       * Manages the minimum amount of milliseconds required to
       * elapse between invoking {@link PIXI.Ticker#update}.
       * This will effect the measured value of {@link PIXI.Ticker#FPS}.
       * If it is set to `0`, then there is no limit; PixiJS will render as many frames as it can.
       * Otherwise it will be at least `minFPS`
       * @member {number}
       * @default 0
       */
      get: function() {
        return this._minElapsedMS ? Math.round(1e3 / this._minElapsedMS) : 0;
      },
      set: function(e) {
        if (e === 0)
          this._minElapsedMS = 0;
        else {
          var t = Math.max(this.minFPS, e);
          this._minElapsedMS = 1 / (t / 1e3);
        }
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(i2, "shared", {
      /**
       * The shared ticker instance used by {@link PIXI.AnimatedSprite} and by
       * {@link PIXI.VideoResource} to update animation frames / video textures.
       *
       * It may also be used by {@link PIXI.Application} if created with the `sharedTicker` option property set to true.
       *
       * The property {@link PIXI.Ticker#autoStart} is set to `true` for this instance.
       * Please follow the examples for usage, including how to opt-out of auto-starting the shared ticker.
       * @example
       * let ticker = PIXI.Ticker.shared;
       * // Set this to prevent starting this ticker when listeners are added.
       * // By default this is true only for the PIXI.Ticker.shared instance.
       * ticker.autoStart = false;
       * // FYI, call this to ensure the ticker is stopped. It should be stopped
       * // if you have not attempted to render anything yet.
       * ticker.stop();
       * // Call this when you are ready for a running shared ticker.
       * ticker.start();
       * @example
       * // You may use the shared ticker to render...
       * let renderer = PIXI.autoDetectRenderer();
       * let stage = new PIXI.Container();
       * document.body.appendChild(renderer.view);
       * ticker.add(function (time) {
       *     renderer.render(stage);
       * });
       * @example
       * // Or you can just update it manually.
       * ticker.autoStart = false;
       * ticker.stop();
       * function animate(time) {
       *     ticker.update(time);
       *     renderer.render(stage);
       *     requestAnimationFrame(animate);
       * }
       * animate(performance.now());
       * @member {PIXI.Ticker}
       * @static
       */
      get: function() {
        if (!i2._shared) {
          var e = i2._shared = new i2();
          e.autoStart = true, e._protected = true;
        }
        return i2._shared;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(i2, "system", {
      /**
       * The system ticker instance used by {@link PIXI.InteractionManager} and by
       * {@link PIXI.BasePrepare} for core timing functionality that shouldn't usually need to be paused,
       * unlike the `shared` ticker which drives visual animations and rendering which may want to be paused.
       *
       * The property {@link PIXI.Ticker#autoStart} is set to `true` for this instance.
       * @member {PIXI.Ticker}
       * @static
       */
      get: function() {
        if (!i2._system) {
          var e = i2._system = new i2();
          e.autoStart = true, e._protected = true;
        }
        return i2._system;
      },
      enumerable: false,
      configurable: true
    }), i2;
  }()
);
(function() {
  function i2() {
  }
  return i2.init = function(e) {
    var t = this;
    e = Object.assign({
      autoStart: true,
      sharedTicker: false
    }, e), Object.defineProperty(this, "ticker", {
      set: function(r) {
        this._ticker && this._ticker.remove(this.render, this), this._ticker = r, r && r.add(this.render, this, UPDATE_PRIORITY.LOW);
      },
      get: function() {
        return this._ticker;
      }
    }), this.stop = function() {
      t._ticker.stop();
    }, this.start = function() {
      t._ticker.start();
    }, this._ticker = null, this.ticker = e.sharedTicker ? Ticker$1.shared : new Ticker$1(), e.autoStart && this.start();
  }, i2.destroy = function() {
    if (this._ticker) {
      var e = this._ticker;
      this.ticker = null, e.destroy();
    }
  }, i2.extension = ExtensionType.Application, i2;
})();
var commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function getDefaultExportFromCjs$1(i2) {
  return i2 && i2.__esModule && Object.prototype.hasOwnProperty.call(i2, "default") ? i2.default : i2;
}
function getAugmentedNamespace$1(i2) {
  if (i2.__esModule) return i2;
  var e = i2.default;
  if (typeof e == "function") {
    var t = function r() {
      return this instanceof r ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments);
    };
    t.prototype = e.prototype;
  } else t = {};
  return Object.defineProperty(t, "__esModule", { value: true }), Object.keys(i2).forEach(function(r) {
    var a = Object.getOwnPropertyDescriptor(i2, r);
    Object.defineProperty(t, r, a.get ? a : {
      enumerable: true,
      get: function() {
        return i2[r];
      }
    });
  }), t;
}
var eventemitter3$2 = { exports: {} }, hasRequiredEventemitter3$2;
function requireEventemitter3$2() {
  return hasRequiredEventemitter3$2 || (hasRequiredEventemitter3$2 = 1, function(i2) {
    var e = Object.prototype.hasOwnProperty, t = "~";
    function r() {
    }
    Object.create && (r.prototype = /* @__PURE__ */ Object.create(null), new r().__proto__ || (t = false));
    function a(c, d, f) {
      this.fn = c, this.context = d, this.once = f || false;
    }
    function s(c, d, f, p, m) {
      if (typeof f != "function")
        throw new TypeError("The listener must be a function");
      var y = new a(f, p || c, m), x = t ? t + d : d;
      return c._events[x] ? c._events[x].fn ? c._events[x] = [c._events[x], y] : c._events[x].push(y) : (c._events[x] = y, c._eventsCount++), c;
    }
    function u(c, d) {
      --c._eventsCount === 0 ? c._events = new r() : delete c._events[d];
    }
    function l() {
      this._events = new r(), this._eventsCount = 0;
    }
    l.prototype.eventNames = function() {
      var d = [], f, p;
      if (this._eventsCount === 0) return d;
      for (p in f = this._events)
        e.call(f, p) && d.push(t ? p.slice(1) : p);
      return Object.getOwnPropertySymbols ? d.concat(Object.getOwnPropertySymbols(f)) : d;
    }, l.prototype.listeners = function(d) {
      var f = t ? t + d : d, p = this._events[f];
      if (!p) return [];
      if (p.fn) return [p.fn];
      for (var m = 0, y = p.length, x = new Array(y); m < y; m++)
        x[m] = p[m].fn;
      return x;
    }, l.prototype.listenerCount = function(d) {
      var f = t ? t + d : d, p = this._events[f];
      return p ? p.fn ? 1 : p.length : 0;
    }, l.prototype.emit = function(d, f, p, m, y, x) {
      var g = t ? t + d : d;
      if (!this._events[g]) return false;
      var _ = this._events[g], T = arguments.length, E, b;
      if (_.fn) {
        switch (_.once && this.removeListener(d, _.fn, void 0, true), T) {
          case 1:
            return _.fn.call(_.context), true;
          case 2:
            return _.fn.call(_.context, f), true;
          case 3:
            return _.fn.call(_.context, f, p), true;
          case 4:
            return _.fn.call(_.context, f, p, m), true;
          case 5:
            return _.fn.call(_.context, f, p, m, y), true;
          case 6:
            return _.fn.call(_.context, f, p, m, y, x), true;
        }
        for (b = 1, E = new Array(T - 1); b < T; b++)
          E[b - 1] = arguments[b];
        _.fn.apply(_.context, E);
      } else {
        var C = _.length, w;
        for (b = 0; b < C; b++)
          switch (_[b].once && this.removeListener(d, _[b].fn, void 0, true), T) {
            case 1:
              _[b].fn.call(_[b].context);
              break;
            case 2:
              _[b].fn.call(_[b].context, f);
              break;
            case 3:
              _[b].fn.call(_[b].context, f, p);
              break;
            case 4:
              _[b].fn.call(_[b].context, f, p, m);
              break;
            default:
              if (!E) for (w = 1, E = new Array(T - 1); w < T; w++)
                E[w - 1] = arguments[w];
              _[b].fn.apply(_[b].context, E);
          }
      }
      return true;
    }, l.prototype.on = function(d, f, p) {
      return s(this, d, f, p, false);
    }, l.prototype.once = function(d, f, p) {
      return s(this, d, f, p, true);
    }, l.prototype.removeListener = function(d, f, p, m) {
      var y = t ? t + d : d;
      if (!this._events[y]) return this;
      if (!f)
        return u(this, y), this;
      var x = this._events[y];
      if (x.fn)
        x.fn === f && (!m || x.once) && (!p || x.context === p) && u(this, y);
      else {
        for (var g = 0, _ = [], T = x.length; g < T; g++)
          (x[g].fn !== f || m && !x[g].once || p && x[g].context !== p) && _.push(x[g]);
        _.length ? this._events[y] = _.length === 1 ? _[0] : _ : u(this, y);
      }
      return this;
    }, l.prototype.removeAllListeners = function(d) {
      var f;
      return d ? (f = t ? t + d : d, this._events[f] && u(this, f)) : (this._events = new r(), this._eventsCount = 0), this;
    }, l.prototype.off = l.prototype.removeListener, l.prototype.addListener = l.prototype.on, l.prefixed = t, l.EventEmitter = l, i2.exports = l;
  }(eventemitter3$2)), eventemitter3$2.exports;
}
var eventemitter3Exports = requireEventemitter3$2();
const EventEmitter = /* @__PURE__ */ getDefaultExportFromCjs$1(eventemitter3Exports);
var earcut$1 = { exports: {} }, hasRequiredEarcut$1;
function requireEarcut$1() {
  if (hasRequiredEarcut$1) return earcut$1.exports;
  hasRequiredEarcut$1 = 1, earcut$1.exports = i2, earcut$1.exports.default = i2;
  function i2(k, I, P) {
    P = P || 2;
    var G = I && I.length, W = G ? I[0] * P : k.length, V = e(k, 0, W, P, true), K = [];
    if (!V || V.next === V.prev) return K;
    var J, ae, re, he, ge, me, Te;
    if (G && (V = c(k, I, V, P)), k.length > 80 * P) {
      J = re = k[0], ae = he = k[1];
      for (var _e = P; _e < W; _e += P)
        ge = k[_e], me = k[_e + 1], ge < J && (J = ge), me < ae && (ae = me), ge > re && (re = ge), me > he && (he = me);
      Te = Math.max(re - J, he - ae), Te = Te !== 0 ? 32767 / Te : 0;
    }
    return r(V, K, P, J, ae, Te, 0), K;
  }
  function e(k, I, P, G, W) {
    var V, K;
    if (W === X(k, I, P, G) > 0)
      for (V = I; V < P; V += G) K = q(V, k[V], k[V + 1], K);
    else
      for (V = P - G; V >= I; V -= G) K = q(V, k[V], k[V + 1], K);
    return K && C(K, K.next) && (z(K), K = K.next), K;
  }
  function t(k, I) {
    if (!k) return k;
    I || (I = k);
    var P = k, G;
    do
      if (G = false, !P.steiner && (C(P, P.next) || b(P.prev, P, P.next) === 0)) {
        if (z(P), P = I = P.prev, P === P.next) break;
        G = true;
      } else
        P = P.next;
    while (G || P !== I);
    return I;
  }
  function r(k, I, P, G, W, V, K) {
    if (k) {
      !K && V && y(k, G, W, V);
      for (var J = k, ae, re; k.prev !== k.next; ) {
        if (ae = k.prev, re = k.next, V ? s(k, G, W, V) : a(k)) {
          I.push(ae.i / P | 0), I.push(k.i / P | 0), I.push(re.i / P | 0), z(k), k = re.next, J = re.next;
          continue;
        }
        if (k = re, k === J) {
          K ? K === 1 ? (k = u(t(k), I, P), r(k, I, P, G, W, V, 2)) : K === 2 && l(k, I, P, G, W, V) : r(t(k), I, P, G, W, V, 1);
          break;
        }
      }
    }
  }
  function a(k) {
    var I = k.prev, P = k, G = k.next;
    if (b(I, P, G) >= 0) return false;
    for (var W = I.x, V = P.x, K = G.x, J = I.y, ae = P.y, re = G.y, he = W < V ? W < K ? W : K : V < K ? V : K, ge = J < ae ? J < re ? J : re : ae < re ? ae : re, me = W > V ? W > K ? W : K : V > K ? V : K, Te = J > ae ? J > re ? J : re : ae > re ? ae : re, _e = G.next; _e !== I; ) {
      if (_e.x >= he && _e.x <= me && _e.y >= ge && _e.y <= Te && T(W, J, V, ae, K, re, _e.x, _e.y) && b(_e.prev, _e, _e.next) >= 0) return false;
      _e = _e.next;
    }
    return true;
  }
  function s(k, I, P, G) {
    var W = k.prev, V = k, K = k.next;
    if (b(W, V, K) >= 0) return false;
    for (var J = W.x, ae = V.x, re = K.x, he = W.y, ge = V.y, me = K.y, Te = J < ae ? J < re ? J : re : ae < re ? ae : re, _e = he < ge ? he < me ? he : me : ge < me ? ge : me, ye = J > ae ? J > re ? J : re : ae > re ? ae : re, Ae = he > ge ? he > me ? he : me : ge > me ? ge : me, ke = g(Te, _e, I, P, G), Pe = g(ye, Ae, I, P, G), Ee = k.prevZ, Oe = k.nextZ; Ee && Ee.z >= ke && Oe && Oe.z <= Pe; ) {
      if (Ee.x >= Te && Ee.x <= ye && Ee.y >= _e && Ee.y <= Ae && Ee !== W && Ee !== K && T(J, he, ae, ge, re, me, Ee.x, Ee.y) && b(Ee.prev, Ee, Ee.next) >= 0 || (Ee = Ee.prevZ, Oe.x >= Te && Oe.x <= ye && Oe.y >= _e && Oe.y <= Ae && Oe !== W && Oe !== K && T(J, he, ae, ge, re, me, Oe.x, Oe.y) && b(Oe.prev, Oe, Oe.next) >= 0)) return false;
      Oe = Oe.nextZ;
    }
    for (; Ee && Ee.z >= ke; ) {
      if (Ee.x >= Te && Ee.x <= ye && Ee.y >= _e && Ee.y <= Ae && Ee !== W && Ee !== K && T(J, he, ae, ge, re, me, Ee.x, Ee.y) && b(Ee.prev, Ee, Ee.next) >= 0) return false;
      Ee = Ee.prevZ;
    }
    for (; Oe && Oe.z <= Pe; ) {
      if (Oe.x >= Te && Oe.x <= ye && Oe.y >= _e && Oe.y <= Ae && Oe !== W && Oe !== K && T(J, he, ae, ge, re, me, Oe.x, Oe.y) && b(Oe.prev, Oe, Oe.next) >= 0) return false;
      Oe = Oe.nextZ;
    }
    return true;
  }
  function u(k, I, P) {
    var G = k;
    do {
      var W = G.prev, V = G.next.next;
      !C(W, V) && w(W, G, G.next, V) && M(W, V) && M(V, W) && (I.push(W.i / P | 0), I.push(G.i / P | 0), I.push(V.i / P | 0), z(G), z(G.next), G = k = V), G = G.next;
    } while (G !== k);
    return t(G);
  }
  function l(k, I, P, G, W, V) {
    var K = k;
    do {
      for (var J = K.next.next; J !== K.prev; ) {
        if (K.i !== J.i && E(K, J)) {
          var ae = B(K, J);
          K = t(K, K.next), ae = t(ae, ae.next), r(K, I, P, G, W, V, 0), r(ae, I, P, G, W, V, 0);
          return;
        }
        J = J.next;
      }
      K = K.next;
    } while (K !== k);
  }
  function c(k, I, P, G) {
    var W = [], V, K, J, ae, re;
    for (V = 0, K = I.length; V < K; V++)
      J = I[V] * G, ae = V < K - 1 ? I[V + 1] * G : k.length, re = e(k, J, ae, G, false), re === re.next && (re.steiner = true), W.push(_(re));
    for (W.sort(d), V = 0; V < W.length; V++)
      P = f(W[V], P);
    return P;
  }
  function d(k, I) {
    return k.x - I.x;
  }
  function f(k, I) {
    var P = p(k, I);
    if (!P)
      return I;
    var G = B(P, k);
    return t(G, G.next), t(P, P.next);
  }
  function p(k, I) {
    var P = I, G = k.x, W = k.y, V = -1 / 0, K;
    do {
      if (W <= P.y && W >= P.next.y && P.next.y !== P.y) {
        var J = P.x + (W - P.y) * (P.next.x - P.x) / (P.next.y - P.y);
        if (J <= G && J > V && (V = J, K = P.x < P.next.x ? P : P.next, J === G))
          return K;
      }
      P = P.next;
    } while (P !== I);
    if (!K) return null;
    var ae = K, re = K.x, he = K.y, ge = 1 / 0, me;
    P = K;
    do
      G >= P.x && P.x >= re && G !== P.x && T(W < he ? G : V, W, re, he, W < he ? V : G, W, P.x, P.y) && (me = Math.abs(W - P.y) / (G - P.x), M(P, k) && (me < ge || me === ge && (P.x > K.x || P.x === K.x && m(K, P))) && (K = P, ge = me)), P = P.next;
    while (P !== ae);
    return K;
  }
  function m(k, I) {
    return b(k.prev, k, I.prev) < 0 && b(I.next, k, k.next) < 0;
  }
  function y(k, I, P, G) {
    var W = k;
    do
      W.z === 0 && (W.z = g(W.x, W.y, I, P, G)), W.prevZ = W.prev, W.nextZ = W.next, W = W.next;
    while (W !== k);
    W.prevZ.nextZ = null, W.prevZ = null, x(W);
  }
  function x(k) {
    var I, P, G, W, V, K, J, ae, re = 1;
    do {
      for (P = k, k = null, V = null, K = 0; P; ) {
        for (K++, G = P, J = 0, I = 0; I < re && (J++, G = G.nextZ, !!G); I++)
          ;
        for (ae = re; J > 0 || ae > 0 && G; )
          J !== 0 && (ae === 0 || !G || P.z <= G.z) ? (W = P, P = P.nextZ, J--) : (W = G, G = G.nextZ, ae--), V ? V.nextZ = W : k = W, W.prevZ = V, V = W;
        P = G;
      }
      V.nextZ = null, re *= 2;
    } while (K > 1);
    return k;
  }
  function g(k, I, P, G, W) {
    return k = (k - P) * W | 0, I = (I - G) * W | 0, k = (k | k << 8) & 16711935, k = (k | k << 4) & 252645135, k = (k | k << 2) & 858993459, k = (k | k << 1) & 1431655765, I = (I | I << 8) & 16711935, I = (I | I << 4) & 252645135, I = (I | I << 2) & 858993459, I = (I | I << 1) & 1431655765, k | I << 1;
  }
  function _(k) {
    var I = k, P = k;
    do
      (I.x < P.x || I.x === P.x && I.y < P.y) && (P = I), I = I.next;
    while (I !== k);
    return P;
  }
  function T(k, I, P, G, W, V, K, J) {
    return (W - K) * (I - J) >= (k - K) * (V - J) && (k - K) * (G - J) >= (P - K) * (I - J) && (P - K) * (V - J) >= (W - K) * (G - J);
  }
  function E(k, I) {
    return k.next.i !== I.i && k.prev.i !== I.i && !F(k, I) && // dones't intersect other edges
    (M(k, I) && M(I, k) && U(k, I) && // locally visible
    (b(k.prev, k, I.prev) || b(k, I.prev, I)) || // does not create opposite-facing sectors
    C(k, I) && b(k.prev, k, k.next) > 0 && b(I.prev, I, I.next) > 0);
  }
  function b(k, I, P) {
    return (I.y - k.y) * (P.x - I.x) - (I.x - k.x) * (P.y - I.y);
  }
  function C(k, I) {
    return k.x === I.x && k.y === I.y;
  }
  function w(k, I, P, G) {
    var W = S(b(k, I, P)), V = S(b(k, I, G)), K = S(b(P, G, k)), J = S(b(P, G, I));
    return !!(W !== V && K !== J || W === 0 && A(k, P, I) || V === 0 && A(k, G, I) || K === 0 && A(P, k, G) || J === 0 && A(P, I, G));
  }
  function A(k, I, P) {
    return I.x <= Math.max(k.x, P.x) && I.x >= Math.min(k.x, P.x) && I.y <= Math.max(k.y, P.y) && I.y >= Math.min(k.y, P.y);
  }
  function S(k) {
    return k > 0 ? 1 : k < 0 ? -1 : 0;
  }
  function F(k, I) {
    var P = k;
    do {
      if (P.i !== k.i && P.next.i !== k.i && P.i !== I.i && P.next.i !== I.i && w(P, P.next, k, I)) return true;
      P = P.next;
    } while (P !== k);
    return false;
  }
  function M(k, I) {
    return b(k.prev, k, k.next) < 0 ? b(k, I, k.next) >= 0 && b(k, k.prev, I) >= 0 : b(k, I, k.prev) < 0 || b(k, k.next, I) < 0;
  }
  function U(k, I) {
    var P = k, G = false, W = (k.x + I.x) / 2, V = (k.y + I.y) / 2;
    do
      P.y > V != P.next.y > V && P.next.y !== P.y && W < (P.next.x - P.x) * (V - P.y) / (P.next.y - P.y) + P.x && (G = !G), P = P.next;
    while (P !== k);
    return G;
  }
  function B(k, I) {
    var P = new D(k.i, k.x, k.y), G = new D(I.i, I.x, I.y), W = k.next, V = I.prev;
    return k.next = I, I.prev = k, P.next = W, W.prev = P, G.next = P, P.prev = G, V.next = G, G.prev = V, G;
  }
  function q(k, I, P, G) {
    var W = new D(k, I, P);
    return G ? (W.next = G.next, W.prev = G, G.next.prev = W, G.next = W) : (W.prev = W, W.next = W), W;
  }
  function z(k) {
    k.next.prev = k.prev, k.prev.next = k.next, k.prevZ && (k.prevZ.nextZ = k.nextZ), k.nextZ && (k.nextZ.prevZ = k.prevZ);
  }
  function D(k, I, P) {
    this.i = k, this.x = I, this.y = P, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = false;
  }
  i2.deviation = function(k, I, P, G) {
    var W = I && I.length, V = W ? I[0] * P : k.length, K = Math.abs(X(k, 0, V, P));
    if (W)
      for (var J = 0, ae = I.length; J < ae; J++) {
        var re = I[J] * P, he = J < ae - 1 ? I[J + 1] * P : k.length;
        K -= Math.abs(X(k, re, he, P));
      }
    var ge = 0;
    for (J = 0; J < G.length; J += 3) {
      var me = G[J] * P, Te = G[J + 1] * P, _e = G[J + 2] * P;
      ge += Math.abs(
        (k[me] - k[_e]) * (k[Te + 1] - k[me + 1]) - (k[me] - k[Te]) * (k[_e + 1] - k[me + 1])
      );
    }
    return K === 0 && ge === 0 ? 0 : Math.abs((ge - K) / K);
  };
  function X(k, I, P, G) {
    for (var W = 0, V = I, K = P - G; V < P; V += G)
      W += (k[K] - k[V]) * (k[V + 1] + k[K + 1]), K = V;
    return W;
  }
  return i2.flatten = function(k) {
    for (var I = k[0][0].length, P = { vertices: [], holes: [], dimensions: I }, G = 0, W = 0; W < k.length; W++) {
      for (var V = 0; V < k[W].length; V++)
        for (var K = 0; K < I; K++) P.vertices.push(k[W][V][K]);
      W > 0 && (G += k[W - 1].length, P.holes.push(G));
    }
    return P;
  }, earcut$1.exports;
}
requireEarcut$1();
var url$2 = {}, punycode$3 = { exports: {} };
/*! https://mths.be/punycode v1.4.1 by @mathias */
var punycode$2 = punycode$3.exports, hasRequiredPunycode$1;
function requirePunycode$1() {
  return hasRequiredPunycode$1 || (hasRequiredPunycode$1 = 1, function(i2, e) {
    (function(t) {
      var r = e && !e.nodeType && e, a = !i2.nodeType && i2, s = typeof commonjsGlobal == "object" && commonjsGlobal;
      (s.global === s || s.window === s || s.self === s) && (t = s);
      var u, l = 2147483647, c = 36, d = 1, f = 26, p = 38, m = 700, y = 72, x = 128, g = "-", _ = /^xn--/, T = /[^\x20-\x7E]/, E = /[\x2E\u3002\uFF0E\uFF61]/g, b = {
        overflow: "Overflow: input needs wider integers to process",
        "not-basic": "Illegal input >= 0x80 (not a basic code point)",
        "invalid-input": "Invalid input"
      }, C = c - d, w = Math.floor, A = String.fromCharCode, S;
      function F(W) {
        throw new RangeError(b[W]);
      }
      function M(W, V) {
        for (var K = W.length, J = []; K--; )
          J[K] = V(W[K]);
        return J;
      }
      function U(W, V) {
        var K = W.split("@"), J = "";
        K.length > 1 && (J = K[0] + "@", W = K[1]), W = W.replace(E, ".");
        var ae = W.split("."), re = M(ae, V).join(".");
        return J + re;
      }
      function B(W) {
        for (var V = [], K = 0, J = W.length, ae, re; K < J; )
          ae = W.charCodeAt(K++), ae >= 55296 && ae <= 56319 && K < J ? (re = W.charCodeAt(K++), (re & 64512) == 56320 ? V.push(((ae & 1023) << 10) + (re & 1023) + 65536) : (V.push(ae), K--)) : V.push(ae);
        return V;
      }
      function q(W) {
        return M(W, function(V) {
          var K = "";
          return V > 65535 && (V -= 65536, K += A(V >>> 10 & 1023 | 55296), V = 56320 | V & 1023), K += A(V), K;
        }).join("");
      }
      function z(W) {
        return W - 48 < 10 ? W - 22 : W - 65 < 26 ? W - 65 : W - 97 < 26 ? W - 97 : c;
      }
      function D(W, V) {
        return W + 22 + 75 * (W < 26) - ((V != 0) << 5);
      }
      function X(W, V, K) {
        var J = 0;
        for (W = K ? w(W / m) : W >> 1, W += w(W / V); W > C * f >> 1; J += c)
          W = w(W / C);
        return w(J + (C + 1) * W / (W + p));
      }
      function k(W) {
        var V = [], K = W.length, J, ae = 0, re = x, he = y, ge, me, Te, _e, ye, Ae, ke, Pe, Ee;
        for (ge = W.lastIndexOf(g), ge < 0 && (ge = 0), me = 0; me < ge; ++me)
          W.charCodeAt(me) >= 128 && F("not-basic"), V.push(W.charCodeAt(me));
        for (Te = ge > 0 ? ge + 1 : 0; Te < K; ) {
          for (_e = ae, ye = 1, Ae = c; Te >= K && F("invalid-input"), ke = z(W.charCodeAt(Te++)), (ke >= c || ke > w((l - ae) / ye)) && F("overflow"), ae += ke * ye, Pe = Ae <= he ? d : Ae >= he + f ? f : Ae - he, !(ke < Pe); Ae += c)
            Ee = c - Pe, ye > w(l / Ee) && F("overflow"), ye *= Ee;
          J = V.length + 1, he = X(ae - _e, J, _e == 0), w(ae / J) > l - re && F("overflow"), re += w(ae / J), ae %= J, V.splice(ae++, 0, re);
        }
        return q(V);
      }
      function I(W) {
        var V, K, J, ae, re, he, ge, me, Te, _e, ye, Ae = [], ke, Pe, Ee, Oe;
        for (W = B(W), ke = W.length, V = x, K = 0, re = y, he = 0; he < ke; ++he)
          ye = W[he], ye < 128 && Ae.push(A(ye));
        for (J = ae = Ae.length, ae && Ae.push(g); J < ke; ) {
          for (ge = l, he = 0; he < ke; ++he)
            ye = W[he], ye >= V && ye < ge && (ge = ye);
          for (Pe = J + 1, ge - V > w((l - K) / Pe) && F("overflow"), K += (ge - V) * Pe, V = ge, he = 0; he < ke; ++he)
            if (ye = W[he], ye < V && ++K > l && F("overflow"), ye == V) {
              for (me = K, Te = c; _e = Te <= re ? d : Te >= re + f ? f : Te - re, !(me < _e); Te += c)
                Oe = me - _e, Ee = c - _e, Ae.push(
                  A(D(_e + Oe % Ee, 0))
                ), me = w(Oe / Ee);
              Ae.push(A(D(me, 0))), re = X(K, Pe, J == ae), K = 0, ++J;
            }
          ++K, ++V;
        }
        return Ae.join("");
      }
      function P(W) {
        return U(W, function(V) {
          return _.test(V) ? k(V.slice(4).toLowerCase()) : V;
        });
      }
      function G(W) {
        return U(W, function(V) {
          return T.test(V) ? "xn--" + I(V) : V;
        });
      }
      if (u = {
        /**
         * A string representing the current Punycode.js version number.
         * @memberOf punycode
         * @type String
         */
        version: "1.4.1",
        /**
         * An object of methods to convert from JavaScript's internal character
         * representation (UCS-2) to Unicode code points, and back.
         * @see <https://mathiasbynens.be/notes/javascript-encoding>
         * @memberOf punycode
         * @type Object
         */
        ucs2: {
          decode: B,
          encode: q
        },
        decode: k,
        encode: I,
        toASCII: G,
        toUnicode: P
      }, r && a)
        if (i2.exports == r)
          a.exports = u;
        else
          for (S in u)
            u.hasOwnProperty(S) && (r[S] = u[S]);
      else
        t.punycode = u;
    })(punycode$2);
  }(punycode$3, punycode$3.exports)), punycode$3.exports;
}
var type$1, hasRequiredType$1;
function requireType$1() {
  return hasRequiredType$1 || (hasRequiredType$1 = 1, type$1 = TypeError), type$1;
}
const __viteBrowserExternal$2 = {}, __viteBrowserExternal$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: __viteBrowserExternal$2
}, Symbol.toStringTag, { value: "Module" })), require$$0$1 = /* @__PURE__ */ getAugmentedNamespace$1(__viteBrowserExternal$3);
var objectInspect$1, hasRequiredObjectInspect$1;
function requireObjectInspect$1() {
  if (hasRequiredObjectInspect$1) return objectInspect$1;
  hasRequiredObjectInspect$1 = 1;
  var i2 = typeof Map == "function" && Map.prototype, e = Object.getOwnPropertyDescriptor && i2 ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null, t = i2 && e && typeof e.get == "function" ? e.get : null, r = i2 && Map.prototype.forEach, a = typeof Set == "function" && Set.prototype, s = Object.getOwnPropertyDescriptor && a ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null, u = a && s && typeof s.get == "function" ? s.get : null, l = a && Set.prototype.forEach, c = typeof WeakMap == "function" && WeakMap.prototype, d = c ? WeakMap.prototype.has : null, f = typeof WeakSet == "function" && WeakSet.prototype, p = f ? WeakSet.prototype.has : null, m = typeof WeakRef == "function" && WeakRef.prototype, y = m ? WeakRef.prototype.deref : null, x = Boolean.prototype.valueOf, g = Object.prototype.toString, _ = Function.prototype.toString, T = String.prototype.match, E = String.prototype.slice, b = String.prototype.replace, C = String.prototype.toUpperCase, w = String.prototype.toLowerCase, A = RegExp.prototype.test, S = Array.prototype.concat, F = Array.prototype.join, M = Array.prototype.slice, U = Math.floor, B = typeof BigInt == "function" ? BigInt.prototype.valueOf : null, q = Object.getOwnPropertySymbols, z = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Symbol.prototype.toString : null, D = typeof Symbol == "function" && typeof Symbol.iterator == "object", X = typeof Symbol == "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === D || true) ? Symbol.toStringTag : null, k = Object.prototype.propertyIsEnumerable, I = (typeof Reflect == "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(oe) {
    return oe.__proto__;
  } : null);
  function P(oe, le) {
    if (oe === 1 / 0 || oe === -1 / 0 || oe !== oe || oe && oe > -1e3 && oe < 1e3 || A.call(/e/, le))
      return le;
    var Ue = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
    if (typeof oe == "number") {
      var et = oe < 0 ? -U(-oe) : U(oe);
      if (et !== oe) {
        var lt = String(et), We = E.call(le, lt.length + 1);
        return b.call(lt, Ue, "$&_") + "." + b.call(b.call(We, /([0-9]{3})/g, "$&_"), /_$/, "");
      }
    }
    return b.call(le, Ue, "$&_");
  }
  var G = require$$0$1, W = G.custom, V = ke(W) ? W : null, K = {
    __proto__: null,
    double: '"',
    single: "'"
  }, J = {
    __proto__: null,
    double: /(["\\])/g,
    single: /(['\\])/g
  };
  objectInspect$1 = function oe(le, Ue, et, lt) {
    var We = Ue || {};
    if (Oe(We, "quoteStyle") && !Oe(K, We.quoteStyle))
      throw new TypeError('option "quoteStyle" must be "single" or "double"');
    if (Oe(We, "maxStringLength") && (typeof We.maxStringLength == "number" ? We.maxStringLength < 0 && We.maxStringLength !== 1 / 0 : We.maxStringLength !== null))
      throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
    var te = Oe(We, "customInspect") ? We.customInspect : true;
    if (typeof te != "boolean" && te !== "symbol")
      throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
    if (Oe(We, "indent") && We.indent !== null && We.indent !== "	" && !(parseInt(We.indent, 10) === We.indent && We.indent > 0))
      throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
    if (Oe(We, "numericSeparator") && typeof We.numericSeparator != "boolean")
      throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
    var ne = We.numericSeparator;
    if (typeof le > "u")
      return "undefined";
    if (le === null)
      return "null";
    if (typeof le == "boolean")
      return le ? "true" : "false";
    if (typeof le == "string")
      return er(le, We);
    if (typeof le == "number") {
      if (le === 0)
        return 1 / 0 / le > 0 ? "0" : "-0";
      var fe = String(le);
      return ne ? P(le, fe) : fe;
    }
    if (typeof le == "bigint") {
      var qe = String(le) + "n";
      return ne ? P(le, qe) : qe;
    }
    var Je = typeof We.depth > "u" ? 5 : We.depth;
    if (typeof et > "u" && (et = 0), et >= Je && Je > 0 && typeof le == "object")
      return he(le) ? "[Array]" : "[Object]";
    var ht = Ne(We, et);
    if (typeof lt > "u")
      lt = [];
    else if (xt(lt, le) >= 0)
      return "[Circular]";
    function bt(Ir, Zr, Xi) {
      if (Zr && (lt = M.call(lt), lt.push(Zr)), Xi) {
        var Ai = {
          depth: We.depth
        };
        return Oe(We, "quoteStyle") && (Ai.quoteStyle = We.quoteStyle), oe(Ir, Ai, et + 1, lt);
      }
      return oe(Ir, We, et + 1, lt);
    }
    if (typeof le == "function" && !me(le)) {
      var kt = gt(le), Ar = pt(le, bt);
      return "[Function" + (kt ? ": " + kt : " (anonymous)") + "]" + (Ar.length > 0 ? " { " + F.call(Ar, ", ") + " }" : "");
    }
    if (ke(le)) {
      var Sr = D ? b.call(String(le), /^(Symbol\(.*\))_[^)]*$/, "$1") : z.call(le);
      return typeof le == "object" && !D ? Y(Sr) : Sr;
    }
    if (It(le)) {
      for (var Vt = "<" + w.call(String(le.nodeName)), jr = le.attributes || [], tr = 0; tr < jr.length; tr++)
        Vt += " " + jr[tr].name + "=" + ae(re(jr[tr].value), "double", We);
      return Vt += ">", le.childNodes && le.childNodes.length && (Vt += "..."), Vt += "</" + w.call(String(le.nodeName)) + ">", Vt;
    }
    if (he(le)) {
      if (le.length === 0)
        return "[]";
      var _r = pt(le, bt);
      return ht && !Se(_r) ? "[" + je(_r, ht) + "]" : "[ " + F.call(_r, ", ") + " ]";
    }
    if (Te(le)) {
      var wr = pt(le, bt);
      return !("cause" in Error.prototype) && "cause" in le && !k.call(le, "cause") ? "{ [" + String(le) + "] " + F.call(S.call("[cause]: " + bt(le.cause), wr), ", ") + " }" : wr.length === 0 ? "[" + String(le) + "]" : "{ [" + String(le) + "] " + F.call(wr, ", ") + " }";
    }
    if (typeof le == "object" && te) {
      if (V && typeof le[V] == "function" && G)
        return G(le, { depth: Je - et });
      if (te !== "symbol" && typeof le.inspect == "function")
        return le.inspect();
    }
    if (vt(le)) {
      var xr = [];
      return r && r.call(le, function(Ir, Zr) {
        xr.push(bt(Zr, le, true) + " => " + bt(Ir, le));
      }), be("Map", t.call(le), xr, ht);
    }
    if (ct(le)) {
      var Mr = [];
      return l && l.call(le, function(Ir) {
        Mr.push(bt(Ir, le));
      }), be("Set", u.call(le), Mr, ht);
    }
    if (Xe(le))
      return ee("WeakMap");
    if (Rt(le))
      return ee("WeakSet");
    if (at(le))
      return ee("WeakRef");
    if (ye(le))
      return Y(bt(Number(le)));
    if (Pe(le))
      return Y(bt(B.call(le)));
    if (Ae(le))
      return Y(x.call(le));
    if (_e(le))
      return Y(bt(String(le)));
    if (typeof window < "u" && le === window)
      return "{ [object Window] }";
    if (typeof globalThis < "u" && le === globalThis || typeof commonjsGlobal < "u" && le === commonjsGlobal)
      return "{ [object globalThis] }";
    if (!ge(le) && !me(le)) {
      var Or = pt(le, bt), hi = I ? I(le) === Object.prototype : le instanceof Object || le.constructor === Object, Rr = le instanceof Object ? "" : "null prototype", ci = !hi && X && Object(le) === le && X in le ? E.call($e(le), 8, -1) : Rr ? "Object" : "", Ri = hi || typeof le.constructor != "function" ? "" : le.constructor.name ? le.constructor.name + " " : "", fi = Ri + (ci || Rr ? "[" + F.call(S.call([], ci || [], Rr || []), ": ") + "] " : "");
      return Or.length === 0 ? fi + "{}" : ht ? fi + "{" + je(Or, ht) + "}" : fi + "{ " + F.call(Or, ", ") + " }";
    }
    return String(le);
  };
  function ae(oe, le, Ue) {
    var et = Ue.quoteStyle || le, lt = K[et];
    return lt + oe + lt;
  }
  function re(oe) {
    return b.call(String(oe), /"/g, "&quot;");
  }
  function he(oe) {
    return $e(oe) === "[object Array]" && (!X || !(typeof oe == "object" && X in oe));
  }
  function ge(oe) {
    return $e(oe) === "[object Date]" && (!X || !(typeof oe == "object" && X in oe));
  }
  function me(oe) {
    return $e(oe) === "[object RegExp]" && (!X || !(typeof oe == "object" && X in oe));
  }
  function Te(oe) {
    return $e(oe) === "[object Error]" && (!X || !(typeof oe == "object" && X in oe));
  }
  function _e(oe) {
    return $e(oe) === "[object String]" && (!X || !(typeof oe == "object" && X in oe));
  }
  function ye(oe) {
    return $e(oe) === "[object Number]" && (!X || !(typeof oe == "object" && X in oe));
  }
  function Ae(oe) {
    return $e(oe) === "[object Boolean]" && (!X || !(typeof oe == "object" && X in oe));
  }
  function ke(oe) {
    if (D)
      return oe && typeof oe == "object" && oe instanceof Symbol;
    if (typeof oe == "symbol")
      return true;
    if (!oe || typeof oe != "object" || !z)
      return false;
    try {
      return z.call(oe), true;
    } catch {
    }
    return false;
  }
  function Pe(oe) {
    if (!oe || typeof oe != "object" || !B)
      return false;
    try {
      return B.call(oe), true;
    } catch {
    }
    return false;
  }
  var Ee = Object.prototype.hasOwnProperty || function(oe) {
    return oe in this;
  };
  function Oe(oe, le) {
    return Ee.call(oe, le);
  }
  function $e(oe) {
    return g.call(oe);
  }
  function gt(oe) {
    if (oe.name)
      return oe.name;
    var le = T.call(_.call(oe), /^function\s*([\w$]+)/);
    return le ? le[1] : null;
  }
  function xt(oe, le) {
    if (oe.indexOf)
      return oe.indexOf(le);
    for (var Ue = 0, et = oe.length; Ue < et; Ue++)
      if (oe[Ue] === le)
        return Ue;
    return -1;
  }
  function vt(oe) {
    if (!t || !oe || typeof oe != "object")
      return false;
    try {
      t.call(oe);
      try {
        u.call(oe);
      } catch {
        return true;
      }
      return oe instanceof Map;
    } catch {
    }
    return false;
  }
  function Xe(oe) {
    if (!d || !oe || typeof oe != "object")
      return false;
    try {
      d.call(oe, d);
      try {
        p.call(oe, p);
      } catch {
        return true;
      }
      return oe instanceof WeakMap;
    } catch {
    }
    return false;
  }
  function at(oe) {
    if (!y || !oe || typeof oe != "object")
      return false;
    try {
      return y.call(oe), true;
    } catch {
    }
    return false;
  }
  function ct(oe) {
    if (!u || !oe || typeof oe != "object")
      return false;
    try {
      u.call(oe);
      try {
        t.call(oe);
      } catch {
        return true;
      }
      return oe instanceof Set;
    } catch {
    }
    return false;
  }
  function Rt(oe) {
    if (!p || !oe || typeof oe != "object")
      return false;
    try {
      p.call(oe, p);
      try {
        d.call(oe, d);
      } catch {
        return true;
      }
      return oe instanceof WeakSet;
    } catch {
    }
    return false;
  }
  function It(oe) {
    return !oe || typeof oe != "object" ? false : typeof HTMLElement < "u" && oe instanceof HTMLElement ? true : typeof oe.nodeName == "string" && typeof oe.getAttribute == "function";
  }
  function er(oe, le) {
    if (oe.length > le.maxStringLength) {
      var Ue = oe.length - le.maxStringLength, et = "... " + Ue + " more character" + (Ue > 1 ? "s" : "");
      return er(E.call(oe, 0, le.maxStringLength), le) + et;
    }
    var lt = J[le.quoteStyle || "single"];
    lt.lastIndex = 0;
    var We = b.call(b.call(oe, lt, "\\$1"), /[\x00-\x1f]/g, $);
    return ae(We, "single", le);
  }
  function $(oe) {
    var le = oe.charCodeAt(0), Ue = {
      8: "b",
      9: "t",
      10: "n",
      12: "f",
      13: "r"
    }[le];
    return Ue ? "\\" + Ue : "\\x" + (le < 16 ? "0" : "") + C.call(le.toString(16));
  }
  function Y(oe) {
    return "Object(" + oe + ")";
  }
  function ee(oe) {
    return oe + " { ? }";
  }
  function be(oe, le, Ue, et) {
    var lt = et ? je(Ue, et) : F.call(Ue, ", ");
    return oe + " (" + le + ") {" + lt + "}";
  }
  function Se(oe) {
    for (var le = 0; le < oe.length; le++)
      if (xt(oe[le], `
`) >= 0)
        return false;
    return true;
  }
  function Ne(oe, le) {
    var Ue;
    if (oe.indent === "	")
      Ue = "	";
    else if (typeof oe.indent == "number" && oe.indent > 0)
      Ue = F.call(Array(oe.indent + 1), " ");
    else
      return null;
    return {
      base: Ue,
      prev: F.call(Array(le + 1), Ue)
    };
  }
  function je(oe, le) {
    if (oe.length === 0)
      return "";
    var Ue = `
` + le.prev + le.base;
    return Ue + F.call(oe, "," + Ue) + `
` + le.prev;
  }
  function pt(oe, le) {
    var Ue = he(oe), et = [];
    if (Ue) {
      et.length = oe.length;
      for (var lt = 0; lt < oe.length; lt++)
        et[lt] = Oe(oe, lt) ? le(oe[lt], oe) : "";
    }
    var We = typeof q == "function" ? q(oe) : [], te;
    if (D) {
      te = {};
      for (var ne = 0; ne < We.length; ne++)
        te["$" + We[ne]] = We[ne];
    }
    for (var fe in oe)
      Oe(oe, fe) && (Ue && String(Number(fe)) === fe && fe < oe.length || D && te["$" + fe] instanceof Symbol || (A.call(/[^\w$]/, fe) ? et.push(le(fe, oe) + ": " + le(oe[fe], oe)) : et.push(fe + ": " + le(oe[fe], oe))));
    if (typeof q == "function")
      for (var qe = 0; qe < We.length; qe++)
        k.call(oe, We[qe]) && et.push("[" + le(We[qe]) + "]: " + le(oe[We[qe]], oe));
    return et;
  }
  return objectInspect$1;
}
var sideChannelList$1, hasRequiredSideChannelList$1;
function requireSideChannelList$1() {
  if (hasRequiredSideChannelList$1) return sideChannelList$1;
  hasRequiredSideChannelList$1 = 1;
  var i2 = /* @__PURE__ */ requireObjectInspect$1(), e = /* @__PURE__ */ requireType$1(), t = function(l, c, d) {
    for (var f = l, p; (p = f.next) != null; f = p)
      if (p.key === c)
        return f.next = p.next, d || (p.next = /** @type {NonNullable<typeof list.next>} */
        l.next, l.next = p), p;
  }, r = function(l, c) {
    if (l) {
      var d = t(l, c);
      return d && d.value;
    }
  }, a = function(l, c, d) {
    var f = t(l, c);
    f ? f.value = d : l.next = /** @type {import('./list.d.ts').ListNode<typeof value, typeof key>} */
    {
      // eslint-disable-line no-param-reassign, no-extra-parens
      key: c,
      next: l.next,
      value: d
    };
  }, s = function(l, c) {
    return l ? !!t(l, c) : false;
  }, u = function(l, c) {
    if (l)
      return t(l, c, true);
  };
  return sideChannelList$1 = function() {
    var c, d = {
      assert: function(f) {
        if (!d.has(f))
          throw new e("Side channel does not contain " + i2(f));
      },
      delete: function(f) {
        var p = c && c.next, m = u(c, f);
        return m && p && p === m && (c = void 0), !!m;
      },
      get: function(f) {
        return r(c, f);
      },
      has: function(f) {
        return s(c, f);
      },
      set: function(f, p) {
        c || (c = {
          next: void 0
        }), a(
          /** @type {NonNullable<typeof $o>} */
          c,
          f,
          p
        );
      }
    };
    return d;
  }, sideChannelList$1;
}
var esObjectAtoms$1, hasRequiredEsObjectAtoms$1;
function requireEsObjectAtoms$1() {
  return hasRequiredEsObjectAtoms$1 || (hasRequiredEsObjectAtoms$1 = 1, esObjectAtoms$1 = Object), esObjectAtoms$1;
}
var esErrors$1, hasRequiredEsErrors$1;
function requireEsErrors$1() {
  return hasRequiredEsErrors$1 || (hasRequiredEsErrors$1 = 1, esErrors$1 = Error), esErrors$1;
}
var _eval$1, hasRequired_eval$1;
function require_eval$1() {
  return hasRequired_eval$1 || (hasRequired_eval$1 = 1, _eval$1 = EvalError), _eval$1;
}
var range$1, hasRequiredRange$1;
function requireRange$1() {
  return hasRequiredRange$1 || (hasRequiredRange$1 = 1, range$1 = RangeError), range$1;
}
var ref$2, hasRequiredRef$1;
function requireRef$1() {
  return hasRequiredRef$1 || (hasRequiredRef$1 = 1, ref$2 = ReferenceError), ref$2;
}
var syntax$1, hasRequiredSyntax$1;
function requireSyntax$1() {
  return hasRequiredSyntax$1 || (hasRequiredSyntax$1 = 1, syntax$1 = SyntaxError), syntax$1;
}
var uri$1, hasRequiredUri$1;
function requireUri$1() {
  return hasRequiredUri$1 || (hasRequiredUri$1 = 1, uri$1 = URIError), uri$1;
}
var abs$1, hasRequiredAbs$1;
function requireAbs$1() {
  return hasRequiredAbs$1 || (hasRequiredAbs$1 = 1, abs$1 = Math.abs), abs$1;
}
var floor$1, hasRequiredFloor$1;
function requireFloor$1() {
  return hasRequiredFloor$1 || (hasRequiredFloor$1 = 1, floor$1 = Math.floor), floor$1;
}
var max$2, hasRequiredMax$1;
function requireMax$1() {
  return hasRequiredMax$1 || (hasRequiredMax$1 = 1, max$2 = Math.max), max$2;
}
var min$1, hasRequiredMin$2;
function requireMin$2() {
  return hasRequiredMin$2 || (hasRequiredMin$2 = 1, min$1 = Math.min), min$1;
}
var pow$1, hasRequiredPow$1;
function requirePow$1() {
  return hasRequiredPow$1 || (hasRequiredPow$1 = 1, pow$1 = Math.pow), pow$1;
}
var round$1, hasRequiredRound$1;
function requireRound$1() {
  return hasRequiredRound$1 || (hasRequiredRound$1 = 1, round$1 = Math.round), round$1;
}
var _isNaN$1, hasRequired_isNaN$1;
function require_isNaN$1() {
  return hasRequired_isNaN$1 || (hasRequired_isNaN$1 = 1, _isNaN$1 = Number.isNaN || function(e) {
    return e !== e;
  }), _isNaN$1;
}
var sign$1, hasRequiredSign$1;
function requireSign$1() {
  if (hasRequiredSign$1) return sign$1;
  hasRequiredSign$1 = 1;
  var i2 = /* @__PURE__ */ require_isNaN$1();
  return sign$1 = function(t) {
    return i2(t) || t === 0 ? t : t < 0 ? -1 : 1;
  }, sign$1;
}
var gOPD$1, hasRequiredGOPD$1;
function requireGOPD$1() {
  return hasRequiredGOPD$1 || (hasRequiredGOPD$1 = 1, gOPD$1 = Object.getOwnPropertyDescriptor), gOPD$1;
}
var gopd$1, hasRequiredGopd$1;
function requireGopd$1() {
  if (hasRequiredGopd$1) return gopd$1;
  hasRequiredGopd$1 = 1;
  var i2 = /* @__PURE__ */ requireGOPD$1();
  if (i2)
    try {
      i2([], "length");
    } catch {
      i2 = null;
    }
  return gopd$1 = i2, gopd$1;
}
var esDefineProperty$1, hasRequiredEsDefineProperty$1;
function requireEsDefineProperty$1() {
  if (hasRequiredEsDefineProperty$1) return esDefineProperty$1;
  hasRequiredEsDefineProperty$1 = 1;
  var i2 = Object.defineProperty || false;
  if (i2)
    try {
      i2({}, "a", { value: 1 });
    } catch {
      i2 = false;
    }
  return esDefineProperty$1 = i2, esDefineProperty$1;
}
var shams$1, hasRequiredShams$1;
function requireShams$1() {
  return hasRequiredShams$1 || (hasRequiredShams$1 = 1, shams$1 = function() {
    if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
      return false;
    if (typeof Symbol.iterator == "symbol")
      return true;
    var e = {}, t = Symbol("test"), r = Object(t);
    if (typeof t == "string" || Object.prototype.toString.call(t) !== "[object Symbol]" || Object.prototype.toString.call(r) !== "[object Symbol]")
      return false;
    var a = 42;
    e[t] = a;
    for (var s in e)
      return false;
    if (typeof Object.keys == "function" && Object.keys(e).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(e).length !== 0)
      return false;
    var u = Object.getOwnPropertySymbols(e);
    if (u.length !== 1 || u[0] !== t || !Object.prototype.propertyIsEnumerable.call(e, t))
      return false;
    if (typeof Object.getOwnPropertyDescriptor == "function") {
      var l = (
        /** @type {PropertyDescriptor} */
        Object.getOwnPropertyDescriptor(e, t)
      );
      if (l.value !== a || l.enumerable !== true)
        return false;
    }
    return true;
  }), shams$1;
}
var hasSymbols$1, hasRequiredHasSymbols$1;
function requireHasSymbols$1() {
  if (hasRequiredHasSymbols$1) return hasSymbols$1;
  hasRequiredHasSymbols$1 = 1;
  var i2 = typeof Symbol < "u" && Symbol, e = requireShams$1();
  return hasSymbols$1 = function() {
    return typeof i2 != "function" || typeof Symbol != "function" || typeof i2("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? false : e();
  }, hasSymbols$1;
}
var Reflect_getPrototypeOf$1, hasRequiredReflect_getPrototypeOf$1;
function requireReflect_getPrototypeOf$1() {
  return hasRequiredReflect_getPrototypeOf$1 || (hasRequiredReflect_getPrototypeOf$1 = 1, Reflect_getPrototypeOf$1 = typeof Reflect < "u" && Reflect.getPrototypeOf || null), Reflect_getPrototypeOf$1;
}
var Object_getPrototypeOf$1, hasRequiredObject_getPrototypeOf$1;
function requireObject_getPrototypeOf$1() {
  if (hasRequiredObject_getPrototypeOf$1) return Object_getPrototypeOf$1;
  hasRequiredObject_getPrototypeOf$1 = 1;
  var i2 = /* @__PURE__ */ requireEsObjectAtoms$1();
  return Object_getPrototypeOf$1 = i2.getPrototypeOf || null, Object_getPrototypeOf$1;
}
var implementation$1, hasRequiredImplementation$1;
function requireImplementation$1() {
  if (hasRequiredImplementation$1) return implementation$1;
  hasRequiredImplementation$1 = 1;
  var i2 = "Function.prototype.bind called on incompatible ", e = Object.prototype.toString, t = Math.max, r = "[object Function]", a = function(c, d) {
    for (var f = [], p = 0; p < c.length; p += 1)
      f[p] = c[p];
    for (var m = 0; m < d.length; m += 1)
      f[m + c.length] = d[m];
    return f;
  }, s = function(c, d) {
    for (var f = [], p = d, m = 0; p < c.length; p += 1, m += 1)
      f[m] = c[p];
    return f;
  }, u = function(l, c) {
    for (var d = "", f = 0; f < l.length; f += 1)
      d += l[f], f + 1 < l.length && (d += c);
    return d;
  };
  return implementation$1 = function(c) {
    var d = this;
    if (typeof d != "function" || e.apply(d) !== r)
      throw new TypeError(i2 + d);
    for (var f = s(arguments, 1), p, m = function() {
      if (this instanceof p) {
        var T = d.apply(
          this,
          a(f, arguments)
        );
        return Object(T) === T ? T : this;
      }
      return d.apply(
        c,
        a(f, arguments)
      );
    }, y = t(0, d.length - f.length), x = [], g = 0; g < y; g++)
      x[g] = "$" + g;
    if (p = Function("binder", "return function (" + u(x, ",") + "){ return binder.apply(this,arguments); }")(m), d.prototype) {
      var _ = function() {
      };
      _.prototype = d.prototype, p.prototype = new _(), _.prototype = null;
    }
    return p;
  }, implementation$1;
}
var functionBind$1, hasRequiredFunctionBind$1;
function requireFunctionBind$1() {
  if (hasRequiredFunctionBind$1) return functionBind$1;
  hasRequiredFunctionBind$1 = 1;
  var i2 = requireImplementation$1();
  return functionBind$1 = Function.prototype.bind || i2, functionBind$1;
}
var functionCall$1, hasRequiredFunctionCall$1;
function requireFunctionCall$1() {
  return hasRequiredFunctionCall$1 || (hasRequiredFunctionCall$1 = 1, functionCall$1 = Function.prototype.call), functionCall$1;
}
var functionApply$1, hasRequiredFunctionApply$1;
function requireFunctionApply$1() {
  return hasRequiredFunctionApply$1 || (hasRequiredFunctionApply$1 = 1, functionApply$1 = Function.prototype.apply), functionApply$1;
}
var reflectApply$1, hasRequiredReflectApply$1;
function requireReflectApply$1() {
  return hasRequiredReflectApply$1 || (hasRequiredReflectApply$1 = 1, reflectApply$1 = typeof Reflect < "u" && Reflect && Reflect.apply), reflectApply$1;
}
var actualApply$1, hasRequiredActualApply$1;
function requireActualApply$1() {
  if (hasRequiredActualApply$1) return actualApply$1;
  hasRequiredActualApply$1 = 1;
  var i2 = requireFunctionBind$1(), e = requireFunctionApply$1(), t = requireFunctionCall$1(), r = requireReflectApply$1();
  return actualApply$1 = r || i2.call(t, e), actualApply$1;
}
var callBindApplyHelpers$1, hasRequiredCallBindApplyHelpers$1;
function requireCallBindApplyHelpers$1() {
  if (hasRequiredCallBindApplyHelpers$1) return callBindApplyHelpers$1;
  hasRequiredCallBindApplyHelpers$1 = 1;
  var i2 = requireFunctionBind$1(), e = /* @__PURE__ */ requireType$1(), t = requireFunctionCall$1(), r = requireActualApply$1();
  return callBindApplyHelpers$1 = function(s) {
    if (s.length < 1 || typeof s[0] != "function")
      throw new e("a function is required");
    return r(i2, t, s);
  }, callBindApplyHelpers$1;
}
var get$1, hasRequiredGet$1;
function requireGet$1() {
  if (hasRequiredGet$1) return get$1;
  hasRequiredGet$1 = 1;
  var i2 = requireCallBindApplyHelpers$1(), e = /* @__PURE__ */ requireGopd$1(), t;
  try {
    t = /** @type {{ __proto__?: typeof Array.prototype }} */
    [].__proto__ === Array.prototype;
  } catch (u) {
    if (!u || typeof u != "object" || !("code" in u) || u.code !== "ERR_PROTO_ACCESS")
      throw u;
  }
  var r = !!t && e && e(
    Object.prototype,
    /** @type {keyof typeof Object.prototype} */
    "__proto__"
  ), a = Object, s = a.getPrototypeOf;
  return get$1 = r && typeof r.get == "function" ? i2([r.get]) : typeof s == "function" ? (
    /** @type {import('./get')} */
    function(l) {
      return s(l == null ? l : a(l));
    }
  ) : false, get$1;
}
var getProto$1, hasRequiredGetProto$1;
function requireGetProto$1() {
  if (hasRequiredGetProto$1) return getProto$1;
  hasRequiredGetProto$1 = 1;
  var i2 = requireReflect_getPrototypeOf$1(), e = requireObject_getPrototypeOf$1(), t = /* @__PURE__ */ requireGet$1();
  return getProto$1 = i2 ? function(a) {
    return i2(a);
  } : e ? function(a) {
    if (!a || typeof a != "object" && typeof a != "function")
      throw new TypeError("getProto: not an object");
    return e(a);
  } : t ? function(a) {
    return t(a);
  } : null, getProto$1;
}
var hasown$1, hasRequiredHasown$1;
function requireHasown$1() {
  if (hasRequiredHasown$1) return hasown$1;
  hasRequiredHasown$1 = 1;
  var i2 = Function.prototype.call, e = Object.prototype.hasOwnProperty, t = requireFunctionBind$1();
  return hasown$1 = t.call(i2, e), hasown$1;
}
var getIntrinsic$1, hasRequiredGetIntrinsic$1;
function requireGetIntrinsic$1() {
  if (hasRequiredGetIntrinsic$1) return getIntrinsic$1;
  hasRequiredGetIntrinsic$1 = 1;
  var i2, e = /* @__PURE__ */ requireEsObjectAtoms$1(), t = /* @__PURE__ */ requireEsErrors$1(), r = /* @__PURE__ */ require_eval$1(), a = /* @__PURE__ */ requireRange$1(), s = /* @__PURE__ */ requireRef$1(), u = /* @__PURE__ */ requireSyntax$1(), l = /* @__PURE__ */ requireType$1(), c = /* @__PURE__ */ requireUri$1(), d = /* @__PURE__ */ requireAbs$1(), f = /* @__PURE__ */ requireFloor$1(), p = /* @__PURE__ */ requireMax$1(), m = /* @__PURE__ */ requireMin$2(), y = /* @__PURE__ */ requirePow$1(), x = /* @__PURE__ */ requireRound$1(), g = /* @__PURE__ */ requireSign$1(), _ = Function, T = function(Te) {
    try {
      return _('"use strict"; return (' + Te + ").constructor;")();
    } catch {
    }
  }, E = /* @__PURE__ */ requireGopd$1(), b = /* @__PURE__ */ requireEsDefineProperty$1(), C = function() {
    throw new l();
  }, w = E ? function() {
    try {
      return arguments.callee, C;
    } catch {
      try {
        return E(arguments, "callee").get;
      } catch {
        return C;
      }
    }
  }() : C, A = requireHasSymbols$1()(), S = requireGetProto$1(), F = requireObject_getPrototypeOf$1(), M = requireReflect_getPrototypeOf$1(), U = requireFunctionApply$1(), B = requireFunctionCall$1(), q = {}, z = typeof Uint8Array > "u" || !S ? i2 : S(Uint8Array), D = {
    __proto__: null,
    "%AggregateError%": typeof AggregateError > "u" ? i2 : AggregateError,
    "%Array%": Array,
    "%ArrayBuffer%": typeof ArrayBuffer > "u" ? i2 : ArrayBuffer,
    "%ArrayIteratorPrototype%": A && S ? S([][Symbol.iterator]()) : i2,
    "%AsyncFromSyncIteratorPrototype%": i2,
    "%AsyncFunction%": q,
    "%AsyncGenerator%": q,
    "%AsyncGeneratorFunction%": q,
    "%AsyncIteratorPrototype%": q,
    "%Atomics%": typeof Atomics > "u" ? i2 : Atomics,
    "%BigInt%": typeof BigInt > "u" ? i2 : BigInt,
    "%BigInt64Array%": typeof BigInt64Array > "u" ? i2 : BigInt64Array,
    "%BigUint64Array%": typeof BigUint64Array > "u" ? i2 : BigUint64Array,
    "%Boolean%": Boolean,
    "%DataView%": typeof DataView > "u" ? i2 : DataView,
    "%Date%": Date,
    "%decodeURI%": decodeURI,
    "%decodeURIComponent%": decodeURIComponent,
    "%encodeURI%": encodeURI,
    "%encodeURIComponent%": encodeURIComponent,
    "%Error%": t,
    "%eval%": eval,
    // eslint-disable-line no-eval
    "%EvalError%": r,
    "%Float32Array%": typeof Float32Array > "u" ? i2 : Float32Array,
    "%Float64Array%": typeof Float64Array > "u" ? i2 : Float64Array,
    "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? i2 : FinalizationRegistry,
    "%Function%": _,
    "%GeneratorFunction%": q,
    "%Int8Array%": typeof Int8Array > "u" ? i2 : Int8Array,
    "%Int16Array%": typeof Int16Array > "u" ? i2 : Int16Array,
    "%Int32Array%": typeof Int32Array > "u" ? i2 : Int32Array,
    "%isFinite%": isFinite,
    "%isNaN%": isNaN,
    "%IteratorPrototype%": A && S ? S(S([][Symbol.iterator]())) : i2,
    "%JSON%": typeof JSON == "object" ? JSON : i2,
    "%Map%": typeof Map > "u" ? i2 : Map,
    "%MapIteratorPrototype%": typeof Map > "u" || !A || !S ? i2 : S((/* @__PURE__ */ new Map())[Symbol.iterator]()),
    "%Math%": Math,
    "%Number%": Number,
    "%Object%": e,
    "%Object.getOwnPropertyDescriptor%": E,
    "%parseFloat%": parseFloat,
    "%parseInt%": parseInt,
    "%Promise%": typeof Promise > "u" ? i2 : Promise,
    "%Proxy%": typeof Proxy > "u" ? i2 : Proxy,
    "%RangeError%": a,
    "%ReferenceError%": s,
    "%Reflect%": typeof Reflect > "u" ? i2 : Reflect,
    "%RegExp%": RegExp,
    "%Set%": typeof Set > "u" ? i2 : Set,
    "%SetIteratorPrototype%": typeof Set > "u" || !A || !S ? i2 : S((/* @__PURE__ */ new Set())[Symbol.iterator]()),
    "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? i2 : SharedArrayBuffer,
    "%String%": String,
    "%StringIteratorPrototype%": A && S ? S(""[Symbol.iterator]()) : i2,
    "%Symbol%": A ? Symbol : i2,
    "%SyntaxError%": u,
    "%ThrowTypeError%": w,
    "%TypedArray%": z,
    "%TypeError%": l,
    "%Uint8Array%": typeof Uint8Array > "u" ? i2 : Uint8Array,
    "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? i2 : Uint8ClampedArray,
    "%Uint16Array%": typeof Uint16Array > "u" ? i2 : Uint16Array,
    "%Uint32Array%": typeof Uint32Array > "u" ? i2 : Uint32Array,
    "%URIError%": c,
    "%WeakMap%": typeof WeakMap > "u" ? i2 : WeakMap,
    "%WeakRef%": typeof WeakRef > "u" ? i2 : WeakRef,
    "%WeakSet%": typeof WeakSet > "u" ? i2 : WeakSet,
    "%Function.prototype.call%": B,
    "%Function.prototype.apply%": U,
    "%Object.defineProperty%": b,
    "%Object.getPrototypeOf%": F,
    "%Math.abs%": d,
    "%Math.floor%": f,
    "%Math.max%": p,
    "%Math.min%": m,
    "%Math.pow%": y,
    "%Math.round%": x,
    "%Math.sign%": g,
    "%Reflect.getPrototypeOf%": M
  };
  if (S)
    try {
      null.error;
    } catch (Te) {
      var X = S(S(Te));
      D["%Error.prototype%"] = X;
    }
  var k = function Te(_e) {
    var ye;
    if (_e === "%AsyncFunction%")
      ye = T("async function () {}");
    else if (_e === "%GeneratorFunction%")
      ye = T("function* () {}");
    else if (_e === "%AsyncGeneratorFunction%")
      ye = T("async function* () {}");
    else if (_e === "%AsyncGenerator%") {
      var Ae = Te("%AsyncGeneratorFunction%");
      Ae && (ye = Ae.prototype);
    } else if (_e === "%AsyncIteratorPrototype%") {
      var ke = Te("%AsyncGenerator%");
      ke && S && (ye = S(ke.prototype));
    }
    return D[_e] = ye, ye;
  }, I = {
    __proto__: null,
    "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
    "%ArrayPrototype%": ["Array", "prototype"],
    "%ArrayProto_entries%": ["Array", "prototype", "entries"],
    "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
    "%ArrayProto_keys%": ["Array", "prototype", "keys"],
    "%ArrayProto_values%": ["Array", "prototype", "values"],
    "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
    "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
    "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
    "%BooleanPrototype%": ["Boolean", "prototype"],
    "%DataViewPrototype%": ["DataView", "prototype"],
    "%DatePrototype%": ["Date", "prototype"],
    "%ErrorPrototype%": ["Error", "prototype"],
    "%EvalErrorPrototype%": ["EvalError", "prototype"],
    "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
    "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
    "%FunctionPrototype%": ["Function", "prototype"],
    "%Generator%": ["GeneratorFunction", "prototype"],
    "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
    "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
    "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
    "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
    "%JSONParse%": ["JSON", "parse"],
    "%JSONStringify%": ["JSON", "stringify"],
    "%MapPrototype%": ["Map", "prototype"],
    "%NumberPrototype%": ["Number", "prototype"],
    "%ObjectPrototype%": ["Object", "prototype"],
    "%ObjProto_toString%": ["Object", "prototype", "toString"],
    "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
    "%PromisePrototype%": ["Promise", "prototype"],
    "%PromiseProto_then%": ["Promise", "prototype", "then"],
    "%Promise_all%": ["Promise", "all"],
    "%Promise_reject%": ["Promise", "reject"],
    "%Promise_resolve%": ["Promise", "resolve"],
    "%RangeErrorPrototype%": ["RangeError", "prototype"],
    "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
    "%RegExpPrototype%": ["RegExp", "prototype"],
    "%SetPrototype%": ["Set", "prototype"],
    "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
    "%StringPrototype%": ["String", "prototype"],
    "%SymbolPrototype%": ["Symbol", "prototype"],
    "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
    "%TypedArrayPrototype%": ["TypedArray", "prototype"],
    "%TypeErrorPrototype%": ["TypeError", "prototype"],
    "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
    "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
    "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
    "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
    "%URIErrorPrototype%": ["URIError", "prototype"],
    "%WeakMapPrototype%": ["WeakMap", "prototype"],
    "%WeakSetPrototype%": ["WeakSet", "prototype"]
  }, P = requireFunctionBind$1(), G = /* @__PURE__ */ requireHasown$1(), W = P.call(B, Array.prototype.concat), V = P.call(U, Array.prototype.splice), K = P.call(B, String.prototype.replace), J = P.call(B, String.prototype.slice), ae = P.call(B, RegExp.prototype.exec), re = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, he = /\\(\\)?/g, ge = function(_e) {
    var ye = J(_e, 0, 1), Ae = J(_e, -1);
    if (ye === "%" && Ae !== "%")
      throw new u("invalid intrinsic syntax, expected closing `%`");
    if (Ae === "%" && ye !== "%")
      throw new u("invalid intrinsic syntax, expected opening `%`");
    var ke = [];
    return K(_e, re, function(Pe, Ee, Oe, $e) {
      ke[ke.length] = Oe ? K($e, he, "$1") : Ee || Pe;
    }), ke;
  }, me = function(_e, ye) {
    var Ae = _e, ke;
    if (G(I, Ae) && (ke = I[Ae], Ae = "%" + ke[0] + "%"), G(D, Ae)) {
      var Pe = D[Ae];
      if (Pe === q && (Pe = k(Ae)), typeof Pe > "u" && !ye)
        throw new l("intrinsic " + _e + " exists, but is not available. Please file an issue!");
      return {
        alias: ke,
        name: Ae,
        value: Pe
      };
    }
    throw new u("intrinsic " + _e + " does not exist!");
  };
  return getIntrinsic$1 = function(_e, ye) {
    if (typeof _e != "string" || _e.length === 0)
      throw new l("intrinsic name must be a non-empty string");
    if (arguments.length > 1 && typeof ye != "boolean")
      throw new l('"allowMissing" argument must be a boolean');
    if (ae(/^%?[^%]*%?$/, _e) === null)
      throw new u("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
    var Ae = ge(_e), ke = Ae.length > 0 ? Ae[0] : "", Pe = me("%" + ke + "%", ye), Ee = Pe.name, Oe = Pe.value, $e = false, gt = Pe.alias;
    gt && (ke = gt[0], V(Ae, W([0, 1], gt)));
    for (var xt = 1, vt = true; xt < Ae.length; xt += 1) {
      var Xe = Ae[xt], at = J(Xe, 0, 1), ct = J(Xe, -1);
      if ((at === '"' || at === "'" || at === "`" || ct === '"' || ct === "'" || ct === "`") && at !== ct)
        throw new u("property names with quotes must have matching quotes");
      if ((Xe === "constructor" || !vt) && ($e = true), ke += "." + Xe, Ee = "%" + ke + "%", G(D, Ee))
        Oe = D[Ee];
      else if (Oe != null) {
        if (!(Xe in Oe)) {
          if (!ye)
            throw new l("base intrinsic for " + _e + " exists, but the property is not available.");
          return;
        }
        if (E && xt + 1 >= Ae.length) {
          var Rt = E(Oe, Xe);
          vt = !!Rt, vt && "get" in Rt && !("originalValue" in Rt.get) ? Oe = Rt.get : Oe = Oe[Xe];
        } else
          vt = G(Oe, Xe), Oe = Oe[Xe];
        vt && !$e && (D[Ee] = Oe);
      }
    }
    return Oe;
  }, getIntrinsic$1;
}
var callBound$1, hasRequiredCallBound$1;
function requireCallBound$1() {
  if (hasRequiredCallBound$1) return callBound$1;
  hasRequiredCallBound$1 = 1;
  var i2 = /* @__PURE__ */ requireGetIntrinsic$1(), e = requireCallBindApplyHelpers$1(), t = e([i2("%String.prototype.indexOf%")]);
  return callBound$1 = function(a, s) {
    var u = (
      /** @type {Parameters<typeof callBindBasic>[0][0]} */
      i2(a, !!s)
    );
    return typeof u == "function" && t(a, ".prototype.") > -1 ? e([u]) : u;
  }, callBound$1;
}
var sideChannelMap$1, hasRequiredSideChannelMap$1;
function requireSideChannelMap$1() {
  if (hasRequiredSideChannelMap$1) return sideChannelMap$1;
  hasRequiredSideChannelMap$1 = 1;
  var i2 = /* @__PURE__ */ requireGetIntrinsic$1(), e = /* @__PURE__ */ requireCallBound$1(), t = /* @__PURE__ */ requireObjectInspect$1(), r = /* @__PURE__ */ requireType$1(), a = i2("%Map%", true), s = e("Map.prototype.get", true), u = e("Map.prototype.set", true), l = e("Map.prototype.has", true), c = e("Map.prototype.delete", true), d = e("Map.prototype.size", true);
  return sideChannelMap$1 = !!a && /** @type {Exclude<import('.'), false>} */
  function() {
    var p, m = {
      assert: function(y) {
        if (!m.has(y))
          throw new r("Side channel does not contain " + t(y));
      },
      delete: function(y) {
        if (p) {
          var x = c(p, y);
          return d(p) === 0 && (p = void 0), x;
        }
        return false;
      },
      get: function(y) {
        if (p)
          return s(p, y);
      },
      has: function(y) {
        return p ? l(p, y) : false;
      },
      set: function(y, x) {
        p || (p = new a()), u(p, y, x);
      }
    };
    return m;
  }, sideChannelMap$1;
}
var sideChannelWeakmap$1, hasRequiredSideChannelWeakmap$1;
function requireSideChannelWeakmap$1() {
  if (hasRequiredSideChannelWeakmap$1) return sideChannelWeakmap$1;
  hasRequiredSideChannelWeakmap$1 = 1;
  var i2 = /* @__PURE__ */ requireGetIntrinsic$1(), e = /* @__PURE__ */ requireCallBound$1(), t = /* @__PURE__ */ requireObjectInspect$1(), r = requireSideChannelMap$1(), a = /* @__PURE__ */ requireType$1(), s = i2("%WeakMap%", true), u = e("WeakMap.prototype.get", true), l = e("WeakMap.prototype.set", true), c = e("WeakMap.prototype.has", true), d = e("WeakMap.prototype.delete", true);
  return sideChannelWeakmap$1 = s ? (
    /** @type {Exclude<import('.'), false>} */
    function() {
      var p, m, y = {
        assert: function(x) {
          if (!y.has(x))
            throw new a("Side channel does not contain " + t(x));
        },
        delete: function(x) {
          if (s && x && (typeof x == "object" || typeof x == "function")) {
            if (p)
              return d(p, x);
          } else if (r && m)
            return m.delete(x);
          return false;
        },
        get: function(x) {
          return s && x && (typeof x == "object" || typeof x == "function") && p ? u(p, x) : m && m.get(x);
        },
        has: function(x) {
          return s && x && (typeof x == "object" || typeof x == "function") && p ? c(p, x) : !!m && m.has(x);
        },
        set: function(x, g) {
          s && x && (typeof x == "object" || typeof x == "function") ? (p || (p = new s()), l(p, x, g)) : r && (m || (m = r()), m.set(x, g));
        }
      };
      return y;
    }
  ) : r, sideChannelWeakmap$1;
}
var sideChannel$1, hasRequiredSideChannel$1;
function requireSideChannel$1() {
  if (hasRequiredSideChannel$1) return sideChannel$1;
  hasRequiredSideChannel$1 = 1;
  var i2 = /* @__PURE__ */ requireType$1(), e = /* @__PURE__ */ requireObjectInspect$1(), t = requireSideChannelList$1(), r = requireSideChannelMap$1(), a = requireSideChannelWeakmap$1(), s = a || r || t;
  return sideChannel$1 = function() {
    var l, c = {
      assert: function(d) {
        if (!c.has(d))
          throw new i2("Side channel does not contain " + e(d));
      },
      delete: function(d) {
        return !!l && l.delete(d);
      },
      get: function(d) {
        return l && l.get(d);
      },
      has: function(d) {
        return !!l && l.has(d);
      },
      set: function(d, f) {
        l || (l = s()), l.set(d, f);
      }
    };
    return c;
  }, sideChannel$1;
}
var formats$1, hasRequiredFormats$1;
function requireFormats$1() {
  if (hasRequiredFormats$1) return formats$1;
  hasRequiredFormats$1 = 1;
  var i2 = String.prototype.replace, e = /%20/g, t = {
    RFC1738: "RFC1738",
    RFC3986: "RFC3986"
  };
  return formats$1 = {
    default: t.RFC3986,
    formatters: {
      RFC1738: function(r) {
        return i2.call(r, e, "+");
      },
      RFC3986: function(r) {
        return String(r);
      }
    },
    RFC1738: t.RFC1738,
    RFC3986: t.RFC3986
  }, formats$1;
}
var utils$4, hasRequiredUtils$4;
function requireUtils$4() {
  if (hasRequiredUtils$4) return utils$4;
  hasRequiredUtils$4 = 1;
  var i2 = /* @__PURE__ */ requireFormats$1(), e = Object.prototype.hasOwnProperty, t = Array.isArray, r = function() {
    for (var _ = [], T = 0; T < 256; ++T)
      _.push("%" + ((T < 16 ? "0" : "") + T.toString(16)).toUpperCase());
    return _;
  }(), a = function(T) {
    for (; T.length > 1; ) {
      var E = T.pop(), b = E.obj[E.prop];
      if (t(b)) {
        for (var C = [], w = 0; w < b.length; ++w)
          typeof b[w] < "u" && C.push(b[w]);
        E.obj[E.prop] = C;
      }
    }
  }, s = function(T, E) {
    for (var b = E && E.plainObjects ? { __proto__: null } : {}, C = 0; C < T.length; ++C)
      typeof T[C] < "u" && (b[C] = T[C]);
    return b;
  }, u = function _(T, E, b) {
    if (!E)
      return T;
    if (typeof E != "object" && typeof E != "function") {
      if (t(T))
        T.push(E);
      else if (T && typeof T == "object")
        (b && (b.plainObjects || b.allowPrototypes) || !e.call(Object.prototype, E)) && (T[E] = true);
      else
        return [T, E];
      return T;
    }
    if (!T || typeof T != "object")
      return [T].concat(E);
    var C = T;
    return t(T) && !t(E) && (C = s(T, b)), t(T) && t(E) ? (E.forEach(function(w, A) {
      if (e.call(T, A)) {
        var S = T[A];
        S && typeof S == "object" && w && typeof w == "object" ? T[A] = _(S, w, b) : T.push(w);
      } else
        T[A] = w;
    }), T) : Object.keys(E).reduce(function(w, A) {
      var S = E[A];
      return e.call(w, A) ? w[A] = _(w[A], S, b) : w[A] = S, w;
    }, C);
  }, l = function(T, E) {
    return Object.keys(E).reduce(function(b, C) {
      return b[C] = E[C], b;
    }, T);
  }, c = function(_, T, E) {
    var b = _.replace(/\+/g, " ");
    if (E === "iso-8859-1")
      return b.replace(/%[0-9a-f]{2}/gi, unescape);
    try {
      return decodeURIComponent(b);
    } catch {
      return b;
    }
  }, d = 1024, f = function(T, E, b, C, w) {
    if (T.length === 0)
      return T;
    var A = T;
    if (typeof T == "symbol" ? A = Symbol.prototype.toString.call(T) : typeof T != "string" && (A = String(T)), b === "iso-8859-1")
      return escape(A).replace(/%u[0-9a-f]{4}/gi, function(z) {
        return "%26%23" + parseInt(z.slice(2), 16) + "%3B";
      });
    for (var S = "", F = 0; F < A.length; F += d) {
      for (var M = A.length >= d ? A.slice(F, F + d) : A, U = [], B = 0; B < M.length; ++B) {
        var q = M.charCodeAt(B);
        if (q === 45 || q === 46 || q === 95 || q === 126 || q >= 48 && q <= 57 || q >= 65 && q <= 90 || q >= 97 && q <= 122 || w === i2.RFC1738 && (q === 40 || q === 41)) {
          U[U.length] = M.charAt(B);
          continue;
        }
        if (q < 128) {
          U[U.length] = r[q];
          continue;
        }
        if (q < 2048) {
          U[U.length] = r[192 | q >> 6] + r[128 | q & 63];
          continue;
        }
        if (q < 55296 || q >= 57344) {
          U[U.length] = r[224 | q >> 12] + r[128 | q >> 6 & 63] + r[128 | q & 63];
          continue;
        }
        B += 1, q = 65536 + ((q & 1023) << 10 | M.charCodeAt(B) & 1023), U[U.length] = r[240 | q >> 18] + r[128 | q >> 12 & 63] + r[128 | q >> 6 & 63] + r[128 | q & 63];
      }
      S += U.join("");
    }
    return S;
  }, p = function(T) {
    for (var E = [{ obj: { o: T }, prop: "o" }], b = [], C = 0; C < E.length; ++C)
      for (var w = E[C], A = w.obj[w.prop], S = Object.keys(A), F = 0; F < S.length; ++F) {
        var M = S[F], U = A[M];
        typeof U == "object" && U !== null && b.indexOf(U) === -1 && (E.push({ obj: A, prop: M }), b.push(U));
      }
    return a(E), T;
  }, m = function(T) {
    return Object.prototype.toString.call(T) === "[object RegExp]";
  }, y = function(T) {
    return !T || typeof T != "object" ? false : !!(T.constructor && T.constructor.isBuffer && T.constructor.isBuffer(T));
  }, x = function(T, E) {
    return [].concat(T, E);
  }, g = function(T, E) {
    if (t(T)) {
      for (var b = [], C = 0; C < T.length; C += 1)
        b.push(E(T[C]));
      return b;
    }
    return E(T);
  };
  return utils$4 = {
    arrayToObject: s,
    assign: l,
    combine: x,
    compact: p,
    decode: c,
    encode: f,
    isBuffer: y,
    isRegExp: m,
    maybeMap: g,
    merge: u
  }, utils$4;
}
var stringify_1$1, hasRequiredStringify$1;
function requireStringify$1() {
  if (hasRequiredStringify$1) return stringify_1$1;
  hasRequiredStringify$1 = 1;
  var i2 = requireSideChannel$1(), e = /* @__PURE__ */ requireUtils$4(), t = /* @__PURE__ */ requireFormats$1(), r = Object.prototype.hasOwnProperty, a = {
    brackets: function(_) {
      return _ + "[]";
    },
    comma: "comma",
    indices: function(_, T) {
      return _ + "[" + T + "]";
    },
    repeat: function(_) {
      return _;
    }
  }, s = Array.isArray, u = Array.prototype.push, l = function(g, _) {
    u.apply(g, s(_) ? _ : [_]);
  }, c = Date.prototype.toISOString, d = t.default, f = {
    addQueryPrefix: false,
    allowDots: false,
    allowEmptyArrays: false,
    arrayFormat: "indices",
    charset: "utf-8",
    charsetSentinel: false,
    commaRoundTrip: false,
    delimiter: "&",
    encode: true,
    encodeDotInKeys: false,
    encoder: e.encode,
    encodeValuesOnly: false,
    filter: void 0,
    format: d,
    formatter: t.formatters[d],
    // deprecated
    indices: false,
    serializeDate: function(_) {
      return c.call(_);
    },
    skipNulls: false,
    strictNullHandling: false
  }, p = function(_) {
    return typeof _ == "string" || typeof _ == "number" || typeof _ == "boolean" || typeof _ == "symbol" || typeof _ == "bigint";
  }, m = {}, y = function g(_, T, E, b, C, w, A, S, F, M, U, B, q, z, D, X, k, I) {
    for (var P = _, G = I, W = 0, V = false; (G = G.get(m)) !== void 0 && !V; ) {
      var K = G.get(_);
      if (W += 1, typeof K < "u") {
        if (K === W)
          throw new RangeError("Cyclic object value");
        V = true;
      }
      typeof G.get(m) > "u" && (W = 0);
    }
    if (typeof M == "function" ? P = M(T, P) : P instanceof Date ? P = q(P) : E === "comma" && s(P) && (P = e.maybeMap(P, function(Ee) {
      return Ee instanceof Date ? q(Ee) : Ee;
    })), P === null) {
      if (w)
        return F && !X ? F(T, f.encoder, k, "key", z) : T;
      P = "";
    }
    if (p(P) || e.isBuffer(P)) {
      if (F) {
        var J = X ? T : F(T, f.encoder, k, "key", z);
        return [D(J) + "=" + D(F(P, f.encoder, k, "value", z))];
      }
      return [D(T) + "=" + D(String(P))];
    }
    var ae = [];
    if (typeof P > "u")
      return ae;
    var re;
    if (E === "comma" && s(P))
      X && F && (P = e.maybeMap(P, F)), re = [{ value: P.length > 0 ? P.join(",") || null : void 0 }];
    else if (s(M))
      re = M;
    else {
      var he = Object.keys(P);
      re = U ? he.sort(U) : he;
    }
    var ge = S ? String(T).replace(/\./g, "%2E") : String(T), me = b && s(P) && P.length === 1 ? ge + "[]" : ge;
    if (C && s(P) && P.length === 0)
      return me + "[]";
    for (var Te = 0; Te < re.length; ++Te) {
      var _e = re[Te], ye = typeof _e == "object" && _e && typeof _e.value < "u" ? _e.value : P[_e];
      if (!(A && ye === null)) {
        var Ae = B && S ? String(_e).replace(/\./g, "%2E") : String(_e), ke = s(P) ? typeof E == "function" ? E(me, Ae) : me : me + (B ? "." + Ae : "[" + Ae + "]");
        I.set(_, W);
        var Pe = i2();
        Pe.set(m, I), l(ae, g(
          ye,
          ke,
          E,
          b,
          C,
          w,
          A,
          S,
          E === "comma" && X && s(P) ? null : F,
          M,
          U,
          B,
          q,
          z,
          D,
          X,
          k,
          Pe
        ));
      }
    }
    return ae;
  }, x = function(_) {
    if (!_)
      return f;
    if (typeof _.allowEmptyArrays < "u" && typeof _.allowEmptyArrays != "boolean")
      throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
    if (typeof _.encodeDotInKeys < "u" && typeof _.encodeDotInKeys != "boolean")
      throw new TypeError("`encodeDotInKeys` option can only be `true` or `false`, when provided");
    if (_.encoder !== null && typeof _.encoder < "u" && typeof _.encoder != "function")
      throw new TypeError("Encoder has to be a function.");
    var T = _.charset || f.charset;
    if (typeof _.charset < "u" && _.charset !== "utf-8" && _.charset !== "iso-8859-1")
      throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
    var E = t.default;
    if (typeof _.format < "u") {
      if (!r.call(t.formatters, _.format))
        throw new TypeError("Unknown format option provided.");
      E = _.format;
    }
    var b = t.formatters[E], C = f.filter;
    (typeof _.filter == "function" || s(_.filter)) && (C = _.filter);
    var w;
    if (_.arrayFormat in a ? w = _.arrayFormat : "indices" in _ ? w = _.indices ? "indices" : "repeat" : w = f.arrayFormat, "commaRoundTrip" in _ && typeof _.commaRoundTrip != "boolean")
      throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
    var A = typeof _.allowDots > "u" ? _.encodeDotInKeys === true ? true : f.allowDots : !!_.allowDots;
    return {
      addQueryPrefix: typeof _.addQueryPrefix == "boolean" ? _.addQueryPrefix : f.addQueryPrefix,
      allowDots: A,
      allowEmptyArrays: typeof _.allowEmptyArrays == "boolean" ? !!_.allowEmptyArrays : f.allowEmptyArrays,
      arrayFormat: w,
      charset: T,
      charsetSentinel: typeof _.charsetSentinel == "boolean" ? _.charsetSentinel : f.charsetSentinel,
      commaRoundTrip: !!_.commaRoundTrip,
      delimiter: typeof _.delimiter > "u" ? f.delimiter : _.delimiter,
      encode: typeof _.encode == "boolean" ? _.encode : f.encode,
      encodeDotInKeys: typeof _.encodeDotInKeys == "boolean" ? _.encodeDotInKeys : f.encodeDotInKeys,
      encoder: typeof _.encoder == "function" ? _.encoder : f.encoder,
      encodeValuesOnly: typeof _.encodeValuesOnly == "boolean" ? _.encodeValuesOnly : f.encodeValuesOnly,
      filter: C,
      format: E,
      formatter: b,
      serializeDate: typeof _.serializeDate == "function" ? _.serializeDate : f.serializeDate,
      skipNulls: typeof _.skipNulls == "boolean" ? _.skipNulls : f.skipNulls,
      sort: typeof _.sort == "function" ? _.sort : null,
      strictNullHandling: typeof _.strictNullHandling == "boolean" ? _.strictNullHandling : f.strictNullHandling
    };
  };
  return stringify_1$1 = function(g, _) {
    var T = g, E = x(_), b, C;
    typeof E.filter == "function" ? (C = E.filter, T = C("", T)) : s(E.filter) && (C = E.filter, b = C);
    var w = [];
    if (typeof T != "object" || T === null)
      return "";
    var A = a[E.arrayFormat], S = A === "comma" && E.commaRoundTrip;
    b || (b = Object.keys(T)), E.sort && b.sort(E.sort);
    for (var F = i2(), M = 0; M < b.length; ++M) {
      var U = b[M], B = T[U];
      E.skipNulls && B === null || l(w, y(
        B,
        U,
        A,
        S,
        E.allowEmptyArrays,
        E.strictNullHandling,
        E.skipNulls,
        E.encodeDotInKeys,
        E.encode ? E.encoder : null,
        E.filter,
        E.sort,
        E.allowDots,
        E.serializeDate,
        E.format,
        E.formatter,
        E.encodeValuesOnly,
        E.charset,
        F
      ));
    }
    var q = w.join(E.delimiter), z = E.addQueryPrefix === true ? "?" : "";
    return E.charsetSentinel && (E.charset === "iso-8859-1" ? z += "utf8=%26%2310003%3B&" : z += "utf8=%E2%9C%93&"), q.length > 0 ? z + q : "";
  }, stringify_1$1;
}
var parse$1, hasRequiredParse$1;
function requireParse$1() {
  if (hasRequiredParse$1) return parse$1;
  hasRequiredParse$1 = 1;
  var i2 = /* @__PURE__ */ requireUtils$4(), e = Object.prototype.hasOwnProperty, t = Array.isArray, r = {
    allowDots: false,
    allowEmptyArrays: false,
    allowPrototypes: false,
    allowSparse: false,
    arrayLimit: 20,
    charset: "utf-8",
    charsetSentinel: false,
    comma: false,
    decodeDotInKeys: false,
    decoder: i2.decode,
    delimiter: "&",
    depth: 5,
    duplicates: "combine",
    ignoreQueryPrefix: false,
    interpretNumericEntities: false,
    parameterLimit: 1e3,
    parseArrays: true,
    plainObjects: false,
    strictDepth: false,
    strictNullHandling: false,
    throwOnLimitExceeded: false
  }, a = function(m) {
    return m.replace(/&#(\d+);/g, function(y, x) {
      return String.fromCharCode(parseInt(x, 10));
    });
  }, s = function(m, y, x) {
    if (m && typeof m == "string" && y.comma && m.indexOf(",") > -1)
      return m.split(",");
    if (y.throwOnLimitExceeded && x >= y.arrayLimit)
      throw new RangeError("Array limit exceeded. Only " + y.arrayLimit + " element" + (y.arrayLimit === 1 ? "" : "s") + " allowed in an array.");
    return m;
  }, u = "utf8=%26%2310003%3B", l = "utf8=%E2%9C%93", c = function(y, x) {
    var g = { __proto__: null }, _ = x.ignoreQueryPrefix ? y.replace(/^\?/, "") : y;
    _ = _.replace(/%5B/gi, "[").replace(/%5D/gi, "]");
    var T = x.parameterLimit === 1 / 0 ? void 0 : x.parameterLimit, E = _.split(
      x.delimiter,
      x.throwOnLimitExceeded ? T + 1 : T
    );
    if (x.throwOnLimitExceeded && E.length > T)
      throw new RangeError("Parameter limit exceeded. Only " + T + " parameter" + (T === 1 ? "" : "s") + " allowed.");
    var b = -1, C, w = x.charset;
    if (x.charsetSentinel)
      for (C = 0; C < E.length; ++C)
        E[C].indexOf("utf8=") === 0 && (E[C] === l ? w = "utf-8" : E[C] === u && (w = "iso-8859-1"), b = C, C = E.length);
    for (C = 0; C < E.length; ++C)
      if (C !== b) {
        var A = E[C], S = A.indexOf("]="), F = S === -1 ? A.indexOf("=") : S + 1, M, U;
        F === -1 ? (M = x.decoder(A, r.decoder, w, "key"), U = x.strictNullHandling ? null : "") : (M = x.decoder(A.slice(0, F), r.decoder, w, "key"), U = i2.maybeMap(
          s(
            A.slice(F + 1),
            x,
            t(g[M]) ? g[M].length : 0
          ),
          function(q) {
            return x.decoder(q, r.decoder, w, "value");
          }
        )), U && x.interpretNumericEntities && w === "iso-8859-1" && (U = a(String(U))), A.indexOf("[]=") > -1 && (U = t(U) ? [U] : U);
        var B = e.call(g, M);
        B && x.duplicates === "combine" ? g[M] = i2.combine(g[M], U) : (!B || x.duplicates === "last") && (g[M] = U);
      }
    return g;
  }, d = function(m, y, x, g) {
    var _ = 0;
    if (m.length > 0 && m[m.length - 1] === "[]") {
      var T = m.slice(0, -1).join("");
      _ = Array.isArray(y) && y[T] ? y[T].length : 0;
    }
    for (var E = g ? y : s(y, x, _), b = m.length - 1; b >= 0; --b) {
      var C, w = m[b];
      if (w === "[]" && x.parseArrays)
        C = x.allowEmptyArrays && (E === "" || x.strictNullHandling && E === null) ? [] : i2.combine([], E);
      else {
        C = x.plainObjects ? { __proto__: null } : {};
        var A = w.charAt(0) === "[" && w.charAt(w.length - 1) === "]" ? w.slice(1, -1) : w, S = x.decodeDotInKeys ? A.replace(/%2E/g, ".") : A, F = parseInt(S, 10);
        !x.parseArrays && S === "" ? C = { 0: E } : !isNaN(F) && w !== S && String(F) === S && F >= 0 && x.parseArrays && F <= x.arrayLimit ? (C = [], C[F] = E) : S !== "__proto__" && (C[S] = E);
      }
      E = C;
    }
    return E;
  }, f = function(y, x, g, _) {
    if (y) {
      var T = g.allowDots ? y.replace(/\.([^.[]+)/g, "[$1]") : y, E = /(\[[^[\]]*])/, b = /(\[[^[\]]*])/g, C = g.depth > 0 && E.exec(T), w = C ? T.slice(0, C.index) : T, A = [];
      if (w) {
        if (!g.plainObjects && e.call(Object.prototype, w) && !g.allowPrototypes)
          return;
        A.push(w);
      }
      for (var S = 0; g.depth > 0 && (C = b.exec(T)) !== null && S < g.depth; ) {
        if (S += 1, !g.plainObjects && e.call(Object.prototype, C[1].slice(1, -1)) && !g.allowPrototypes)
          return;
        A.push(C[1]);
      }
      if (C) {
        if (g.strictDepth === true)
          throw new RangeError("Input depth exceeded depth option of " + g.depth + " and strictDepth is true");
        A.push("[" + T.slice(C.index) + "]");
      }
      return d(A, x, g, _);
    }
  }, p = function(y) {
    if (!y)
      return r;
    if (typeof y.allowEmptyArrays < "u" && typeof y.allowEmptyArrays != "boolean")
      throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
    if (typeof y.decodeDotInKeys < "u" && typeof y.decodeDotInKeys != "boolean")
      throw new TypeError("`decodeDotInKeys` option can only be `true` or `false`, when provided");
    if (y.decoder !== null && typeof y.decoder < "u" && typeof y.decoder != "function")
      throw new TypeError("Decoder has to be a function.");
    if (typeof y.charset < "u" && y.charset !== "utf-8" && y.charset !== "iso-8859-1")
      throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
    if (typeof y.throwOnLimitExceeded < "u" && typeof y.throwOnLimitExceeded != "boolean")
      throw new TypeError("`throwOnLimitExceeded` option must be a boolean");
    var x = typeof y.charset > "u" ? r.charset : y.charset, g = typeof y.duplicates > "u" ? r.duplicates : y.duplicates;
    if (g !== "combine" && g !== "first" && g !== "last")
      throw new TypeError("The duplicates option must be either combine, first, or last");
    var _ = typeof y.allowDots > "u" ? y.decodeDotInKeys === true ? true : r.allowDots : !!y.allowDots;
    return {
      allowDots: _,
      allowEmptyArrays: typeof y.allowEmptyArrays == "boolean" ? !!y.allowEmptyArrays : r.allowEmptyArrays,
      allowPrototypes: typeof y.allowPrototypes == "boolean" ? y.allowPrototypes : r.allowPrototypes,
      allowSparse: typeof y.allowSparse == "boolean" ? y.allowSparse : r.allowSparse,
      arrayLimit: typeof y.arrayLimit == "number" ? y.arrayLimit : r.arrayLimit,
      charset: x,
      charsetSentinel: typeof y.charsetSentinel == "boolean" ? y.charsetSentinel : r.charsetSentinel,
      comma: typeof y.comma == "boolean" ? y.comma : r.comma,
      decodeDotInKeys: typeof y.decodeDotInKeys == "boolean" ? y.decodeDotInKeys : r.decodeDotInKeys,
      decoder: typeof y.decoder == "function" ? y.decoder : r.decoder,
      delimiter: typeof y.delimiter == "string" || i2.isRegExp(y.delimiter) ? y.delimiter : r.delimiter,
      // eslint-disable-next-line no-implicit-coercion, no-extra-parens
      depth: typeof y.depth == "number" || y.depth === false ? +y.depth : r.depth,
      duplicates: g,
      ignoreQueryPrefix: y.ignoreQueryPrefix === true,
      interpretNumericEntities: typeof y.interpretNumericEntities == "boolean" ? y.interpretNumericEntities : r.interpretNumericEntities,
      parameterLimit: typeof y.parameterLimit == "number" ? y.parameterLimit : r.parameterLimit,
      parseArrays: y.parseArrays !== false,
      plainObjects: typeof y.plainObjects == "boolean" ? y.plainObjects : r.plainObjects,
      strictDepth: typeof y.strictDepth == "boolean" ? !!y.strictDepth : r.strictDepth,
      strictNullHandling: typeof y.strictNullHandling == "boolean" ? y.strictNullHandling : r.strictNullHandling,
      throwOnLimitExceeded: typeof y.throwOnLimitExceeded == "boolean" ? y.throwOnLimitExceeded : false
    };
  };
  return parse$1 = function(m, y) {
    var x = p(y);
    if (m === "" || m === null || typeof m > "u")
      return x.plainObjects ? { __proto__: null } : {};
    for (var g = typeof m == "string" ? c(m, x) : m, _ = x.plainObjects ? { __proto__: null } : {}, T = Object.keys(g), E = 0; E < T.length; ++E) {
      var b = T[E], C = f(b, g[b], x, typeof m == "string");
      _ = i2.merge(_, C, x);
    }
    return x.allowSparse === true ? _ : i2.compact(_);
  }, parse$1;
}
var lib$6, hasRequiredLib$6;
function requireLib$6() {
  if (hasRequiredLib$6) return lib$6;
  hasRequiredLib$6 = 1;
  var i2 = /* @__PURE__ */ requireStringify$1(), e = /* @__PURE__ */ requireParse$1(), t = /* @__PURE__ */ requireFormats$1();
  return lib$6 = {
    formats: t,
    parse: e,
    stringify: i2
  }, lib$6;
}
var hasRequiredUrl$1;
function requireUrl$1() {
  if (hasRequiredUrl$1) return url$2;
  hasRequiredUrl$1 = 1;
  var i2 = requirePunycode$1();
  function e() {
    this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null;
  }
  var t = /^([a-z0-9.+-]+:)/i, r = /:[0-9]*$/, a = /^(\/\/?(?!\/)[^?\s]*)(\?[^\s]*)?$/, s = [
    "<",
    ">",
    '"',
    "`",
    " ",
    "\r",
    `
`,
    "	"
  ], u = [
    "{",
    "}",
    "|",
    "\\",
    "^",
    "`"
  ].concat(s), l = ["'"].concat(u), c = [
    "%",
    "/",
    "?",
    ";",
    "#"
  ].concat(l), d = [
    "/",
    "?",
    "#"
  ], f = 255, p = /^[+a-z0-9A-Z_-]{0,63}$/, m = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, y = {
    javascript: true,
    "javascript:": true
  }, x = {
    javascript: true,
    "javascript:": true
  }, g = {
    http: true,
    https: true,
    ftp: true,
    gopher: true,
    file: true,
    "http:": true,
    "https:": true,
    "ftp:": true,
    "gopher:": true,
    "file:": true
  }, _ = /* @__PURE__ */ requireLib$6();
  function T(w, A, S) {
    if (w && typeof w == "object" && w instanceof e)
      return w;
    var F = new e();
    return F.parse(w, A, S), F;
  }
  e.prototype.parse = function(w, A, S) {
    if (typeof w != "string")
      throw new TypeError("Parameter 'url' must be a string, not " + typeof w);
    var F = w.indexOf("?"), M = F !== -1 && F < w.indexOf("#") ? "?" : "#", U = w.split(M), B = /\\/g;
    U[0] = U[0].replace(B, "/"), w = U.join(M);
    var q = w;
    if (q = q.trim(), !S && w.split("#").length === 1) {
      var z = a.exec(q);
      if (z)
        return this.path = q, this.href = q, this.pathname = z[1], z[2] ? (this.search = z[2], A ? this.query = _.parse(this.search.substr(1)) : this.query = this.search.substr(1)) : A && (this.search = "", this.query = {}), this;
    }
    var D = t.exec(q);
    if (D) {
      D = D[0];
      var X = D.toLowerCase();
      this.protocol = X, q = q.substr(D.length);
    }
    if (S || D || q.match(/^\/\/[^@/]+@[^@/]+/)) {
      var k = q.substr(0, 2) === "//";
      k && !(D && x[D]) && (q = q.substr(2), this.slashes = true);
    }
    if (!x[D] && (k || D && !g[D])) {
      for (var I = -1, P = 0; P < d.length; P++) {
        var G = q.indexOf(d[P]);
        G !== -1 && (I === -1 || G < I) && (I = G);
      }
      var W, V;
      I === -1 ? V = q.lastIndexOf("@") : V = q.lastIndexOf("@", I), V !== -1 && (W = q.slice(0, V), q = q.slice(V + 1), this.auth = decodeURIComponent(W)), I = -1;
      for (var P = 0; P < c.length; P++) {
        var G = q.indexOf(c[P]);
        G !== -1 && (I === -1 || G < I) && (I = G);
      }
      I === -1 && (I = q.length), this.host = q.slice(0, I), q = q.slice(I), this.parseHost(), this.hostname = this.hostname || "";
      var K = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
      if (!K)
        for (var J = this.hostname.split(/\./), P = 0, ae = J.length; P < ae; P++) {
          var re = J[P];
          if (re && !re.match(p)) {
            for (var he = "", ge = 0, me = re.length; ge < me; ge++)
              re.charCodeAt(ge) > 127 ? he += "x" : he += re[ge];
            if (!he.match(p)) {
              var Te = J.slice(0, P), _e = J.slice(P + 1), ye = re.match(m);
              ye && (Te.push(ye[1]), _e.unshift(ye[2])), _e.length && (q = "/" + _e.join(".") + q), this.hostname = Te.join(".");
              break;
            }
          }
        }
      this.hostname.length > f ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(), K || (this.hostname = i2.toASCII(this.hostname));
      var Ae = this.port ? ":" + this.port : "", ke = this.hostname || "";
      this.host = ke + Ae, this.href += this.host, K && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), q[0] !== "/" && (q = "/" + q));
    }
    if (!y[X])
      for (var P = 0, ae = l.length; P < ae; P++) {
        var Pe = l[P];
        if (q.indexOf(Pe) !== -1) {
          var Ee = encodeURIComponent(Pe);
          Ee === Pe && (Ee = escape(Pe)), q = q.split(Pe).join(Ee);
        }
      }
    var Oe = q.indexOf("#");
    Oe !== -1 && (this.hash = q.substr(Oe), q = q.slice(0, Oe));
    var $e = q.indexOf("?");
    if ($e !== -1 ? (this.search = q.substr($e), this.query = q.substr($e + 1), A && (this.query = _.parse(this.query)), q = q.slice(0, $e)) : A && (this.search = "", this.query = {}), q && (this.pathname = q), g[X] && this.hostname && !this.pathname && (this.pathname = "/"), this.pathname || this.search) {
      var Ae = this.pathname || "", gt = this.search || "";
      this.path = Ae + gt;
    }
    return this.href = this.format(), this;
  };
  function E(w) {
    return typeof w == "string" && (w = T(w)), w instanceof e ? w.format() : e.prototype.format.call(w);
  }
  e.prototype.format = function() {
    var w = this.auth || "";
    w && (w = encodeURIComponent(w), w = w.replace(/%3A/i, ":"), w += "@");
    var A = this.protocol || "", S = this.pathname || "", F = this.hash || "", M = false, U = "";
    this.host ? M = w + this.host : this.hostname && (M = w + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]"), this.port && (M += ":" + this.port)), this.query && typeof this.query == "object" && Object.keys(this.query).length && (U = _.stringify(this.query, {
      arrayFormat: "repeat",
      addQueryPrefix: false
    }));
    var B = this.search || U && "?" + U || "";
    return A && A.substr(-1) !== ":" && (A += ":"), this.slashes || (!A || g[A]) && M !== false ? (M = "//" + (M || ""), S && S.charAt(0) !== "/" && (S = "/" + S)) : M || (M = ""), F && F.charAt(0) !== "#" && (F = "#" + F), B && B.charAt(0) !== "?" && (B = "?" + B), S = S.replace(/[?#]/g, function(q) {
      return encodeURIComponent(q);
    }), B = B.replace("#", "%23"), A + M + S + B + F;
  };
  function b(w, A) {
    return T(w, false, true).resolve(A);
  }
  e.prototype.resolve = function(w) {
    return this.resolveObject(T(w, false, true)).format();
  };
  function C(w, A) {
    return w ? T(w, false, true).resolveObject(A) : A;
  }
  return e.prototype.resolveObject = function(w) {
    if (typeof w == "string") {
      var A = new e();
      A.parse(w, false, true), w = A;
    }
    for (var S = new e(), F = Object.keys(this), M = 0; M < F.length; M++) {
      var U = F[M];
      S[U] = this[U];
    }
    if (S.hash = w.hash, w.href === "")
      return S.href = S.format(), S;
    if (w.slashes && !w.protocol) {
      for (var B = Object.keys(w), q = 0; q < B.length; q++) {
        var z = B[q];
        z !== "protocol" && (S[z] = w[z]);
      }
      return g[S.protocol] && S.hostname && !S.pathname && (S.pathname = "/", S.path = S.pathname), S.href = S.format(), S;
    }
    if (w.protocol && w.protocol !== S.protocol) {
      if (!g[w.protocol]) {
        for (var D = Object.keys(w), X = 0; X < D.length; X++) {
          var k = D[X];
          S[k] = w[k];
        }
        return S.href = S.format(), S;
      }
      if (S.protocol = w.protocol, !w.host && !x[w.protocol]) {
        for (var ae = (w.pathname || "").split("/"); ae.length && !(w.host = ae.shift()); )
          ;
        w.host || (w.host = ""), w.hostname || (w.hostname = ""), ae[0] !== "" && ae.unshift(""), ae.length < 2 && ae.unshift(""), S.pathname = ae.join("/");
      } else
        S.pathname = w.pathname;
      if (S.search = w.search, S.query = w.query, S.host = w.host || "", S.auth = w.auth, S.hostname = w.hostname || w.host, S.port = w.port, S.pathname || S.search) {
        var I = S.pathname || "", P = S.search || "";
        S.path = I + P;
      }
      return S.slashes = S.slashes || w.slashes, S.href = S.format(), S;
    }
    var G = S.pathname && S.pathname.charAt(0) === "/", W = w.host || w.pathname && w.pathname.charAt(0) === "/", V = W || G || S.host && w.pathname, K = V, J = S.pathname && S.pathname.split("/") || [], ae = w.pathname && w.pathname.split("/") || [], re = S.protocol && !g[S.protocol];
    if (re && (S.hostname = "", S.port = null, S.host && (J[0] === "" ? J[0] = S.host : J.unshift(S.host)), S.host = "", w.protocol && (w.hostname = null, w.port = null, w.host && (ae[0] === "" ? ae[0] = w.host : ae.unshift(w.host)), w.host = null), V = V && (ae[0] === "" || J[0] === "")), W)
      S.host = w.host || w.host === "" ? w.host : S.host, S.hostname = w.hostname || w.hostname === "" ? w.hostname : S.hostname, S.search = w.search, S.query = w.query, J = ae;
    else if (ae.length)
      J || (J = []), J.pop(), J = J.concat(ae), S.search = w.search, S.query = w.query;
    else if (w.search != null) {
      if (re) {
        S.host = J.shift(), S.hostname = S.host;
        var he = S.host && S.host.indexOf("@") > 0 ? S.host.split("@") : false;
        he && (S.auth = he.shift(), S.hostname = he.shift(), S.host = S.hostname);
      }
      return S.search = w.search, S.query = w.query, (S.pathname !== null || S.search !== null) && (S.path = (S.pathname ? S.pathname : "") + (S.search ? S.search : "")), S.href = S.format(), S;
    }
    if (!J.length)
      return S.pathname = null, S.search ? S.path = "/" + S.search : S.path = null, S.href = S.format(), S;
    for (var ge = J.slice(-1)[0], me = (S.host || w.host || J.length > 1) && (ge === "." || ge === "..") || ge === "", Te = 0, _e = J.length; _e >= 0; _e--)
      ge = J[_e], ge === "." ? J.splice(_e, 1) : ge === ".." ? (J.splice(_e, 1), Te++) : Te && (J.splice(_e, 1), Te--);
    if (!V && !K)
      for (; Te--; Te)
        J.unshift("..");
    V && J[0] !== "" && (!J[0] || J[0].charAt(0) !== "/") && J.unshift(""), me && J.join("/").substr(-1) !== "/" && J.push("");
    var ye = J[0] === "" || J[0] && J[0].charAt(0) === "/";
    if (re) {
      S.hostname = ye ? "" : J.length ? J.shift() : "", S.host = S.hostname;
      var he = S.host && S.host.indexOf("@") > 0 ? S.host.split("@") : false;
      he && (S.auth = he.shift(), S.hostname = he.shift(), S.host = S.hostname);
    }
    return V = V || S.host && J.length, V && !ye && J.unshift(""), J.length > 0 ? S.pathname = J.join("/") : (S.pathname = null, S.path = null), (S.pathname !== null || S.search !== null) && (S.path = (S.pathname ? S.pathname : "") + (S.search ? S.search : "")), S.auth = w.auth || S.auth, S.slashes = S.slashes || w.slashes, S.href = S.format(), S;
  }, e.prototype.parseHost = function() {
    var w = this.host, A = r.exec(w);
    A && (A = A[0], A !== ":" && (this.port = A.substr(1)), w = w.substr(0, w.length - A.length)), w && (this.hostname = w);
  }, url$2.parse = T, url$2.resolve = b, url$2.resolveObject = C, url$2.format = E, url$2.Url = e, url$2;
}
var urlExports = requireUrl$1();
/*!
 * @pixi/utils - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/utils is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var url$1 = {
  parse: urlExports.parse,
  format: urlExports.format,
  resolve: urlExports.resolve
};
settings$1.RETINA_PREFIX = /@([0-9\.]+)x/;
settings$1.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT = false;
var saidHello = false, VERSION = "6.5.10";
function sayHello(i2) {
  var e;
  if (!saidHello) {
    if (settings$1.ADAPTER.getNavigator().userAgent.toLowerCase().indexOf("chrome") > -1) {
      var t = [
        `
 %c %c %c PixiJS ` + VERSION + " - ✰ " + i2 + ` ✰  %c  %c  http://www.pixijs.com/  %c %c ♥%c♥%c♥ 

`,
        "background: #ff66a5; padding:5px 0;",
        "background: #ff66a5; padding:5px 0;",
        "color: #ff66a5; background: #030307; padding:5px 0;",
        "background: #ff66a5; padding:5px 0;",
        "background: #ffc3dc; padding:5px 0;",
        "background: #ff66a5; padding:5px 0;",
        "color: #ff2424; background: #fff; padding:5px 0;",
        "color: #ff2424; background: #fff; padding:5px 0;",
        "color: #ff2424; background: #fff; padding:5px 0;"
      ];
      (e = globalThis.console).log.apply(e, t);
    } else globalThis.console && globalThis.console.log("PixiJS " + VERSION + " - " + i2 + " - http://www.pixijs.com/");
    saidHello = true;
  }
}
var supported;
function isWebGLSupported() {
  return typeof supported > "u" && (supported = function() {
    var e = {
      stencil: true,
      failIfMajorPerformanceCaveat: settings$1.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT
    };
    try {
      if (!settings$1.ADAPTER.getWebGLRenderingContext())
        return false;
      var t = settings$1.ADAPTER.createCanvas(), r = t.getContext("webgl", e) || t.getContext("experimental-webgl", e), a = !!(r && r.getContextAttributes().stencil);
      if (r) {
        var s = r.getExtension("WEBGL_lose_context");
        s && s.loseContext();
      }
      return r = null, a;
    } catch {
      return false;
    }
  }()), supported;
}
function hex2rgb(i2, e) {
  return e === void 0 && (e = []), e[0] = (i2 >> 16 & 255) / 255, e[1] = (i2 >> 8 & 255) / 255, e[2] = (i2 & 255) / 255, e;
}
function hex2string(i2) {
  var e = i2.toString(16);
  return e = "000000".substring(0, 6 - e.length) + e, "#" + e;
}
function mapPremultipliedBlendModes$1() {
  for (var i2 = [], e = [], t = 0; t < 32; t++)
    i2[t] = t, e[t] = t;
  i2[BLEND_MODES.NORMAL_NPM] = BLEND_MODES.NORMAL, i2[BLEND_MODES.ADD_NPM] = BLEND_MODES.ADD, i2[BLEND_MODES.SCREEN_NPM] = BLEND_MODES.SCREEN, e[BLEND_MODES.NORMAL] = BLEND_MODES.NORMAL_NPM, e[BLEND_MODES.ADD] = BLEND_MODES.ADD_NPM, e[BLEND_MODES.SCREEN] = BLEND_MODES.SCREEN_NPM;
  var r = [];
  return r.push(e), r.push(i2), r;
}
var premultiplyBlendMode = mapPremultipliedBlendModes$1();
function premultiplyTint(i2, e) {
  if (e === 1)
    return (e * 255 << 24) + i2;
  if (e === 0)
    return 0;
  var t = i2 >> 16 & 255, r = i2 >> 8 & 255, a = i2 & 255;
  return t = t * e + 0.5 | 0, r = r * e + 0.5 | 0, a = a * e + 0.5 | 0, (e * 255 << 24) + (t << 16) + (r << 8) + a;
}
function getBufferType(i2) {
  if (i2.BYTES_PER_ELEMENT === 4)
    return i2 instanceof Float32Array ? "Float32Array" : i2 instanceof Uint32Array ? "Uint32Array" : "Int32Array";
  if (i2.BYTES_PER_ELEMENT === 2) {
    if (i2 instanceof Uint16Array)
      return "Uint16Array";
  } else if (i2.BYTES_PER_ELEMENT === 1 && i2 instanceof Uint8Array)
    return "Uint8Array";
  return null;
}
function nextPow2(i2) {
  return i2 += i2 === 0 ? 1 : 0, --i2, i2 |= i2 >>> 1, i2 |= i2 >>> 2, i2 |= i2 >>> 4, i2 |= i2 >>> 8, i2 |= i2 >>> 16, i2 + 1;
}
function isPow2(i2) {
  return !(i2 & i2 - 1) && !!i2;
}
function log2(i2) {
  var e = (i2 > 65535 ? 1 : 0) << 4;
  i2 >>>= e;
  var t = (i2 > 255 ? 1 : 0) << 3;
  return i2 >>>= t, e |= t, t = (i2 > 15 ? 1 : 0) << 2, i2 >>>= t, e |= t, t = (i2 > 3 ? 1 : 0) << 1, i2 >>>= t, e |= t, e | i2 >> 1;
}
function removeItems(i2, e, t) {
  var r = i2.length, a;
  if (!(e >= r || t === 0)) {
    t = e + t > r ? r - e : t;
    var s = r - t;
    for (a = e; a < s; ++a)
      i2[a] = i2[a + t];
    i2.length = s;
  }
}
var nextUid = 0;
function uid$3() {
  return ++nextUid;
}
var warnings = {};
function deprecation(i2, e, t) {
  if (t === void 0 && (t = 3), !warnings[e]) {
    var r = new Error().stack;
    typeof r > "u" ? console.warn("PixiJS Deprecation Warning: ", e + `
Deprecated since v` + i2) : (r = r.split(`
`).splice(t).join(`
`), console.groupCollapsed ? (console.groupCollapsed("%cPixiJS Deprecation Warning: %c%s", "color:#614108;background:#fffbe6", "font-weight:normal;color:#614108;background:#fffbe6", e + `
Deprecated since v` + i2), console.warn(r), console.groupEnd()) : (console.warn("PixiJS Deprecation Warning: ", e + `
Deprecated since v` + i2), console.warn(r))), warnings[e] = true;
  }
}
var ProgramCache = {}, TextureCache = /* @__PURE__ */ Object.create(null), BaseTextureCache = /* @__PURE__ */ Object.create(null);
(function() {
  function i2(e, t, r) {
    this.canvas = settings$1.ADAPTER.createCanvas(), this.context = this.canvas.getContext("2d"), this.resolution = r || settings$1.RESOLUTION, this.resize(e, t);
  }
  return i2.prototype.clear = function() {
    this.context.setTransform(1, 0, 0, 1, 0, 0), this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
  }, i2.prototype.resize = function(e, t) {
    this.canvas.width = Math.round(e * this.resolution), this.canvas.height = Math.round(t * this.resolution);
  }, i2.prototype.destroy = function() {
    this.context = null, this.canvas = null;
  }, Object.defineProperty(i2.prototype, "width", {
    /**
     * The width of the canvas buffer in pixels.
     * @member {number}
     */
    get: function() {
      return this.canvas.width;
    },
    set: function(e) {
      this.canvas.width = Math.round(e);
    },
    enumerable: false,
    configurable: true
  }), Object.defineProperty(i2.prototype, "height", {
    /**
     * The height of the canvas buffer in pixels.
     * @member {number}
     */
    get: function() {
      return this.canvas.height;
    },
    set: function(e) {
      this.canvas.height = Math.round(e);
    },
    enumerable: false,
    configurable: true
  }), i2;
})();
var tempAnchor;
function determineCrossOrigin(i2, e) {
  if (e === void 0 && (e = globalThis.location), i2.indexOf("data:") === 0)
    return "";
  e = e || globalThis.location, tempAnchor || (tempAnchor = document.createElement("a")), tempAnchor.href = i2;
  var t = url$1.parse(tempAnchor.href), r = !t.port && e.port === "" || t.port === e.port;
  return t.hostname !== e.hostname || !r || t.protocol !== e.protocol ? "anonymous" : "";
}
function getResolutionOfUrl(i2, e) {
  var t = settings$1.RETINA_PREFIX.exec(i2);
  return t ? parseFloat(t[1]) : e !== void 0 ? e : 1;
}
/*!
 * @pixi/display - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/display is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
settings$1.SORTABLE_CHILDREN = false;
var Bounds$1 = (
  /** @class */
  function() {
    function i2() {
      this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0, this.rect = null, this.updateID = -1;
    }
    return i2.prototype.isEmpty = function() {
      return this.minX > this.maxX || this.minY > this.maxY;
    }, i2.prototype.clear = function() {
      this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0;
    }, i2.prototype.getRectangle = function(e) {
      return this.minX > this.maxX || this.minY > this.maxY ? Rectangle$1.EMPTY : (e = e || new Rectangle$1(0, 0, 1, 1), e.x = this.minX, e.y = this.minY, e.width = this.maxX - this.minX, e.height = this.maxY - this.minY, e);
    }, i2.prototype.addPoint = function(e) {
      this.minX = Math.min(this.minX, e.x), this.maxX = Math.max(this.maxX, e.x), this.minY = Math.min(this.minY, e.y), this.maxY = Math.max(this.maxY, e.y);
    }, i2.prototype.addPointMatrix = function(e, t) {
      var r = e.a, a = e.b, s = e.c, u = e.d, l = e.tx, c = e.ty, d = r * t.x + s * t.y + l, f = a * t.x + u * t.y + c;
      this.minX = Math.min(this.minX, d), this.maxX = Math.max(this.maxX, d), this.minY = Math.min(this.minY, f), this.maxY = Math.max(this.maxY, f);
    }, i2.prototype.addQuad = function(e) {
      var t = this.minX, r = this.minY, a = this.maxX, s = this.maxY, u = e[0], l = e[1];
      t = u < t ? u : t, r = l < r ? l : r, a = u > a ? u : a, s = l > s ? l : s, u = e[2], l = e[3], t = u < t ? u : t, r = l < r ? l : r, a = u > a ? u : a, s = l > s ? l : s, u = e[4], l = e[5], t = u < t ? u : t, r = l < r ? l : r, a = u > a ? u : a, s = l > s ? l : s, u = e[6], l = e[7], t = u < t ? u : t, r = l < r ? l : r, a = u > a ? u : a, s = l > s ? l : s, this.minX = t, this.minY = r, this.maxX = a, this.maxY = s;
    }, i2.prototype.addFrame = function(e, t, r, a, s) {
      this.addFrameMatrix(e.worldTransform, t, r, a, s);
    }, i2.prototype.addFrameMatrix = function(e, t, r, a, s) {
      var u = e.a, l = e.b, c = e.c, d = e.d, f = e.tx, p = e.ty, m = this.minX, y = this.minY, x = this.maxX, g = this.maxY, _ = u * t + c * r + f, T = l * t + d * r + p;
      m = _ < m ? _ : m, y = T < y ? T : y, x = _ > x ? _ : x, g = T > g ? T : g, _ = u * a + c * r + f, T = l * a + d * r + p, m = _ < m ? _ : m, y = T < y ? T : y, x = _ > x ? _ : x, g = T > g ? T : g, _ = u * t + c * s + f, T = l * t + d * s + p, m = _ < m ? _ : m, y = T < y ? T : y, x = _ > x ? _ : x, g = T > g ? T : g, _ = u * a + c * s + f, T = l * a + d * s + p, m = _ < m ? _ : m, y = T < y ? T : y, x = _ > x ? _ : x, g = T > g ? T : g, this.minX = m, this.minY = y, this.maxX = x, this.maxY = g;
    }, i2.prototype.addVertexData = function(e, t, r) {
      for (var a = this.minX, s = this.minY, u = this.maxX, l = this.maxY, c = t; c < r; c += 2) {
        var d = e[c], f = e[c + 1];
        a = d < a ? d : a, s = f < s ? f : s, u = d > u ? d : u, l = f > l ? f : l;
      }
      this.minX = a, this.minY = s, this.maxX = u, this.maxY = l;
    }, i2.prototype.addVertices = function(e, t, r, a) {
      this.addVerticesMatrix(e.worldTransform, t, r, a);
    }, i2.prototype.addVerticesMatrix = function(e, t, r, a, s, u) {
      s === void 0 && (s = 0), u === void 0 && (u = s);
      for (var l = e.a, c = e.b, d = e.c, f = e.d, p = e.tx, m = e.ty, y = this.minX, x = this.minY, g = this.maxX, _ = this.maxY, T = r; T < a; T += 2) {
        var E = t[T], b = t[T + 1], C = l * E + d * b + p, w = f * b + c * E + m;
        y = Math.min(y, C - s), g = Math.max(g, C + s), x = Math.min(x, w - u), _ = Math.max(_, w + u);
      }
      this.minX = y, this.minY = x, this.maxX = g, this.maxY = _;
    }, i2.prototype.addBounds = function(e) {
      var t = this.minX, r = this.minY, a = this.maxX, s = this.maxY;
      this.minX = e.minX < t ? e.minX : t, this.minY = e.minY < r ? e.minY : r, this.maxX = e.maxX > a ? e.maxX : a, this.maxY = e.maxY > s ? e.maxY : s;
    }, i2.prototype.addBoundsMask = function(e, t) {
      var r = e.minX > t.minX ? e.minX : t.minX, a = e.minY > t.minY ? e.minY : t.minY, s = e.maxX < t.maxX ? e.maxX : t.maxX, u = e.maxY < t.maxY ? e.maxY : t.maxY;
      if (r <= s && a <= u) {
        var l = this.minX, c = this.minY, d = this.maxX, f = this.maxY;
        this.minX = r < l ? r : l, this.minY = a < c ? a : c, this.maxX = s > d ? s : d, this.maxY = u > f ? u : f;
      }
    }, i2.prototype.addBoundsMatrix = function(e, t) {
      this.addFrameMatrix(t, e.minX, e.minY, e.maxX, e.maxY);
    }, i2.prototype.addBoundsArea = function(e, t) {
      var r = e.minX > t.x ? e.minX : t.x, a = e.minY > t.y ? e.minY : t.y, s = e.maxX < t.x + t.width ? e.maxX : t.x + t.width, u = e.maxY < t.y + t.height ? e.maxY : t.y + t.height;
      if (r <= s && a <= u) {
        var l = this.minX, c = this.minY, d = this.maxX, f = this.maxY;
        this.minX = r < l ? r : l, this.minY = a < c ? a : c, this.maxX = s > d ? s : d, this.maxY = u > f ? u : f;
      }
    }, i2.prototype.pad = function(e, t) {
      e === void 0 && (e = 0), t === void 0 && (t = e), this.isEmpty() || (this.minX -= e, this.maxX += e, this.minY -= t, this.maxY += t);
    }, i2.prototype.addFramePad = function(e, t, r, a, s, u) {
      e -= s, t -= u, r += s, a += u, this.minX = this.minX < e ? this.minX : e, this.maxX = this.maxX > r ? this.maxX : r, this.minY = this.minY < t ? this.minY : t, this.maxY = this.maxY > a ? this.maxY : a;
    }, i2;
  }()
);
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$2 = function(i2, e) {
  return extendStatics$2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, r) {
    t.__proto__ = r;
  } || function(t, r) {
    for (var a in r)
      r.hasOwnProperty(a) && (t[a] = r[a]);
  }, extendStatics$2(i2, e);
};
function __extends$2(i2, e) {
  extendStatics$2(i2, e);
  function t() {
    this.constructor = i2;
  }
  i2.prototype = e === null ? Object.create(e) : (t.prototype = e.prototype, new t());
}
var DisplayObject$1 = (
  /** @class */
  function(i2) {
    __extends$2(e, i2);
    function e() {
      var t = i2.call(this) || this;
      return t.tempDisplayObjectParent = null, t.transform = new Transform$1(), t.alpha = 1, t.visible = true, t.renderable = true, t.cullable = false, t.cullArea = null, t.parent = null, t.worldAlpha = 1, t._lastSortedIndex = 0, t._zIndex = 0, t.filterArea = null, t.filters = null, t._enabledFilters = null, t._bounds = new Bounds$1(), t._localBounds = null, t._boundsID = 0, t._boundsRect = null, t._localBoundsRect = null, t._mask = null, t._maskRefCount = 0, t._destroyed = false, t.isSprite = false, t.isMask = false, t;
    }
    return e.mixin = function(t) {
      for (var r = Object.keys(t), a = 0; a < r.length; ++a) {
        var s = r[a];
        Object.defineProperty(e.prototype, s, Object.getOwnPropertyDescriptor(t, s));
      }
    }, Object.defineProperty(e.prototype, "destroyed", {
      /**
       * Fired when this DisplayObject is added to a Container.
       * @instance
       * @event added
       * @param {PIXI.Container} container - The container added to.
       */
      /**
       * Fired when this DisplayObject is removed from a Container.
       * @instance
       * @event removed
       * @param {PIXI.Container} container - The container removed from.
       */
      /**
       * Fired when this DisplayObject is destroyed. This event is emitted once
       * destroy is finished.
       * @instance
       * @event destroyed
       */
      /** Readonly flag for destroyed display objects. */
      get: function() {
        return this._destroyed;
      },
      enumerable: false,
      configurable: true
    }), e.prototype._recursivePostUpdateTransform = function() {
      this.parent ? (this.parent._recursivePostUpdateTransform(), this.transform.updateTransform(this.parent.transform)) : this.transform.updateTransform(this._tempDisplayObjectParent.transform);
    }, e.prototype.updateTransform = function() {
      this._boundsID++, this.transform.updateTransform(this.parent.transform), this.worldAlpha = this.alpha * this.parent.worldAlpha;
    }, e.prototype.getBounds = function(t, r) {
      return t || (this.parent ? (this._recursivePostUpdateTransform(), this.updateTransform()) : (this.parent = this._tempDisplayObjectParent, this.updateTransform(), this.parent = null)), this._bounds.updateID !== this._boundsID && (this.calculateBounds(), this._bounds.updateID = this._boundsID), r || (this._boundsRect || (this._boundsRect = new Rectangle$1()), r = this._boundsRect), this._bounds.getRectangle(r);
    }, e.prototype.getLocalBounds = function(t) {
      t || (this._localBoundsRect || (this._localBoundsRect = new Rectangle$1()), t = this._localBoundsRect), this._localBounds || (this._localBounds = new Bounds$1());
      var r = this.transform, a = this.parent;
      this.parent = null, this.transform = this._tempDisplayObjectParent.transform;
      var s = this._bounds, u = this._boundsID;
      this._bounds = this._localBounds;
      var l = this.getBounds(false, t);
      return this.parent = a, this.transform = r, this._bounds = s, this._bounds.updateID += this._boundsID - u, l;
    }, e.prototype.toGlobal = function(t, r, a) {
      return a === void 0 && (a = false), a || (this._recursivePostUpdateTransform(), this.parent ? this.displayObjectUpdateTransform() : (this.parent = this._tempDisplayObjectParent, this.displayObjectUpdateTransform(), this.parent = null)), this.worldTransform.apply(t, r);
    }, e.prototype.toLocal = function(t, r, a, s) {
      return r && (t = r.toGlobal(t, a, s)), s || (this._recursivePostUpdateTransform(), this.parent ? this.displayObjectUpdateTransform() : (this.parent = this._tempDisplayObjectParent, this.displayObjectUpdateTransform(), this.parent = null)), this.worldTransform.applyInverse(t, a);
    }, e.prototype.setParent = function(t) {
      if (!t || !t.addChild)
        throw new Error("setParent: Argument must be a Container");
      return t.addChild(this), t;
    }, e.prototype.setTransform = function(t, r, a, s, u, l, c, d, f) {
      return t === void 0 && (t = 0), r === void 0 && (r = 0), a === void 0 && (a = 1), s === void 0 && (s = 1), u === void 0 && (u = 0), l === void 0 && (l = 0), c === void 0 && (c = 0), d === void 0 && (d = 0), f === void 0 && (f = 0), this.position.x = t, this.position.y = r, this.scale.x = a || 1, this.scale.y = s || 1, this.rotation = u, this.skew.x = l, this.skew.y = c, this.pivot.x = d, this.pivot.y = f, this;
    }, e.prototype.destroy = function(t) {
      this.parent && this.parent.removeChild(this), this._destroyed = true, this.transform = null, this.parent = null, this._bounds = null, this.mask = null, this.cullArea = null, this.filters = null, this.filterArea = null, this.hitArea = null, this.interactive = false, this.interactiveChildren = false, this.emit("destroyed"), this.removeAllListeners();
    }, Object.defineProperty(e.prototype, "_tempDisplayObjectParent", {
      /**
       * @protected
       * @member {PIXI.Container}
       */
      get: function() {
        return this.tempDisplayObjectParent === null && (this.tempDisplayObjectParent = new TemporaryDisplayObject()), this.tempDisplayObjectParent;
      },
      enumerable: false,
      configurable: true
    }), e.prototype.enableTempParent = function() {
      var t = this.parent;
      return this.parent = this._tempDisplayObjectParent, t;
    }, e.prototype.disableTempParent = function(t) {
      this.parent = t;
    }, Object.defineProperty(e.prototype, "x", {
      /**
       * The position of the displayObject on the x axis relative to the local coordinates of the parent.
       * An alias to position.x
       */
      get: function() {
        return this.position.x;
      },
      set: function(t) {
        this.transform.position.x = t;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(e.prototype, "y", {
      /**
       * The position of the displayObject on the y axis relative to the local coordinates of the parent.
       * An alias to position.y
       */
      get: function() {
        return this.position.y;
      },
      set: function(t) {
        this.transform.position.y = t;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(e.prototype, "worldTransform", {
      /**
       * Current transform of the object based on world (parent) factors.
       * @readonly
       */
      get: function() {
        return this.transform.worldTransform;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(e.prototype, "localTransform", {
      /**
       * Current transform of the object based on local factors: position, scale, other stuff.
       * @readonly
       */
      get: function() {
        return this.transform.localTransform;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(e.prototype, "position", {
      /**
       * The coordinate of the object relative to the local coordinates of the parent.
       * @since 4.0.0
       */
      get: function() {
        return this.transform.position;
      },
      set: function(t) {
        this.transform.position.copyFrom(t);
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(e.prototype, "scale", {
      /**
       * The scale factors of this object along the local coordinate axes.
       *
       * The default scale is (1, 1).
       * @since 4.0.0
       */
      get: function() {
        return this.transform.scale;
      },
      set: function(t) {
        this.transform.scale.copyFrom(t);
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(e.prototype, "pivot", {
      /**
       * The center of rotation, scaling, and skewing for this display object in its local space. The `position`
       * is the projection of `pivot` in the parent's local space.
       *
       * By default, the pivot is the origin (0, 0).
       * @since 4.0.0
       */
      get: function() {
        return this.transform.pivot;
      },
      set: function(t) {
        this.transform.pivot.copyFrom(t);
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(e.prototype, "skew", {
      /**
       * The skew factor for the object in radians.
       * @since 4.0.0
       */
      get: function() {
        return this.transform.skew;
      },
      set: function(t) {
        this.transform.skew.copyFrom(t);
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(e.prototype, "rotation", {
      /**
       * The rotation of the object in radians.
       * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.
       */
      get: function() {
        return this.transform.rotation;
      },
      set: function(t) {
        this.transform.rotation = t;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(e.prototype, "angle", {
      /**
       * The angle of the object in degrees.
       * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.
       */
      get: function() {
        return this.transform.rotation * RAD_TO_DEG;
      },
      set: function(t) {
        this.transform.rotation = t * DEG_TO_RAD;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(e.prototype, "zIndex", {
      /**
       * The zIndex of the displayObject.
       *
       * If a container has the sortableChildren property set to true, children will be automatically
       * sorted by zIndex value; a higher value will mean it will be moved towards the end of the array,
       * and thus rendered on top of other display objects within the same container.
       * @see PIXI.Container#sortableChildren
       */
      get: function() {
        return this._zIndex;
      },
      set: function(t) {
        this._zIndex = t, this.parent && (this.parent.sortDirty = true);
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(e.prototype, "worldVisible", {
      /**
       * Indicates if the object is globally visible.
       * @readonly
       */
      get: function() {
        var t = this;
        do {
          if (!t.visible)
            return false;
          t = t.parent;
        } while (t);
        return true;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(e.prototype, "mask", {
      /**
       * Sets a mask for the displayObject. A mask is an object that limits the visibility of an
       * object to the shape of the mask applied to it. In PixiJS a regular mask must be a
       * {@link PIXI.Graphics} or a {@link PIXI.Sprite} object. This allows for much faster masking in canvas as it
       * utilities shape clipping. Furthermore, a mask of an object must be in the subtree of its parent.
       * Otherwise, `getLocalBounds` may calculate incorrect bounds, which makes the container's width and height wrong.
       * To remove a mask, set this property to `null`.
       *
       * For sprite mask both alpha and red channel are used. Black mask is the same as transparent mask.
       * @example
       * const graphics = new PIXI.Graphics();
       * graphics.beginFill(0xFF3300);
       * graphics.drawRect(50, 250, 100, 100);
       * graphics.endFill();
       *
       * const sprite = new PIXI.Sprite(texture);
       * sprite.mask = graphics;
       * @todo At the moment, PIXI.CanvasRenderer doesn't support PIXI.Sprite as mask.
       */
      get: function() {
        return this._mask;
      },
      set: function(t) {
        if (this._mask !== t) {
          if (this._mask) {
            var r = this._mask.isMaskData ? this._mask.maskObject : this._mask;
            r && (r._maskRefCount--, r._maskRefCount === 0 && (r.renderable = true, r.isMask = false));
          }
          if (this._mask = t, this._mask) {
            var r = this._mask.isMaskData ? this._mask.maskObject : this._mask;
            r && (r._maskRefCount === 0 && (r.renderable = false, r.isMask = true), r._maskRefCount++);
          }
        }
      },
      enumerable: false,
      configurable: true
    }), e;
  }(EventEmitter)
), TemporaryDisplayObject = (
  /** @class */
  function(i2) {
    __extends$2(e, i2);
    function e() {
      var t = i2 !== null && i2.apply(this, arguments) || this;
      return t.sortDirty = null, t;
    }
    return e;
  }(DisplayObject$1)
);
DisplayObject$1.prototype.displayObjectUpdateTransform = DisplayObject$1.prototype.updateTransform;
function sortChildren(i2, e) {
  return i2.zIndex === e.zIndex ? i2._lastSortedIndex - e._lastSortedIndex : i2.zIndex - e.zIndex;
}
var Container$1 = (
  /** @class */
  function(i2) {
    __extends$2(e, i2);
    function e() {
      var t = i2.call(this) || this;
      return t.children = [], t.sortableChildren = settings$1.SORTABLE_CHILDREN, t.sortDirty = false, t;
    }
    return e.prototype.onChildrenChange = function(t) {
    }, e.prototype.addChild = function() {
      for (var t = arguments, r = [], a = 0; a < arguments.length; a++)
        r[a] = t[a];
      if (r.length > 1)
        for (var s = 0; s < r.length; s++)
          this.addChild(r[s]);
      else {
        var u = r[0];
        u.parent && u.parent.removeChild(u), u.parent = this, this.sortDirty = true, u.transform._parentID = -1, this.children.push(u), this._boundsID++, this.onChildrenChange(this.children.length - 1), this.emit("childAdded", u, this, this.children.length - 1), u.emit("added", this);
      }
      return r[0];
    }, e.prototype.addChildAt = function(t, r) {
      if (r < 0 || r > this.children.length)
        throw new Error(t + "addChildAt: The index " + r + " supplied is out of bounds " + this.children.length);
      return t.parent && t.parent.removeChild(t), t.parent = this, this.sortDirty = true, t.transform._parentID = -1, this.children.splice(r, 0, t), this._boundsID++, this.onChildrenChange(r), t.emit("added", this), this.emit("childAdded", t, this, r), t;
    }, e.prototype.swapChildren = function(t, r) {
      if (t !== r) {
        var a = this.getChildIndex(t), s = this.getChildIndex(r);
        this.children[a] = r, this.children[s] = t, this.onChildrenChange(a < s ? a : s);
      }
    }, e.prototype.getChildIndex = function(t) {
      var r = this.children.indexOf(t);
      if (r === -1)
        throw new Error("The supplied DisplayObject must be a child of the caller");
      return r;
    }, e.prototype.setChildIndex = function(t, r) {
      if (r < 0 || r >= this.children.length)
        throw new Error("The index " + r + " supplied is out of bounds " + this.children.length);
      var a = this.getChildIndex(t);
      removeItems(this.children, a, 1), this.children.splice(r, 0, t), this.onChildrenChange(r);
    }, e.prototype.getChildAt = function(t) {
      if (t < 0 || t >= this.children.length)
        throw new Error("getChildAt: Index (" + t + ") does not exist.");
      return this.children[t];
    }, e.prototype.removeChild = function() {
      for (var t = arguments, r = [], a = 0; a < arguments.length; a++)
        r[a] = t[a];
      if (r.length > 1)
        for (var s = 0; s < r.length; s++)
          this.removeChild(r[s]);
      else {
        var u = r[0], l = this.children.indexOf(u);
        if (l === -1)
          return null;
        u.parent = null, u.transform._parentID = -1, removeItems(this.children, l, 1), this._boundsID++, this.onChildrenChange(l), u.emit("removed", this), this.emit("childRemoved", u, this, l);
      }
      return r[0];
    }, e.prototype.removeChildAt = function(t) {
      var r = this.getChildAt(t);
      return r.parent = null, r.transform._parentID = -1, removeItems(this.children, t, 1), this._boundsID++, this.onChildrenChange(t), r.emit("removed", this), this.emit("childRemoved", r, this, t), r;
    }, e.prototype.removeChildren = function(t, r) {
      t === void 0 && (t = 0), r === void 0 && (r = this.children.length);
      var a = t, s = r, u = s - a, l;
      if (u > 0 && u <= s) {
        l = this.children.splice(a, u);
        for (var c = 0; c < l.length; ++c)
          l[c].parent = null, l[c].transform && (l[c].transform._parentID = -1);
        this._boundsID++, this.onChildrenChange(t);
        for (var c = 0; c < l.length; ++c)
          l[c].emit("removed", this), this.emit("childRemoved", l[c], this, c);
        return l;
      } else if (u === 0 && this.children.length === 0)
        return [];
      throw new RangeError("removeChildren: numeric values are outside the acceptable range.");
    }, e.prototype.sortChildren = function() {
      for (var t = false, r = 0, a = this.children.length; r < a; ++r) {
        var s = this.children[r];
        s._lastSortedIndex = r, !t && s.zIndex !== 0 && (t = true);
      }
      t && this.children.length > 1 && this.children.sort(sortChildren), this.sortDirty = false;
    }, e.prototype.updateTransform = function() {
      this.sortableChildren && this.sortDirty && this.sortChildren(), this._boundsID++, this.transform.updateTransform(this.parent.transform), this.worldAlpha = this.alpha * this.parent.worldAlpha;
      for (var t = 0, r = this.children.length; t < r; ++t) {
        var a = this.children[t];
        a.visible && a.updateTransform();
      }
    }, e.prototype.calculateBounds = function() {
      this._bounds.clear(), this._calculateBounds();
      for (var t = 0; t < this.children.length; t++) {
        var r = this.children[t];
        if (!(!r.visible || !r.renderable))
          if (r.calculateBounds(), r._mask) {
            var a = r._mask.isMaskData ? r._mask.maskObject : r._mask;
            a ? (a.calculateBounds(), this._bounds.addBoundsMask(r._bounds, a._bounds)) : this._bounds.addBounds(r._bounds);
          } else r.filterArea ? this._bounds.addBoundsArea(r._bounds, r.filterArea) : this._bounds.addBounds(r._bounds);
      }
      this._bounds.updateID = this._boundsID;
    }, e.prototype.getLocalBounds = function(t, r) {
      r === void 0 && (r = false);
      var a = i2.prototype.getLocalBounds.call(this, t);
      if (!r)
        for (var s = 0, u = this.children.length; s < u; ++s) {
          var l = this.children[s];
          l.visible && l.updateTransform();
        }
      return a;
    }, e.prototype._calculateBounds = function() {
    }, e.prototype._renderWithCulling = function(t) {
      var r = t.renderTexture.sourceFrame;
      if (r.width > 0 && r.height > 0) {
        var a, s;
        if (this.cullArea ? (a = this.cullArea, s = this.worldTransform) : this._render !== e.prototype._render && (a = this.getBounds(true)), a && r.intersects(a, s))
          this._render(t);
        else if (this.cullArea)
          return;
        for (var u = 0, l = this.children.length; u < l; ++u) {
          var c = this.children[u], d = c.cullable;
          c.cullable = d || !this.cullArea, c.render(t), c.cullable = d;
        }
      }
    }, e.prototype.render = function(t) {
      if (!(!this.visible || this.worldAlpha <= 0 || !this.renderable))
        if (this._mask || this.filters && this.filters.length)
          this.renderAdvanced(t);
        else if (this.cullable)
          this._renderWithCulling(t);
        else {
          this._render(t);
          for (var r = 0, a = this.children.length; r < a; ++r)
            this.children[r].render(t);
        }
    }, e.prototype.renderAdvanced = function(t) {
      var r = this.filters, a = this._mask;
      if (r) {
        this._enabledFilters || (this._enabledFilters = []), this._enabledFilters.length = 0;
        for (var s = 0; s < r.length; s++)
          r[s].enabled && this._enabledFilters.push(r[s]);
      }
      var u = r && this._enabledFilters && this._enabledFilters.length || a && (!a.isMaskData || a.enabled && (a.autoDetect || a.type !== MASK_TYPES.NONE));
      if (u && t.batch.flush(), r && this._enabledFilters && this._enabledFilters.length && t.filter.push(this, this._enabledFilters), a && t.mask.push(this, this._mask), this.cullable)
        this._renderWithCulling(t);
      else {
        this._render(t);
        for (var s = 0, l = this.children.length; s < l; ++s)
          this.children[s].render(t);
      }
      u && t.batch.flush(), a && t.mask.pop(this), r && this._enabledFilters && this._enabledFilters.length && t.filter.pop();
    }, e.prototype._render = function(t) {
    }, e.prototype.destroy = function(t) {
      i2.prototype.destroy.call(this), this.sortDirty = false;
      var r = typeof t == "boolean" ? t : t && t.children, a = this.removeChildren(0, this.children.length);
      if (r)
        for (var s = 0; s < a.length; ++s)
          a[s].destroy(t);
    }, Object.defineProperty(e.prototype, "width", {
      /** The width of the Container, setting this will actually modify the scale to achieve the value set. */
      get: function() {
        return this.scale.x * this.getLocalBounds().width;
      },
      set: function(t) {
        var r = this.getLocalBounds().width;
        r !== 0 ? this.scale.x = t / r : this.scale.x = 1, this._width = t;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(e.prototype, "height", {
      /** The height of the Container, setting this will actually modify the scale to achieve the value set. */
      get: function() {
        return this.scale.y * this.getLocalBounds().height;
      },
      set: function(t) {
        var r = this.getLocalBounds().height;
        r !== 0 ? this.scale.y = t / r : this.scale.y = 1, this._height = t;
      },
      enumerable: false,
      configurable: true
    }), e;
  }(DisplayObject$1)
);
Container$1.prototype.containerUpdateTransform = Container$1.prototype.updateTransform;
/*!
 * @pixi/runner - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/runner is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var Runner = (
  /** @class */
  function() {
    function i2(e) {
      this.items = [], this._name = e, this._aliasCount = 0;
    }
    return i2.prototype.emit = function(e, t, r, a, s, u, l, c) {
      if (arguments.length > 8)
        throw new Error("max arguments reached");
      var d = this, f = d.name, p = d.items;
      this._aliasCount++;
      for (var m = 0, y = p.length; m < y; m++)
        p[m][f](e, t, r, a, s, u, l, c);
      return p === this.items && this._aliasCount--, this;
    }, i2.prototype.ensureNonAliasedItems = function() {
      this._aliasCount > 0 && this.items.length > 1 && (this._aliasCount = 0, this.items = this.items.slice(0));
    }, i2.prototype.add = function(e) {
      return e[this._name] && (this.ensureNonAliasedItems(), this.remove(e), this.items.push(e)), this;
    }, i2.prototype.remove = function(e) {
      var t = this.items.indexOf(e);
      return t !== -1 && (this.ensureNonAliasedItems(), this.items.splice(t, 1)), this;
    }, i2.prototype.contains = function(e) {
      return this.items.indexOf(e) !== -1;
    }, i2.prototype.removeAll = function() {
      return this.ensureNonAliasedItems(), this.items.length = 0, this;
    }, i2.prototype.destroy = function() {
      this.removeAll(), this.items = null, this._name = null;
    }, Object.defineProperty(i2.prototype, "empty", {
      /**
       * `true` if there are no this Runner contains no listeners
       * @readonly
       */
      get: function() {
        return this.items.length === 0;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(i2.prototype, "name", {
      /**
       * The name of the runner.
       * @readonly
       */
      get: function() {
        return this._name;
      },
      enumerable: false,
      configurable: true
    }), i2;
  }()
);
Object.defineProperties(Runner.prototype, {
  /**
   * Alias for `emit`
   * @memberof PIXI.Runner#
   * @method dispatch
   * @see PIXI.Runner#emit
   */
  dispatch: { value: Runner.prototype.emit },
  /**
   * Alias for `emit`
   * @memberof PIXI.Runner#
   * @method run
   * @see PIXI.Runner#emit
   */
  run: { value: Runner.prototype.emit }
});
/*!
 * @pixi/core - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/core is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
settings$1.PREFER_ENV = isMobile.any ? ENV.WEBGL : ENV.WEBGL2;
settings$1.STRICT_TEXTURE_CACHE = false;
var INSTALLED = [];
function autoDetectResource(i2, e) {
  if (!i2)
    return null;
  var t = "";
  if (typeof i2 == "string") {
    var r = /\.(\w{3,4})(?:$|\?|#)/i.exec(i2);
    r && (t = r[1].toLowerCase());
  }
  for (var a = INSTALLED.length - 1; a >= 0; --a) {
    var s = INSTALLED[a];
    if (s.test && s.test(i2, t))
      return new s(i2, e);
  }
  throw new Error("Unrecognized source type to auto-detect Resource");
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$1 = function(i2, e) {
  return extendStatics$1 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, r) {
    t.__proto__ = r;
  } || function(t, r) {
    for (var a in r)
      r.hasOwnProperty(a) && (t[a] = r[a]);
  }, extendStatics$1(i2, e);
};
function __extends$1(i2, e) {
  extendStatics$1(i2, e);
  function t() {
    this.constructor = i2;
  }
  i2.prototype = e === null ? Object.create(e) : (t.prototype = e.prototype, new t());
}
var __assign = function() {
  return __assign = Object.assign || function(e) {
    for (var t = arguments, r, a = 1, s = arguments.length; a < s; a++) {
      r = t[a];
      for (var u in r)
        Object.prototype.hasOwnProperty.call(r, u) && (e[u] = r[u]);
    }
    return e;
  }, __assign.apply(this, arguments);
};
function __rest(i2, e) {
  var t = {};
  for (var r in i2)
    Object.prototype.hasOwnProperty.call(i2, r) && e.indexOf(r) < 0 && (t[r] = i2[r]);
  if (i2 != null && typeof Object.getOwnPropertySymbols == "function")
    for (var a = 0, r = Object.getOwnPropertySymbols(i2); a < r.length; a++)
      e.indexOf(r[a]) < 0 && Object.prototype.propertyIsEnumerable.call(i2, r[a]) && (t[r[a]] = i2[r[a]]);
  return t;
}
var Resource$1 = (
  /** @class */
  function() {
    function i2(e, t) {
      e === void 0 && (e = 0), t === void 0 && (t = 0), this._width = e, this._height = t, this.destroyed = false, this.internal = false, this.onResize = new Runner("setRealSize"), this.onUpdate = new Runner("update"), this.onError = new Runner("onError");
    }
    return i2.prototype.bind = function(e) {
      this.onResize.add(e), this.onUpdate.add(e), this.onError.add(e), (this._width || this._height) && this.onResize.emit(this._width, this._height);
    }, i2.prototype.unbind = function(e) {
      this.onResize.remove(e), this.onUpdate.remove(e), this.onError.remove(e);
    }, i2.prototype.resize = function(e, t) {
      (e !== this._width || t !== this._height) && (this._width = e, this._height = t, this.onResize.emit(e, t));
    }, Object.defineProperty(i2.prototype, "valid", {
      /**
       * Has been validated
       * @readonly
       */
      get: function() {
        return !!this._width && !!this._height;
      },
      enumerable: false,
      configurable: true
    }), i2.prototype.update = function() {
      this.destroyed || this.onUpdate.emit();
    }, i2.prototype.load = function() {
      return Promise.resolve(this);
    }, Object.defineProperty(i2.prototype, "width", {
      /**
       * The width of the resource.
       * @readonly
       */
      get: function() {
        return this._width;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(i2.prototype, "height", {
      /**
       * The height of the resource.
       * @readonly
       */
      get: function() {
        return this._height;
      },
      enumerable: false,
      configurable: true
    }), i2.prototype.style = function(e, t, r) {
      return false;
    }, i2.prototype.dispose = function() {
    }, i2.prototype.destroy = function() {
      this.destroyed || (this.destroyed = true, this.dispose(), this.onError.removeAll(), this.onError = null, this.onResize.removeAll(), this.onResize = null, this.onUpdate.removeAll(), this.onUpdate = null);
    }, i2.test = function(e, t) {
      return false;
    }, i2;
  }()
), BufferResource = (
  /** @class */
  function(i2) {
    __extends$1(e, i2);
    function e(t, r) {
      var a = this, s = r || {}, u = s.width, l = s.height;
      if (!u || !l)
        throw new Error("BufferResource width or height invalid");
      return a = i2.call(this, u, l) || this, a.data = t, a;
    }
    return e.prototype.upload = function(t, r, a) {
      var s = t.gl;
      s.pixelStorei(s.UNPACK_PREMULTIPLY_ALPHA_WEBGL, r.alphaMode === ALPHA_MODES.UNPACK);
      var u = r.realWidth, l = r.realHeight;
      return a.width === u && a.height === l ? s.texSubImage2D(r.target, 0, 0, 0, u, l, r.format, a.type, this.data) : (a.width = u, a.height = l, s.texImage2D(r.target, 0, a.internalFormat, u, l, 0, r.format, a.type, this.data)), true;
    }, e.prototype.dispose = function() {
      this.data = null;
    }, e.test = function(t) {
      return t instanceof Float32Array || t instanceof Uint8Array || t instanceof Uint32Array;
    }, e;
  }(Resource$1)
), defaultBufferOptions = {
  scaleMode: SCALE_MODES.NEAREST,
  format: FORMATS.RGBA,
  alphaMode: ALPHA_MODES.NPM
}, BaseTexture$1 = (
  /** @class */
  function(i2) {
    __extends$1(e, i2);
    function e(t, r) {
      t === void 0 && (t = null), r === void 0 && (r = null);
      var a = i2.call(this) || this;
      r = r || {};
      var s = r.alphaMode, u = r.mipmap, l = r.anisotropicLevel, c = r.scaleMode, d = r.width, f = r.height, p = r.wrapMode, m = r.format, y = r.type, x = r.target, g = r.resolution, _ = r.resourceOptions;
      return t && !(t instanceof Resource$1) && (t = autoDetectResource(t, _), t.internal = true), a.resolution = g || settings$1.RESOLUTION, a.width = Math.round((d || 0) * a.resolution) / a.resolution, a.height = Math.round((f || 0) * a.resolution) / a.resolution, a._mipmap = u !== void 0 ? u : settings$1.MIPMAP_TEXTURES, a.anisotropicLevel = l !== void 0 ? l : settings$1.ANISOTROPIC_LEVEL, a._wrapMode = p || settings$1.WRAP_MODE, a._scaleMode = c !== void 0 ? c : settings$1.SCALE_MODE, a.format = m || FORMATS.RGBA, a.type = y || TYPES.UNSIGNED_BYTE, a.target = x || TARGETS.TEXTURE_2D, a.alphaMode = s !== void 0 ? s : ALPHA_MODES.UNPACK, a.uid = uid$3(), a.touched = 0, a.isPowerOfTwo = false, a._refreshPOT(), a._glTextures = {}, a.dirtyId = 0, a.dirtyStyleId = 0, a.cacheId = null, a.valid = d > 0 && f > 0, a.textureCacheIds = [], a.destroyed = false, a.resource = null, a._batchEnabled = 0, a._batchLocation = 0, a.parentTextureArray = null, a.setResource(t), a;
    }
    return Object.defineProperty(e.prototype, "realWidth", {
      /**
       * Pixel width of the source of this texture
       * @readonly
       */
      get: function() {
        return Math.round(this.width * this.resolution);
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(e.prototype, "realHeight", {
      /**
       * Pixel height of the source of this texture
       * @readonly
       */
      get: function() {
        return Math.round(this.height * this.resolution);
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(e.prototype, "mipmap", {
      /**
       * Mipmap mode of the texture, affects downscaled images
       * @default PIXI.settings.MIPMAP_TEXTURES
       */
      get: function() {
        return this._mipmap;
      },
      set: function(t) {
        this._mipmap !== t && (this._mipmap = t, this.dirtyStyleId++);
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(e.prototype, "scaleMode", {
      /**
       * The scale mode to apply when scaling this texture
       * @default PIXI.settings.SCALE_MODE
       */
      get: function() {
        return this._scaleMode;
      },
      set: function(t) {
        this._scaleMode !== t && (this._scaleMode = t, this.dirtyStyleId++);
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(e.prototype, "wrapMode", {
      /**
       * How the texture wraps
       * @default PIXI.settings.WRAP_MODE
       */
      get: function() {
        return this._wrapMode;
      },
      set: function(t) {
        this._wrapMode !== t && (this._wrapMode = t, this.dirtyStyleId++);
      },
      enumerable: false,
      configurable: true
    }), e.prototype.setStyle = function(t, r) {
      var a;
      return t !== void 0 && t !== this.scaleMode && (this.scaleMode = t, a = true), r !== void 0 && r !== this.mipmap && (this.mipmap = r, a = true), a && this.dirtyStyleId++, this;
    }, e.prototype.setSize = function(t, r, a) {
      return a = a || this.resolution, this.setRealSize(t * a, r * a, a);
    }, e.prototype.setRealSize = function(t, r, a) {
      return this.resolution = a || this.resolution, this.width = Math.round(t) / this.resolution, this.height = Math.round(r) / this.resolution, this._refreshPOT(), this.update(), this;
    }, e.prototype._refreshPOT = function() {
      this.isPowerOfTwo = isPow2(this.realWidth) && isPow2(this.realHeight);
    }, e.prototype.setResolution = function(t) {
      var r = this.resolution;
      return r === t ? this : (this.resolution = t, this.valid && (this.width = Math.round(this.width * r) / t, this.height = Math.round(this.height * r) / t, this.emit("update", this)), this._refreshPOT(), this);
    }, e.prototype.setResource = function(t) {
      if (this.resource === t)
        return this;
      if (this.resource)
        throw new Error("Resource can be set only once");
      return t.bind(this), this.resource = t, this;
    }, e.prototype.update = function() {
      this.valid ? (this.dirtyId++, this.dirtyStyleId++, this.emit("update", this)) : this.width > 0 && this.height > 0 && (this.valid = true, this.emit("loaded", this), this.emit("update", this));
    }, e.prototype.onError = function(t) {
      this.emit("error", this, t);
    }, e.prototype.destroy = function() {
      this.resource && (this.resource.unbind(this), this.resource.internal && this.resource.destroy(), this.resource = null), this.cacheId && (delete BaseTextureCache[this.cacheId], delete TextureCache[this.cacheId], this.cacheId = null), this.dispose(), e.removeFromCache(this), this.textureCacheIds = null, this.destroyed = true;
    }, e.prototype.dispose = function() {
      this.emit("dispose", this);
    }, e.prototype.castToBaseTexture = function() {
      return this;
    }, e.from = function(t, r, a) {
      a === void 0 && (a = settings$1.STRICT_TEXTURE_CACHE);
      var s = typeof t == "string", u = null;
      if (s)
        u = t;
      else {
        if (!t._pixiId) {
          var l = r && r.pixiIdPrefix || "pixiid";
          t._pixiId = l + "_" + uid$3();
        }
        u = t._pixiId;
      }
      var c = BaseTextureCache[u];
      if (s && a && !c)
        throw new Error('The cacheId "' + u + '" does not exist in BaseTextureCache.');
      return c || (c = new e(t, r), c.cacheId = u, e.addToCache(c, u)), c;
    }, e.fromBuffer = function(t, r, a, s) {
      t = t || new Float32Array(r * a * 4);
      var u = new BufferResource(t, { width: r, height: a }), l = t instanceof Float32Array ? TYPES.FLOAT : TYPES.UNSIGNED_BYTE;
      return new e(u, Object.assign({}, defaultBufferOptions, s || { width: r, height: a, type: l }));
    }, e.addToCache = function(t, r) {
      r && (t.textureCacheIds.indexOf(r) === -1 && t.textureCacheIds.push(r), BaseTextureCache[r] && console.warn("BaseTexture added to the cache with an id [" + r + "] that already had an entry"), BaseTextureCache[r] = t);
    }, e.removeFromCache = function(t) {
      if (typeof t == "string") {
        var r = BaseTextureCache[t];
        if (r) {
          var a = r.textureCacheIds.indexOf(t);
          return a > -1 && r.textureCacheIds.splice(a, 1), delete BaseTextureCache[t], r;
        }
      } else if (t && t.textureCacheIds) {
        for (var s = 0; s < t.textureCacheIds.length; ++s)
          delete BaseTextureCache[t.textureCacheIds[s]];
        return t.textureCacheIds.length = 0, t;
      }
      return null;
    }, e._globalBatch = 0, e;
  }(EventEmitter)
), AbstractMultiResource = (
  /** @class */
  function(i2) {
    __extends$1(e, i2);
    function e(t, r) {
      var a = this, s = r || {}, u = s.width, l = s.height;
      a = i2.call(this, u, l) || this, a.items = [], a.itemDirtyIds = [];
      for (var c = 0; c < t; c++) {
        var d = new BaseTexture$1();
        a.items.push(d), a.itemDirtyIds.push(-2);
      }
      return a.length = t, a._load = null, a.baseTexture = null, a;
    }
    return e.prototype.initFromArray = function(t, r) {
      for (var a = 0; a < this.length; a++)
        t[a] && (t[a].castToBaseTexture ? this.addBaseTextureAt(t[a].castToBaseTexture(), a) : t[a] instanceof Resource$1 ? this.addResourceAt(t[a], a) : this.addResourceAt(autoDetectResource(t[a], r), a));
    }, e.prototype.dispose = function() {
      for (var t = 0, r = this.length; t < r; t++)
        this.items[t].destroy();
      this.items = null, this.itemDirtyIds = null, this._load = null;
    }, e.prototype.addResourceAt = function(t, r) {
      if (!this.items[r])
        throw new Error("Index " + r + " is out of bounds");
      return t.valid && !this.valid && this.resize(t.width, t.height), this.items[r].setResource(t), this;
    }, e.prototype.bind = function(t) {
      if (this.baseTexture !== null)
        throw new Error("Only one base texture per TextureArray is allowed");
      i2.prototype.bind.call(this, t);
      for (var r = 0; r < this.length; r++)
        this.items[r].parentTextureArray = t, this.items[r].on("update", t.update, t);
    }, e.prototype.unbind = function(t) {
      i2.prototype.unbind.call(this, t);
      for (var r = 0; r < this.length; r++)
        this.items[r].parentTextureArray = null, this.items[r].off("update", t.update, t);
    }, e.prototype.load = function() {
      var t = this;
      if (this._load)
        return this._load;
      var r = this.items.map(function(s) {
        return s.resource;
      }).filter(function(s) {
        return s;
      }), a = r.map(function(s) {
        return s.load();
      });
      return this._load = Promise.all(a).then(function() {
        var s = t.items[0], u = s.realWidth, l = s.realHeight;
        return t.resize(u, l), Promise.resolve(t);
      }), this._load;
    }, e;
  }(Resource$1)
), ArrayResource = (
  /** @class */
  function(i2) {
    __extends$1(e, i2);
    function e(t, r) {
      var a = this, s = r || {}, u = s.width, l = s.height, c, d;
      return Array.isArray(t) ? (c = t, d = t.length) : d = t, a = i2.call(this, d, { width: u, height: l }) || this, c && a.initFromArray(c, r), a;
    }
    return e.prototype.addBaseTextureAt = function(t, r) {
      if (t.resource)
        this.addResourceAt(t.resource, r);
      else
        throw new Error("ArrayResource does not support RenderTexture");
      return this;
    }, e.prototype.bind = function(t) {
      i2.prototype.bind.call(this, t), t.target = TARGETS.TEXTURE_2D_ARRAY;
    }, e.prototype.upload = function(t, r, a) {
      var s = this, u = s.length, l = s.itemDirtyIds, c = s.items, d = t.gl;
      a.dirtyId < 0 && d.texImage3D(d.TEXTURE_2D_ARRAY, 0, a.internalFormat, this._width, this._height, u, 0, r.format, a.type, null);
      for (var f = 0; f < u; f++) {
        var p = c[f];
        l[f] < p.dirtyId && (l[f] = p.dirtyId, p.valid && d.texSubImage3D(
          d.TEXTURE_2D_ARRAY,
          0,
          0,
          // xoffset
          0,
          // yoffset
          f,
          // zoffset
          p.resource.width,
          p.resource.height,
          1,
          r.format,
          a.type,
          p.resource.source
        ));
      }
      return true;
    }, e;
  }(AbstractMultiResource)
), BaseImageResource = (
  /** @class */
  function(i2) {
    __extends$1(e, i2);
    function e(t) {
      var r = this, a = t, s = a.naturalWidth || a.videoWidth || a.width, u = a.naturalHeight || a.videoHeight || a.height;
      return r = i2.call(this, s, u) || this, r.source = t, r.noSubImage = false, r;
    }
    return e.crossOrigin = function(t, r, a) {
      a === void 0 && r.indexOf("data:") !== 0 ? t.crossOrigin = determineCrossOrigin(r) : a !== false && (t.crossOrigin = typeof a == "string" ? a : "anonymous");
    }, e.prototype.upload = function(t, r, a, s) {
      var u = t.gl, l = r.realWidth, c = r.realHeight;
      if (s = s || this.source, s instanceof HTMLImageElement) {
        if (!s.complete || s.naturalWidth === 0)
          return false;
      } else if (s instanceof HTMLVideoElement && s.readyState <= 1)
        return false;
      return u.pixelStorei(u.UNPACK_PREMULTIPLY_ALPHA_WEBGL, r.alphaMode === ALPHA_MODES.UNPACK), !this.noSubImage && r.target === u.TEXTURE_2D && a.width === l && a.height === c ? u.texSubImage2D(u.TEXTURE_2D, 0, 0, 0, r.format, a.type, s) : (a.width = l, a.height = c, u.texImage2D(r.target, 0, a.internalFormat, r.format, a.type, s)), true;
    }, e.prototype.update = function() {
      if (!this.destroyed) {
        var t = this.source, r = t.naturalWidth || t.videoWidth || t.width, a = t.naturalHeight || t.videoHeight || t.height;
        this.resize(r, a), i2.prototype.update.call(this);
      }
    }, e.prototype.dispose = function() {
      this.source = null;
    }, e;
  }(Resource$1)
), CanvasResource = (
  /** @class */
  function(i2) {
    __extends$1(e, i2);
    function e(t) {
      return i2.call(this, t) || this;
    }
    return e.test = function(t) {
      var r = globalThis.OffscreenCanvas;
      return r && t instanceof r ? true : globalThis.HTMLCanvasElement && t instanceof HTMLCanvasElement;
    }, e;
  }(BaseImageResource)
), CubeResource = (
  /** @class */
  function(i2) {
    __extends$1(e, i2);
    function e(t, r) {
      var a = this, s = r || {}, u = s.width, l = s.height, c = s.autoLoad, d = s.linkBaseTexture;
      if (t && t.length !== e.SIDES)
        throw new Error("Invalid length. Got " + t.length + ", expected 6");
      a = i2.call(this, 6, { width: u, height: l }) || this;
      for (var f = 0; f < e.SIDES; f++)
        a.items[f].target = TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X + f;
      return a.linkBaseTexture = d !== false, t && a.initFromArray(t, r), c !== false && a.load(), a;
    }
    return e.prototype.bind = function(t) {
      i2.prototype.bind.call(this, t), t.target = TARGETS.TEXTURE_CUBE_MAP;
    }, e.prototype.addBaseTextureAt = function(t, r, a) {
      if (!this.items[r])
        throw new Error("Index " + r + " is out of bounds");
      if (!this.linkBaseTexture || t.parentTextureArray || Object.keys(t._glTextures).length > 0)
        if (t.resource)
          this.addResourceAt(t.resource, r);
        else
          throw new Error("CubeResource does not support copying of renderTexture.");
      else
        t.target = TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X + r, t.parentTextureArray = this.baseTexture, this.items[r] = t;
      return t.valid && !this.valid && this.resize(t.realWidth, t.realHeight), this.items[r] = t, this;
    }, e.prototype.upload = function(t, r, a) {
      for (var s = this.itemDirtyIds, u = 0; u < e.SIDES; u++) {
        var l = this.items[u];
        (s[u] < l.dirtyId || a.dirtyId < r.dirtyId) && (l.valid && l.resource ? (l.resource.upload(t, l, a), s[u] = l.dirtyId) : s[u] < -1 && (t.gl.texImage2D(l.target, 0, a.internalFormat, r.realWidth, r.realHeight, 0, r.format, a.type, null), s[u] = -1));
      }
      return true;
    }, e.test = function(t) {
      return Array.isArray(t) && t.length === e.SIDES;
    }, e.SIDES = 6, e;
  }(AbstractMultiResource)
), ImageResource = (
  /** @class */
  function(i2) {
    __extends$1(e, i2);
    function e(t, r) {
      var a = this;
      if (r = r || {}, !(t instanceof HTMLImageElement)) {
        var s = new Image();
        BaseImageResource.crossOrigin(s, t, r.crossorigin), s.src = t, t = s;
      }
      return a = i2.call(this, t) || this, !t.complete && a._width && a._height && (a._width = 0, a._height = 0), a.url = t.src, a._process = null, a.preserveBitmap = false, a.createBitmap = (r.createBitmap !== void 0 ? r.createBitmap : settings$1.CREATE_IMAGE_BITMAP) && !!globalThis.createImageBitmap, a.alphaMode = typeof r.alphaMode == "number" ? r.alphaMode : null, a.bitmap = null, a._load = null, r.autoLoad !== false && a.load(), a;
    }
    return e.prototype.load = function(t) {
      var r = this;
      return this._load ? this._load : (t !== void 0 && (this.createBitmap = t), this._load = new Promise(function(a, s) {
        var u = r.source;
        r.url = u.src;
        var l = function() {
          r.destroyed || (u.onload = null, u.onerror = null, r.resize(u.width, u.height), r._load = null, r.createBitmap ? a(r.process()) : a(r));
        };
        u.complete && u.src ? l() : (u.onload = l, u.onerror = function(c) {
          s(c), r.onError.emit(c);
        });
      }), this._load);
    }, e.prototype.process = function() {
      var t = this, r = this.source;
      if (this._process !== null)
        return this._process;
      if (this.bitmap !== null || !globalThis.createImageBitmap)
        return Promise.resolve(this);
      var a = globalThis.createImageBitmap, s = !r.crossOrigin || r.crossOrigin === "anonymous";
      return this._process = fetch(r.src, {
        mode: s ? "cors" : "no-cors"
      }).then(function(u) {
        return u.blob();
      }).then(function(u) {
        return a(u, 0, 0, r.width, r.height, {
          premultiplyAlpha: t.alphaMode === null || t.alphaMode === ALPHA_MODES.UNPACK ? "premultiply" : "none"
        });
      }).then(function(u) {
        return t.destroyed ? Promise.reject() : (t.bitmap = u, t.update(), t._process = null, Promise.resolve(t));
      }), this._process;
    }, e.prototype.upload = function(t, r, a) {
      if (typeof this.alphaMode == "number" && (r.alphaMode = this.alphaMode), !this.createBitmap)
        return i2.prototype.upload.call(this, t, r, a);
      if (!this.bitmap && (this.process(), !this.bitmap))
        return false;
      if (i2.prototype.upload.call(this, t, r, a, this.bitmap), !this.preserveBitmap) {
        var s = true, u = r._glTextures;
        for (var l in u) {
          var c = u[l];
          if (c !== a && c.dirtyId !== r.dirtyId) {
            s = false;
            break;
          }
        }
        s && (this.bitmap.close && this.bitmap.close(), this.bitmap = null);
      }
      return true;
    }, e.prototype.dispose = function() {
      this.source.onload = null, this.source.onerror = null, i2.prototype.dispose.call(this), this.bitmap && (this.bitmap.close(), this.bitmap = null), this._process = null, this._load = null;
    }, e.test = function(t) {
      return typeof t == "string" || t instanceof HTMLImageElement;
    }, e;
  }(BaseImageResource)
), SVGResource = (
  /** @class */
  function(i2) {
    __extends$1(e, i2);
    function e(t, r) {
      var a = this;
      return r = r || {}, a = i2.call(this, settings$1.ADAPTER.createCanvas()) || this, a._width = 0, a._height = 0, a.svg = t, a.scale = r.scale || 1, a._overrideWidth = r.width, a._overrideHeight = r.height, a._resolve = null, a._crossorigin = r.crossorigin, a._load = null, r.autoLoad !== false && a.load(), a;
    }
    return e.prototype.load = function() {
      var t = this;
      return this._load ? this._load : (this._load = new Promise(function(r) {
        if (t._resolve = function() {
          t.resize(t.source.width, t.source.height), r(t);
        }, e.SVG_XML.test(t.svg.trim())) {
          if (!btoa)
            throw new Error("Your browser doesn't support base64 conversions.");
          t.svg = "data:image/svg+xml;base64," + btoa(unescape(encodeURIComponent(t.svg)));
        }
        t._loadSvg();
      }), this._load);
    }, e.prototype._loadSvg = function() {
      var t = this, r = new Image();
      BaseImageResource.crossOrigin(r, this.svg, this._crossorigin), r.src = this.svg, r.onerror = function(a) {
        t._resolve && (r.onerror = null, t.onError.emit(a));
      }, r.onload = function() {
        if (t._resolve) {
          var a = r.width, s = r.height;
          if (!a || !s)
            throw new Error("The SVG image must have width and height defined (in pixels), canvas API needs them.");
          var u = a * t.scale, l = s * t.scale;
          (t._overrideWidth || t._overrideHeight) && (u = t._overrideWidth || t._overrideHeight / s * a, l = t._overrideHeight || t._overrideWidth / a * s), u = Math.round(u), l = Math.round(l);
          var c = t.source;
          c.width = u, c.height = l, c._pixiId = "canvas_" + uid$3(), c.getContext("2d").drawImage(r, 0, 0, a, s, 0, 0, u, l), t._resolve(), t._resolve = null;
        }
      };
    }, e.getSize = function(t) {
      var r = e.SVG_SIZE.exec(t), a = {};
      return r && (a[r[1]] = Math.round(parseFloat(r[3])), a[r[5]] = Math.round(parseFloat(r[7]))), a;
    }, e.prototype.dispose = function() {
      i2.prototype.dispose.call(this), this._resolve = null, this._crossorigin = null;
    }, e.test = function(t, r) {
      return r === "svg" || typeof t == "string" && t.startsWith("data:image/svg+xml") || typeof t == "string" && e.SVG_XML.test(t);
    }, e.SVG_XML = /^(<\?xml[^?]+\?>)?\s*(<!--[^(-->)]*-->)?\s*\<svg/m, e.SVG_SIZE = /<svg[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*>/i, e;
  }(BaseImageResource)
), VideoResource = (
  /** @class */
  function(i2) {
    __extends$1(e, i2);
    function e(t, r) {
      var a = this;
      if (r = r || {}, !(t instanceof HTMLVideoElement)) {
        var s = document.createElement("video");
        s.setAttribute("preload", "auto"), s.setAttribute("webkit-playsinline", ""), s.setAttribute("playsinline", ""), typeof t == "string" && (t = [t]);
        var u = t[0].src || t[0];
        BaseImageResource.crossOrigin(s, u, r.crossorigin);
        for (var l = 0; l < t.length; ++l) {
          var c = document.createElement("source"), d = t[l], f = d.src, p = d.mime;
          f = f || t[l];
          var m = f.split("?").shift().toLowerCase(), y = m.slice(m.lastIndexOf(".") + 1);
          p = p || e.MIME_TYPES[y] || "video/" + y, c.src = f, c.type = p, s.appendChild(c);
        }
        t = s;
      }
      return a = i2.call(this, t) || this, a.noSubImage = true, a._autoUpdate = true, a._isConnectedToTicker = false, a._updateFPS = r.updateFPS || 0, a._msToNextUpdate = 0, a.autoPlay = r.autoPlay !== false, a._load = null, a._resolve = null, a._onCanPlay = a._onCanPlay.bind(a), a._onError = a._onError.bind(a), r.autoLoad !== false && a.load(), a;
    }
    return e.prototype.update = function(t) {
      if (!this.destroyed) {
        var r = Ticker$1.shared.elapsedMS * this.source.playbackRate;
        this._msToNextUpdate = Math.floor(this._msToNextUpdate - r), (!this._updateFPS || this._msToNextUpdate <= 0) && (i2.prototype.update.call(this), this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0);
      }
    }, e.prototype.load = function() {
      var t = this;
      if (this._load)
        return this._load;
      var r = this.source;
      return (r.readyState === r.HAVE_ENOUGH_DATA || r.readyState === r.HAVE_FUTURE_DATA) && r.width && r.height && (r.complete = true), r.addEventListener("play", this._onPlayStart.bind(this)), r.addEventListener("pause", this._onPlayStop.bind(this)), this._isSourceReady() ? this._onCanPlay() : (r.addEventListener("canplay", this._onCanPlay), r.addEventListener("canplaythrough", this._onCanPlay), r.addEventListener("error", this._onError, true)), this._load = new Promise(function(a) {
        t.valid ? a(t) : (t._resolve = a, r.load());
      }), this._load;
    }, e.prototype._onError = function(t) {
      this.source.removeEventListener("error", this._onError, true), this.onError.emit(t);
    }, e.prototype._isSourcePlaying = function() {
      var t = this.source;
      return !t.paused && !t.ended && this._isSourceReady();
    }, e.prototype._isSourceReady = function() {
      var t = this.source;
      return t.readyState > 2;
    }, e.prototype._onPlayStart = function() {
      this.valid || this._onCanPlay(), this.autoUpdate && !this._isConnectedToTicker && (Ticker$1.shared.add(this.update, this), this._isConnectedToTicker = true);
    }, e.prototype._onPlayStop = function() {
      this._isConnectedToTicker && (Ticker$1.shared.remove(this.update, this), this._isConnectedToTicker = false);
    }, e.prototype._onCanPlay = function() {
      var t = this.source;
      t.removeEventListener("canplay", this._onCanPlay), t.removeEventListener("canplaythrough", this._onCanPlay);
      var r = this.valid;
      this.resize(t.videoWidth, t.videoHeight), !r && this._resolve && (this._resolve(this), this._resolve = null), this._isSourcePlaying() ? this._onPlayStart() : this.autoPlay && t.play();
    }, e.prototype.dispose = function() {
      this._isConnectedToTicker && (Ticker$1.shared.remove(this.update, this), this._isConnectedToTicker = false);
      var t = this.source;
      t && (t.removeEventListener("error", this._onError, true), t.pause(), t.src = "", t.load()), i2.prototype.dispose.call(this);
    }, Object.defineProperty(e.prototype, "autoUpdate", {
      /** Should the base texture automatically update itself, set to true by default. */
      get: function() {
        return this._autoUpdate;
      },
      set: function(t) {
        t !== this._autoUpdate && (this._autoUpdate = t, !this._autoUpdate && this._isConnectedToTicker ? (Ticker$1.shared.remove(this.update, this), this._isConnectedToTicker = false) : this._autoUpdate && !this._isConnectedToTicker && this._isSourcePlaying() && (Ticker$1.shared.add(this.update, this), this._isConnectedToTicker = true));
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(e.prototype, "updateFPS", {
      /**
       * How many times a second to update the texture from the video. Leave at 0 to update at every render.
       * A lower fps can help performance, as updating the texture at 60fps on a 30ps video may not be efficient.
       */
      get: function() {
        return this._updateFPS;
      },
      set: function(t) {
        t !== this._updateFPS && (this._updateFPS = t);
      },
      enumerable: false,
      configurable: true
    }), e.test = function(t, r) {
      return globalThis.HTMLVideoElement && t instanceof HTMLVideoElement || e.TYPES.indexOf(r) > -1;
    }, e.TYPES = ["mp4", "m4v", "webm", "ogg", "ogv", "h264", "avi", "mov"], e.MIME_TYPES = {
      ogv: "video/ogg",
      mov: "video/quicktime",
      m4v: "video/mp4"
    }, e;
  }(BaseImageResource)
), ImageBitmapResource = (
  /** @class */
  function(i2) {
    __extends$1(e, i2);
    function e(t) {
      return i2.call(this, t) || this;
    }
    return e.test = function(t) {
      return !!globalThis.createImageBitmap && typeof ImageBitmap < "u" && t instanceof ImageBitmap;
    }, e;
  }(BaseImageResource)
);
INSTALLED.push(ImageResource, ImageBitmapResource, CanvasResource, VideoResource, SVGResource, BufferResource, CubeResource, ArrayResource);
var DepthResource = (
  /** @class */
  function(i2) {
    __extends$1(e, i2);
    function e() {
      return i2 !== null && i2.apply(this, arguments) || this;
    }
    return e.prototype.upload = function(t, r, a) {
      var s = t.gl;
      s.pixelStorei(s.UNPACK_PREMULTIPLY_ALPHA_WEBGL, r.alphaMode === ALPHA_MODES.UNPACK);
      var u = r.realWidth, l = r.realHeight;
      return a.width === u && a.height === l ? s.texSubImage2D(r.target, 0, 0, 0, u, l, r.format, a.type, this.data) : (a.width = u, a.height = l, s.texImage2D(r.target, 0, a.internalFormat, u, l, 0, r.format, a.type, this.data)), true;
    }, e;
  }(BufferResource)
), Framebuffer = (
  /** @class */
  function() {
    function i2(e, t) {
      this.width = Math.round(e || 100), this.height = Math.round(t || 100), this.stencil = false, this.depth = false, this.dirtyId = 0, this.dirtyFormat = 0, this.dirtySize = 0, this.depthTexture = null, this.colorTextures = [], this.glFramebuffers = {}, this.disposeRunner = new Runner("disposeFramebuffer"), this.multisample = MSAA_QUALITY.NONE;
    }
    return Object.defineProperty(i2.prototype, "colorTexture", {
      /**
       * Reference to the colorTexture.
       * @readonly
       */
      get: function() {
        return this.colorTextures[0];
      },
      enumerable: false,
      configurable: true
    }), i2.prototype.addColorTexture = function(e, t) {
      return e === void 0 && (e = 0), this.colorTextures[e] = t || new BaseTexture$1(null, {
        scaleMode: SCALE_MODES.NEAREST,
        resolution: 1,
        mipmap: MIPMAP_MODES.OFF,
        width: this.width,
        height: this.height
      }), this.dirtyId++, this.dirtyFormat++, this;
    }, i2.prototype.addDepthTexture = function(e) {
      return this.depthTexture = e || new BaseTexture$1(new DepthResource(null, { width: this.width, height: this.height }), {
        scaleMode: SCALE_MODES.NEAREST,
        resolution: 1,
        width: this.width,
        height: this.height,
        mipmap: MIPMAP_MODES.OFF,
        format: FORMATS.DEPTH_COMPONENT,
        type: TYPES.UNSIGNED_SHORT
      }), this.dirtyId++, this.dirtyFormat++, this;
    }, i2.prototype.enableDepth = function() {
      return this.depth = true, this.dirtyId++, this.dirtyFormat++, this;
    }, i2.prototype.enableStencil = function() {
      return this.stencil = true, this.dirtyId++, this.dirtyFormat++, this;
    }, i2.prototype.resize = function(e, t) {
      if (e = Math.round(e), t = Math.round(t), !(e === this.width && t === this.height)) {
        this.width = e, this.height = t, this.dirtyId++, this.dirtySize++;
        for (var r = 0; r < this.colorTextures.length; r++) {
          var a = this.colorTextures[r], s = a.resolution;
          a.setSize(e / s, t / s);
        }
        if (this.depthTexture) {
          var s = this.depthTexture.resolution;
          this.depthTexture.setSize(e / s, t / s);
        }
      }
    }, i2.prototype.dispose = function() {
      this.disposeRunner.emit(this, false);
    }, i2.prototype.destroyDepthTexture = function() {
      this.depthTexture && (this.depthTexture.destroy(), this.depthTexture = null, ++this.dirtyId, ++this.dirtyFormat);
    }, i2;
  }()
), BaseRenderTexture$1 = (
  /** @class */
  function(i2) {
    __extends$1(e, i2);
    function e(t) {
      t === void 0 && (t = {});
      var r = this;
      if (typeof t == "number") {
        var a = arguments[0], s = arguments[1], u = arguments[2], l = arguments[3];
        t = { width: a, height: s, scaleMode: u, resolution: l };
      }
      return t.width = t.width || 100, t.height = t.height || 100, t.multisample = t.multisample !== void 0 ? t.multisample : MSAA_QUALITY.NONE, r = i2.call(this, null, t) || this, r.mipmap = MIPMAP_MODES.OFF, r.valid = true, r.clearColor = [0, 0, 0, 0], r.framebuffer = new Framebuffer(r.realWidth, r.realHeight).addColorTexture(0, r), r.framebuffer.multisample = t.multisample, r.maskStack = [], r.filterStack = [{}], r;
    }
    return e.prototype.resize = function(t, r) {
      this.framebuffer.resize(t * this.resolution, r * this.resolution), this.setRealSize(this.framebuffer.width, this.framebuffer.height);
    }, e.prototype.dispose = function() {
      this.framebuffer.dispose(), i2.prototype.dispose.call(this);
    }, e.prototype.destroy = function() {
      i2.prototype.destroy.call(this), this.framebuffer.destroyDepthTexture(), this.framebuffer = null;
    }, e;
  }(BaseTexture$1)
), TextureUvs$1 = (
  /** @class */
  function() {
    function i2() {
      this.x0 = 0, this.y0 = 0, this.x1 = 1, this.y1 = 0, this.x2 = 1, this.y2 = 1, this.x3 = 0, this.y3 = 1, this.uvsFloat32 = new Float32Array(8);
    }
    return i2.prototype.set = function(e, t, r) {
      var a = t.width, s = t.height;
      if (r) {
        var u = e.width / 2 / a, l = e.height / 2 / s, c = e.x / a + u, d = e.y / s + l;
        r = groupD8.add(r, groupD8.NW), this.x0 = c + u * groupD8.uX(r), this.y0 = d + l * groupD8.uY(r), r = groupD8.add(r, 2), this.x1 = c + u * groupD8.uX(r), this.y1 = d + l * groupD8.uY(r), r = groupD8.add(r, 2), this.x2 = c + u * groupD8.uX(r), this.y2 = d + l * groupD8.uY(r), r = groupD8.add(r, 2), this.x3 = c + u * groupD8.uX(r), this.y3 = d + l * groupD8.uY(r);
      } else
        this.x0 = e.x / a, this.y0 = e.y / s, this.x1 = (e.x + e.width) / a, this.y1 = e.y / s, this.x2 = (e.x + e.width) / a, this.y2 = (e.y + e.height) / s, this.x3 = e.x / a, this.y3 = (e.y + e.height) / s;
      this.uvsFloat32[0] = this.x0, this.uvsFloat32[1] = this.y0, this.uvsFloat32[2] = this.x1, this.uvsFloat32[3] = this.y1, this.uvsFloat32[4] = this.x2, this.uvsFloat32[5] = this.y2, this.uvsFloat32[6] = this.x3, this.uvsFloat32[7] = this.y3;
    }, i2.prototype.toString = function() {
      return "[@pixi/core:TextureUvs " + ("x0=" + this.x0 + " y0=" + this.y0 + " ") + ("x1=" + this.x1 + " y1=" + this.y1 + " x2=" + this.x2 + " ") + ("y2=" + this.y2 + " x3=" + this.x3 + " y3=" + this.y3) + "]";
    }, i2;
  }()
), DEFAULT_UVS = new TextureUvs$1();
function removeAllHandlers(i2) {
  i2.destroy = function() {
  }, i2.on = function() {
  }, i2.once = function() {
  }, i2.emit = function() {
  };
}
var Texture$1 = (
  /** @class */
  function(i2) {
    __extends$1(e, i2);
    function e(t, r, a, s, u, l) {
      var c = i2.call(this) || this;
      if (c.noFrame = false, r || (c.noFrame = true, r = new Rectangle$1(0, 0, 1, 1)), t instanceof e && (t = t.baseTexture), c.baseTexture = t, c._frame = r, c.trim = s, c.valid = false, c._uvs = DEFAULT_UVS, c.uvMatrix = null, c.orig = a || r, c._rotate = Number(u || 0), u === true)
        c._rotate = 2;
      else if (c._rotate % 2 !== 0)
        throw new Error("attempt to use diamond-shaped UVs. If you are sure, set rotation manually");
      return c.defaultAnchor = l ? new Point$1(l.x, l.y) : new Point$1(0, 0), c._updateID = 0, c.textureCacheIds = [], t.valid ? c.noFrame ? t.valid && c.onBaseTextureUpdated(t) : c.frame = r : t.once("loaded", c.onBaseTextureUpdated, c), c.noFrame && t.on("update", c.onBaseTextureUpdated, c), c;
    }
    return e.prototype.update = function() {
      this.baseTexture.resource && this.baseTexture.resource.update();
    }, e.prototype.onBaseTextureUpdated = function(t) {
      if (this.noFrame) {
        if (!this.baseTexture.valid)
          return;
        this._frame.width = t.width, this._frame.height = t.height, this.valid = true, this.updateUvs();
      } else
        this.frame = this._frame;
      this.emit("update", this);
    }, e.prototype.destroy = function(t) {
      if (this.baseTexture) {
        if (t) {
          var r = this.baseTexture.resource;
          r && r.url && TextureCache[r.url] && e.removeFromCache(r.url), this.baseTexture.destroy();
        }
        this.baseTexture.off("loaded", this.onBaseTextureUpdated, this), this.baseTexture.off("update", this.onBaseTextureUpdated, this), this.baseTexture = null;
      }
      this._frame = null, this._uvs = null, this.trim = null, this.orig = null, this.valid = false, e.removeFromCache(this), this.textureCacheIds = null;
    }, e.prototype.clone = function() {
      var t = this._frame.clone(), r = this._frame === this.orig ? t : this.orig.clone(), a = new e(this.baseTexture, !this.noFrame && t, r, this.trim && this.trim.clone(), this.rotate, this.defaultAnchor);
      return this.noFrame && (a._frame = t), a;
    }, e.prototype.updateUvs = function() {
      this._uvs === DEFAULT_UVS && (this._uvs = new TextureUvs$1()), this._uvs.set(this._frame, this.baseTexture, this.rotate), this._updateID++;
    }, e.from = function(t, r, a) {
      r === void 0 && (r = {}), a === void 0 && (a = settings$1.STRICT_TEXTURE_CACHE);
      var s = typeof t == "string", u = null;
      if (s)
        u = t;
      else if (t instanceof BaseTexture$1) {
        if (!t.cacheId) {
          var l = r && r.pixiIdPrefix || "pixiid";
          t.cacheId = l + "-" + uid$3(), BaseTexture$1.addToCache(t, t.cacheId);
        }
        u = t.cacheId;
      } else {
        if (!t._pixiId) {
          var l = r && r.pixiIdPrefix || "pixiid";
          t._pixiId = l + "_" + uid$3();
        }
        u = t._pixiId;
      }
      var c = TextureCache[u];
      if (s && a && !c)
        throw new Error('The cacheId "' + u + '" does not exist in TextureCache.');
      return !c && !(t instanceof BaseTexture$1) ? (r.resolution || (r.resolution = getResolutionOfUrl(t)), c = new e(new BaseTexture$1(t, r)), c.baseTexture.cacheId = u, BaseTexture$1.addToCache(c.baseTexture, u), e.addToCache(c, u)) : !c && t instanceof BaseTexture$1 && (c = new e(t), e.addToCache(c, u)), c;
    }, e.fromURL = function(t, r) {
      var a = Object.assign({ autoLoad: false }, r == null ? void 0 : r.resourceOptions), s = e.from(t, Object.assign({ resourceOptions: a }, r), false), u = s.baseTexture.resource;
      return s.baseTexture.valid ? Promise.resolve(s) : u.load().then(function() {
        return Promise.resolve(s);
      });
    }, e.fromBuffer = function(t, r, a, s) {
      return new e(BaseTexture$1.fromBuffer(t, r, a, s));
    }, e.fromLoader = function(t, r, a, s) {
      var u = new BaseTexture$1(t, Object.assign({
        scaleMode: settings$1.SCALE_MODE,
        resolution: getResolutionOfUrl(r)
      }, s)), l = u.resource;
      l instanceof ImageResource && (l.url = r);
      var c = new e(u);
      return a || (a = r), BaseTexture$1.addToCache(c.baseTexture, a), e.addToCache(c, a), a !== r && (BaseTexture$1.addToCache(c.baseTexture, r), e.addToCache(c, r)), c.baseTexture.valid ? Promise.resolve(c) : new Promise(function(d) {
        c.baseTexture.once("loaded", function() {
          return d(c);
        });
      });
    }, e.addToCache = function(t, r) {
      r && (t.textureCacheIds.indexOf(r) === -1 && t.textureCacheIds.push(r), TextureCache[r] && console.warn("Texture added to the cache with an id [" + r + "] that already had an entry"), TextureCache[r] = t);
    }, e.removeFromCache = function(t) {
      if (typeof t == "string") {
        var r = TextureCache[t];
        if (r) {
          var a = r.textureCacheIds.indexOf(t);
          return a > -1 && r.textureCacheIds.splice(a, 1), delete TextureCache[t], r;
        }
      } else if (t && t.textureCacheIds) {
        for (var s = 0; s < t.textureCacheIds.length; ++s)
          TextureCache[t.textureCacheIds[s]] === t && delete TextureCache[t.textureCacheIds[s]];
        return t.textureCacheIds.length = 0, t;
      }
      return null;
    }, Object.defineProperty(e.prototype, "resolution", {
      /**
       * Returns resolution of baseTexture
       * @readonly
       */
      get: function() {
        return this.baseTexture.resolution;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(e.prototype, "frame", {
      /**
       * The frame specifies the region of the base texture that this texture uses.
       * Please call `updateUvs()` after you change coordinates of `frame` manually.
       */
      get: function() {
        return this._frame;
      },
      set: function(t) {
        this._frame = t, this.noFrame = false;
        var r = t.x, a = t.y, s = t.width, u = t.height, l = r + s > this.baseTexture.width, c = a + u > this.baseTexture.height;
        if (l || c) {
          var d = l && c ? "and" : "or", f = "X: " + r + " + " + s + " = " + (r + s) + " > " + this.baseTexture.width, p = "Y: " + a + " + " + u + " = " + (a + u) + " > " + this.baseTexture.height;
          throw new Error("Texture Error: frame does not fit inside the base Texture dimensions: " + (f + " " + d + " " + p));
        }
        this.valid = s && u && this.baseTexture.valid, !this.trim && !this.rotate && (this.orig = t), this.valid && this.updateUvs();
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(e.prototype, "rotate", {
      /**
       * Indicates whether the texture is rotated inside the atlas
       * set to 2 to compensate for texture packer rotation
       * set to 6 to compensate for spine packer rotation
       * can be used to rotate or mirror sprites
       * See {@link PIXI.groupD8} for explanation
       */
      get: function() {
        return this._rotate;
      },
      set: function(t) {
        this._rotate = t, this.valid && this.updateUvs();
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(e.prototype, "width", {
      /** The width of the Texture in pixels. */
      get: function() {
        return this.orig.width;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(e.prototype, "height", {
      /** The height of the Texture in pixels. */
      get: function() {
        return this.orig.height;
      },
      enumerable: false,
      configurable: true
    }), e.prototype.castToBaseTexture = function() {
      return this.baseTexture;
    }, Object.defineProperty(e, "EMPTY", {
      /** An empty texture, used often to not have to create multiple empty textures. Can not be destroyed. */
      get: function() {
        return e._EMPTY || (e._EMPTY = new e(new BaseTexture$1()), removeAllHandlers(e._EMPTY), removeAllHandlers(e._EMPTY.baseTexture)), e._EMPTY;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(e, "WHITE", {
      /** A white texture of 16x16 size, used for graphics and other things Can not be destroyed. */
      get: function() {
        if (!e._WHITE) {
          var t = settings$1.ADAPTER.createCanvas(16, 16), r = t.getContext("2d");
          t.width = 16, t.height = 16, r.fillStyle = "white", r.fillRect(0, 0, 16, 16), e._WHITE = new e(BaseTexture$1.from(t)), removeAllHandlers(e._WHITE), removeAllHandlers(e._WHITE.baseTexture);
        }
        return e._WHITE;
      },
      enumerable: false,
      configurable: true
    }), e;
  }(EventEmitter)
), RenderTexture$1 = (
  /** @class */
  function(i2) {
    __extends$1(e, i2);
    function e(t, r) {
      var a = i2.call(this, t, r) || this;
      return a.valid = true, a.filterFrame = null, a.filterPoolKey = null, a.updateUvs(), a;
    }
    return Object.defineProperty(e.prototype, "framebuffer", {
      /**
       * Shortcut to `this.baseTexture.framebuffer`, saves baseTexture cast.
       * @readonly
       */
      get: function() {
        return this.baseTexture.framebuffer;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(e.prototype, "multisample", {
      /**
       * Shortcut to `this.framebuffer.multisample`.
       * @default PIXI.MSAA_QUALITY.NONE
       */
      get: function() {
        return this.framebuffer.multisample;
      },
      set: function(t) {
        this.framebuffer.multisample = t;
      },
      enumerable: false,
      configurable: true
    }), e.prototype.resize = function(t, r, a) {
      a === void 0 && (a = true);
      var s = this.baseTexture.resolution, u = Math.round(t * s) / s, l = Math.round(r * s) / s;
      this.valid = u > 0 && l > 0, this._frame.width = this.orig.width = u, this._frame.height = this.orig.height = l, a && this.baseTexture.resize(u, l), this.updateUvs();
    }, e.prototype.setResolution = function(t) {
      var r = this.baseTexture;
      r.resolution !== t && (r.setResolution(t), this.resize(r.width, r.height, false));
    }, e.create = function(t) {
      for (var r = arguments, a = [], s = 1; s < arguments.length; s++)
        a[s - 1] = r[s];
      return typeof t == "number" && (deprecation("6.0.0", "Arguments (width, height, scaleMode, resolution) have been deprecated."), t = {
        width: t,
        height: a[0],
        scaleMode: a[1],
        resolution: a[2]
      }), new e(new BaseRenderTexture$1(t));
    }, e;
  }(Texture$1)
), RenderTexturePool = (
  /** @class */
  function() {
    function i2(e) {
      this.texturePool = {}, this.textureOptions = e || {}, this.enableFullScreen = false, this._pixelsWidth = 0, this._pixelsHeight = 0;
    }
    return i2.prototype.createTexture = function(e, t, r) {
      r === void 0 && (r = MSAA_QUALITY.NONE);
      var a = new BaseRenderTexture$1(Object.assign({
        width: e,
        height: t,
        resolution: 1,
        multisample: r
      }, this.textureOptions));
      return new RenderTexture$1(a);
    }, i2.prototype.getOptimalTexture = function(e, t, r, a) {
      r === void 0 && (r = 1), a === void 0 && (a = MSAA_QUALITY.NONE);
      var s;
      e = Math.ceil(e * r - 1e-6), t = Math.ceil(t * r - 1e-6), !this.enableFullScreen || e !== this._pixelsWidth || t !== this._pixelsHeight ? (e = nextPow2(e), t = nextPow2(t), s = ((e & 65535) << 16 | t & 65535) >>> 0, a > 1 && (s += a * 4294967296)) : s = a > 1 ? -a : -1, this.texturePool[s] || (this.texturePool[s] = []);
      var u = this.texturePool[s].pop();
      return u || (u = this.createTexture(e, t, a)), u.filterPoolKey = s, u.setResolution(r), u;
    }, i2.prototype.getFilterTexture = function(e, t, r) {
      var a = this.getOptimalTexture(e.width, e.height, t || e.resolution, r || MSAA_QUALITY.NONE);
      return a.filterFrame = e.filterFrame, a;
    }, i2.prototype.returnTexture = function(e) {
      var t = e.filterPoolKey;
      e.filterFrame = null, this.texturePool[t].push(e);
    }, i2.prototype.returnFilterTexture = function(e) {
      this.returnTexture(e);
    }, i2.prototype.clear = function(e) {
      if (e = e !== false, e)
        for (var t in this.texturePool) {
          var r = this.texturePool[t];
          if (r)
            for (var a = 0; a < r.length; a++)
              r[a].destroy(true);
        }
      this.texturePool = {};
    }, i2.prototype.setScreenSize = function(e) {
      if (!(e.width === this._pixelsWidth && e.height === this._pixelsHeight)) {
        this.enableFullScreen = e.width > 0 && e.height > 0;
        for (var t in this.texturePool)
          if (Number(t) < 0) {
            var r = this.texturePool[t];
            if (r)
              for (var a = 0; a < r.length; a++)
                r[a].destroy(true);
            this.texturePool[t] = [];
          }
        this._pixelsWidth = e.width, this._pixelsHeight = e.height;
      }
    }, i2.SCREEN_KEY = -1, i2;
  }()
), Attribute = (
  /** @class */
  function() {
    function i2(e, t, r, a, s, u, l) {
      t === void 0 && (t = 0), r === void 0 && (r = false), a === void 0 && (a = TYPES.FLOAT), this.buffer = e, this.size = t, this.normalized = r, this.type = a, this.stride = s, this.start = u, this.instance = l;
    }
    return i2.prototype.destroy = function() {
      this.buffer = null;
    }, i2.from = function(e, t, r, a, s) {
      return new i2(e, t, r, a, s);
    }, i2;
  }()
), UID$4 = 0, Buffer$1 = (
  /** @class */
  function() {
    function i2(e, t, r) {
      t === void 0 && (t = true), r === void 0 && (r = false), this.data = e || new Float32Array(1), this._glBuffers = {}, this._updateID = 0, this.index = r, this.static = t, this.id = UID$4++, this.disposeRunner = new Runner("disposeBuffer");
    }
    return i2.prototype.update = function(e) {
      e instanceof Array && (e = new Float32Array(e)), this.data = e || this.data, this._updateID++;
    }, i2.prototype.dispose = function() {
      this.disposeRunner.emit(this, false);
    }, i2.prototype.destroy = function() {
      this.dispose(), this.data = null;
    }, Object.defineProperty(i2.prototype, "index", {
      get: function() {
        return this.type === BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;
      },
      /**
       * Flags whether this is an index buffer.
       *
       * Index buffers are of type `ELEMENT_ARRAY_BUFFER`. Note that setting this property to false will make
       * the buffer of type `ARRAY_BUFFER`.
       *
       * For backwards compatibility.
       */
      set: function(e) {
        this.type = e ? BUFFER_TYPE.ELEMENT_ARRAY_BUFFER : BUFFER_TYPE.ARRAY_BUFFER;
      },
      enumerable: false,
      configurable: true
    }), i2.from = function(e) {
      return e instanceof Array && (e = new Float32Array(e)), new i2(e);
    }, i2;
  }()
), map$1 = {
  Float32Array,
  Uint32Array,
  Int32Array,
  Uint8Array
};
function interleaveTypedArrays(i2, e) {
  for (var t = 0, r = 0, a = {}, s = 0; s < i2.length; s++)
    r += e[s], t += i2[s].length;
  for (var u = new ArrayBuffer(t * 4), l = null, c = 0, s = 0; s < i2.length; s++) {
    var d = e[s], f = i2[s], p = getBufferType(f);
    a[p] || (a[p] = new map$1[p](u)), l = a[p];
    for (var m = 0; m < f.length; m++) {
      var y = (m / d | 0) * r + c, x = m % d;
      l[y + x] = f[m];
    }
    c += d;
  }
  return new Float32Array(u);
}
var byteSizeMap$1 = { 5126: 4, 5123: 2, 5121: 1 }, UID$3 = 0, map = {
  Float32Array,
  Uint32Array,
  Int32Array,
  Uint8Array,
  Uint16Array
}, Geometry = (
  /** @class */
  function() {
    function i2(e, t) {
      e === void 0 && (e = []), t === void 0 && (t = {}), this.buffers = e, this.indexBuffer = null, this.attributes = t, this.glVertexArrayObjects = {}, this.id = UID$3++, this.instanced = false, this.instanceCount = 1, this.disposeRunner = new Runner("disposeGeometry"), this.refCount = 0;
    }
    return i2.prototype.addAttribute = function(e, t, r, a, s, u, l, c) {
      if (r === void 0 && (r = 0), a === void 0 && (a = false), c === void 0 && (c = false), !t)
        throw new Error("You must pass a buffer when creating an attribute");
      t instanceof Buffer$1 || (t instanceof Array && (t = new Float32Array(t)), t = new Buffer$1(t));
      var d = e.split("|");
      if (d.length > 1) {
        for (var f = 0; f < d.length; f++)
          this.addAttribute(d[f], t, r, a, s);
        return this;
      }
      var p = this.buffers.indexOf(t);
      return p === -1 && (this.buffers.push(t), p = this.buffers.length - 1), this.attributes[e] = new Attribute(p, r, a, s, u, l, c), this.instanced = this.instanced || c, this;
    }, i2.prototype.getAttribute = function(e) {
      return this.attributes[e];
    }, i2.prototype.getBuffer = function(e) {
      return this.buffers[this.getAttribute(e).buffer];
    }, i2.prototype.addIndex = function(e) {
      return e instanceof Buffer$1 || (e instanceof Array && (e = new Uint16Array(e)), e = new Buffer$1(e)), e.type = BUFFER_TYPE.ELEMENT_ARRAY_BUFFER, this.indexBuffer = e, this.buffers.indexOf(e) === -1 && this.buffers.push(e), this;
    }, i2.prototype.getIndex = function() {
      return this.indexBuffer;
    }, i2.prototype.interleave = function() {
      if (this.buffers.length === 1 || this.buffers.length === 2 && this.indexBuffer)
        return this;
      var e = [], t = [], r = new Buffer$1(), a;
      for (a in this.attributes) {
        var s = this.attributes[a], u = this.buffers[s.buffer];
        e.push(u.data), t.push(s.size * byteSizeMap$1[s.type] / 4), s.buffer = 0;
      }
      for (r.data = interleaveTypedArrays(e, t), a = 0; a < this.buffers.length; a++)
        this.buffers[a] !== this.indexBuffer && this.buffers[a].destroy();
      return this.buffers = [r], this.indexBuffer && this.buffers.push(this.indexBuffer), this;
    }, i2.prototype.getSize = function() {
      for (var e in this.attributes) {
        var t = this.attributes[e], r = this.buffers[t.buffer];
        return r.data.length / (t.stride / 4 || t.size);
      }
      return 0;
    }, i2.prototype.dispose = function() {
      this.disposeRunner.emit(this, false);
    }, i2.prototype.destroy = function() {
      this.dispose(), this.buffers = null, this.indexBuffer = null, this.attributes = null;
    }, i2.prototype.clone = function() {
      for (var e = new i2(), t = 0; t < this.buffers.length; t++)
        e.buffers[t] = new Buffer$1(this.buffers[t].data.slice(0));
      for (var t in this.attributes) {
        var r = this.attributes[t];
        e.attributes[t] = new Attribute(r.buffer, r.size, r.normalized, r.type, r.stride, r.start, r.instance);
      }
      return this.indexBuffer && (e.indexBuffer = e.buffers[this.buffers.indexOf(this.indexBuffer)], e.indexBuffer.type = BUFFER_TYPE.ELEMENT_ARRAY_BUFFER), e;
    }, i2.merge = function(e) {
      for (var t = new i2(), r = [], a = [], s = [], u, l = 0; l < e.length; l++) {
        u = e[l];
        for (var c = 0; c < u.buffers.length; c++)
          a[c] = a[c] || 0, a[c] += u.buffers[c].data.length, s[c] = 0;
      }
      for (var l = 0; l < u.buffers.length; l++)
        r[l] = new map[getBufferType(u.buffers[l].data)](a[l]), t.buffers[l] = new Buffer$1(r[l]);
      for (var l = 0; l < e.length; l++) {
        u = e[l];
        for (var c = 0; c < u.buffers.length; c++)
          r[c].set(u.buffers[c].data, s[c]), s[c] += u.buffers[c].data.length;
      }
      if (t.attributes = u.attributes, u.indexBuffer) {
        t.indexBuffer = t.buffers[u.buffers.indexOf(u.indexBuffer)], t.indexBuffer.type = BUFFER_TYPE.ELEMENT_ARRAY_BUFFER;
        for (var d = 0, f = 0, p = 0, m = 0, l = 0; l < u.buffers.length; l++)
          if (u.buffers[l] !== u.indexBuffer) {
            m = l;
            break;
          }
        for (var l in u.attributes) {
          var y = u.attributes[l];
          (y.buffer | 0) === m && (f += y.size * byteSizeMap$1[y.type] / 4);
        }
        for (var l = 0; l < e.length; l++) {
          for (var x = e[l].indexBuffer.data, c = 0; c < x.length; c++)
            t.indexBuffer.data[c + p] += d;
          d += e[l].buffers[m].data.length / f, p += x.length;
        }
      }
      return t;
    }, i2;
  }()
), Quad$1 = (
  /** @class */
  function(i2) {
    __extends$1(e, i2);
    function e() {
      var t = i2.call(this) || this;
      return t.addAttribute("aVertexPosition", new Float32Array([
        0,
        0,
        1,
        0,
        1,
        1,
        0,
        1
      ])).addIndex([0, 1, 3, 2]), t;
    }
    return e;
  }(Geometry)
), QuadUv = (
  /** @class */
  function(i2) {
    __extends$1(e, i2);
    function e() {
      var t = i2.call(this) || this;
      return t.vertices = new Float32Array([
        -1,
        -1,
        1,
        -1,
        1,
        1,
        -1,
        1
      ]), t.uvs = new Float32Array([
        0,
        0,
        1,
        0,
        1,
        1,
        0,
        1
      ]), t.vertexBuffer = new Buffer$1(t.vertices), t.uvBuffer = new Buffer$1(t.uvs), t.addAttribute("aVertexPosition", t.vertexBuffer).addAttribute("aTextureCoord", t.uvBuffer).addIndex([0, 1, 2, 0, 2, 3]), t;
    }
    return e.prototype.map = function(t, r) {
      var a = 0, s = 0;
      return this.uvs[0] = a, this.uvs[1] = s, this.uvs[2] = a + r.width / t.width, this.uvs[3] = s, this.uvs[4] = a + r.width / t.width, this.uvs[5] = s + r.height / t.height, this.uvs[6] = a, this.uvs[7] = s + r.height / t.height, a = r.x, s = r.y, this.vertices[0] = a, this.vertices[1] = s, this.vertices[2] = a + r.width, this.vertices[3] = s, this.vertices[4] = a + r.width, this.vertices[5] = s + r.height, this.vertices[6] = a, this.vertices[7] = s + r.height, this.invalidate(), this;
    }, e.prototype.invalidate = function() {
      return this.vertexBuffer._updateID++, this.uvBuffer._updateID++, this;
    }, e;
  }(Geometry)
), UID$2 = 0, UniformGroup = (
  /** @class */
  function() {
    function i2(e, t, r) {
      this.group = true, this.syncUniforms = {}, this.dirtyId = 0, this.id = UID$2++, this.static = !!t, this.ubo = !!r, e instanceof Buffer$1 ? (this.buffer = e, this.buffer.type = BUFFER_TYPE.UNIFORM_BUFFER, this.autoManage = false, this.ubo = true) : (this.uniforms = e, this.ubo && (this.buffer = new Buffer$1(new Float32Array(1)), this.buffer.type = BUFFER_TYPE.UNIFORM_BUFFER, this.autoManage = true));
    }
    return i2.prototype.update = function() {
      this.dirtyId++, !this.autoManage && this.buffer && this.buffer.update();
    }, i2.prototype.add = function(e, t, r) {
      if (!this.ubo)
        this.uniforms[e] = new i2(t, r);
      else
        throw new Error("[UniformGroup] uniform groups in ubo mode cannot be modified, or have uniform groups nested in them");
    }, i2.from = function(e, t, r) {
      return new i2(e, t, r);
    }, i2.uboFrom = function(e, t) {
      return new i2(e, t ?? true, true);
    }, i2;
  }()
), FilterState = (
  /** @class */
  function() {
    function i2() {
      this.renderTexture = null, this.target = null, this.legacy = false, this.resolution = 1, this.multisample = MSAA_QUALITY.NONE, this.sourceFrame = new Rectangle$1(), this.destinationFrame = new Rectangle$1(), this.bindingSourceFrame = new Rectangle$1(), this.bindingDestinationFrame = new Rectangle$1(), this.filters = [], this.transform = null;
    }
    return i2.prototype.clear = function() {
      this.target = null, this.filters = null, this.renderTexture = null;
    }, i2;
  }()
), tempPoints = [new Point$1(), new Point$1(), new Point$1(), new Point$1()], tempMatrix$2 = new Matrix$1(), FilterSystem = (
  /** @class */
  function() {
    function i2(e) {
      this.renderer = e, this.defaultFilterStack = [{}], this.texturePool = new RenderTexturePool(), this.texturePool.setScreenSize(e.view), this.statePool = [], this.quad = new Quad$1(), this.quadUv = new QuadUv(), this.tempRect = new Rectangle$1(), this.activeState = {}, this.globalUniforms = new UniformGroup({
        outputFrame: new Rectangle$1(),
        inputSize: new Float32Array(4),
        inputPixel: new Float32Array(4),
        inputClamp: new Float32Array(4),
        resolution: 1,
        // legacy variables
        filterArea: new Float32Array(4),
        filterClamp: new Float32Array(4)
      }, true), this.forceClear = false, this.useMaxPadding = false;
    }
    return i2.prototype.push = function(e, t) {
      for (var r, a, s = this.renderer, u = this.defaultFilterStack, l = this.statePool.pop() || new FilterState(), c = this.renderer.renderTexture, d = t[0].resolution, f = t[0].multisample, p = t[0].padding, m = t[0].autoFit, y = (r = t[0].legacy) !== null && r !== void 0 ? r : true, x = 1; x < t.length; x++) {
        var g = t[x];
        d = Math.min(d, g.resolution), f = Math.min(f, g.multisample), p = this.useMaxPadding ? Math.max(p, g.padding) : p + g.padding, m = m && g.autoFit, y = y || ((a = g.legacy) !== null && a !== void 0 ? a : true);
      }
      u.length === 1 && (this.defaultFilterStack[0].renderTexture = c.current), u.push(l), l.resolution = d, l.multisample = f, l.legacy = y, l.target = e, l.sourceFrame.copyFrom(e.filterArea || e.getBounds(true)), l.sourceFrame.pad(p);
      var _ = this.tempRect.copyFrom(c.sourceFrame);
      s.projection.transform && this.transformAABB(tempMatrix$2.copyFrom(s.projection.transform).invert(), _), m ? (l.sourceFrame.fit(_), (l.sourceFrame.width <= 0 || l.sourceFrame.height <= 0) && (l.sourceFrame.width = 0, l.sourceFrame.height = 0)) : l.sourceFrame.intersects(_) || (l.sourceFrame.width = 0, l.sourceFrame.height = 0), this.roundFrame(l.sourceFrame, c.current ? c.current.resolution : s.resolution, c.sourceFrame, c.destinationFrame, s.projection.transform), l.renderTexture = this.getOptimalFilterTexture(l.sourceFrame.width, l.sourceFrame.height, d, f), l.filters = t, l.destinationFrame.width = l.renderTexture.width, l.destinationFrame.height = l.renderTexture.height;
      var T = this.tempRect;
      T.x = 0, T.y = 0, T.width = l.sourceFrame.width, T.height = l.sourceFrame.height, l.renderTexture.filterFrame = l.sourceFrame, l.bindingSourceFrame.copyFrom(c.sourceFrame), l.bindingDestinationFrame.copyFrom(c.destinationFrame), l.transform = s.projection.transform, s.projection.transform = null, c.bind(l.renderTexture, l.sourceFrame, T), s.framebuffer.clear(0, 0, 0, 0);
    }, i2.prototype.pop = function() {
      var e = this.defaultFilterStack, t = e.pop(), r = t.filters;
      this.activeState = t;
      var a = this.globalUniforms.uniforms;
      a.outputFrame = t.sourceFrame, a.resolution = t.resolution;
      var s = a.inputSize, u = a.inputPixel, l = a.inputClamp;
      if (s[0] = t.destinationFrame.width, s[1] = t.destinationFrame.height, s[2] = 1 / s[0], s[3] = 1 / s[1], u[0] = Math.round(s[0] * t.resolution), u[1] = Math.round(s[1] * t.resolution), u[2] = 1 / u[0], u[3] = 1 / u[1], l[0] = 0.5 * u[2], l[1] = 0.5 * u[3], l[2] = t.sourceFrame.width * s[2] - 0.5 * u[2], l[3] = t.sourceFrame.height * s[3] - 0.5 * u[3], t.legacy) {
        var c = a.filterArea;
        c[0] = t.destinationFrame.width, c[1] = t.destinationFrame.height, c[2] = t.sourceFrame.x, c[3] = t.sourceFrame.y, a.filterClamp = a.inputClamp;
      }
      this.globalUniforms.update();
      var d = e[e.length - 1];
      if (this.renderer.framebuffer.blit(), r.length === 1)
        r[0].apply(this, t.renderTexture, d.renderTexture, CLEAR_MODES.BLEND, t), this.returnFilterTexture(t.renderTexture);
      else {
        var f = t.renderTexture, p = this.getOptimalFilterTexture(f.width, f.height, t.resolution);
        p.filterFrame = f.filterFrame;
        var m = 0;
        for (m = 0; m < r.length - 1; ++m) {
          m === 1 && t.multisample > 1 && (p = this.getOptimalFilterTexture(f.width, f.height, t.resolution), p.filterFrame = f.filterFrame), r[m].apply(this, f, p, CLEAR_MODES.CLEAR, t);
          var y = f;
          f = p, p = y;
        }
        r[m].apply(this, f, d.renderTexture, CLEAR_MODES.BLEND, t), m > 1 && t.multisample > 1 && this.returnFilterTexture(t.renderTexture), this.returnFilterTexture(f), this.returnFilterTexture(p);
      }
      t.clear(), this.statePool.push(t);
    }, i2.prototype.bindAndClear = function(e, t) {
      t === void 0 && (t = CLEAR_MODES.CLEAR);
      var r = this.renderer, a = r.renderTexture, s = r.state;
      if (e === this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture ? this.renderer.projection.transform = this.activeState.transform : this.renderer.projection.transform = null, e && e.filterFrame) {
        var u = this.tempRect;
        u.x = 0, u.y = 0, u.width = e.filterFrame.width, u.height = e.filterFrame.height, a.bind(e, e.filterFrame, u);
      } else e !== this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture ? a.bind(e) : this.renderer.renderTexture.bind(e, this.activeState.bindingSourceFrame, this.activeState.bindingDestinationFrame);
      var l = s.stateId & 1 || this.forceClear;
      (t === CLEAR_MODES.CLEAR || t === CLEAR_MODES.BLIT && l) && this.renderer.framebuffer.clear(0, 0, 0, 0);
    }, i2.prototype.applyFilter = function(e, t, r, a) {
      var s = this.renderer;
      s.state.set(e.state), this.bindAndClear(r, a), e.uniforms.uSampler = t, e.uniforms.filterGlobals = this.globalUniforms, s.shader.bind(e), e.legacy = !!e.program.attributeData.aTextureCoord, e.legacy ? (this.quadUv.map(t._frame, t.filterFrame), s.geometry.bind(this.quadUv), s.geometry.draw(DRAW_MODES.TRIANGLES)) : (s.geometry.bind(this.quad), s.geometry.draw(DRAW_MODES.TRIANGLE_STRIP));
    }, i2.prototype.calculateSpriteMatrix = function(e, t) {
      var r = this.activeState, a = r.sourceFrame, s = r.destinationFrame, u = t._texture.orig, l = e.set(s.width, 0, 0, s.height, a.x, a.y), c = t.worldTransform.copyTo(Matrix$1.TEMP_MATRIX);
      return c.invert(), l.prepend(c), l.scale(1 / u.width, 1 / u.height), l.translate(t.anchor.x, t.anchor.y), l;
    }, i2.prototype.destroy = function() {
      this.renderer = null, this.texturePool.clear(false);
    }, i2.prototype.getOptimalFilterTexture = function(e, t, r, a) {
      return r === void 0 && (r = 1), a === void 0 && (a = MSAA_QUALITY.NONE), this.texturePool.getOptimalTexture(e, t, r, a);
    }, i2.prototype.getFilterTexture = function(e, t, r) {
      if (typeof e == "number") {
        var a = e;
        e = t, t = a;
      }
      e = e || this.activeState.renderTexture;
      var s = this.texturePool.getOptimalTexture(e.width, e.height, t || e.resolution, r || MSAA_QUALITY.NONE);
      return s.filterFrame = e.filterFrame, s;
    }, i2.prototype.returnFilterTexture = function(e) {
      this.texturePool.returnTexture(e);
    }, i2.prototype.emptyPool = function() {
      this.texturePool.clear(true);
    }, i2.prototype.resize = function() {
      this.texturePool.setScreenSize(this.renderer.view);
    }, i2.prototype.transformAABB = function(e, t) {
      var r = tempPoints[0], a = tempPoints[1], s = tempPoints[2], u = tempPoints[3];
      r.set(t.left, t.top), a.set(t.left, t.bottom), s.set(t.right, t.top), u.set(t.right, t.bottom), e.apply(r, r), e.apply(a, a), e.apply(s, s), e.apply(u, u);
      var l = Math.min(r.x, a.x, s.x, u.x), c = Math.min(r.y, a.y, s.y, u.y), d = Math.max(r.x, a.x, s.x, u.x), f = Math.max(r.y, a.y, s.y, u.y);
      t.x = l, t.y = c, t.width = d - l, t.height = f - c;
    }, i2.prototype.roundFrame = function(e, t, r, a, s) {
      if (!(e.width <= 0 || e.height <= 0 || r.width <= 0 || r.height <= 0)) {
        if (s) {
          var u = s.a, l = s.b, c = s.c, d = s.d;
          if ((Math.abs(l) > 1e-4 || Math.abs(c) > 1e-4) && (Math.abs(u) > 1e-4 || Math.abs(d) > 1e-4))
            return;
        }
        s = s ? tempMatrix$2.copyFrom(s) : tempMatrix$2.identity(), s.translate(-r.x, -r.y).scale(a.width / r.width, a.height / r.height).translate(a.x, a.y), this.transformAABB(s, e), e.ceil(t), this.transformAABB(s.invert(), e);
      }
    }, i2;
  }()
), ObjectRenderer$1 = (
  /** @class */
  function() {
    function i2(e) {
      this.renderer = e;
    }
    return i2.prototype.flush = function() {
    }, i2.prototype.destroy = function() {
      this.renderer = null;
    }, i2.prototype.start = function() {
    }, i2.prototype.stop = function() {
      this.flush();
    }, i2.prototype.render = function(e) {
    }, i2;
  }()
), BatchSystem = (
  /** @class */
  function() {
    function i2(e) {
      this.renderer = e, this.emptyRenderer = new ObjectRenderer$1(e), this.currentRenderer = this.emptyRenderer;
    }
    return i2.prototype.setObjectRenderer = function(e) {
      this.currentRenderer !== e && (this.currentRenderer.stop(), this.currentRenderer = e, this.currentRenderer.start());
    }, i2.prototype.flush = function() {
      this.setObjectRenderer(this.emptyRenderer);
    }, i2.prototype.reset = function() {
      this.setObjectRenderer(this.emptyRenderer);
    }, i2.prototype.copyBoundTextures = function(e, t) {
      for (var r = this.renderer.texture.boundTextures, a = t - 1; a >= 0; --a)
        e[a] = r[a] || null, e[a] && (e[a]._batchLocation = a);
    }, i2.prototype.boundArray = function(e, t, r, a) {
      for (var s = e.elements, u = e.ids, l = e.count, c = 0, d = 0; d < l; d++) {
        var f = s[d], p = f._batchLocation;
        if (p >= 0 && p < a && t[p] === f) {
          u[d] = p;
          continue;
        }
        for (; c < a; ) {
          var m = t[c];
          if (m && m._batchEnabled === r && m._batchLocation === c) {
            c++;
            continue;
          }
          u[d] = c, f._batchLocation = c, t[c] = f;
          break;
        }
      }
    }, i2.prototype.destroy = function() {
      this.renderer = null;
    }, i2;
  }()
), CONTEXT_UID_COUNTER = 0, ContextSystem = (
  /** @class */
  function() {
    function i2(e) {
      this.renderer = e, this.webGLVersion = 1, this.extensions = {}, this.supports = {
        uint32Indices: false
      }, this.handleContextLost = this.handleContextLost.bind(this), this.handleContextRestored = this.handleContextRestored.bind(this), e.view.addEventListener("webglcontextlost", this.handleContextLost, false), e.view.addEventListener("webglcontextrestored", this.handleContextRestored, false);
    }
    return Object.defineProperty(i2.prototype, "isLost", {
      /**
       * `true` if the context is lost
       * @readonly
       */
      get: function() {
        return !this.gl || this.gl.isContextLost();
      },
      enumerable: false,
      configurable: true
    }), i2.prototype.contextChange = function(e) {
      this.gl = e, this.renderer.gl = e, this.renderer.CONTEXT_UID = CONTEXT_UID_COUNTER++;
    }, i2.prototype.initFromContext = function(e) {
      this.gl = e, this.validateContext(e), this.renderer.gl = e, this.renderer.CONTEXT_UID = CONTEXT_UID_COUNTER++, this.renderer.runners.contextChange.emit(e);
    }, i2.prototype.initFromOptions = function(e) {
      var t = this.createContext(this.renderer.view, e);
      this.initFromContext(t);
    }, i2.prototype.createContext = function(e, t) {
      var r;
      if (settings$1.PREFER_ENV >= ENV.WEBGL2 && (r = e.getContext("webgl2", t)), r)
        this.webGLVersion = 2;
      else if (this.webGLVersion = 1, r = e.getContext("webgl", t) || e.getContext("experimental-webgl", t), !r)
        throw new Error("This browser does not support WebGL. Try using the canvas renderer");
      return this.gl = r, this.getExtensions(), this.gl;
    }, i2.prototype.getExtensions = function() {
      var e = this.gl, t = {
        loseContext: e.getExtension("WEBGL_lose_context"),
        anisotropicFiltering: e.getExtension("EXT_texture_filter_anisotropic"),
        floatTextureLinear: e.getExtension("OES_texture_float_linear"),
        s3tc: e.getExtension("WEBGL_compressed_texture_s3tc"),
        s3tc_sRGB: e.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
        etc: e.getExtension("WEBGL_compressed_texture_etc"),
        etc1: e.getExtension("WEBGL_compressed_texture_etc1"),
        pvrtc: e.getExtension("WEBGL_compressed_texture_pvrtc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
        atc: e.getExtension("WEBGL_compressed_texture_atc"),
        astc: e.getExtension("WEBGL_compressed_texture_astc")
      };
      this.webGLVersion === 1 ? Object.assign(this.extensions, t, {
        drawBuffers: e.getExtension("WEBGL_draw_buffers"),
        depthTexture: e.getExtension("WEBGL_depth_texture"),
        vertexArrayObject: e.getExtension("OES_vertex_array_object") || e.getExtension("MOZ_OES_vertex_array_object") || e.getExtension("WEBKIT_OES_vertex_array_object"),
        uint32ElementIndex: e.getExtension("OES_element_index_uint"),
        // Floats and half-floats
        floatTexture: e.getExtension("OES_texture_float"),
        floatTextureLinear: e.getExtension("OES_texture_float_linear"),
        textureHalfFloat: e.getExtension("OES_texture_half_float"),
        textureHalfFloatLinear: e.getExtension("OES_texture_half_float_linear")
      }) : this.webGLVersion === 2 && Object.assign(this.extensions, t, {
        // Floats and half-floats
        colorBufferFloat: e.getExtension("EXT_color_buffer_float")
      });
    }, i2.prototype.handleContextLost = function(e) {
      var t = this;
      e.preventDefault(), setTimeout(function() {
        t.gl.isContextLost() && t.extensions.loseContext && t.extensions.loseContext.restoreContext();
      }, 0);
    }, i2.prototype.handleContextRestored = function() {
      this.renderer.runners.contextChange.emit(this.gl);
    }, i2.prototype.destroy = function() {
      var e = this.renderer.view;
      this.renderer = null, e.removeEventListener("webglcontextlost", this.handleContextLost), e.removeEventListener("webglcontextrestored", this.handleContextRestored), this.gl.useProgram(null), this.extensions.loseContext && this.extensions.loseContext.loseContext();
    }, i2.prototype.postrender = function() {
      this.renderer.renderingToScreen && this.gl.flush();
    }, i2.prototype.validateContext = function(e) {
      var t = e.getContextAttributes(), r = "WebGL2RenderingContext" in globalThis && e instanceof globalThis.WebGL2RenderingContext;
      r && (this.webGLVersion = 2), t && !t.stencil && console.warn("Provided WebGL context does not have a stencil buffer, masks may not render correctly");
      var a = r || !!e.getExtension("OES_element_index_uint");
      this.supports.uint32Indices = a, a || console.warn("Provided WebGL context does not support 32 index buffer, complex graphics may not render correctly");
    }, i2;
  }()
), GLFramebuffer$1 = (
  /** @class */
  /* @__PURE__ */ function() {
    function i2(e) {
      this.framebuffer = e, this.stencil = null, this.dirtyId = -1, this.dirtyFormat = -1, this.dirtySize = -1, this.multisample = MSAA_QUALITY.NONE, this.msaaBuffer = null, this.blitFramebuffer = null, this.mipLevel = 0;
    }
    return i2;
  }()
), tempRectangle = new Rectangle$1(), FramebufferSystem = (
  /** @class */
  function() {
    function i2(e) {
      this.renderer = e, this.managedFramebuffers = [], this.unknownFramebuffer = new Framebuffer(10, 10), this.msaaSamples = null;
    }
    return i2.prototype.contextChange = function() {
      this.disposeAll(true);
      var e = this.gl = this.renderer.gl;
      if (this.CONTEXT_UID = this.renderer.CONTEXT_UID, this.current = this.unknownFramebuffer, this.viewport = new Rectangle$1(), this.hasMRT = true, this.writeDepthTexture = true, this.renderer.context.webGLVersion === 1) {
        var t = this.renderer.context.extensions.drawBuffers, r = this.renderer.context.extensions.depthTexture;
        settings$1.PREFER_ENV === ENV.WEBGL_LEGACY && (t = null, r = null), t ? e.drawBuffers = function(a) {
          return t.drawBuffersWEBGL(a);
        } : (this.hasMRT = false, e.drawBuffers = function() {
        }), r || (this.writeDepthTexture = false);
      } else
        this.msaaSamples = e.getInternalformatParameter(e.RENDERBUFFER, e.RGBA8, e.SAMPLES);
    }, i2.prototype.bind = function(e, t, r) {
      r === void 0 && (r = 0);
      var a = this.gl;
      if (e) {
        var s = e.glFramebuffers[this.CONTEXT_UID] || this.initFramebuffer(e);
        this.current !== e && (this.current = e, a.bindFramebuffer(a.FRAMEBUFFER, s.framebuffer)), s.mipLevel !== r && (e.dirtyId++, e.dirtyFormat++, s.mipLevel = r), s.dirtyId !== e.dirtyId && (s.dirtyId = e.dirtyId, s.dirtyFormat !== e.dirtyFormat ? (s.dirtyFormat = e.dirtyFormat, s.dirtySize = e.dirtySize, this.updateFramebuffer(e, r)) : s.dirtySize !== e.dirtySize && (s.dirtySize = e.dirtySize, this.resizeFramebuffer(e)));
        for (var u = 0; u < e.colorTextures.length; u++) {
          var l = e.colorTextures[u];
          this.renderer.texture.unbind(l.parentTextureArray || l);
        }
        if (e.depthTexture && this.renderer.texture.unbind(e.depthTexture), t) {
          var c = t.width >> r, d = t.height >> r, f = c / t.width;
          this.setViewport(t.x * f, t.y * f, c, d);
        } else {
          var c = e.width >> r, d = e.height >> r;
          this.setViewport(0, 0, c, d);
        }
      } else
        this.current && (this.current = null, a.bindFramebuffer(a.FRAMEBUFFER, null)), t ? this.setViewport(t.x, t.y, t.width, t.height) : this.setViewport(0, 0, this.renderer.width, this.renderer.height);
    }, i2.prototype.setViewport = function(e, t, r, a) {
      var s = this.viewport;
      e = Math.round(e), t = Math.round(t), r = Math.round(r), a = Math.round(a), (s.width !== r || s.height !== a || s.x !== e || s.y !== t) && (s.x = e, s.y = t, s.width = r, s.height = a, this.gl.viewport(e, t, r, a));
    }, Object.defineProperty(i2.prototype, "size", {
      /**
       * Get the size of the current width and height. Returns object with `width` and `height` values.
       * @readonly
       */
      get: function() {
        return this.current ? { x: 0, y: 0, width: this.current.width, height: this.current.height } : { x: 0, y: 0, width: this.renderer.width, height: this.renderer.height };
      },
      enumerable: false,
      configurable: true
    }), i2.prototype.clear = function(e, t, r, a, s) {
      s === void 0 && (s = BUFFER_BITS.COLOR | BUFFER_BITS.DEPTH);
      var u = this.gl;
      u.clearColor(e, t, r, a), u.clear(s);
    }, i2.prototype.initFramebuffer = function(e) {
      var t = this.gl, r = new GLFramebuffer$1(t.createFramebuffer());
      return r.multisample = this.detectSamples(e.multisample), e.glFramebuffers[this.CONTEXT_UID] = r, this.managedFramebuffers.push(e), e.disposeRunner.add(this), r;
    }, i2.prototype.resizeFramebuffer = function(e) {
      var t = this.gl, r = e.glFramebuffers[this.CONTEXT_UID];
      r.msaaBuffer && (t.bindRenderbuffer(t.RENDERBUFFER, r.msaaBuffer), t.renderbufferStorageMultisample(t.RENDERBUFFER, r.multisample, t.RGBA8, e.width, e.height)), r.stencil && (t.bindRenderbuffer(t.RENDERBUFFER, r.stencil), r.msaaBuffer ? t.renderbufferStorageMultisample(t.RENDERBUFFER, r.multisample, t.DEPTH24_STENCIL8, e.width, e.height) : t.renderbufferStorage(t.RENDERBUFFER, t.DEPTH_STENCIL, e.width, e.height));
      var a = e.colorTextures, s = a.length;
      t.drawBuffers || (s = Math.min(s, 1));
      for (var u = 0; u < s; u++) {
        var l = a[u], c = l.parentTextureArray || l;
        this.renderer.texture.bind(c, 0);
      }
      e.depthTexture && this.writeDepthTexture && this.renderer.texture.bind(e.depthTexture, 0);
    }, i2.prototype.updateFramebuffer = function(e, t) {
      var r = this.gl, a = e.glFramebuffers[this.CONTEXT_UID], s = e.colorTextures, u = s.length;
      r.drawBuffers || (u = Math.min(u, 1)), a.multisample > 1 && this.canMultisampleFramebuffer(e) ? (a.msaaBuffer = a.msaaBuffer || r.createRenderbuffer(), r.bindRenderbuffer(r.RENDERBUFFER, a.msaaBuffer), r.renderbufferStorageMultisample(r.RENDERBUFFER, a.multisample, r.RGBA8, e.width, e.height), r.framebufferRenderbuffer(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0, r.RENDERBUFFER, a.msaaBuffer)) : a.msaaBuffer && (r.deleteRenderbuffer(a.msaaBuffer), a.msaaBuffer = null, a.blitFramebuffer && (a.blitFramebuffer.dispose(), a.blitFramebuffer = null));
      for (var l = [], c = 0; c < u; c++) {
        var d = s[c], f = d.parentTextureArray || d;
        this.renderer.texture.bind(f, 0), !(c === 0 && a.msaaBuffer) && (r.framebufferTexture2D(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0 + c, d.target, f._glTextures[this.CONTEXT_UID].texture, t), l.push(r.COLOR_ATTACHMENT0 + c));
      }
      if (l.length > 1 && r.drawBuffers(l), e.depthTexture) {
        var p = this.writeDepthTexture;
        if (p) {
          var m = e.depthTexture;
          this.renderer.texture.bind(m, 0), r.framebufferTexture2D(r.FRAMEBUFFER, r.DEPTH_ATTACHMENT, r.TEXTURE_2D, m._glTextures[this.CONTEXT_UID].texture, t);
        }
      }
      (e.stencil || e.depth) && !(e.depthTexture && this.writeDepthTexture) ? (a.stencil = a.stencil || r.createRenderbuffer(), r.bindRenderbuffer(r.RENDERBUFFER, a.stencil), a.msaaBuffer ? r.renderbufferStorageMultisample(r.RENDERBUFFER, a.multisample, r.DEPTH24_STENCIL8, e.width, e.height) : r.renderbufferStorage(r.RENDERBUFFER, r.DEPTH_STENCIL, e.width, e.height), r.framebufferRenderbuffer(r.FRAMEBUFFER, r.DEPTH_STENCIL_ATTACHMENT, r.RENDERBUFFER, a.stencil)) : a.stencil && (r.deleteRenderbuffer(a.stencil), a.stencil = null);
    }, i2.prototype.canMultisampleFramebuffer = function(e) {
      return this.renderer.context.webGLVersion !== 1 && e.colorTextures.length <= 1 && !e.depthTexture;
    }, i2.prototype.detectSamples = function(e) {
      var t = this.msaaSamples, r = MSAA_QUALITY.NONE;
      if (e <= 1 || t === null)
        return r;
      for (var a = 0; a < t.length; a++)
        if (t[a] <= e) {
          r = t[a];
          break;
        }
      return r === 1 && (r = MSAA_QUALITY.NONE), r;
    }, i2.prototype.blit = function(e, t, r) {
      var a = this, s = a.current, u = a.renderer, l = a.gl, c = a.CONTEXT_UID;
      if (u.context.webGLVersion === 2 && s) {
        var d = s.glFramebuffers[c];
        if (d) {
          if (!e) {
            if (!d.msaaBuffer)
              return;
            var f = s.colorTextures[0];
            if (!f)
              return;
            d.blitFramebuffer || (d.blitFramebuffer = new Framebuffer(s.width, s.height), d.blitFramebuffer.addColorTexture(0, f)), e = d.blitFramebuffer, e.colorTextures[0] !== f && (e.colorTextures[0] = f, e.dirtyId++, e.dirtyFormat++), (e.width !== s.width || e.height !== s.height) && (e.width = s.width, e.height = s.height, e.dirtyId++, e.dirtySize++);
          }
          t || (t = tempRectangle, t.width = s.width, t.height = s.height), r || (r = t);
          var p = t.width === r.width && t.height === r.height;
          this.bind(e), l.bindFramebuffer(l.READ_FRAMEBUFFER, d.framebuffer), l.blitFramebuffer(t.left, t.top, t.right, t.bottom, r.left, r.top, r.right, r.bottom, l.COLOR_BUFFER_BIT, p ? l.NEAREST : l.LINEAR);
        }
      }
    }, i2.prototype.disposeFramebuffer = function(e, t) {
      var r = e.glFramebuffers[this.CONTEXT_UID], a = this.gl;
      if (r) {
        delete e.glFramebuffers[this.CONTEXT_UID];
        var s = this.managedFramebuffers.indexOf(e);
        s >= 0 && this.managedFramebuffers.splice(s, 1), e.disposeRunner.remove(this), t || (a.deleteFramebuffer(r.framebuffer), r.msaaBuffer && a.deleteRenderbuffer(r.msaaBuffer), r.stencil && a.deleteRenderbuffer(r.stencil)), r.blitFramebuffer && r.blitFramebuffer.dispose();
      }
    }, i2.prototype.disposeAll = function(e) {
      var t = this.managedFramebuffers;
      this.managedFramebuffers = [];
      for (var r = 0; r < t.length; r++)
        this.disposeFramebuffer(t[r], e);
    }, i2.prototype.forceStencil = function() {
      var e = this.current;
      if (e) {
        var t = e.glFramebuffers[this.CONTEXT_UID];
        if (!(!t || t.stencil)) {
          e.stencil = true;
          var r = e.width, a = e.height, s = this.gl, u = s.createRenderbuffer();
          s.bindRenderbuffer(s.RENDERBUFFER, u), t.msaaBuffer ? s.renderbufferStorageMultisample(s.RENDERBUFFER, t.multisample, s.DEPTH24_STENCIL8, r, a) : s.renderbufferStorage(s.RENDERBUFFER, s.DEPTH_STENCIL, r, a), t.stencil = u, s.framebufferRenderbuffer(s.FRAMEBUFFER, s.DEPTH_STENCIL_ATTACHMENT, s.RENDERBUFFER, u);
        }
      }
    }, i2.prototype.reset = function() {
      this.current = this.unknownFramebuffer, this.viewport = new Rectangle$1();
    }, i2.prototype.destroy = function() {
      this.renderer = null;
    }, i2;
  }()
), byteSizeMap = { 5126: 4, 5123: 2, 5121: 1 }, GeometrySystem = (
  /** @class */
  function() {
    function i2(e) {
      this.renderer = e, this._activeGeometry = null, this._activeVao = null, this.hasVao = true, this.hasInstance = true, this.canUseUInt32ElementIndex = false, this.managedGeometries = {};
    }
    return i2.prototype.contextChange = function() {
      this.disposeAll(true);
      var e = this.gl = this.renderer.gl, t = this.renderer.context;
      if (this.CONTEXT_UID = this.renderer.CONTEXT_UID, t.webGLVersion !== 2) {
        var r = this.renderer.context.extensions.vertexArrayObject;
        settings$1.PREFER_ENV === ENV.WEBGL_LEGACY && (r = null), r ? (e.createVertexArray = function() {
          return r.createVertexArrayOES();
        }, e.bindVertexArray = function(s) {
          return r.bindVertexArrayOES(s);
        }, e.deleteVertexArray = function(s) {
          return r.deleteVertexArrayOES(s);
        }) : (this.hasVao = false, e.createVertexArray = function() {
          return null;
        }, e.bindVertexArray = function() {
          return null;
        }, e.deleteVertexArray = function() {
          return null;
        });
      }
      if (t.webGLVersion !== 2) {
        var a = e.getExtension("ANGLE_instanced_arrays");
        a ? (e.vertexAttribDivisor = function(s, u) {
          return a.vertexAttribDivisorANGLE(s, u);
        }, e.drawElementsInstanced = function(s, u, l, c, d) {
          return a.drawElementsInstancedANGLE(s, u, l, c, d);
        }, e.drawArraysInstanced = function(s, u, l, c) {
          return a.drawArraysInstancedANGLE(s, u, l, c);
        }) : this.hasInstance = false;
      }
      this.canUseUInt32ElementIndex = t.webGLVersion === 2 || !!t.extensions.uint32ElementIndex;
    }, i2.prototype.bind = function(e, t) {
      t = t || this.renderer.shader.shader;
      var r = this.gl, a = e.glVertexArrayObjects[this.CONTEXT_UID], s = false;
      a || (this.managedGeometries[e.id] = e, e.disposeRunner.add(this), e.glVertexArrayObjects[this.CONTEXT_UID] = a = {}, s = true);
      var u = a[t.program.id] || this.initGeometryVao(e, t, s);
      this._activeGeometry = e, this._activeVao !== u && (this._activeVao = u, this.hasVao ? r.bindVertexArray(u) : this.activateVao(e, t.program)), this.updateBuffers();
    }, i2.prototype.reset = function() {
      this.unbind();
    }, i2.prototype.updateBuffers = function() {
      for (var e = this._activeGeometry, t = this.renderer.buffer, r = 0; r < e.buffers.length; r++) {
        var a = e.buffers[r];
        t.update(a);
      }
    }, i2.prototype.checkCompatibility = function(e, t) {
      var r = e.attributes, a = t.attributeData;
      for (var s in a)
        if (!r[s])
          throw new Error('shader and geometry incompatible, geometry missing the "' + s + '" attribute');
    }, i2.prototype.getSignature = function(e, t) {
      var r = e.attributes, a = t.attributeData, s = ["g", e.id];
      for (var u in r)
        a[u] && s.push(u, a[u].location);
      return s.join("-");
    }, i2.prototype.initGeometryVao = function(e, t, r) {
      r === void 0 && (r = true);
      var a = this.gl, s = this.CONTEXT_UID, u = this.renderer.buffer, l = t.program;
      l.glPrograms[s] || this.renderer.shader.generateProgram(t), this.checkCompatibility(e, l);
      var c = this.getSignature(e, l), d = e.glVertexArrayObjects[this.CONTEXT_UID], f = d[c];
      if (f)
        return d[l.id] = f, f;
      var p = e.buffers, m = e.attributes, y = {}, x = {};
      for (var g in p)
        y[g] = 0, x[g] = 0;
      for (var g in m)
        !m[g].size && l.attributeData[g] ? m[g].size = l.attributeData[g].size : m[g].size || console.warn("PIXI Geometry attribute '" + g + "' size cannot be determined (likely the bound shader does not have the attribute)"), y[m[g].buffer] += m[g].size * byteSizeMap[m[g].type];
      for (var g in m) {
        var _ = m[g], T = _.size;
        _.stride === void 0 && (y[_.buffer] === T * byteSizeMap[_.type] ? _.stride = 0 : _.stride = y[_.buffer]), _.start === void 0 && (_.start = x[_.buffer], x[_.buffer] += T * byteSizeMap[_.type]);
      }
      f = a.createVertexArray(), a.bindVertexArray(f);
      for (var E = 0; E < p.length; E++) {
        var b = p[E];
        u.bind(b), r && b._glBuffers[s].refCount++;
      }
      return this.activateVao(e, l), this._activeVao = f, d[l.id] = f, d[c] = f, f;
    }, i2.prototype.disposeGeometry = function(e, t) {
      var r;
      if (this.managedGeometries[e.id]) {
        delete this.managedGeometries[e.id];
        var a = e.glVertexArrayObjects[this.CONTEXT_UID], s = this.gl, u = e.buffers, l = (r = this.renderer) === null || r === void 0 ? void 0 : r.buffer;
        if (e.disposeRunner.remove(this), !!a) {
          if (l)
            for (var c = 0; c < u.length; c++) {
              var d = u[c]._glBuffers[this.CONTEXT_UID];
              d && (d.refCount--, d.refCount === 0 && !t && l.dispose(u[c], t));
            }
          if (!t) {
            for (var f in a)
              if (f[0] === "g") {
                var p = a[f];
                this._activeVao === p && this.unbind(), s.deleteVertexArray(p);
              }
          }
          delete e.glVertexArrayObjects[this.CONTEXT_UID];
        }
      }
    }, i2.prototype.disposeAll = function(e) {
      for (var t = Object.keys(this.managedGeometries), r = 0; r < t.length; r++)
        this.disposeGeometry(this.managedGeometries[t[r]], e);
    }, i2.prototype.activateVao = function(e, t) {
      var r = this.gl, a = this.CONTEXT_UID, s = this.renderer.buffer, u = e.buffers, l = e.attributes;
      e.indexBuffer && s.bind(e.indexBuffer);
      var c = null;
      for (var d in l) {
        var f = l[d], p = u[f.buffer], m = p._glBuffers[a];
        if (t.attributeData[d]) {
          c !== m && (s.bind(p), c = m);
          var y = t.attributeData[d].location;
          if (r.enableVertexAttribArray(y), r.vertexAttribPointer(y, f.size, f.type || r.FLOAT, f.normalized, f.stride, f.start), f.instance)
            if (this.hasInstance)
              r.vertexAttribDivisor(y, 1);
            else
              throw new Error("geometry error, GPU Instancing is not supported on this device");
        }
      }
    }, i2.prototype.draw = function(e, t, r, a) {
      var s = this.gl, u = this._activeGeometry;
      if (u.indexBuffer) {
        var l = u.indexBuffer.data.BYTES_PER_ELEMENT, c = l === 2 ? s.UNSIGNED_SHORT : s.UNSIGNED_INT;
        l === 2 || l === 4 && this.canUseUInt32ElementIndex ? u.instanced ? s.drawElementsInstanced(e, t || u.indexBuffer.data.length, c, (r || 0) * l, a || 1) : s.drawElements(e, t || u.indexBuffer.data.length, c, (r || 0) * l) : console.warn("unsupported index buffer type: uint32");
      } else u.instanced ? s.drawArraysInstanced(e, r, t || u.getSize(), a || 1) : s.drawArrays(e, r, t || u.getSize());
      return this;
    }, i2.prototype.unbind = function() {
      this.gl.bindVertexArray(null), this._activeVao = null, this._activeGeometry = null;
    }, i2.prototype.destroy = function() {
      this.renderer = null;
    }, i2;
  }()
), MaskData = (
  /** @class */
  function() {
    function i2(e) {
      e === void 0 && (e = null), this.type = MASK_TYPES.NONE, this.autoDetect = true, this.maskObject = e || null, this.pooled = false, this.isMaskData = true, this.resolution = null, this.multisample = settings$1.FILTER_MULTISAMPLE, this.enabled = true, this.colorMask = 15, this._filters = null, this._stencilCounter = 0, this._scissorCounter = 0, this._scissorRect = null, this._scissorRectLocal = null, this._colorMask = 15, this._target = null;
    }
    return Object.defineProperty(i2.prototype, "filter", {
      /**
       * The sprite mask filter.
       * If set to `null`, the default sprite mask filter is used.
       * @default null
       */
      get: function() {
        return this._filters ? this._filters[0] : null;
      },
      set: function(e) {
        e ? this._filters ? this._filters[0] = e : this._filters = [e] : this._filters = null;
      },
      enumerable: false,
      configurable: true
    }), i2.prototype.reset = function() {
      this.pooled && (this.maskObject = null, this.type = MASK_TYPES.NONE, this.autoDetect = true), this._target = null, this._scissorRectLocal = null;
    }, i2.prototype.copyCountersOrReset = function(e) {
      e ? (this._stencilCounter = e._stencilCounter, this._scissorCounter = e._scissorCounter, this._scissorRect = e._scissorRect) : (this._stencilCounter = 0, this._scissorCounter = 0, this._scissorRect = null);
    }, i2;
  }()
);
function compileShader(i2, e, t) {
  var r = i2.createShader(e);
  return i2.shaderSource(r, t), i2.compileShader(r), r;
}
function logPrettyShaderError(i2, e) {
  var t = i2.getShaderSource(e).split(`
`).map(function(d, f) {
    return f + ": " + d;
  }), r = i2.getShaderInfoLog(e), a = r.split(`
`), s = {}, u = a.map(function(d) {
    return parseFloat(d.replace(/^ERROR\: 0\:([\d]+)\:.*$/, "$1"));
  }).filter(function(d) {
    return d && !s[d] ? (s[d] = true, true) : false;
  }), l = [""];
  u.forEach(function(d) {
    t[d - 1] = "%c" + t[d - 1] + "%c", l.push("background: #FF0000; color:#FFFFFF; font-size: 10px", "font-size: 10px");
  });
  var c = t.join(`
`);
  l[0] = c, console.error(r), console.groupCollapsed("click to view full shader code"), console.warn.apply(console, l), console.groupEnd();
}
function logProgramError(i2, e, t, r) {
  i2.getProgramParameter(e, i2.LINK_STATUS) || (i2.getShaderParameter(t, i2.COMPILE_STATUS) || logPrettyShaderError(i2, t), i2.getShaderParameter(r, i2.COMPILE_STATUS) || logPrettyShaderError(i2, r), console.error("PixiJS Error: Could not initialize shader."), i2.getProgramInfoLog(e) !== "" && console.warn("PixiJS Warning: gl.getProgramInfoLog()", i2.getProgramInfoLog(e)));
}
function booleanArray(i2) {
  for (var e = new Array(i2), t = 0; t < e.length; t++)
    e[t] = false;
  return e;
}
function defaultValue(i2, e) {
  switch (i2) {
    case "float":
      return 0;
    case "vec2":
      return new Float32Array(2 * e);
    case "vec3":
      return new Float32Array(3 * e);
    case "vec4":
      return new Float32Array(4 * e);
    case "int":
    case "uint":
    case "sampler2D":
    case "sampler2DArray":
      return 0;
    case "ivec2":
      return new Int32Array(2 * e);
    case "ivec3":
      return new Int32Array(3 * e);
    case "ivec4":
      return new Int32Array(4 * e);
    case "uvec2":
      return new Uint32Array(2 * e);
    case "uvec3":
      return new Uint32Array(3 * e);
    case "uvec4":
      return new Uint32Array(4 * e);
    case "bool":
      return false;
    case "bvec2":
      return booleanArray(2 * e);
    case "bvec3":
      return booleanArray(3 * e);
    case "bvec4":
      return booleanArray(4 * e);
    case "mat2":
      return new Float32Array([
        1,
        0,
        0,
        1
      ]);
    case "mat3":
      return new Float32Array([
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1
      ]);
    case "mat4":
      return new Float32Array([
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
      ]);
  }
  return null;
}
var unknownContext = {}, context = unknownContext;
function getTestContext() {
  if (context === unknownContext || context && context.isContextLost()) {
    var i2 = settings$1.ADAPTER.createCanvas(), e = void 0;
    settings$1.PREFER_ENV >= ENV.WEBGL2 && (e = i2.getContext("webgl2", {})), e || (e = i2.getContext("webgl", {}) || i2.getContext("experimental-webgl", {}), e ? e.getExtension("WEBGL_draw_buffers") : e = null), context = e;
  }
  return context;
}
var maxFragmentPrecision;
function getMaxFragmentPrecision() {
  if (!maxFragmentPrecision) {
    maxFragmentPrecision = PRECISION.MEDIUM;
    var i2 = getTestContext();
    if (i2 && i2.getShaderPrecisionFormat) {
      var e = i2.getShaderPrecisionFormat(i2.FRAGMENT_SHADER, i2.HIGH_FLOAT);
      maxFragmentPrecision = e.precision ? PRECISION.HIGH : PRECISION.MEDIUM;
    }
  }
  return maxFragmentPrecision;
}
function setPrecision(i2, e, t) {
  if (i2.substring(0, 9) !== "precision") {
    var r = e;
    return e === PRECISION.HIGH && t !== PRECISION.HIGH && (r = PRECISION.MEDIUM), "precision " + r + ` float;
` + i2;
  } else if (t !== PRECISION.HIGH && i2.substring(0, 15) === "precision highp")
    return i2.replace("precision highp", "precision mediump");
  return i2;
}
var GLSL_TO_SIZE = {
  float: 1,
  vec2: 2,
  vec3: 3,
  vec4: 4,
  int: 1,
  ivec2: 2,
  ivec3: 3,
  ivec4: 4,
  uint: 1,
  uvec2: 2,
  uvec3: 3,
  uvec4: 4,
  bool: 1,
  bvec2: 2,
  bvec3: 3,
  bvec4: 4,
  mat2: 4,
  mat3: 9,
  mat4: 16,
  sampler2D: 1
};
function mapSize(i2) {
  return GLSL_TO_SIZE[i2];
}
var GL_TABLE = null, GL_TO_GLSL_TYPES = {
  FLOAT: "float",
  FLOAT_VEC2: "vec2",
  FLOAT_VEC3: "vec3",
  FLOAT_VEC4: "vec4",
  INT: "int",
  INT_VEC2: "ivec2",
  INT_VEC3: "ivec3",
  INT_VEC4: "ivec4",
  UNSIGNED_INT: "uint",
  UNSIGNED_INT_VEC2: "uvec2",
  UNSIGNED_INT_VEC3: "uvec3",
  UNSIGNED_INT_VEC4: "uvec4",
  BOOL: "bool",
  BOOL_VEC2: "bvec2",
  BOOL_VEC3: "bvec3",
  BOOL_VEC4: "bvec4",
  FLOAT_MAT2: "mat2",
  FLOAT_MAT3: "mat3",
  FLOAT_MAT4: "mat4",
  SAMPLER_2D: "sampler2D",
  INT_SAMPLER_2D: "sampler2D",
  UNSIGNED_INT_SAMPLER_2D: "sampler2D",
  SAMPLER_CUBE: "samplerCube",
  INT_SAMPLER_CUBE: "samplerCube",
  UNSIGNED_INT_SAMPLER_CUBE: "samplerCube",
  SAMPLER_2D_ARRAY: "sampler2DArray",
  INT_SAMPLER_2D_ARRAY: "sampler2DArray",
  UNSIGNED_INT_SAMPLER_2D_ARRAY: "sampler2DArray"
};
function mapType(i2, e) {
  if (!GL_TABLE) {
    var t = Object.keys(GL_TO_GLSL_TYPES);
    GL_TABLE = {};
    for (var r = 0; r < t.length; ++r) {
      var a = t[r];
      GL_TABLE[i2[a]] = GL_TO_GLSL_TYPES[a];
    }
  }
  return GL_TABLE[e];
}
var uniformParsers = [
  // a float cache layer
  {
    test: function(i2) {
      return i2.type === "float" && i2.size === 1 && !i2.isArray;
    },
    code: function(i2) {
      return `
            if(uv["` + i2 + '"] !== ud["' + i2 + `"].value)
            {
                ud["` + i2 + '"].value = uv["' + i2 + `"]
                gl.uniform1f(ud["` + i2 + '"].location, uv["' + i2 + `"])
            }
            `;
    }
  },
  // handling samplers
  {
    test: function(i2, e) {
      return (i2.type === "sampler2D" || i2.type === "samplerCube" || i2.type === "sampler2DArray") && i2.size === 1 && !i2.isArray && (e == null || e.castToBaseTexture !== void 0);
    },
    code: function(i2) {
      return `t = syncData.textureCount++;

            renderer.texture.bind(uv["` + i2 + `"], t);

            if(ud["` + i2 + `"].value !== t)
            {
                ud["` + i2 + `"].value = t;
                gl.uniform1i(ud["` + i2 + `"].location, t);
; // eslint-disable-line max-len
            }`;
    }
  },
  // uploading pixi matrix object to mat3
  {
    test: function(i2, e) {
      return i2.type === "mat3" && i2.size === 1 && !i2.isArray && e.a !== void 0;
    },
    code: function(i2) {
      return `
            gl.uniformMatrix3fv(ud["` + i2 + '"].location, false, uv["' + i2 + `"].toArray(true));
            `;
    },
    codeUbo: function(i2) {
      return `
                var ` + i2 + "_matrix = uv." + i2 + `.toArray(true);

                data[offset] = ` + i2 + `_matrix[0];
                data[offset+1] = ` + i2 + `_matrix[1];
                data[offset+2] = ` + i2 + `_matrix[2];
        
                data[offset + 4] = ` + i2 + `_matrix[3];
                data[offset + 5] = ` + i2 + `_matrix[4];
                data[offset + 6] = ` + i2 + `_matrix[5];
        
                data[offset + 8] = ` + i2 + `_matrix[6];
                data[offset + 9] = ` + i2 + `_matrix[7];
                data[offset + 10] = ` + i2 + `_matrix[8];
            `;
    }
  },
  // uploading a pixi point as a vec2 with caching layer
  {
    test: function(i2, e) {
      return i2.type === "vec2" && i2.size === 1 && !i2.isArray && e.x !== void 0;
    },
    code: function(i2) {
      return `
                cv = ud["` + i2 + `"].value;
                v = uv["` + i2 + `"];

                if(cv[0] !== v.x || cv[1] !== v.y)
                {
                    cv[0] = v.x;
                    cv[1] = v.y;
                    gl.uniform2f(ud["` + i2 + `"].location, v.x, v.y);
                }`;
    },
    codeUbo: function(i2) {
      return `
                v = uv.` + i2 + `;

                data[offset] = v.x;
                data[offset+1] = v.y;
            `;
    }
  },
  // caching layer for a vec2
  {
    test: function(i2) {
      return i2.type === "vec2" && i2.size === 1 && !i2.isArray;
    },
    code: function(i2) {
      return `
                cv = ud["` + i2 + `"].value;
                v = uv["` + i2 + `"];

                if(cv[0] !== v[0] || cv[1] !== v[1])
                {
                    cv[0] = v[0];
                    cv[1] = v[1];
                    gl.uniform2f(ud["` + i2 + `"].location, v[0], v[1]);
                }
            `;
    }
  },
  // upload a pixi rectangle as a vec4 with caching layer
  {
    test: function(i2, e) {
      return i2.type === "vec4" && i2.size === 1 && !i2.isArray && e.width !== void 0;
    },
    code: function(i2) {
      return `
                cv = ud["` + i2 + `"].value;
                v = uv["` + i2 + `"];

                if(cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height)
                {
                    cv[0] = v.x;
                    cv[1] = v.y;
                    cv[2] = v.width;
                    cv[3] = v.height;
                    gl.uniform4f(ud["` + i2 + `"].location, v.x, v.y, v.width, v.height)
                }`;
    },
    codeUbo: function(i2) {
      return `
                    v = uv.` + i2 + `;

                    data[offset] = v.x;
                    data[offset+1] = v.y;
                    data[offset+2] = v.width;
                    data[offset+3] = v.height;
                `;
    }
  },
  // a caching layer for vec4 uploading
  {
    test: function(i2) {
      return i2.type === "vec4" && i2.size === 1 && !i2.isArray;
    },
    code: function(i2) {
      return `
                cv = ud["` + i2 + `"].value;
                v = uv["` + i2 + `"];

                if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
                {
                    cv[0] = v[0];
                    cv[1] = v[1];
                    cv[2] = v[2];
                    cv[3] = v[3];

                    gl.uniform4f(ud["` + i2 + `"].location, v[0], v[1], v[2], v[3])
                }`;
    }
  }
], GLSL_TO_SINGLE_SETTERS_CACHED = {
  float: `
    if (cv !== v)
    {
        cu.value = v;
        gl.uniform1f(location, v);
    }`,
  vec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2f(location, v[0], v[1])
    }`,
  vec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3f(location, v[0], v[1], v[2])
    }`,
  vec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4f(location, v[0], v[1], v[2], v[3]);
    }`,
  int: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
  ivec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2i(location, v[0], v[1]);
    }`,
  ivec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3i(location, v[0], v[1], v[2]);
    }`,
  ivec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4i(location, v[0], v[1], v[2], v[3]);
    }`,
  uint: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1ui(location, v);
    }`,
  uvec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2ui(location, v[0], v[1]);
    }`,
  uvec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3ui(location, v[0], v[1], v[2]);
    }`,
  uvec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4ui(location, v[0], v[1], v[2], v[3]);
    }`,
  bool: `
    if (cv !== v)
    {
        cu.value = v;
        gl.uniform1i(location, v);
    }`,
  bvec2: `
    if (cv[0] != v[0] || cv[1] != v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2i(location, v[0], v[1]);
    }`,
  bvec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3i(location, v[0], v[1], v[2]);
    }`,
  bvec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4i(location, v[0], v[1], v[2], v[3]);
    }`,
  mat2: "gl.uniformMatrix2fv(location, false, v)",
  mat3: "gl.uniformMatrix3fv(location, false, v)",
  mat4: "gl.uniformMatrix4fv(location, false, v)",
  sampler2D: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
  samplerCube: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
  sampler2DArray: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`
}, GLSL_TO_ARRAY_SETTERS = {
  float: "gl.uniform1fv(location, v)",
  vec2: "gl.uniform2fv(location, v)",
  vec3: "gl.uniform3fv(location, v)",
  vec4: "gl.uniform4fv(location, v)",
  mat4: "gl.uniformMatrix4fv(location, false, v)",
  mat3: "gl.uniformMatrix3fv(location, false, v)",
  mat2: "gl.uniformMatrix2fv(location, false, v)",
  int: "gl.uniform1iv(location, v)",
  ivec2: "gl.uniform2iv(location, v)",
  ivec3: "gl.uniform3iv(location, v)",
  ivec4: "gl.uniform4iv(location, v)",
  uint: "gl.uniform1uiv(location, v)",
  uvec2: "gl.uniform2uiv(location, v)",
  uvec3: "gl.uniform3uiv(location, v)",
  uvec4: "gl.uniform4uiv(location, v)",
  bool: "gl.uniform1iv(location, v)",
  bvec2: "gl.uniform2iv(location, v)",
  bvec3: "gl.uniform3iv(location, v)",
  bvec4: "gl.uniform4iv(location, v)",
  sampler2D: "gl.uniform1iv(location, v)",
  samplerCube: "gl.uniform1iv(location, v)",
  sampler2DArray: "gl.uniform1iv(location, v)"
};
function generateUniformsSync(i2, e) {
  var t, r = [`
        var v = null;
        var cv = null;
        var cu = null;
        var t = 0;
        var gl = renderer.gl;
    `];
  for (var a in i2.uniforms) {
    var s = e[a];
    if (!s) {
      !((t = i2.uniforms[a]) === null || t === void 0) && t.group && (i2.uniforms[a].ubo ? r.push(`
                        renderer.shader.syncUniformBufferGroup(uv.` + a + ", '" + a + `');
                    `) : r.push(`
                        renderer.shader.syncUniformGroup(uv.` + a + `, syncData);
                    `));
      continue;
    }
    for (var u = i2.uniforms[a], l = false, c = 0; c < uniformParsers.length; c++)
      if (uniformParsers[c].test(s, u)) {
        r.push(uniformParsers[c].code(a, u)), l = true;
        break;
      }
    if (!l) {
      var d = s.size === 1 && !s.isArray ? GLSL_TO_SINGLE_SETTERS_CACHED : GLSL_TO_ARRAY_SETTERS, f = d[s.type].replace("location", 'ud["' + a + '"].location');
      r.push(`
            cu = ud["` + a + `"];
            cv = cu.value;
            v = uv["` + a + `"];
            ` + f + ";");
    }
  }
  return new Function("ud", "uv", "renderer", "syncData", r.join(`
`));
}
var fragTemplate = [
  "precision mediump float;",
  "void main(void){",
  "float test = 0.1;",
  "%forloop%",
  "gl_FragColor = vec4(0.0);",
  "}"
].join(`
`);
function generateIfTestSrc(i2) {
  for (var e = "", t = 0; t < i2; ++t)
    t > 0 && (e += `
else `), t < i2 - 1 && (e += "if(test == " + t + ".0){}");
  return e;
}
function checkMaxIfStatementsInShader(i2, e) {
  if (i2 === 0)
    throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");
  for (var t = e.createShader(e.FRAGMENT_SHADER); ; ) {
    var r = fragTemplate.replace(/%forloop%/gi, generateIfTestSrc(i2));
    if (e.shaderSource(t, r), e.compileShader(t), !e.getShaderParameter(t, e.COMPILE_STATUS))
      i2 = i2 / 2 | 0;
    else
      break;
  }
  return i2;
}
var unsafeEval;
function unsafeEvalSupported() {
  if (typeof unsafeEval == "boolean")
    return unsafeEval;
  try {
    var i2 = new Function("param1", "param2", "param3", "return param1[param2] === param3;");
    unsafeEval = i2({ a: "b" }, "a", "b") === true;
  } catch {
    unsafeEval = false;
  }
  return unsafeEval;
}
var defaultFragment$2 = `varying vec2 vTextureCoord;

uniform sampler2D uSampler;

void main(void){
   gl_FragColor *= texture2D(uSampler, vTextureCoord);
}`, defaultVertex$3 = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;

void main(void){
   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);
   vTextureCoord = aTextureCoord;
}
`, UID$1 = 0, nameCache = {}, Program = (
  /** @class */
  function() {
    function i2(e, t, r) {
      r === void 0 && (r = "pixi-shader"), this.id = UID$1++, this.vertexSrc = e || i2.defaultVertexSrc, this.fragmentSrc = t || i2.defaultFragmentSrc, this.vertexSrc = this.vertexSrc.trim(), this.fragmentSrc = this.fragmentSrc.trim(), this.vertexSrc.substring(0, 8) !== "#version" && (r = r.replace(/\s+/g, "-"), nameCache[r] ? (nameCache[r]++, r += "-" + nameCache[r]) : nameCache[r] = 1, this.vertexSrc = "#define SHADER_NAME " + r + `
` + this.vertexSrc, this.fragmentSrc = "#define SHADER_NAME " + r + `
` + this.fragmentSrc, this.vertexSrc = setPrecision(this.vertexSrc, settings$1.PRECISION_VERTEX, PRECISION.HIGH), this.fragmentSrc = setPrecision(this.fragmentSrc, settings$1.PRECISION_FRAGMENT, getMaxFragmentPrecision())), this.glPrograms = {}, this.syncUniforms = null;
    }
    return Object.defineProperty(i2, "defaultVertexSrc", {
      /**
       * The default vertex shader source.
       * @constant
       */
      get: function() {
        return defaultVertex$3;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(i2, "defaultFragmentSrc", {
      /**
       * The default fragment shader source.
       * @constant
       */
      get: function() {
        return defaultFragment$2;
      },
      enumerable: false,
      configurable: true
    }), i2.from = function(e, t, r) {
      var a = e + t, s = ProgramCache[a];
      return s || (ProgramCache[a] = s = new i2(e, t, r)), s;
    }, i2;
  }()
), Shader$1 = (
  /** @class */
  function() {
    function i2(e, t) {
      this.uniformBindCount = 0, this.program = e, t ? t instanceof UniformGroup ? this.uniformGroup = t : this.uniformGroup = new UniformGroup(t) : this.uniformGroup = new UniformGroup({}), this.disposeRunner = new Runner("disposeShader");
    }
    return i2.prototype.checkUniformExists = function(e, t) {
      if (t.uniforms[e])
        return true;
      for (var r in t.uniforms) {
        var a = t.uniforms[r];
        if (a.group && this.checkUniformExists(e, a))
          return true;
      }
      return false;
    }, i2.prototype.destroy = function() {
      this.uniformGroup = null, this.disposeRunner.emit(this), this.disposeRunner.destroy();
    }, Object.defineProperty(i2.prototype, "uniforms", {
      /**
       * Shader uniform values, shortcut for `uniformGroup.uniforms`.
       * @readonly
       */
      get: function() {
        return this.uniformGroup.uniforms;
      },
      enumerable: false,
      configurable: true
    }), i2.from = function(e, t, r) {
      var a = Program.from(e, t);
      return new i2(a, r);
    }, i2;
  }()
), BLEND$1 = 0, OFFSET$1 = 1, CULLING$1 = 2, DEPTH_TEST$1 = 3, WINDING$1 = 4, DEPTH_MASK$1 = 5, State = (
  /** @class */
  function() {
    function i2() {
      this.data = 0, this.blendMode = BLEND_MODES.NORMAL, this.polygonOffset = 0, this.blend = true, this.depthMask = true;
    }
    return Object.defineProperty(i2.prototype, "blend", {
      /**
       * Activates blending of the computed fragment color values.
       * @default true
       */
      get: function() {
        return !!(this.data & 1 << BLEND$1);
      },
      set: function(e) {
        !!(this.data & 1 << BLEND$1) !== e && (this.data ^= 1 << BLEND$1);
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(i2.prototype, "offsets", {
      /**
       * Activates adding an offset to depth values of polygon's fragments
       * @default false
       */
      get: function() {
        return !!(this.data & 1 << OFFSET$1);
      },
      set: function(e) {
        !!(this.data & 1 << OFFSET$1) !== e && (this.data ^= 1 << OFFSET$1);
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(i2.prototype, "culling", {
      /**
       * Activates culling of polygons.
       * @default false
       */
      get: function() {
        return !!(this.data & 1 << CULLING$1);
      },
      set: function(e) {
        !!(this.data & 1 << CULLING$1) !== e && (this.data ^= 1 << CULLING$1);
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(i2.prototype, "depthTest", {
      /**
       * Activates depth comparisons and updates to the depth buffer.
       * @default false
       */
      get: function() {
        return !!(this.data & 1 << DEPTH_TEST$1);
      },
      set: function(e) {
        !!(this.data & 1 << DEPTH_TEST$1) !== e && (this.data ^= 1 << DEPTH_TEST$1);
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(i2.prototype, "depthMask", {
      /**
       * Enables or disables writing to the depth buffer.
       * @default true
       */
      get: function() {
        return !!(this.data & 1 << DEPTH_MASK$1);
      },
      set: function(e) {
        !!(this.data & 1 << DEPTH_MASK$1) !== e && (this.data ^= 1 << DEPTH_MASK$1);
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(i2.prototype, "clockwiseFrontFace", {
      /**
       * Specifies whether or not front or back-facing polygons can be culled.
       * @default false
       */
      get: function() {
        return !!(this.data & 1 << WINDING$1);
      },
      set: function(e) {
        !!(this.data & 1 << WINDING$1) !== e && (this.data ^= 1 << WINDING$1);
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(i2.prototype, "blendMode", {
      /**
       * The blend mode to be applied when this state is set. Apply a value of `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.
       * Setting this mode to anything other than NO_BLEND will automatically switch blending on.
       * @default PIXI.BLEND_MODES.NORMAL
       */
      get: function() {
        return this._blendMode;
      },
      set: function(e) {
        this.blend = e !== BLEND_MODES.NONE, this._blendMode = e;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(i2.prototype, "polygonOffset", {
      /**
       * The polygon offset. Setting this property to anything other than 0 will automatically enable polygon offset fill.
       * @default 0
       */
      get: function() {
        return this._polygonOffset;
      },
      set: function(e) {
        this.offsets = !!e, this._polygonOffset = e;
      },
      enumerable: false,
      configurable: true
    }), i2.prototype.toString = function() {
      return "[@pixi/core:State " + ("blendMode=" + this.blendMode + " ") + ("clockwiseFrontFace=" + this.clockwiseFrontFace + " ") + ("culling=" + this.culling + " ") + ("depthMask=" + this.depthMask + " ") + ("polygonOffset=" + this.polygonOffset) + "]";
    }, i2.for2d = function() {
      var e = new i2();
      return e.depthTest = false, e.blend = true, e;
    }, i2;
  }()
), defaultFragment$1 = `varying vec2 vTextureCoord;

uniform sampler2D uSampler;

void main(void){
   gl_FragColor = texture2D(uSampler, vTextureCoord);
}
`, defaultVertex$2 = `attribute vec2 aVertexPosition;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;

uniform vec4 inputSize;
uniform vec4 outputFrame;

vec4 filterVertexPosition( void )
{
    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
}

vec2 filterTextureCoord( void )
{
    return aVertexPosition * (outputFrame.zw * inputSize.zw);
}

void main(void)
{
    gl_Position = filterVertexPosition();
    vTextureCoord = filterTextureCoord();
}
`, Filter$1 = (
  /** @class */
  function(i2) {
    __extends$1(e, i2);
    function e(t, r, a) {
      var s = this, u = Program.from(t || e.defaultVertexSrc, r || e.defaultFragmentSrc);
      return s = i2.call(this, u, a) || this, s.padding = 0, s.resolution = settings$1.FILTER_RESOLUTION, s.multisample = settings$1.FILTER_MULTISAMPLE, s.enabled = true, s.autoFit = true, s.state = new State(), s;
    }
    return e.prototype.apply = function(t, r, a, s, u) {
      t.applyFilter(this, r, a, s);
    }, Object.defineProperty(e.prototype, "blendMode", {
      /**
       * Sets the blend mode of the filter.
       * @default PIXI.BLEND_MODES.NORMAL
       */
      get: function() {
        return this.state.blendMode;
      },
      set: function(t) {
        this.state.blendMode = t;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(e.prototype, "resolution", {
      /**
       * The resolution of the filter. Setting this to be lower will lower the quality but
       * increase the performance of the filter.
       */
      get: function() {
        return this._resolution;
      },
      set: function(t) {
        this._resolution = t;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(e, "defaultVertexSrc", {
      /**
       * The default vertex shader source
       * @constant
       */
      get: function() {
        return defaultVertex$2;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(e, "defaultFragmentSrc", {
      /**
       * The default fragment shader source
       * @constant
       */
      get: function() {
        return defaultFragment$1;
      },
      enumerable: false,
      configurable: true
    }), e;
  }(Shader$1)
), vertex = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;
uniform mat3 otherMatrix;

varying vec2 vMaskCoord;
varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = aTextureCoord;
    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;
}
`, fragment = `varying vec2 vMaskCoord;
varying vec2 vTextureCoord;

uniform sampler2D uSampler;
uniform sampler2D mask;
uniform float alpha;
uniform float npmAlpha;
uniform vec4 maskClamp;

void main(void)
{
    float clip = step(3.5,
        step(maskClamp.x, vMaskCoord.x) +
        step(maskClamp.y, vMaskCoord.y) +
        step(vMaskCoord.x, maskClamp.z) +
        step(vMaskCoord.y, maskClamp.w));

    vec4 original = texture2D(uSampler, vTextureCoord);
    vec4 masky = texture2D(mask, vMaskCoord);
    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);

    original *= (alphaMul * masky.r * alpha * clip);

    gl_FragColor = original;
}
`, tempMat = new Matrix$1(), TextureMatrix$1 = (
  /** @class */
  function() {
    function i2(e, t) {
      this._texture = e, this.mapCoord = new Matrix$1(), this.uClampFrame = new Float32Array(4), this.uClampOffset = new Float32Array(2), this._textureID = -1, this._updateID = 0, this.clampOffset = 0, this.clampMargin = typeof t > "u" ? 0.5 : t, this.isSimple = false;
    }
    return Object.defineProperty(i2.prototype, "texture", {
      /** Texture property. */
      get: function() {
        return this._texture;
      },
      set: function(e) {
        this._texture = e, this._textureID = -1;
      },
      enumerable: false,
      configurable: true
    }), i2.prototype.multiplyUvs = function(e, t) {
      t === void 0 && (t = e);
      for (var r = this.mapCoord, a = 0; a < e.length; a += 2) {
        var s = e[a], u = e[a + 1];
        t[a] = s * r.a + u * r.c + r.tx, t[a + 1] = s * r.b + u * r.d + r.ty;
      }
      return t;
    }, i2.prototype.update = function(e) {
      var t = this._texture;
      if (!t || !t.valid || !e && this._textureID === t._updateID)
        return false;
      this._textureID = t._updateID, this._updateID++;
      var r = t._uvs;
      this.mapCoord.set(r.x1 - r.x0, r.y1 - r.y0, r.x3 - r.x0, r.y3 - r.y0, r.x0, r.y0);
      var a = t.orig, s = t.trim;
      s && (tempMat.set(a.width / s.width, 0, 0, a.height / s.height, -s.x / s.width, -s.y / s.height), this.mapCoord.append(tempMat));
      var u = t.baseTexture, l = this.uClampFrame, c = this.clampMargin / u.resolution, d = this.clampOffset;
      return l[0] = (t._frame.x + c + d) / u.width, l[1] = (t._frame.y + c + d) / u.height, l[2] = (t._frame.x + t._frame.width - c + d) / u.width, l[3] = (t._frame.y + t._frame.height - c + d) / u.height, this.uClampOffset[0] = d / u.realWidth, this.uClampOffset[1] = d / u.realHeight, this.isSimple = t._frame.width === u.width && t._frame.height === u.height && t.rotate === 0, true;
    }, i2;
  }()
), SpriteMaskFilter$1 = (
  /** @class */
  function(i2) {
    __extends$1(e, i2);
    function e(t, r, a) {
      var s = this, u = null;
      return typeof t != "string" && r === void 0 && a === void 0 && (u = t, t = void 0, r = void 0, a = void 0), s = i2.call(this, t || vertex, r || fragment, a) || this, s.maskSprite = u, s.maskMatrix = new Matrix$1(), s;
    }
    return Object.defineProperty(e.prototype, "maskSprite", {
      /**
       * Sprite mask
       * @type {PIXI.DisplayObject}
       */
      get: function() {
        return this._maskSprite;
      },
      set: function(t) {
        this._maskSprite = t, this._maskSprite && (this._maskSprite.renderable = false);
      },
      enumerable: false,
      configurable: true
    }), e.prototype.apply = function(t, r, a, s) {
      var u = this._maskSprite, l = u._texture;
      l.valid && (l.uvMatrix || (l.uvMatrix = new TextureMatrix$1(l, 0)), l.uvMatrix.update(), this.uniforms.npmAlpha = l.baseTexture.alphaMode ? 0 : 1, this.uniforms.mask = l, this.uniforms.otherMatrix = t.calculateSpriteMatrix(this.maskMatrix, u).prepend(l.uvMatrix.mapCoord), this.uniforms.alpha = u.worldAlpha, this.uniforms.maskClamp = l.uvMatrix.uClampFrame, t.applyFilter(this, r, a, s));
    }, e;
  }(Filter$1)
), MaskSystem = (
  /** @class */
  function() {
    function i2(e) {
      this.renderer = e, this.enableScissor = true, this.alphaMaskPool = [], this.maskDataPool = [], this.maskStack = [], this.alphaMaskIndex = 0;
    }
    return i2.prototype.setMaskStack = function(e) {
      this.maskStack = e, this.renderer.scissor.setMaskStack(e), this.renderer.stencil.setMaskStack(e);
    }, i2.prototype.push = function(e, t) {
      var r = t;
      if (!r.isMaskData) {
        var a = this.maskDataPool.pop() || new MaskData();
        a.pooled = true, a.maskObject = t, r = a;
      }
      var s = this.maskStack.length !== 0 ? this.maskStack[this.maskStack.length - 1] : null;
      if (r.copyCountersOrReset(s), r._colorMask = s ? s._colorMask : 15, r.autoDetect && this.detect(r), r._target = e, r.type !== MASK_TYPES.SPRITE && this.maskStack.push(r), r.enabled)
        switch (r.type) {
          case MASK_TYPES.SCISSOR:
            this.renderer.scissor.push(r);
            break;
          case MASK_TYPES.STENCIL:
            this.renderer.stencil.push(r);
            break;
          case MASK_TYPES.SPRITE:
            r.copyCountersOrReset(null), this.pushSpriteMask(r);
            break;
          case MASK_TYPES.COLOR:
            this.pushColorMask(r);
            break;
        }
      r.type === MASK_TYPES.SPRITE && this.maskStack.push(r);
    }, i2.prototype.pop = function(e) {
      var t = this.maskStack.pop();
      if (!(!t || t._target !== e)) {
        if (t.enabled)
          switch (t.type) {
            case MASK_TYPES.SCISSOR:
              this.renderer.scissor.pop(t);
              break;
            case MASK_TYPES.STENCIL:
              this.renderer.stencil.pop(t.maskObject);
              break;
            case MASK_TYPES.SPRITE:
              this.popSpriteMask(t);
              break;
            case MASK_TYPES.COLOR:
              this.popColorMask(t);
              break;
          }
        if (t.reset(), t.pooled && this.maskDataPool.push(t), this.maskStack.length !== 0) {
          var r = this.maskStack[this.maskStack.length - 1];
          r.type === MASK_TYPES.SPRITE && r._filters && (r._filters[0].maskSprite = r.maskObject);
        }
      }
    }, i2.prototype.detect = function(e) {
      var t = e.maskObject;
      t ? t.isSprite ? e.type = MASK_TYPES.SPRITE : this.enableScissor && this.renderer.scissor.testScissor(e) ? e.type = MASK_TYPES.SCISSOR : e.type = MASK_TYPES.STENCIL : e.type = MASK_TYPES.COLOR;
    }, i2.prototype.pushSpriteMask = function(e) {
      var t, r, a = e.maskObject, s = e._target, u = e._filters;
      u || (u = this.alphaMaskPool[this.alphaMaskIndex], u || (u = this.alphaMaskPool[this.alphaMaskIndex] = [new SpriteMaskFilter$1()]));
      var l = this.renderer, c = l.renderTexture, d, f;
      if (c.current) {
        var p = c.current;
        d = e.resolution || p.resolution, f = (t = e.multisample) !== null && t !== void 0 ? t : p.multisample;
      } else
        d = e.resolution || l.resolution, f = (r = e.multisample) !== null && r !== void 0 ? r : l.multisample;
      u[0].resolution = d, u[0].multisample = f, u[0].maskSprite = a;
      var m = s.filterArea;
      s.filterArea = a.getBounds(true), l.filter.push(s, u), s.filterArea = m, e._filters || this.alphaMaskIndex++;
    }, i2.prototype.popSpriteMask = function(e) {
      this.renderer.filter.pop(), e._filters ? e._filters[0].maskSprite = null : (this.alphaMaskIndex--, this.alphaMaskPool[this.alphaMaskIndex][0].maskSprite = null);
    }, i2.prototype.pushColorMask = function(e) {
      var t = e._colorMask, r = e._colorMask = t & e.colorMask;
      r !== t && this.renderer.gl.colorMask((r & 1) !== 0, (r & 2) !== 0, (r & 4) !== 0, (r & 8) !== 0);
    }, i2.prototype.popColorMask = function(e) {
      var t = e._colorMask, r = this.maskStack.length > 0 ? this.maskStack[this.maskStack.length - 1]._colorMask : 15;
      r !== t && this.renderer.gl.colorMask((r & 1) !== 0, (r & 2) !== 0, (r & 4) !== 0, (r & 8) !== 0);
    }, i2.prototype.destroy = function() {
      this.renderer = null;
    }, i2;
  }()
), AbstractMaskSystem = (
  /** @class */
  function() {
    function i2(e) {
      this.renderer = e, this.maskStack = [], this.glConst = 0;
    }
    return i2.prototype.getStackLength = function() {
      return this.maskStack.length;
    }, i2.prototype.setMaskStack = function(e) {
      var t = this.renderer.gl, r = this.getStackLength();
      this.maskStack = e;
      var a = this.getStackLength();
      a !== r && (a === 0 ? t.disable(this.glConst) : (t.enable(this.glConst), this._useCurrent()));
    }, i2.prototype._useCurrent = function() {
    }, i2.prototype.destroy = function() {
      this.renderer = null, this.maskStack = null;
    }, i2;
  }()
), tempMatrix$1 = new Matrix$1(), rectPool = [], ScissorSystem = (
  /** @class */
  function(i2) {
    __extends$1(e, i2);
    function e(t) {
      var r = i2.call(this, t) || this;
      return r.glConst = settings$1.ADAPTER.getWebGLRenderingContext().SCISSOR_TEST, r;
    }
    return e.prototype.getStackLength = function() {
      var t = this.maskStack[this.maskStack.length - 1];
      return t ? t._scissorCounter : 0;
    }, e.prototype.calcScissorRect = function(t) {
      var r;
      if (!t._scissorRectLocal) {
        var a = t._scissorRect, s = t.maskObject, u = this.renderer, l = u.renderTexture, c = s.getBounds(true, (r = rectPool.pop()) !== null && r !== void 0 ? r : new Rectangle$1());
        this.roundFrameToPixels(c, l.current ? l.current.resolution : u.resolution, l.sourceFrame, l.destinationFrame, u.projection.transform), a && c.fit(a), t._scissorRectLocal = c;
      }
    }, e.isMatrixRotated = function(t) {
      if (!t)
        return false;
      var r = t.a, a = t.b, s = t.c, u = t.d;
      return (Math.abs(a) > 1e-4 || Math.abs(s) > 1e-4) && (Math.abs(r) > 1e-4 || Math.abs(u) > 1e-4);
    }, e.prototype.testScissor = function(t) {
      var r = t.maskObject;
      if (!r.isFastRect || !r.isFastRect() || e.isMatrixRotated(r.worldTransform) || e.isMatrixRotated(this.renderer.projection.transform))
        return false;
      this.calcScissorRect(t);
      var a = t._scissorRectLocal;
      return a.width > 0 && a.height > 0;
    }, e.prototype.roundFrameToPixels = function(t, r, a, s, u) {
      e.isMatrixRotated(u) || (u = u ? tempMatrix$1.copyFrom(u) : tempMatrix$1.identity(), u.translate(-a.x, -a.y).scale(s.width / a.width, s.height / a.height).translate(s.x, s.y), this.renderer.filter.transformAABB(u, t), t.fit(s), t.x = Math.round(t.x * r), t.y = Math.round(t.y * r), t.width = Math.round(t.width * r), t.height = Math.round(t.height * r));
    }, e.prototype.push = function(t) {
      t._scissorRectLocal || this.calcScissorRect(t);
      var r = this.renderer.gl;
      t._scissorRect || r.enable(r.SCISSOR_TEST), t._scissorCounter++, t._scissorRect = t._scissorRectLocal, this._useCurrent();
    }, e.prototype.pop = function(t) {
      var r = this.renderer.gl;
      t && rectPool.push(t._scissorRectLocal), this.getStackLength() > 0 ? this._useCurrent() : r.disable(r.SCISSOR_TEST);
    }, e.prototype._useCurrent = function() {
      var t = this.maskStack[this.maskStack.length - 1]._scissorRect, r;
      this.renderer.renderTexture.current ? r = t.y : r = this.renderer.height - t.height - t.y, this.renderer.gl.scissor(t.x, r, t.width, t.height);
    }, e;
  }(AbstractMaskSystem)
), StencilSystem = (
  /** @class */
  function(i2) {
    __extends$1(e, i2);
    function e(t) {
      var r = i2.call(this, t) || this;
      return r.glConst = settings$1.ADAPTER.getWebGLRenderingContext().STENCIL_TEST, r;
    }
    return e.prototype.getStackLength = function() {
      var t = this.maskStack[this.maskStack.length - 1];
      return t ? t._stencilCounter : 0;
    }, e.prototype.push = function(t) {
      var r = t.maskObject, a = this.renderer.gl, s = t._stencilCounter;
      s === 0 && (this.renderer.framebuffer.forceStencil(), a.clearStencil(0), a.clear(a.STENCIL_BUFFER_BIT), a.enable(a.STENCIL_TEST)), t._stencilCounter++;
      var u = t._colorMask;
      u !== 0 && (t._colorMask = 0, a.colorMask(false, false, false, false)), a.stencilFunc(a.EQUAL, s, 4294967295), a.stencilOp(a.KEEP, a.KEEP, a.INCR), r.renderable = true, r.render(this.renderer), this.renderer.batch.flush(), r.renderable = false, u !== 0 && (t._colorMask = u, a.colorMask((u & 1) !== 0, (u & 2) !== 0, (u & 4) !== 0, (u & 8) !== 0)), this._useCurrent();
    }, e.prototype.pop = function(t) {
      var r = this.renderer.gl;
      if (this.getStackLength() === 0)
        r.disable(r.STENCIL_TEST);
      else {
        var a = this.maskStack.length !== 0 ? this.maskStack[this.maskStack.length - 1] : null, s = a ? a._colorMask : 15;
        s !== 0 && (a._colorMask = 0, r.colorMask(false, false, false, false)), r.stencilOp(r.KEEP, r.KEEP, r.DECR), t.renderable = true, t.render(this.renderer), this.renderer.batch.flush(), t.renderable = false, s !== 0 && (a._colorMask = s, r.colorMask((s & 1) !== 0, (s & 2) !== 0, (s & 4) !== 0, (s & 8) !== 0)), this._useCurrent();
      }
    }, e.prototype._useCurrent = function() {
      var t = this.renderer.gl;
      t.stencilFunc(t.EQUAL, this.getStackLength(), 4294967295), t.stencilOp(t.KEEP, t.KEEP, t.KEEP);
    }, e;
  }(AbstractMaskSystem)
), ProjectionSystem = (
  /** @class */
  function() {
    function i2(e) {
      this.renderer = e, this.destinationFrame = null, this.sourceFrame = null, this.defaultFrame = null, this.projectionMatrix = new Matrix$1(), this.transform = null;
    }
    return i2.prototype.update = function(e, t, r, a) {
      this.destinationFrame = e || this.destinationFrame || this.defaultFrame, this.sourceFrame = t || this.sourceFrame || e, this.calculateProjection(this.destinationFrame, this.sourceFrame, r, a), this.transform && this.projectionMatrix.append(this.transform);
      var s = this.renderer;
      s.globalUniforms.uniforms.projectionMatrix = this.projectionMatrix, s.globalUniforms.update(), s.shader.shader && s.shader.syncUniformGroup(s.shader.shader.uniforms.globals);
    }, i2.prototype.calculateProjection = function(e, t, r, a) {
      var s = this.projectionMatrix, u = a ? -1 : 1;
      s.identity(), s.a = 1 / t.width * 2, s.d = u * (1 / t.height * 2), s.tx = -1 - t.x * s.a, s.ty = -u - t.y * s.d;
    }, i2.prototype.setTransform = function(e) {
    }, i2.prototype.destroy = function() {
      this.renderer = null;
    }, i2;
  }()
), tempRect = new Rectangle$1(), tempRect2 = new Rectangle$1(), RenderTextureSystem = (
  /** @class */
  function() {
    function i2(e) {
      this.renderer = e, this.clearColor = e._backgroundColorRgba, this.defaultMaskStack = [], this.current = null, this.sourceFrame = new Rectangle$1(), this.destinationFrame = new Rectangle$1(), this.viewportFrame = new Rectangle$1();
    }
    return i2.prototype.bind = function(e, t, r) {
      e === void 0 && (e = null);
      var a = this.renderer;
      this.current = e;
      var s, u, l;
      e ? (s = e.baseTexture, l = s.resolution, t || (tempRect.width = e.frame.width, tempRect.height = e.frame.height, t = tempRect), r || (tempRect2.x = e.frame.x, tempRect2.y = e.frame.y, tempRect2.width = t.width, tempRect2.height = t.height, r = tempRect2), u = s.framebuffer) : (l = a.resolution, t || (tempRect.width = a.screen.width, tempRect.height = a.screen.height, t = tempRect), r || (r = tempRect, r.width = t.width, r.height = t.height));
      var c = this.viewportFrame;
      c.x = r.x * l, c.y = r.y * l, c.width = r.width * l, c.height = r.height * l, e || (c.y = a.view.height - (c.y + c.height)), c.ceil(), this.renderer.framebuffer.bind(u, c), this.renderer.projection.update(r, t, l, !u), e ? this.renderer.mask.setMaskStack(s.maskStack) : this.renderer.mask.setMaskStack(this.defaultMaskStack), this.sourceFrame.copyFrom(t), this.destinationFrame.copyFrom(r);
    }, i2.prototype.clear = function(e, t) {
      this.current ? e = e || this.current.baseTexture.clearColor : e = e || this.clearColor;
      var r = this.destinationFrame, a = this.current ? this.current.baseTexture : this.renderer.screen, s = r.width !== a.width || r.height !== a.height;
      if (s) {
        var u = this.viewportFrame, l = u.x, c = u.y, d = u.width, f = u.height;
        l = Math.round(l), c = Math.round(c), d = Math.round(d), f = Math.round(f), this.renderer.gl.enable(this.renderer.gl.SCISSOR_TEST), this.renderer.gl.scissor(l, c, d, f);
      }
      this.renderer.framebuffer.clear(e[0], e[1], e[2], e[3], t), s && this.renderer.scissor.pop();
    }, i2.prototype.resize = function() {
      this.bind(null);
    }, i2.prototype.reset = function() {
      this.bind(null);
    }, i2.prototype.destroy = function() {
      this.renderer = null;
    }, i2;
  }()
);
function uboUpdate(i2, e, t, r, a) {
  t.buffer.update(a);
}
var UBO_TO_SINGLE_SETTERS = {
  float: `
        data[offset] = v;
    `,
  vec2: `
        data[offset] = v[0];
        data[offset+1] = v[1];
    `,
  vec3: `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];

    `,
  vec4: `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];
        data[offset+3] = v[3];
    `,
  mat2: `
        data[offset] = v[0];
        data[offset+1] = v[1];

        data[offset+4] = v[2];
        data[offset+5] = v[3];
    `,
  mat3: `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];

        data[offset + 4] = v[3];
        data[offset + 5] = v[4];
        data[offset + 6] = v[5];

        data[offset + 8] = v[6];
        data[offset + 9] = v[7];
        data[offset + 10] = v[8];
    `,
  mat4: `
        for(var i = 0; i < 16; i++)
        {
            data[offset + i] = v[i];
        }
    `
}, GLSL_TO_STD40_SIZE = {
  float: 4,
  vec2: 8,
  vec3: 12,
  vec4: 16,
  int: 4,
  ivec2: 8,
  ivec3: 12,
  ivec4: 16,
  uint: 4,
  uvec2: 8,
  uvec3: 12,
  uvec4: 16,
  bool: 4,
  bvec2: 8,
  bvec3: 12,
  bvec4: 16,
  mat2: 16 * 2,
  mat3: 16 * 3,
  mat4: 16 * 4
};
function createUBOElements(i2) {
  for (var e = i2.map(function(c) {
    return {
      data: c,
      offset: 0,
      dataLen: 0,
      dirty: 0
    };
  }), t = 0, r = 0, a = 0, s = 0; s < e.length; s++) {
    var u = e[s];
    if (t = GLSL_TO_STD40_SIZE[u.data.type], u.data.size > 1 && (t = Math.max(t, 16) * u.data.size), u.dataLen = t, r % t !== 0 && r < 16) {
      var l = r % t % 16;
      r += l, a += l;
    }
    r + t > 16 ? (a = Math.ceil(a / 16) * 16, u.offset = a, a += t, r = t) : (u.offset = a, r += t, a += t);
  }
  return a = Math.ceil(a / 16) * 16, { uboElements: e, size: a };
}
function getUBOData(i2, e) {
  var t = [];
  for (var r in i2)
    e[r] && t.push(e[r]);
  return t.sort(function(a, s) {
    return a.index - s.index;
  }), t;
}
function generateUniformBufferSync(i2, e) {
  if (!i2.autoManage)
    return { size: 0, syncFunc: uboUpdate };
  for (var t = getUBOData(i2.uniforms, e), r = createUBOElements(t), a = r.uboElements, s = r.size, u = [`
    var v = null;
    var v2 = null;
    var cv = null;
    var t = 0;
    var gl = renderer.gl
    var index = 0;
    var data = buffer.data;
    `], l = 0; l < a.length; l++) {
    for (var c = a[l], d = i2.uniforms[c.data.name], f = c.data.name, p = false, m = 0; m < uniformParsers.length; m++) {
      var y = uniformParsers[m];
      if (y.codeUbo && y.test(c.data, d)) {
        u.push("offset = " + c.offset / 4 + ";", uniformParsers[m].codeUbo(c.data.name, d)), p = true;
        break;
      }
    }
    if (!p)
      if (c.data.size > 1) {
        var x = mapSize(c.data.type), g = Math.max(GLSL_TO_STD40_SIZE[c.data.type] / 16, 1), _ = x / g, T = (4 - _ % 4) % 4;
        u.push(`
                cv = ud.` + f + `.value;
                v = uv.` + f + `;
                offset = ` + c.offset / 4 + `;

                t = 0;

                for(var i=0; i < ` + c.data.size * g + `; i++)
                {
                    for(var j = 0; j < ` + _ + `; j++)
                    {
                        data[offset++] = v[t++];
                    }
                    offset += ` + T + `;
                }

                `);
      } else {
        var E = UBO_TO_SINGLE_SETTERS[c.data.type];
        u.push(`
                cv = ud.` + f + `.value;
                v = uv.` + f + `;
                offset = ` + c.offset / 4 + `;
                ` + E + `;
                `);
      }
  }
  return u.push(`
       renderer.buffer.update(buffer);
    `), {
    size: s,
    // eslint-disable-next-line no-new-func
    syncFunc: new Function("ud", "uv", "renderer", "syncData", "buffer", u.join(`
`))
  };
}
var GLProgram = (
  /** @class */
  function() {
    function i2(e, t) {
      this.program = e, this.uniformData = t, this.uniformGroups = {}, this.uniformDirtyGroups = {}, this.uniformBufferBindings = {};
    }
    return i2.prototype.destroy = function() {
      this.uniformData = null, this.uniformGroups = null, this.uniformDirtyGroups = null, this.uniformBufferBindings = null, this.program = null;
    }, i2;
  }()
);
function getAttributeData(i2, e) {
  for (var t = {}, r = e.getProgramParameter(i2, e.ACTIVE_ATTRIBUTES), a = 0; a < r; a++) {
    var s = e.getActiveAttrib(i2, a);
    if (s.name.indexOf("gl_") !== 0) {
      var u = mapType(e, s.type), l = {
        type: u,
        name: s.name,
        size: mapSize(u),
        location: e.getAttribLocation(i2, s.name)
      };
      t[s.name] = l;
    }
  }
  return t;
}
function getUniformData(i2, e) {
  for (var t = {}, r = e.getProgramParameter(i2, e.ACTIVE_UNIFORMS), a = 0; a < r; a++) {
    var s = e.getActiveUniform(i2, a), u = s.name.replace(/\[.*?\]$/, ""), l = !!s.name.match(/\[.*?\]$/), c = mapType(e, s.type);
    t[u] = {
      name: u,
      index: a,
      type: c,
      size: s.size,
      isArray: l,
      value: defaultValue(c, s.size)
    };
  }
  return t;
}
function generateProgram(i2, e) {
  var t = compileShader(i2, i2.VERTEX_SHADER, e.vertexSrc), r = compileShader(i2, i2.FRAGMENT_SHADER, e.fragmentSrc), a = i2.createProgram();
  if (i2.attachShader(a, t), i2.attachShader(a, r), i2.linkProgram(a), i2.getProgramParameter(a, i2.LINK_STATUS) || logProgramError(i2, a, t, r), e.attributeData = getAttributeData(a, i2), e.uniformData = getUniformData(a, i2), !/^[ \t]*#[ \t]*version[ \t]+300[ \t]+es[ \t]*$/m.test(e.vertexSrc)) {
    var s = Object.keys(e.attributeData);
    s.sort(function(f, p) {
      return f > p ? 1 : -1;
    });
    for (var u = 0; u < s.length; u++)
      e.attributeData[s[u]].location = u, i2.bindAttribLocation(a, u, s[u]);
    i2.linkProgram(a);
  }
  i2.deleteShader(t), i2.deleteShader(r);
  var l = {};
  for (var u in e.uniformData) {
    var c = e.uniformData[u];
    l[u] = {
      location: i2.getUniformLocation(a, u),
      value: defaultValue(c.type, c.size)
    };
  }
  var d = new GLProgram(a, l);
  return d;
}
var UID = 0, defaultSyncData = { textureCount: 0, uboCount: 0 }, ShaderSystem = (
  /** @class */
  function() {
    function i2(e) {
      this.destroyed = false, this.renderer = e, this.systemCheck(), this.gl = null, this.shader = null, this.program = null, this.cache = {}, this._uboCache = {}, this.id = UID++;
    }
    return i2.prototype.systemCheck = function() {
      if (!unsafeEvalSupported())
        throw new Error("Current environment does not allow unsafe-eval, please use @pixi/unsafe-eval module to enable support.");
    }, i2.prototype.contextChange = function(e) {
      this.gl = e, this.reset();
    }, i2.prototype.bind = function(e, t) {
      e.disposeRunner.add(this), e.uniforms.globals = this.renderer.globalUniforms;
      var r = e.program, a = r.glPrograms[this.renderer.CONTEXT_UID] || this.generateProgram(e);
      return this.shader = e, this.program !== r && (this.program = r, this.gl.useProgram(a.program)), t || (defaultSyncData.textureCount = 0, defaultSyncData.uboCount = 0, this.syncUniformGroup(e.uniformGroup, defaultSyncData)), a;
    }, i2.prototype.setUniforms = function(e) {
      var t = this.shader.program, r = t.glPrograms[this.renderer.CONTEXT_UID];
      t.syncUniforms(r.uniformData, e, this.renderer);
    }, i2.prototype.syncUniformGroup = function(e, t) {
      var r = this.getGlProgram();
      (!e.static || e.dirtyId !== r.uniformDirtyGroups[e.id]) && (r.uniformDirtyGroups[e.id] = e.dirtyId, this.syncUniforms(e, r, t));
    }, i2.prototype.syncUniforms = function(e, t, r) {
      var a = e.syncUniforms[this.shader.program.id] || this.createSyncGroups(e);
      a(t.uniformData, e.uniforms, this.renderer, r);
    }, i2.prototype.createSyncGroups = function(e) {
      var t = this.getSignature(e, this.shader.program.uniformData, "u");
      return this.cache[t] || (this.cache[t] = generateUniformsSync(e, this.shader.program.uniformData)), e.syncUniforms[this.shader.program.id] = this.cache[t], e.syncUniforms[this.shader.program.id];
    }, i2.prototype.syncUniformBufferGroup = function(e, t) {
      var r = this.getGlProgram();
      if (!e.static || e.dirtyId !== 0 || !r.uniformGroups[e.id]) {
        e.dirtyId = 0;
        var a = r.uniformGroups[e.id] || this.createSyncBufferGroup(e, r, t);
        e.buffer.update(), a(r.uniformData, e.uniforms, this.renderer, defaultSyncData, e.buffer);
      }
      this.renderer.buffer.bindBufferBase(e.buffer, r.uniformBufferBindings[t]);
    }, i2.prototype.createSyncBufferGroup = function(e, t, r) {
      var a = this.renderer.gl;
      this.renderer.buffer.bind(e.buffer);
      var s = this.gl.getUniformBlockIndex(t.program, r);
      t.uniformBufferBindings[r] = this.shader.uniformBindCount, a.uniformBlockBinding(t.program, s, this.shader.uniformBindCount), this.shader.uniformBindCount++;
      var u = this.getSignature(e, this.shader.program.uniformData, "ubo"), l = this._uboCache[u];
      if (l || (l = this._uboCache[u] = generateUniformBufferSync(e, this.shader.program.uniformData)), e.autoManage) {
        var c = new Float32Array(l.size / 4);
        e.buffer.update(c);
      }
      return t.uniformGroups[e.id] = l.syncFunc, t.uniformGroups[e.id];
    }, i2.prototype.getSignature = function(e, t, r) {
      var a = e.uniforms, s = [r + "-"];
      for (var u in a)
        s.push(u), t[u] && s.push(t[u].type);
      return s.join("-");
    }, i2.prototype.getGlProgram = function() {
      return this.shader ? this.shader.program.glPrograms[this.renderer.CONTEXT_UID] : null;
    }, i2.prototype.generateProgram = function(e) {
      var t = this.gl, r = e.program, a = generateProgram(t, r);
      return r.glPrograms[this.renderer.CONTEXT_UID] = a, a;
    }, i2.prototype.reset = function() {
      this.program = null, this.shader = null;
    }, i2.prototype.disposeShader = function(e) {
      this.shader === e && (this.shader = null);
    }, i2.prototype.destroy = function() {
      this.renderer = null, this.destroyed = true;
    }, i2;
  }()
);
function mapWebGLBlendModesToPixi$1(i2, e) {
  return e === void 0 && (e = []), e[BLEND_MODES.NORMAL] = [i2.ONE, i2.ONE_MINUS_SRC_ALPHA], e[BLEND_MODES.ADD] = [i2.ONE, i2.ONE], e[BLEND_MODES.MULTIPLY] = [i2.DST_COLOR, i2.ONE_MINUS_SRC_ALPHA, i2.ONE, i2.ONE_MINUS_SRC_ALPHA], e[BLEND_MODES.SCREEN] = [i2.ONE, i2.ONE_MINUS_SRC_COLOR, i2.ONE, i2.ONE_MINUS_SRC_ALPHA], e[BLEND_MODES.OVERLAY] = [i2.ONE, i2.ONE_MINUS_SRC_ALPHA], e[BLEND_MODES.DARKEN] = [i2.ONE, i2.ONE_MINUS_SRC_ALPHA], e[BLEND_MODES.LIGHTEN] = [i2.ONE, i2.ONE_MINUS_SRC_ALPHA], e[BLEND_MODES.COLOR_DODGE] = [i2.ONE, i2.ONE_MINUS_SRC_ALPHA], e[BLEND_MODES.COLOR_BURN] = [i2.ONE, i2.ONE_MINUS_SRC_ALPHA], e[BLEND_MODES.HARD_LIGHT] = [i2.ONE, i2.ONE_MINUS_SRC_ALPHA], e[BLEND_MODES.SOFT_LIGHT] = [i2.ONE, i2.ONE_MINUS_SRC_ALPHA], e[BLEND_MODES.DIFFERENCE] = [i2.ONE, i2.ONE_MINUS_SRC_ALPHA], e[BLEND_MODES.EXCLUSION] = [i2.ONE, i2.ONE_MINUS_SRC_ALPHA], e[BLEND_MODES.HUE] = [i2.ONE, i2.ONE_MINUS_SRC_ALPHA], e[BLEND_MODES.SATURATION] = [i2.ONE, i2.ONE_MINUS_SRC_ALPHA], e[BLEND_MODES.COLOR] = [i2.ONE, i2.ONE_MINUS_SRC_ALPHA], e[BLEND_MODES.LUMINOSITY] = [i2.ONE, i2.ONE_MINUS_SRC_ALPHA], e[BLEND_MODES.NONE] = [0, 0], e[BLEND_MODES.NORMAL_NPM] = [i2.SRC_ALPHA, i2.ONE_MINUS_SRC_ALPHA, i2.ONE, i2.ONE_MINUS_SRC_ALPHA], e[BLEND_MODES.ADD_NPM] = [i2.SRC_ALPHA, i2.ONE, i2.ONE, i2.ONE], e[BLEND_MODES.SCREEN_NPM] = [i2.SRC_ALPHA, i2.ONE_MINUS_SRC_COLOR, i2.ONE, i2.ONE_MINUS_SRC_ALPHA], e[BLEND_MODES.SRC_IN] = [i2.DST_ALPHA, i2.ZERO], e[BLEND_MODES.SRC_OUT] = [i2.ONE_MINUS_DST_ALPHA, i2.ZERO], e[BLEND_MODES.SRC_ATOP] = [i2.DST_ALPHA, i2.ONE_MINUS_SRC_ALPHA], e[BLEND_MODES.DST_OVER] = [i2.ONE_MINUS_DST_ALPHA, i2.ONE], e[BLEND_MODES.DST_IN] = [i2.ZERO, i2.SRC_ALPHA], e[BLEND_MODES.DST_OUT] = [i2.ZERO, i2.ONE_MINUS_SRC_ALPHA], e[BLEND_MODES.DST_ATOP] = [i2.ONE_MINUS_DST_ALPHA, i2.SRC_ALPHA], e[BLEND_MODES.XOR] = [i2.ONE_MINUS_DST_ALPHA, i2.ONE_MINUS_SRC_ALPHA], e[BLEND_MODES.SUBTRACT] = [i2.ONE, i2.ONE, i2.ONE, i2.ONE, i2.FUNC_REVERSE_SUBTRACT, i2.FUNC_ADD], e;
}
var BLEND = 0, OFFSET = 1, CULLING = 2, DEPTH_TEST = 3, WINDING = 4, DEPTH_MASK = 5, StateSystem = (
  /** @class */
  function() {
    function i2() {
      this.gl = null, this.stateId = 0, this.polygonOffset = 0, this.blendMode = BLEND_MODES.NONE, this._blendEq = false, this.map = [], this.map[BLEND] = this.setBlend, this.map[OFFSET] = this.setOffset, this.map[CULLING] = this.setCullFace, this.map[DEPTH_TEST] = this.setDepthTest, this.map[WINDING] = this.setFrontFace, this.map[DEPTH_MASK] = this.setDepthMask, this.checks = [], this.defaultState = new State(), this.defaultState.blend = true;
    }
    return i2.prototype.contextChange = function(e) {
      this.gl = e, this.blendModes = mapWebGLBlendModesToPixi$1(e), this.set(this.defaultState), this.reset();
    }, i2.prototype.set = function(e) {
      if (e = e || this.defaultState, this.stateId !== e.data) {
        for (var t = this.stateId ^ e.data, r = 0; t; )
          t & 1 && this.map[r].call(this, !!(e.data & 1 << r)), t = t >> 1, r++;
        this.stateId = e.data;
      }
      for (var r = 0; r < this.checks.length; r++)
        this.checks[r](this, e);
    }, i2.prototype.forceState = function(e) {
      e = e || this.defaultState;
      for (var t = 0; t < this.map.length; t++)
        this.map[t].call(this, !!(e.data & 1 << t));
      for (var t = 0; t < this.checks.length; t++)
        this.checks[t](this, e);
      this.stateId = e.data;
    }, i2.prototype.setBlend = function(e) {
      this.updateCheck(i2.checkBlendMode, e), this.gl[e ? "enable" : "disable"](this.gl.BLEND);
    }, i2.prototype.setOffset = function(e) {
      this.updateCheck(i2.checkPolygonOffset, e), this.gl[e ? "enable" : "disable"](this.gl.POLYGON_OFFSET_FILL);
    }, i2.prototype.setDepthTest = function(e) {
      this.gl[e ? "enable" : "disable"](this.gl.DEPTH_TEST);
    }, i2.prototype.setDepthMask = function(e) {
      this.gl.depthMask(e);
    }, i2.prototype.setCullFace = function(e) {
      this.gl[e ? "enable" : "disable"](this.gl.CULL_FACE);
    }, i2.prototype.setFrontFace = function(e) {
      this.gl.frontFace(this.gl[e ? "CW" : "CCW"]);
    }, i2.prototype.setBlendMode = function(e) {
      if (e !== this.blendMode) {
        this.blendMode = e;
        var t = this.blendModes[e], r = this.gl;
        t.length === 2 ? r.blendFunc(t[0], t[1]) : r.blendFuncSeparate(t[0], t[1], t[2], t[3]), t.length === 6 ? (this._blendEq = true, r.blendEquationSeparate(t[4], t[5])) : this._blendEq && (this._blendEq = false, r.blendEquationSeparate(r.FUNC_ADD, r.FUNC_ADD));
      }
    }, i2.prototype.setPolygonOffset = function(e, t) {
      this.gl.polygonOffset(e, t);
    }, i2.prototype.reset = function() {
      this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, false), this.forceState(this.defaultState), this._blendEq = true, this.blendMode = -1, this.setBlendMode(0);
    }, i2.prototype.updateCheck = function(e, t) {
      var r = this.checks.indexOf(e);
      t && r === -1 ? this.checks.push(e) : !t && r !== -1 && this.checks.splice(r, 1);
    }, i2.checkBlendMode = function(e, t) {
      e.setBlendMode(t.blendMode);
    }, i2.checkPolygonOffset = function(e, t) {
      e.setPolygonOffset(1, t.polygonOffset);
    }, i2.prototype.destroy = function() {
      this.gl = null;
    }, i2;
  }()
), TextureGCSystem = (
  /** @class */
  function() {
    function i2(e) {
      this.renderer = e, this.count = 0, this.checkCount = 0, this.maxIdle = settings$1.GC_MAX_IDLE, this.checkCountMax = settings$1.GC_MAX_CHECK_COUNT, this.mode = settings$1.GC_MODE;
    }
    return i2.prototype.postrender = function() {
      this.renderer.renderingToScreen && (this.count++, this.mode !== GC_MODES.MANUAL && (this.checkCount++, this.checkCount > this.checkCountMax && (this.checkCount = 0, this.run())));
    }, i2.prototype.run = function() {
      for (var e = this.renderer.texture, t = e.managedTextures, r = false, a = 0; a < t.length; a++) {
        var s = t[a];
        !s.framebuffer && this.count - s.touched > this.maxIdle && (e.destroyTexture(s, true), t[a] = null, r = true);
      }
      if (r) {
        for (var u = 0, a = 0; a < t.length; a++)
          t[a] !== null && (t[u++] = t[a]);
        t.length = u;
      }
    }, i2.prototype.unload = function(e) {
      var t = this.renderer.texture, r = e._texture;
      r && !r.framebuffer && t.destroyTexture(r);
      for (var a = e.children.length - 1; a >= 0; a--)
        this.unload(e.children[a]);
    }, i2.prototype.destroy = function() {
      this.renderer = null;
    }, i2;
  }()
);
function mapTypeAndFormatToInternalFormat(i2) {
  var e, t, r, a, s, u, l, c, d, f, p, m, y, x, g, _, T, E, b, C, w, A, S;
  return "WebGL2RenderingContext" in globalThis && i2 instanceof globalThis.WebGL2RenderingContext ? S = (e = {}, e[TYPES.UNSIGNED_BYTE] = (t = {}, t[FORMATS.RGBA] = i2.RGBA8, t[FORMATS.RGB] = i2.RGB8, t[FORMATS.RG] = i2.RG8, t[FORMATS.RED] = i2.R8, t[FORMATS.RGBA_INTEGER] = i2.RGBA8UI, t[FORMATS.RGB_INTEGER] = i2.RGB8UI, t[FORMATS.RG_INTEGER] = i2.RG8UI, t[FORMATS.RED_INTEGER] = i2.R8UI, t[FORMATS.ALPHA] = i2.ALPHA, t[FORMATS.LUMINANCE] = i2.LUMINANCE, t[FORMATS.LUMINANCE_ALPHA] = i2.LUMINANCE_ALPHA, t), e[TYPES.BYTE] = (r = {}, r[FORMATS.RGBA] = i2.RGBA8_SNORM, r[FORMATS.RGB] = i2.RGB8_SNORM, r[FORMATS.RG] = i2.RG8_SNORM, r[FORMATS.RED] = i2.R8_SNORM, r[FORMATS.RGBA_INTEGER] = i2.RGBA8I, r[FORMATS.RGB_INTEGER] = i2.RGB8I, r[FORMATS.RG_INTEGER] = i2.RG8I, r[FORMATS.RED_INTEGER] = i2.R8I, r), e[TYPES.UNSIGNED_SHORT] = (a = {}, a[FORMATS.RGBA_INTEGER] = i2.RGBA16UI, a[FORMATS.RGB_INTEGER] = i2.RGB16UI, a[FORMATS.RG_INTEGER] = i2.RG16UI, a[FORMATS.RED_INTEGER] = i2.R16UI, a[FORMATS.DEPTH_COMPONENT] = i2.DEPTH_COMPONENT16, a), e[TYPES.SHORT] = (s = {}, s[FORMATS.RGBA_INTEGER] = i2.RGBA16I, s[FORMATS.RGB_INTEGER] = i2.RGB16I, s[FORMATS.RG_INTEGER] = i2.RG16I, s[FORMATS.RED_INTEGER] = i2.R16I, s), e[TYPES.UNSIGNED_INT] = (u = {}, u[FORMATS.RGBA_INTEGER] = i2.RGBA32UI, u[FORMATS.RGB_INTEGER] = i2.RGB32UI, u[FORMATS.RG_INTEGER] = i2.RG32UI, u[FORMATS.RED_INTEGER] = i2.R32UI, u[FORMATS.DEPTH_COMPONENT] = i2.DEPTH_COMPONENT24, u), e[TYPES.INT] = (l = {}, l[FORMATS.RGBA_INTEGER] = i2.RGBA32I, l[FORMATS.RGB_INTEGER] = i2.RGB32I, l[FORMATS.RG_INTEGER] = i2.RG32I, l[FORMATS.RED_INTEGER] = i2.R32I, l), e[TYPES.FLOAT] = (c = {}, c[FORMATS.RGBA] = i2.RGBA32F, c[FORMATS.RGB] = i2.RGB32F, c[FORMATS.RG] = i2.RG32F, c[FORMATS.RED] = i2.R32F, c[FORMATS.DEPTH_COMPONENT] = i2.DEPTH_COMPONENT32F, c), e[TYPES.HALF_FLOAT] = (d = {}, d[FORMATS.RGBA] = i2.RGBA16F, d[FORMATS.RGB] = i2.RGB16F, d[FORMATS.RG] = i2.RG16F, d[FORMATS.RED] = i2.R16F, d), e[TYPES.UNSIGNED_SHORT_5_6_5] = (f = {}, f[FORMATS.RGB] = i2.RGB565, f), e[TYPES.UNSIGNED_SHORT_4_4_4_4] = (p = {}, p[FORMATS.RGBA] = i2.RGBA4, p), e[TYPES.UNSIGNED_SHORT_5_5_5_1] = (m = {}, m[FORMATS.RGBA] = i2.RGB5_A1, m), e[TYPES.UNSIGNED_INT_2_10_10_10_REV] = (y = {}, y[FORMATS.RGBA] = i2.RGB10_A2, y[FORMATS.RGBA_INTEGER] = i2.RGB10_A2UI, y), e[TYPES.UNSIGNED_INT_10F_11F_11F_REV] = (x = {}, x[FORMATS.RGB] = i2.R11F_G11F_B10F, x), e[TYPES.UNSIGNED_INT_5_9_9_9_REV] = (g = {}, g[FORMATS.RGB] = i2.RGB9_E5, g), e[TYPES.UNSIGNED_INT_24_8] = (_ = {}, _[FORMATS.DEPTH_STENCIL] = i2.DEPTH24_STENCIL8, _), e[TYPES.FLOAT_32_UNSIGNED_INT_24_8_REV] = (T = {}, T[FORMATS.DEPTH_STENCIL] = i2.DEPTH32F_STENCIL8, T), e) : S = (E = {}, E[TYPES.UNSIGNED_BYTE] = (b = {}, b[FORMATS.RGBA] = i2.RGBA, b[FORMATS.RGB] = i2.RGB, b[FORMATS.ALPHA] = i2.ALPHA, b[FORMATS.LUMINANCE] = i2.LUMINANCE, b[FORMATS.LUMINANCE_ALPHA] = i2.LUMINANCE_ALPHA, b), E[TYPES.UNSIGNED_SHORT_5_6_5] = (C = {}, C[FORMATS.RGB] = i2.RGB, C), E[TYPES.UNSIGNED_SHORT_4_4_4_4] = (w = {}, w[FORMATS.RGBA] = i2.RGBA, w), E[TYPES.UNSIGNED_SHORT_5_5_5_1] = (A = {}, A[FORMATS.RGBA] = i2.RGBA, A), E), S;
}
var GLTexture$1 = (
  /** @class */
  /* @__PURE__ */ function() {
    function i2(e) {
      this.texture = e, this.width = -1, this.height = -1, this.dirtyId = -1, this.dirtyStyleId = -1, this.mipmap = false, this.wrapMode = 33071, this.type = TYPES.UNSIGNED_BYTE, this.internalFormat = FORMATS.RGBA, this.samplerType = 0;
    }
    return i2;
  }()
), TextureSystem = (
  /** @class */
  function() {
    function i2(e) {
      this.renderer = e, this.boundTextures = [], this.currentLocation = -1, this.managedTextures = [], this._unknownBoundTextures = false, this.unknownTexture = new BaseTexture$1(), this.hasIntegerTextures = false;
    }
    return i2.prototype.contextChange = function() {
      var e = this.gl = this.renderer.gl;
      this.CONTEXT_UID = this.renderer.CONTEXT_UID, this.webGLVersion = this.renderer.context.webGLVersion, this.internalFormats = mapTypeAndFormatToInternalFormat(e);
      var t = e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS);
      this.boundTextures.length = t;
      for (var r = 0; r < t; r++)
        this.boundTextures[r] = null;
      this.emptyTextures = {};
      var a = new GLTexture$1(e.createTexture());
      e.bindTexture(e.TEXTURE_2D, a.texture), e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, 1, 1, 0, e.RGBA, e.UNSIGNED_BYTE, new Uint8Array(4)), this.emptyTextures[e.TEXTURE_2D] = a, this.emptyTextures[e.TEXTURE_CUBE_MAP] = new GLTexture$1(e.createTexture()), e.bindTexture(e.TEXTURE_CUBE_MAP, this.emptyTextures[e.TEXTURE_CUBE_MAP].texture);
      for (var r = 0; r < 6; r++)
        e.texImage2D(e.TEXTURE_CUBE_MAP_POSITIVE_X + r, 0, e.RGBA, 1, 1, 0, e.RGBA, e.UNSIGNED_BYTE, null);
      e.texParameteri(e.TEXTURE_CUBE_MAP, e.TEXTURE_MAG_FILTER, e.LINEAR), e.texParameteri(e.TEXTURE_CUBE_MAP, e.TEXTURE_MIN_FILTER, e.LINEAR);
      for (var r = 0; r < this.boundTextures.length; r++)
        this.bind(null, r);
    }, i2.prototype.bind = function(e, t) {
      t === void 0 && (t = 0);
      var r = this.gl;
      if (e = e == null ? void 0 : e.castToBaseTexture(), e && e.valid && !e.parentTextureArray) {
        e.touched = this.renderer.textureGC.count;
        var a = e._glTextures[this.CONTEXT_UID] || this.initTexture(e);
        this.boundTextures[t] !== e && (this.currentLocation !== t && (this.currentLocation = t, r.activeTexture(r.TEXTURE0 + t)), r.bindTexture(e.target, a.texture)), a.dirtyId !== e.dirtyId ? (this.currentLocation !== t && (this.currentLocation = t, r.activeTexture(r.TEXTURE0 + t)), this.updateTexture(e)) : a.dirtyStyleId !== e.dirtyStyleId && this.updateTextureStyle(e), this.boundTextures[t] = e;
      } else
        this.currentLocation !== t && (this.currentLocation = t, r.activeTexture(r.TEXTURE0 + t)), r.bindTexture(r.TEXTURE_2D, this.emptyTextures[r.TEXTURE_2D].texture), this.boundTextures[t] = null;
    }, i2.prototype.reset = function() {
      this._unknownBoundTextures = true, this.hasIntegerTextures = false, this.currentLocation = -1;
      for (var e = 0; e < this.boundTextures.length; e++)
        this.boundTextures[e] = this.unknownTexture;
    }, i2.prototype.unbind = function(e) {
      var t = this, r = t.gl, a = t.boundTextures;
      if (this._unknownBoundTextures) {
        this._unknownBoundTextures = false;
        for (var s = 0; s < a.length; s++)
          a[s] === this.unknownTexture && this.bind(null, s);
      }
      for (var s = 0; s < a.length; s++)
        a[s] === e && (this.currentLocation !== s && (r.activeTexture(r.TEXTURE0 + s), this.currentLocation = s), r.bindTexture(e.target, this.emptyTextures[e.target].texture), a[s] = null);
    }, i2.prototype.ensureSamplerType = function(e) {
      var t = this, r = t.boundTextures, a = t.hasIntegerTextures, s = t.CONTEXT_UID;
      if (a)
        for (var u = e - 1; u >= 0; --u) {
          var l = r[u];
          if (l) {
            var c = l._glTextures[s];
            c.samplerType !== SAMPLER_TYPES.FLOAT && this.renderer.texture.unbind(l);
          }
        }
    }, i2.prototype.initTexture = function(e) {
      var t = new GLTexture$1(this.gl.createTexture());
      return t.dirtyId = -1, e._glTextures[this.CONTEXT_UID] = t, this.managedTextures.push(e), e.on("dispose", this.destroyTexture, this), t;
    }, i2.prototype.initTextureType = function(e, t) {
      var r, a;
      t.internalFormat = (a = (r = this.internalFormats[e.type]) === null || r === void 0 ? void 0 : r[e.format]) !== null && a !== void 0 ? a : e.format, this.webGLVersion === 2 && e.type === TYPES.HALF_FLOAT ? t.type = this.gl.HALF_FLOAT : t.type = e.type;
    }, i2.prototype.updateTexture = function(e) {
      var t = e._glTextures[this.CONTEXT_UID];
      if (t) {
        var r = this.renderer;
        if (this.initTextureType(e, t), e.resource && e.resource.upload(r, e, t))
          t.samplerType !== SAMPLER_TYPES.FLOAT && (this.hasIntegerTextures = true);
        else {
          var a = e.realWidth, s = e.realHeight, u = r.gl;
          (t.width !== a || t.height !== s || t.dirtyId < 0) && (t.width = a, t.height = s, u.texImage2D(e.target, 0, t.internalFormat, a, s, 0, e.format, t.type, null));
        }
        e.dirtyStyleId !== t.dirtyStyleId && this.updateTextureStyle(e), t.dirtyId = e.dirtyId;
      }
    }, i2.prototype.destroyTexture = function(e, t) {
      var r = this.gl;
      if (e = e.castToBaseTexture(), e._glTextures[this.CONTEXT_UID] && (this.unbind(e), r.deleteTexture(e._glTextures[this.CONTEXT_UID].texture), e.off("dispose", this.destroyTexture, this), delete e._glTextures[this.CONTEXT_UID], !t)) {
        var a = this.managedTextures.indexOf(e);
        a !== -1 && removeItems(this.managedTextures, a, 1);
      }
    }, i2.prototype.updateTextureStyle = function(e) {
      var t = e._glTextures[this.CONTEXT_UID];
      t && ((e.mipmap === MIPMAP_MODES.POW2 || this.webGLVersion !== 2) && !e.isPowerOfTwo ? t.mipmap = false : t.mipmap = e.mipmap >= 1, this.webGLVersion !== 2 && !e.isPowerOfTwo ? t.wrapMode = WRAP_MODES.CLAMP : t.wrapMode = e.wrapMode, e.resource && e.resource.style(this.renderer, e, t) || this.setStyle(e, t), t.dirtyStyleId = e.dirtyStyleId);
    }, i2.prototype.setStyle = function(e, t) {
      var r = this.gl;
      if (t.mipmap && e.mipmap !== MIPMAP_MODES.ON_MANUAL && r.generateMipmap(e.target), r.texParameteri(e.target, r.TEXTURE_WRAP_S, t.wrapMode), r.texParameteri(e.target, r.TEXTURE_WRAP_T, t.wrapMode), t.mipmap) {
        r.texParameteri(e.target, r.TEXTURE_MIN_FILTER, e.scaleMode === SCALE_MODES.LINEAR ? r.LINEAR_MIPMAP_LINEAR : r.NEAREST_MIPMAP_NEAREST);
        var a = this.renderer.context.extensions.anisotropicFiltering;
        if (a && e.anisotropicLevel > 0 && e.scaleMode === SCALE_MODES.LINEAR) {
          var s = Math.min(e.anisotropicLevel, r.getParameter(a.MAX_TEXTURE_MAX_ANISOTROPY_EXT));
          r.texParameterf(e.target, a.TEXTURE_MAX_ANISOTROPY_EXT, s);
        }
      } else
        r.texParameteri(e.target, r.TEXTURE_MIN_FILTER, e.scaleMode === SCALE_MODES.LINEAR ? r.LINEAR : r.NEAREST);
      r.texParameteri(e.target, r.TEXTURE_MAG_FILTER, e.scaleMode === SCALE_MODES.LINEAR ? r.LINEAR : r.NEAREST);
    }, i2.prototype.destroy = function() {
      this.renderer = null;
    }, i2;
  }()
), tempMatrix = new Matrix$1(), AbstractRenderer = (
  /** @class */
  function(i2) {
    __extends$1(e, i2);
    function e(t, r) {
      t === void 0 && (t = RENDERER_TYPE.UNKNOWN);
      var a = i2.call(this) || this;
      return r = Object.assign({}, settings$1.RENDER_OPTIONS, r), a.options = r, a.type = t, a.screen = new Rectangle$1(0, 0, r.width, r.height), a.view = r.view || settings$1.ADAPTER.createCanvas(), a.resolution = r.resolution || settings$1.RESOLUTION, a.useContextAlpha = r.useContextAlpha, a.autoDensity = !!r.autoDensity, a.preserveDrawingBuffer = r.preserveDrawingBuffer, a.clearBeforeRender = r.clearBeforeRender, a._backgroundColor = 0, a._backgroundColorRgba = [0, 0, 0, 1], a._backgroundColorString = "#000000", a.backgroundColor = r.backgroundColor || a._backgroundColor, a.backgroundAlpha = r.backgroundAlpha, r.transparent !== void 0 && (deprecation("6.0.0", "Option transparent is deprecated, please use backgroundAlpha instead."), a.useContextAlpha = r.transparent, a.backgroundAlpha = r.transparent ? 0 : 1), a._lastObjectRendered = null, a.plugins = {}, a;
    }
    return e.prototype.initPlugins = function(t) {
      for (var r in t)
        this.plugins[r] = new t[r](this);
    }, Object.defineProperty(e.prototype, "width", {
      /**
       * Same as view.width, actual number of pixels in the canvas by horizontal.
       * @member {number}
       * @readonly
       * @default 800
       */
      get: function() {
        return this.view.width;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(e.prototype, "height", {
      /**
       * Same as view.height, actual number of pixels in the canvas by vertical.
       * @member {number}
       * @readonly
       * @default 600
       */
      get: function() {
        return this.view.height;
      },
      enumerable: false,
      configurable: true
    }), e.prototype.resize = function(t, r) {
      this.view.width = Math.round(t * this.resolution), this.view.height = Math.round(r * this.resolution);
      var a = this.view.width / this.resolution, s = this.view.height / this.resolution;
      this.screen.width = a, this.screen.height = s, this.autoDensity && (this.view.style.width = a + "px", this.view.style.height = s + "px"), this.emit("resize", a, s);
    }, e.prototype.generateTexture = function(t, r, a, s) {
      r === void 0 && (r = {}), typeof r == "number" && (deprecation("6.1.0", "generateTexture options (scaleMode, resolution, region) are now object options."), r = { scaleMode: r, resolution: a, region: s });
      var u = r.region, l = __rest(r, ["region"]);
      s = u || t.getLocalBounds(null, true), s.width === 0 && (s.width = 1), s.height === 0 && (s.height = 1);
      var c = RenderTexture$1.create(__assign({ width: s.width, height: s.height }, l));
      return tempMatrix.tx = -s.x, tempMatrix.ty = -s.y, this.render(t, {
        renderTexture: c,
        clear: false,
        transform: tempMatrix,
        skipUpdateTransform: !!t.parent
      }), c;
    }, e.prototype.destroy = function(t) {
      for (var r in this.plugins)
        this.plugins[r].destroy(), this.plugins[r] = null;
      t && this.view.parentNode && this.view.parentNode.removeChild(this.view);
      var a = this;
      a.plugins = null, a.type = RENDERER_TYPE.UNKNOWN, a.view = null, a.screen = null, a._tempDisplayObjectParent = null, a.options = null, this._backgroundColorRgba = null, this._backgroundColorString = null, this._lastObjectRendered = null;
    }, Object.defineProperty(e.prototype, "backgroundColor", {
      /**
       * The background color to fill if not transparent
       * @member {number}
       */
      get: function() {
        return this._backgroundColor;
      },
      set: function(t) {
        this._backgroundColor = t, this._backgroundColorString = hex2string(t), hex2rgb(t, this._backgroundColorRgba);
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(e.prototype, "backgroundAlpha", {
      /**
       * The background color alpha. Setting this to 0 will make the canvas transparent.
       * @member {number}
       */
      get: function() {
        return this._backgroundColorRgba[3];
      },
      set: function(t) {
        this._backgroundColorRgba[3] = t;
      },
      enumerable: false,
      configurable: true
    }), e;
  }(EventEmitter)
), GLBuffer$1 = (
  /** @class */
  /* @__PURE__ */ function() {
    function i2(e) {
      this.buffer = e || null, this.updateID = -1, this.byteLength = -1, this.refCount = 0;
    }
    return i2;
  }()
), BufferSystem = (
  /** @class */
  function() {
    function i2(e) {
      this.renderer = e, this.managedBuffers = {}, this.boundBufferBases = {};
    }
    return i2.prototype.destroy = function() {
      this.renderer = null;
    }, i2.prototype.contextChange = function() {
      this.disposeAll(true), this.gl = this.renderer.gl, this.CONTEXT_UID = this.renderer.CONTEXT_UID;
    }, i2.prototype.bind = function(e) {
      var t = this, r = t.gl, a = t.CONTEXT_UID, s = e._glBuffers[a] || this.createGLBuffer(e);
      r.bindBuffer(e.type, s.buffer);
    }, i2.prototype.bindBufferBase = function(e, t) {
      var r = this, a = r.gl, s = r.CONTEXT_UID;
      if (this.boundBufferBases[t] !== e) {
        var u = e._glBuffers[s] || this.createGLBuffer(e);
        this.boundBufferBases[t] = e, a.bindBufferBase(a.UNIFORM_BUFFER, t, u.buffer);
      }
    }, i2.prototype.bindBufferRange = function(e, t, r) {
      var a = this, s = a.gl, u = a.CONTEXT_UID;
      r = r || 0;
      var l = e._glBuffers[u] || this.createGLBuffer(e);
      s.bindBufferRange(s.UNIFORM_BUFFER, t || 0, l.buffer, r * 256, 256);
    }, i2.prototype.update = function(e) {
      var t = this, r = t.gl, a = t.CONTEXT_UID, s = e._glBuffers[a];
      if (e._updateID !== s.updateID)
        if (s.updateID = e._updateID, r.bindBuffer(e.type, s.buffer), s.byteLength >= e.data.byteLength)
          r.bufferSubData(e.type, 0, e.data);
        else {
          var u = e.static ? r.STATIC_DRAW : r.DYNAMIC_DRAW;
          s.byteLength = e.data.byteLength, r.bufferData(e.type, e.data, u);
        }
    }, i2.prototype.dispose = function(e, t) {
      if (this.managedBuffers[e.id]) {
        delete this.managedBuffers[e.id];
        var r = e._glBuffers[this.CONTEXT_UID], a = this.gl;
        e.disposeRunner.remove(this), r && (t || a.deleteBuffer(r.buffer), delete e._glBuffers[this.CONTEXT_UID]);
      }
    }, i2.prototype.disposeAll = function(e) {
      for (var t = Object.keys(this.managedBuffers), r = 0; r < t.length; r++)
        this.dispose(this.managedBuffers[t[r]], e);
    }, i2.prototype.createGLBuffer = function(e) {
      var t = this, r = t.CONTEXT_UID, a = t.gl;
      return e._glBuffers[r] = new GLBuffer$1(a.createBuffer()), this.managedBuffers[e.id] = e, e.disposeRunner.add(this), e._glBuffers[r];
    }, i2;
  }()
), Renderer = (
  /** @class */
  function(i2) {
    __extends$1(e, i2);
    function e(t) {
      var r = i2.call(this, RENDERER_TYPE.WEBGL, t) || this;
      return t = r.options, r.gl = null, r.CONTEXT_UID = 0, r.runners = {
        destroy: new Runner("destroy"),
        contextChange: new Runner("contextChange"),
        reset: new Runner("reset"),
        update: new Runner("update"),
        postrender: new Runner("postrender"),
        prerender: new Runner("prerender"),
        resize: new Runner("resize")
      }, r.runners.contextChange.add(r), r.globalUniforms = new UniformGroup({
        projectionMatrix: new Matrix$1()
      }, true), r.addSystem(MaskSystem, "mask").addSystem(ContextSystem, "context").addSystem(StateSystem, "state").addSystem(ShaderSystem, "shader").addSystem(TextureSystem, "texture").addSystem(BufferSystem, "buffer").addSystem(GeometrySystem, "geometry").addSystem(FramebufferSystem, "framebuffer").addSystem(ScissorSystem, "scissor").addSystem(StencilSystem, "stencil").addSystem(ProjectionSystem, "projection").addSystem(TextureGCSystem, "textureGC").addSystem(FilterSystem, "filter").addSystem(RenderTextureSystem, "renderTexture").addSystem(BatchSystem, "batch"), r.initPlugins(e.__plugins), r.multisample = void 0, t.context ? r.context.initFromContext(t.context) : r.context.initFromOptions({
        alpha: !!r.useContextAlpha,
        antialias: t.antialias,
        premultipliedAlpha: r.useContextAlpha && r.useContextAlpha !== "notMultiplied",
        stencil: true,
        preserveDrawingBuffer: t.preserveDrawingBuffer,
        powerPreference: r.options.powerPreference
      }), r.renderingToScreen = true, sayHello(r.context.webGLVersion === 2 ? "WebGL 2" : "WebGL 1"), r.resize(r.options.width, r.options.height), r;
    }
    return e.create = function(t) {
      if (isWebGLSupported())
        return new e(t);
      throw new Error('WebGL unsupported in this browser, use "pixi.js-legacy" for fallback canvas2d support.');
    }, e.prototype.contextChange = function() {
      var t = this.gl, r;
      if (this.context.webGLVersion === 1) {
        var a = t.getParameter(t.FRAMEBUFFER_BINDING);
        t.bindFramebuffer(t.FRAMEBUFFER, null), r = t.getParameter(t.SAMPLES), t.bindFramebuffer(t.FRAMEBUFFER, a);
      } else {
        var a = t.getParameter(t.DRAW_FRAMEBUFFER_BINDING);
        t.bindFramebuffer(t.DRAW_FRAMEBUFFER, null), r = t.getParameter(t.SAMPLES), t.bindFramebuffer(t.DRAW_FRAMEBUFFER, a);
      }
      r >= MSAA_QUALITY.HIGH ? this.multisample = MSAA_QUALITY.HIGH : r >= MSAA_QUALITY.MEDIUM ? this.multisample = MSAA_QUALITY.MEDIUM : r >= MSAA_QUALITY.LOW ? this.multisample = MSAA_QUALITY.LOW : this.multisample = MSAA_QUALITY.NONE;
    }, e.prototype.addSystem = function(t, r) {
      var a = new t(this);
      if (this[r])
        throw new Error('Whoops! The name "' + r + '" is already in use');
      this[r] = a;
      for (var s in this.runners)
        this.runners[s].add(a);
      return this;
    }, e.prototype.render = function(t, r) {
      var a, s, u, l;
      if (r && (r instanceof RenderTexture$1 ? (deprecation("6.0.0", "Renderer#render arguments changed, use options instead."), a = r, s = arguments[2], u = arguments[3], l = arguments[4]) : (a = r.renderTexture, s = r.clear, u = r.transform, l = r.skipUpdateTransform)), this.renderingToScreen = !a, this.runners.prerender.emit(), this.emit("prerender"), this.projection.transform = u, !this.context.isLost) {
        if (a || (this._lastObjectRendered = t), !l) {
          var c = t.enableTempParent();
          t.updateTransform(), t.disableTempParent(c);
        }
        this.renderTexture.bind(a), this.batch.currentRenderer.start(), (s !== void 0 ? s : this.clearBeforeRender) && this.renderTexture.clear(), t.render(this), this.batch.currentRenderer.flush(), a && a.baseTexture.update(), this.runners.postrender.emit(), this.projection.transform = null, this.emit("postrender");
      }
    }, e.prototype.generateTexture = function(t, r, a, s) {
      r === void 0 && (r = {});
      var u = i2.prototype.generateTexture.call(this, t, r, a, s);
      return this.framebuffer.blit(), u;
    }, e.prototype.resize = function(t, r) {
      i2.prototype.resize.call(this, t, r), this.runners.resize.emit(this.screen.height, this.screen.width);
    }, e.prototype.reset = function() {
      return this.runners.reset.emit(), this;
    }, e.prototype.clear = function() {
      this.renderTexture.bind(), this.renderTexture.clear();
    }, e.prototype.destroy = function(t) {
      this.runners.destroy.emit();
      for (var r in this.runners)
        this.runners[r].destroy();
      i2.prototype.destroy.call(this, t), this.gl = null;
    }, Object.defineProperty(e.prototype, "extract", {
      /**
       * Please use `plugins.extract` instead.
       * @member {PIXI.Extract} extract
       * @deprecated since 6.0.0
       * @readonly
       */
      get: function() {
        return deprecation("6.0.0", "Renderer#extract has been deprecated, please use Renderer#plugins.extract instead."), this.plugins.extract;
      },
      enumerable: false,
      configurable: true
    }), e.registerPlugin = function(t, r) {
      deprecation("6.5.0", "Renderer.registerPlugin() has been deprecated, please use extensions.add() instead."), extensions.add({
        name: t,
        type: ExtensionType.RendererPlugin,
        ref: r
      });
    }, e.__plugins = {}, e;
  }(AbstractRenderer)
);
extensions.handleByMap(ExtensionType.RendererPlugin, Renderer.__plugins);
var BatchDrawCall = (
  /** @class */
  /* @__PURE__ */ function() {
    function i2() {
      this.texArray = null, this.blend = 0, this.type = DRAW_MODES.TRIANGLES, this.start = 0, this.size = 0, this.data = null;
    }
    return i2;
  }()
), BatchTextureArray = (
  /** @class */
  function() {
    function i2() {
      this.elements = [], this.ids = [], this.count = 0;
    }
    return i2.prototype.clear = function() {
      for (var e = 0; e < this.count; e++)
        this.elements[e] = null;
      this.count = 0;
    }, i2;
  }()
), ViewableBuffer = (
  /** @class */
  function() {
    function i2(e) {
      typeof e == "number" ? this.rawBinaryData = new ArrayBuffer(e) : e instanceof Uint8Array ? this.rawBinaryData = e.buffer : this.rawBinaryData = e, this.uint32View = new Uint32Array(this.rawBinaryData), this.float32View = new Float32Array(this.rawBinaryData);
    }
    return Object.defineProperty(i2.prototype, "int8View", {
      /** View on the raw binary data as a `Int8Array`. */
      get: function() {
        return this._int8View || (this._int8View = new Int8Array(this.rawBinaryData)), this._int8View;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(i2.prototype, "uint8View", {
      /** View on the raw binary data as a `Uint8Array`. */
      get: function() {
        return this._uint8View || (this._uint8View = new Uint8Array(this.rawBinaryData)), this._uint8View;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(i2.prototype, "int16View", {
      /**  View on the raw binary data as a `Int16Array`. */
      get: function() {
        return this._int16View || (this._int16View = new Int16Array(this.rawBinaryData)), this._int16View;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(i2.prototype, "uint16View", {
      /** View on the raw binary data as a `Uint16Array`. */
      get: function() {
        return this._uint16View || (this._uint16View = new Uint16Array(this.rawBinaryData)), this._uint16View;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(i2.prototype, "int32View", {
      /** View on the raw binary data as a `Int32Array`. */
      get: function() {
        return this._int32View || (this._int32View = new Int32Array(this.rawBinaryData)), this._int32View;
      },
      enumerable: false,
      configurable: true
    }), i2.prototype.view = function(e) {
      return this[e + "View"];
    }, i2.prototype.destroy = function() {
      this.rawBinaryData = null, this._int8View = null, this._uint8View = null, this._int16View = null, this._uint16View = null, this._int32View = null, this.uint32View = null, this.float32View = null;
    }, i2.sizeOf = function(e) {
      switch (e) {
        case "int8":
        case "uint8":
          return 1;
        case "int16":
        case "uint16":
          return 2;
        case "int32":
        case "uint32":
        case "float32":
          return 4;
        default:
          throw new Error(e + " isn't a valid view type");
      }
    }, i2;
  }()
), AbstractBatchRenderer = (
  /** @class */
  function(i2) {
    __extends$1(e, i2);
    function e(t) {
      var r = i2.call(this, t) || this;
      return r.shaderGenerator = null, r.geometryClass = null, r.vertexSize = null, r.state = State.for2d(), r.size = settings$1.SPRITE_BATCH_SIZE * 4, r._vertexCount = 0, r._indexCount = 0, r._bufferedElements = [], r._bufferedTextures = [], r._bufferSize = 0, r._shader = null, r._packedGeometries = [], r._packedGeometryPoolSize = 2, r._flushId = 0, r._aBuffers = {}, r._iBuffers = {}, r.MAX_TEXTURES = 1, r.renderer.on("prerender", r.onPrerender, r), t.runners.contextChange.add(r), r._dcIndex = 0, r._aIndex = 0, r._iIndex = 0, r._attributeBuffer = null, r._indexBuffer = null, r._tempBoundTextures = [], r;
    }
    return e.prototype.contextChange = function() {
      var t = this.renderer.gl;
      settings$1.PREFER_ENV === ENV.WEBGL_LEGACY ? this.MAX_TEXTURES = 1 : (this.MAX_TEXTURES = Math.min(t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS), settings$1.SPRITE_MAX_TEXTURES), this.MAX_TEXTURES = checkMaxIfStatementsInShader(this.MAX_TEXTURES, t)), this._shader = this.shaderGenerator.generateShader(this.MAX_TEXTURES);
      for (var r = 0; r < this._packedGeometryPoolSize; r++)
        this._packedGeometries[r] = new this.geometryClass();
      this.initFlushBuffers();
    }, e.prototype.initFlushBuffers = function() {
      for (var t = e._drawCallPool, r = e._textureArrayPool, a = this.size / 4, s = Math.floor(a / this.MAX_TEXTURES) + 1; t.length < a; )
        t.push(new BatchDrawCall());
      for (; r.length < s; )
        r.push(new BatchTextureArray());
      for (var u = 0; u < this.MAX_TEXTURES; u++)
        this._tempBoundTextures[u] = null;
    }, e.prototype.onPrerender = function() {
      this._flushId = 0;
    }, e.prototype.render = function(t) {
      t._texture.valid && (this._vertexCount + t.vertexData.length / 2 > this.size && this.flush(), this._vertexCount += t.vertexData.length / 2, this._indexCount += t.indices.length, this._bufferedTextures[this._bufferSize] = t._texture.baseTexture, this._bufferedElements[this._bufferSize++] = t);
    }, e.prototype.buildTexturesAndDrawCalls = function() {
      var t = this, r = t._bufferedTextures, a = t.MAX_TEXTURES, s = e._textureArrayPool, u = this.renderer.batch, l = this._tempBoundTextures, c = this.renderer.textureGC.count, d = ++BaseTexture$1._globalBatch, f = 0, p = s[0], m = 0;
      u.copyBoundTextures(l, a);
      for (var y = 0; y < this._bufferSize; ++y) {
        var x = r[y];
        r[y] = null, x._batchEnabled !== d && (p.count >= a && (u.boundArray(p, l, d, a), this.buildDrawCalls(p, m, y), m = y, p = s[++f], ++d), x._batchEnabled = d, x.touched = c, p.elements[p.count++] = x);
      }
      p.count > 0 && (u.boundArray(p, l, d, a), this.buildDrawCalls(p, m, this._bufferSize), ++f, ++d);
      for (var y = 0; y < l.length; y++)
        l[y] = null;
      BaseTexture$1._globalBatch = d;
    }, e.prototype.buildDrawCalls = function(t, r, a) {
      var s = this, u = s._bufferedElements, l = s._attributeBuffer, c = s._indexBuffer, d = s.vertexSize, f = e._drawCallPool, p = this._dcIndex, m = this._aIndex, y = this._iIndex, x = f[p];
      x.start = this._iIndex, x.texArray = t;
      for (var g = r; g < a; ++g) {
        var _ = u[g], T = _._texture.baseTexture, E = premultiplyBlendMode[T.alphaMode ? 1 : 0][_.blendMode];
        u[g] = null, r < g && x.blend !== E && (x.size = y - x.start, r = g, x = f[++p], x.texArray = t, x.start = y), this.packInterleavedGeometry(_, l, c, m, y), m += _.vertexData.length / 2 * d, y += _.indices.length, x.blend = E;
      }
      r < a && (x.size = y - x.start, ++p), this._dcIndex = p, this._aIndex = m, this._iIndex = y;
    }, e.prototype.bindAndClearTexArray = function(t) {
      for (var r = this.renderer.texture, a = 0; a < t.count; a++)
        r.bind(t.elements[a], t.ids[a]), t.elements[a] = null;
      t.count = 0;
    }, e.prototype.updateGeometry = function() {
      var t = this, r = t._packedGeometries, a = t._attributeBuffer, s = t._indexBuffer;
      settings$1.CAN_UPLOAD_SAME_BUFFER ? (r[this._flushId]._buffer.update(a.rawBinaryData), r[this._flushId]._indexBuffer.update(s), this.renderer.geometry.updateBuffers()) : (this._packedGeometryPoolSize <= this._flushId && (this._packedGeometryPoolSize++, r[this._flushId] = new this.geometryClass()), r[this._flushId]._buffer.update(a.rawBinaryData), r[this._flushId]._indexBuffer.update(s), this.renderer.geometry.bind(r[this._flushId]), this.renderer.geometry.updateBuffers(), this._flushId++);
    }, e.prototype.drawBatches = function() {
      for (var t = this._dcIndex, r = this.renderer, a = r.gl, s = r.state, u = e._drawCallPool, l = null, c = 0; c < t; c++) {
        var d = u[c], f = d.texArray, p = d.type, m = d.size, y = d.start, x = d.blend;
        l !== f && (l = f, this.bindAndClearTexArray(f)), this.state.blendMode = x, s.set(this.state), a.drawElements(p, m, a.UNSIGNED_SHORT, y * 2);
      }
    }, e.prototype.flush = function() {
      this._vertexCount !== 0 && (this._attributeBuffer = this.getAttributeBuffer(this._vertexCount), this._indexBuffer = this.getIndexBuffer(this._indexCount), this._aIndex = 0, this._iIndex = 0, this._dcIndex = 0, this.buildTexturesAndDrawCalls(), this.updateGeometry(), this.drawBatches(), this._bufferSize = 0, this._vertexCount = 0, this._indexCount = 0);
    }, e.prototype.start = function() {
      this.renderer.state.set(this.state), this.renderer.texture.ensureSamplerType(this.MAX_TEXTURES), this.renderer.shader.bind(this._shader), settings$1.CAN_UPLOAD_SAME_BUFFER && this.renderer.geometry.bind(this._packedGeometries[this._flushId]);
    }, e.prototype.stop = function() {
      this.flush();
    }, e.prototype.destroy = function() {
      for (var t = 0; t < this._packedGeometryPoolSize; t++)
        this._packedGeometries[t] && this._packedGeometries[t].destroy();
      this.renderer.off("prerender", this.onPrerender, this), this._aBuffers = null, this._iBuffers = null, this._packedGeometries = null, this._attributeBuffer = null, this._indexBuffer = null, this._shader && (this._shader.destroy(), this._shader = null), i2.prototype.destroy.call(this);
    }, e.prototype.getAttributeBuffer = function(t) {
      var r = nextPow2(Math.ceil(t / 8)), a = log2(r), s = r * 8;
      this._aBuffers.length <= a && (this._iBuffers.length = a + 1);
      var u = this._aBuffers[s];
      return u || (this._aBuffers[s] = u = new ViewableBuffer(s * this.vertexSize * 4)), u;
    }, e.prototype.getIndexBuffer = function(t) {
      var r = nextPow2(Math.ceil(t / 12)), a = log2(r), s = r * 12;
      this._iBuffers.length <= a && (this._iBuffers.length = a + 1);
      var u = this._iBuffers[a];
      return u || (this._iBuffers[a] = u = new Uint16Array(s)), u;
    }, e.prototype.packInterleavedGeometry = function(t, r, a, s, u) {
      for (var l = r.uint32View, c = r.float32View, d = s / this.vertexSize, f = t.uvs, p = t.indices, m = t.vertexData, y = t._texture.baseTexture._batchLocation, x = Math.min(t.worldAlpha, 1), g = x < 1 && t._texture.baseTexture.alphaMode ? premultiplyTint(t._tintRGB, x) : t._tintRGB + (x * 255 << 24), _ = 0; _ < m.length; _ += 2)
        c[s++] = m[_], c[s++] = m[_ + 1], c[s++] = f[_], c[s++] = f[_ + 1], l[s++] = g, c[s++] = y;
      for (var _ = 0; _ < p.length; _++)
        a[u++] = d + p[_];
    }, e._drawCallPool = [], e._textureArrayPool = [], e;
  }(ObjectRenderer$1)
), BatchShaderGenerator = (
  /** @class */
  function() {
    function i2(e, t) {
      if (this.vertexSrc = e, this.fragTemplate = t, this.programCache = {}, this.defaultGroupCache = {}, t.indexOf("%count%") < 0)
        throw new Error('Fragment template must contain "%count%".');
      if (t.indexOf("%forloop%") < 0)
        throw new Error('Fragment template must contain "%forloop%".');
    }
    return i2.prototype.generateShader = function(e) {
      if (!this.programCache[e]) {
        for (var t = new Int32Array(e), r = 0; r < e; r++)
          t[r] = r;
        this.defaultGroupCache[e] = UniformGroup.from({ uSamplers: t }, true);
        var a = this.fragTemplate;
        a = a.replace(/%count%/gi, "" + e), a = a.replace(/%forloop%/gi, this.generateSampleSrc(e)), this.programCache[e] = new Program(this.vertexSrc, a);
      }
      var s = {
        tint: new Float32Array([1, 1, 1, 1]),
        translationMatrix: new Matrix$1(),
        default: this.defaultGroupCache[e]
      };
      return new Shader$1(this.programCache[e], s);
    }, i2.prototype.generateSampleSrc = function(e) {
      var t = "";
      t += `
`, t += `
`;
      for (var r = 0; r < e; r++)
        r > 0 && (t += `
else `), r < e - 1 && (t += "if(vTextureId < " + r + ".5)"), t += `
{`, t += `
	color = texture2D(uSamplers[` + r + "], vTextureCoord);", t += `
}`;
      return t += `
`, t += `
`, t;
    }, i2;
  }()
), BatchGeometry = (
  /** @class */
  function(i2) {
    __extends$1(e, i2);
    function e(t) {
      t === void 0 && (t = false);
      var r = i2.call(this) || this;
      return r._buffer = new Buffer$1(null, t, false), r._indexBuffer = new Buffer$1(null, t, true), r.addAttribute("aVertexPosition", r._buffer, 2, false, TYPES.FLOAT).addAttribute("aTextureCoord", r._buffer, 2, false, TYPES.FLOAT).addAttribute("aColor", r._buffer, 4, true, TYPES.UNSIGNED_BYTE).addAttribute("aTextureId", r._buffer, 1, true, TYPES.FLOAT).addIndex(r._indexBuffer), r;
    }
    return e;
  }(Geometry)
), defaultVertex = `precision highp float;
attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;
attribute vec4 aColor;
attribute float aTextureId;

uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
uniform vec4 tint;

varying vec2 vTextureCoord;
varying vec4 vColor;
varying float vTextureId;

void main(void){
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = aTextureCoord;
    vTextureId = aTextureId;
    vColor = aColor * tint;
}
`, defaultFragment = `varying vec2 vTextureCoord;
varying vec4 vColor;
varying float vTextureId;
uniform sampler2D uSamplers[%count%];

void main(void){
    vec4 color;
    %forloop%
    gl_FragColor = color * vColor;
}
`, BatchPluginFactory = (
  /** @class */
  function() {
    function i2() {
    }
    return i2.create = function(e) {
      var t = Object.assign({
        vertex: defaultVertex,
        fragment: defaultFragment,
        geometryClass: BatchGeometry,
        vertexSize: 6
      }, e), r = t.vertex, a = t.fragment, s = t.vertexSize, u = t.geometryClass;
      return (
        /** @class */
        function(l) {
          __extends$1(c, l);
          function c(d) {
            var f = l.call(this, d) || this;
            return f.shaderGenerator = new BatchShaderGenerator(r, a), f.geometryClass = u, f.vertexSize = s, f;
          }
          return c;
        }(AbstractBatchRenderer)
      );
    }, Object.defineProperty(i2, "defaultVertexSrc", {
      /**
       * The default vertex shader source
       * @readonly
       */
      get: function() {
        return defaultVertex;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(i2, "defaultFragmentTemplate", {
      /**
       * The default fragment shader source
       * @readonly
       */
      get: function() {
        return defaultFragment;
      },
      enumerable: false,
      configurable: true
    }), i2;
  }()
), BatchRenderer = BatchPluginFactory.create();
Object.assign(BatchRenderer, {
  extension: {
    name: "batch",
    type: ExtensionType.RendererPlugin
  }
});
/*!
 * @pixi/interaction - v6.5.10
 * Compiled Thu, 06 Jul 2023 15:25:11 UTC
 *
 * @pixi/interaction is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
var InteractionData = (
  /** @class */
  function() {
    function i2() {
      this.pressure = 0, this.rotationAngle = 0, this.twist = 0, this.tangentialPressure = 0, this.global = new Point$1(), this.target = null, this.originalEvent = null, this.identifier = null, this.isPrimary = false, this.button = 0, this.buttons = 0, this.width = 0, this.height = 0, this.tiltX = 0, this.tiltY = 0, this.pointerType = null, this.pressure = 0, this.rotationAngle = 0, this.twist = 0, this.tangentialPressure = 0;
    }
    return Object.defineProperty(i2.prototype, "pointerId", {
      /**
       * The unique identifier of the pointer. It will be the same as `identifier`.
       * @readonly
       * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerId
       */
      get: function() {
        return this.identifier;
      },
      enumerable: false,
      configurable: true
    }), i2.prototype.getLocalPosition = function(e, t, r) {
      return e.worldTransform.applyInverse(r || this.global, t);
    }, i2.prototype.copyEvent = function(e) {
      "isPrimary" in e && e.isPrimary && (this.isPrimary = true), this.button = "button" in e && e.button;
      var t = "buttons" in e && e.buttons;
      this.buttons = Number.isInteger(t) ? t : "which" in e && e.which, this.width = "width" in e && e.width, this.height = "height" in e && e.height, this.tiltX = "tiltX" in e && e.tiltX, this.tiltY = "tiltY" in e && e.tiltY, this.pointerType = "pointerType" in e && e.pointerType, this.pressure = "pressure" in e && e.pressure, this.rotationAngle = "rotationAngle" in e && e.rotationAngle, this.twist = "twist" in e && e.twist || 0, this.tangentialPressure = "tangentialPressure" in e && e.tangentialPressure || 0;
    }, i2.prototype.reset = function() {
      this.isPrimary = false;
    }, i2;
  }()
);
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics = function(i2, e) {
  return extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, r) {
    t.__proto__ = r;
  } || function(t, r) {
    for (var a in r)
      r.hasOwnProperty(a) && (t[a] = r[a]);
  }, extendStatics(i2, e);
};
function __extends(i2, e) {
  extendStatics(i2, e);
  function t() {
    this.constructor = i2;
  }
  i2.prototype = e === null ? Object.create(e) : (t.prototype = e.prototype, new t());
}
var InteractionEvent = (
  /** @class */
  function() {
    function i2() {
      this.stopped = false, this.stopsPropagatingAt = null, this.stopPropagationHint = false, this.target = null, this.currentTarget = null, this.type = null, this.data = null;
    }
    return i2.prototype.stopPropagation = function() {
      this.stopped = true, this.stopPropagationHint = true, this.stopsPropagatingAt = this.currentTarget;
    }, i2.prototype.reset = function() {
      this.stopped = false, this.stopsPropagatingAt = null, this.stopPropagationHint = false, this.currentTarget = null, this.target = null;
    }, i2;
  }()
), InteractionTrackingData = (
  /** @class */
  function() {
    function i2(e) {
      this._pointerId = e, this._flags = i2.FLAGS.NONE;
    }
    return i2.prototype._doSet = function(e, t) {
      t ? this._flags = this._flags | e : this._flags = this._flags & ~e;
    }, Object.defineProperty(i2.prototype, "pointerId", {
      /**
       * Unique pointer id of the event
       * @readonly
       * @private
       * @member {number}
       */
      get: function() {
        return this._pointerId;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(i2.prototype, "flags", {
      /**
       * State of the tracking data, expressed as bit flags
       * @private
       * @member {number}
       */
      get: function() {
        return this._flags;
      },
      set: function(e) {
        this._flags = e;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(i2.prototype, "none", {
      /**
       * Is the tracked event inactive (not over or down)?
       * @private
       * @member {number}
       */
      get: function() {
        return this._flags === i2.FLAGS.NONE;
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(i2.prototype, "over", {
      /**
       * Is the tracked event over the DisplayObject?
       * @private
       * @member {boolean}
       */
      get: function() {
        return (this._flags & i2.FLAGS.OVER) !== 0;
      },
      set: function(e) {
        this._doSet(i2.FLAGS.OVER, e);
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(i2.prototype, "rightDown", {
      /**
       * Did the right mouse button come down in the DisplayObject?
       * @private
       * @member {boolean}
       */
      get: function() {
        return (this._flags & i2.FLAGS.RIGHT_DOWN) !== 0;
      },
      set: function(e) {
        this._doSet(i2.FLAGS.RIGHT_DOWN, e);
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(i2.prototype, "leftDown", {
      /**
       * Did the left mouse button come down in the DisplayObject?
       * @private
       * @member {boolean}
       */
      get: function() {
        return (this._flags & i2.FLAGS.LEFT_DOWN) !== 0;
      },
      set: function(e) {
        this._doSet(i2.FLAGS.LEFT_DOWN, e);
      },
      enumerable: false,
      configurable: true
    }), i2.FLAGS = Object.freeze({
      NONE: 0,
      OVER: 1,
      LEFT_DOWN: 2,
      RIGHT_DOWN: 4
    }), i2;
  }()
), TreeSearch = (
  /** @class */
  function() {
    function i2() {
      this._tempPoint = new Point$1();
    }
    return i2.prototype.recursiveFindHit = function(e, t, r, a, s) {
      var u;
      if (!t || !t.visible)
        return false;
      var l = e.data.global;
      s = t.interactive || s;
      var c = false, d = s, f = true;
      if (t.hitArea)
        a && (t.worldTransform.applyInverse(l, this._tempPoint), t.hitArea.contains(this._tempPoint.x, this._tempPoint.y) ? c = true : (a = false, f = false)), d = false;
      else if (t._mask && a) {
        var p = t._mask.isMaskData ? t._mask.maskObject : t._mask;
        p && !(!((u = p.containsPoint) === null || u === void 0) && u.call(p, l)) && (a = false);
      }
      if (f && t.interactiveChildren && t.children)
        for (var m = t.children, y = m.length - 1; y >= 0; y--) {
          var x = m[y], g = this.recursiveFindHit(e, x, r, a, d);
          if (g) {
            if (!x.parent)
              continue;
            d = false, g && (e.target && (a = false), c = true);
          }
        }
      return s && (a && !e.target && !t.hitArea && t.containsPoint && t.containsPoint(l) && (c = true), t.interactive && (c && !e.target && (e.target = t), r && r(e, t, !!c))), c;
    }, i2.prototype.findHit = function(e, t, r, a) {
      this.recursiveFindHit(e, t, r, a, false);
    }, i2;
  }()
), interactiveTarget = {
  interactive: false,
  interactiveChildren: true,
  hitArea: null,
  /**
   * If enabled, the mouse cursor use the pointer behavior when hovered over the displayObject if it is interactive
   * Setting this changes the 'cursor' property to `'pointer'`.
   * @example
   * const sprite = new PIXI.Sprite(texture);
   * sprite.interactive = true;
   * sprite.buttonMode = true;
   * @member {boolean}
   * @memberof PIXI.DisplayObject#
   */
  get buttonMode() {
    return this.cursor === "pointer";
  },
  set buttonMode(i2) {
    i2 ? this.cursor = "pointer" : this.cursor === "pointer" && (this.cursor = null);
  },
  /**
   * This defines what cursor mode is used when the mouse cursor
   * is hovered over the displayObject.
   * @example
   * const sprite = new PIXI.Sprite(texture);
   * sprite.interactive = true;
   * sprite.cursor = 'wait';
   * @see https://developer.mozilla.org/en/docs/Web/CSS/cursor
   * @member {string}
   * @memberof PIXI.DisplayObject#
   */
  cursor: null,
  /**
   * Internal set of all active pointers, by identifier
   * @member {Map<number, InteractionTrackingData>}
   * @memberof PIXI.DisplayObject#
   * @private
   */
  get trackedPointers() {
    return this._trackedPointers === void 0 && (this._trackedPointers = {}), this._trackedPointers;
  },
  /**
   * Map of all tracked pointers, by identifier. Use trackedPointers to access.
   * @private
   * @type {Map<number, InteractionTrackingData>}
   */
  _trackedPointers: void 0
};
DisplayObject$1.mixin(interactiveTarget);
var MOUSE_POINTER_ID = 1, hitTestEvent = {
  target: null,
  data: {
    global: null
  }
}, InteractionManager = (
  /** @class */
  function(i2) {
    __extends(e, i2);
    function e(t, r) {
      var a = i2.call(this) || this;
      return r = r || {}, a.renderer = t, a.autoPreventDefault = r.autoPreventDefault !== void 0 ? r.autoPreventDefault : true, a.interactionFrequency = r.interactionFrequency || 10, a.mouse = new InteractionData(), a.mouse.identifier = MOUSE_POINTER_ID, a.mouse.global.set(-999999), a.activeInteractionData = {}, a.activeInteractionData[MOUSE_POINTER_ID] = a.mouse, a.interactionDataPool = [], a.eventData = new InteractionEvent(), a.interactionDOMElement = null, a.moveWhenInside = false, a.eventsAdded = false, a.tickerAdded = false, a.mouseOverRenderer = !("PointerEvent" in globalThis), a.supportsTouchEvents = "ontouchstart" in globalThis, a.supportsPointerEvents = !!globalThis.PointerEvent, a.onPointerUp = a.onPointerUp.bind(a), a.processPointerUp = a.processPointerUp.bind(a), a.onPointerCancel = a.onPointerCancel.bind(a), a.processPointerCancel = a.processPointerCancel.bind(a), a.onPointerDown = a.onPointerDown.bind(a), a.processPointerDown = a.processPointerDown.bind(a), a.onPointerMove = a.onPointerMove.bind(a), a.processPointerMove = a.processPointerMove.bind(a), a.onPointerOut = a.onPointerOut.bind(a), a.processPointerOverOut = a.processPointerOverOut.bind(a), a.onPointerOver = a.onPointerOver.bind(a), a.cursorStyles = {
        default: "inherit",
        pointer: "pointer"
      }, a.currentCursorMode = null, a.cursor = null, a.resolution = 1, a.delayedEvents = [], a.search = new TreeSearch(), a._tempDisplayObject = new TemporaryDisplayObject(), a._eventListenerOptions = { capture: true, passive: false }, a._useSystemTicker = r.useSystemTicker !== void 0 ? r.useSystemTicker : true, a.setTargetElement(a.renderer.view, a.renderer.resolution), a;
    }
    return Object.defineProperty(e.prototype, "useSystemTicker", {
      /**
       * Should the InteractionManager automatically add {@link tickerUpdate} to {@link PIXI.Ticker.system}.
       * @default true
       */
      get: function() {
        return this._useSystemTicker;
      },
      set: function(t) {
        this._useSystemTicker = t, t ? this.addTickerListener() : this.removeTickerListener();
      },
      enumerable: false,
      configurable: true
    }), Object.defineProperty(e.prototype, "lastObjectRendered", {
      /**
       * Last rendered object or temp object.
       * @readonly
       * @protected
       */
      get: function() {
        return this.renderer._lastObjectRendered || this._tempDisplayObject;
      },
      enumerable: false,
      configurable: true
    }), e.prototype.hitTest = function(t, r) {
      return hitTestEvent.target = null, hitTestEvent.data.global = t, r || (r = this.lastObjectRendered), this.processInteractive(hitTestEvent, r, null, true), hitTestEvent.target;
    }, e.prototype.setTargetElement = function(t, r) {
      r === void 0 && (r = 1), this.removeTickerListener(), this.removeEvents(), this.interactionDOMElement = t, this.resolution = r, this.addEvents(), this.addTickerListener();
    }, e.prototype.addTickerListener = function() {
      this.tickerAdded || !this.interactionDOMElement || !this._useSystemTicker || (Ticker$1.system.add(this.tickerUpdate, this, UPDATE_PRIORITY.INTERACTION), this.tickerAdded = true);
    }, e.prototype.removeTickerListener = function() {
      this.tickerAdded && (Ticker$1.system.remove(this.tickerUpdate, this), this.tickerAdded = false);
    }, e.prototype.addEvents = function() {
      if (!(this.eventsAdded || !this.interactionDOMElement)) {
        var t = this.interactionDOMElement.style;
        globalThis.navigator.msPointerEnabled ? (t.msContentZooming = "none", t.msTouchAction = "none") : this.supportsPointerEvents && (t.touchAction = "none"), this.supportsPointerEvents ? (globalThis.document.addEventListener("pointermove", this.onPointerMove, this._eventListenerOptions), this.interactionDOMElement.addEventListener("pointerdown", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.addEventListener("pointerleave", this.onPointerOut, this._eventListenerOptions), this.interactionDOMElement.addEventListener("pointerover", this.onPointerOver, this._eventListenerOptions), globalThis.addEventListener("pointercancel", this.onPointerCancel, this._eventListenerOptions), globalThis.addEventListener("pointerup", this.onPointerUp, this._eventListenerOptions)) : (globalThis.document.addEventListener("mousemove", this.onPointerMove, this._eventListenerOptions), this.interactionDOMElement.addEventListener("mousedown", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.addEventListener("mouseout", this.onPointerOut, this._eventListenerOptions), this.interactionDOMElement.addEventListener("mouseover", this.onPointerOver, this._eventListenerOptions), globalThis.addEventListener("mouseup", this.onPointerUp, this._eventListenerOptions)), this.supportsTouchEvents && (this.interactionDOMElement.addEventListener("touchstart", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.addEventListener("touchcancel", this.onPointerCancel, this._eventListenerOptions), this.interactionDOMElement.addEventListener("touchend", this.onPointerUp, this._eventListenerOptions), this.interactionDOMElement.addEventListener("touchmove", this.onPointerMove, this._eventListenerOptions)), this.eventsAdded = true;
      }
    }, e.prototype.removeEvents = function() {
      if (!(!this.eventsAdded || !this.interactionDOMElement)) {
        var t = this.interactionDOMElement.style;
        globalThis.navigator.msPointerEnabled ? (t.msContentZooming = "", t.msTouchAction = "") : this.supportsPointerEvents && (t.touchAction = ""), this.supportsPointerEvents ? (globalThis.document.removeEventListener("pointermove", this.onPointerMove, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("pointerdown", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("pointerleave", this.onPointerOut, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("pointerover", this.onPointerOver, this._eventListenerOptions), globalThis.removeEventListener("pointercancel", this.onPointerCancel, this._eventListenerOptions), globalThis.removeEventListener("pointerup", this.onPointerUp, this._eventListenerOptions)) : (globalThis.document.removeEventListener("mousemove", this.onPointerMove, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("mousedown", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("mouseout", this.onPointerOut, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("mouseover", this.onPointerOver, this._eventListenerOptions), globalThis.removeEventListener("mouseup", this.onPointerUp, this._eventListenerOptions)), this.supportsTouchEvents && (this.interactionDOMElement.removeEventListener("touchstart", this.onPointerDown, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("touchcancel", this.onPointerCancel, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("touchend", this.onPointerUp, this._eventListenerOptions), this.interactionDOMElement.removeEventListener("touchmove", this.onPointerMove, this._eventListenerOptions)), this.interactionDOMElement = null, this.eventsAdded = false;
      }
    }, e.prototype.tickerUpdate = function(t) {
      this._deltaTime += t, !(this._deltaTime < this.interactionFrequency) && (this._deltaTime = 0, this.update());
    }, e.prototype.update = function() {
      if (this.interactionDOMElement) {
        if (this._didMove) {
          this._didMove = false;
          return;
        }
        this.cursor = null;
        for (var t in this.activeInteractionData)
          if (this.activeInteractionData.hasOwnProperty(t)) {
            var r = this.activeInteractionData[t];
            if (r.originalEvent && r.pointerType !== "touch") {
              var a = this.configureInteractionEventForDOMEvent(this.eventData, r.originalEvent, r);
              this.processInteractive(a, this.lastObjectRendered, this.processPointerOverOut, true);
            }
          }
        this.setCursorMode(this.cursor);
      }
    }, e.prototype.setCursorMode = function(t) {
      t = t || "default";
      var r = true;
      if (globalThis.OffscreenCanvas && this.interactionDOMElement instanceof OffscreenCanvas && (r = false), this.currentCursorMode !== t) {
        this.currentCursorMode = t;
        var a = this.cursorStyles[t];
        if (a)
          switch (typeof a) {
            case "string":
              r && (this.interactionDOMElement.style.cursor = a);
              break;
            case "function":
              a(t);
              break;
            case "object":
              r && Object.assign(this.interactionDOMElement.style, a);
              break;
          }
        else r && typeof t == "string" && !Object.prototype.hasOwnProperty.call(this.cursorStyles, t) && (this.interactionDOMElement.style.cursor = t);
      }
    }, e.prototype.dispatchEvent = function(t, r, a) {
      (!a.stopPropagationHint || t === a.stopsPropagatingAt) && (a.currentTarget = t, a.type = r, t.emit(r, a), t[r] && t[r](a));
    }, e.prototype.delayDispatchEvent = function(t, r, a) {
      this.delayedEvents.push({ displayObject: t, eventString: r, eventData: a });
    }, e.prototype.mapPositionToPoint = function(t, r, a) {
      var s;
      this.interactionDOMElement.parentElement ? s = this.interactionDOMElement.getBoundingClientRect() : s = {
        x: 0,
        y: 0,
        width: this.interactionDOMElement.width,
        height: this.interactionDOMElement.height,
        left: 0,
        top: 0
      };
      var u = 1 / this.resolution;
      t.x = (r - s.left) * (this.interactionDOMElement.width / s.width) * u, t.y = (a - s.top) * (this.interactionDOMElement.height / s.height) * u;
    }, e.prototype.processInteractive = function(t, r, a, s) {
      var u = this.search.findHit(t, r, a, s), l = this.delayedEvents;
      if (!l.length)
        return u;
      t.stopPropagationHint = false;
      var c = l.length;
      this.delayedEvents = [];
      for (var d = 0; d < c; d++) {
        var f = l[d], p = f.displayObject, m = f.eventString, y = f.eventData;
        y.stopsPropagatingAt === p && (y.stopPropagationHint = true), this.dispatchEvent(p, m, y);
      }
      return u;
    }, e.prototype.onPointerDown = function(t) {
      if (!(this.supportsTouchEvents && t.pointerType === "touch")) {
        var r = this.normalizeToPointerData(t);
        if (this.autoPreventDefault && r[0].isNormalized) {
          var a = t.cancelable || !("cancelable" in t);
          a && t.preventDefault();
        }
        for (var s = r.length, u = 0; u < s; u++) {
          var l = r[u], c = this.getInteractionDataForPointerId(l), d = this.configureInteractionEventForDOMEvent(this.eventData, l, c);
          if (d.data.originalEvent = t, this.processInteractive(d, this.lastObjectRendered, this.processPointerDown, true), this.emit("pointerdown", d), l.pointerType === "touch")
            this.emit("touchstart", d);
          else if (l.pointerType === "mouse" || l.pointerType === "pen") {
            var f = l.button === 2;
            this.emit(f ? "rightdown" : "mousedown", this.eventData);
          }
        }
      }
    }, e.prototype.processPointerDown = function(t, r, a) {
      var s = t.data, u = t.data.identifier;
      if (a) {
        if (r.trackedPointers[u] || (r.trackedPointers[u] = new InteractionTrackingData(u)), this.dispatchEvent(r, "pointerdown", t), s.pointerType === "touch")
          this.dispatchEvent(r, "touchstart", t);
        else if (s.pointerType === "mouse" || s.pointerType === "pen") {
          var l = s.button === 2;
          l ? r.trackedPointers[u].rightDown = true : r.trackedPointers[u].leftDown = true, this.dispatchEvent(r, l ? "rightdown" : "mousedown", t);
        }
      }
    }, e.prototype.onPointerComplete = function(t, r, a) {
      var s = this.normalizeToPointerData(t), u = s.length, l = t.target;
      t.composedPath && t.composedPath().length > 0 && (l = t.composedPath()[0]);
      for (var c = l !== this.interactionDOMElement ? "outside" : "", d = 0; d < u; d++) {
        var f = s[d], p = this.getInteractionDataForPointerId(f), m = this.configureInteractionEventForDOMEvent(this.eventData, f, p);
        if (m.data.originalEvent = t, this.processInteractive(m, this.lastObjectRendered, a, r || !c), this.emit(r ? "pointercancel" : "pointerup" + c, m), f.pointerType === "mouse" || f.pointerType === "pen") {
          var y = f.button === 2;
          this.emit(y ? "rightup" + c : "mouseup" + c, m);
        } else f.pointerType === "touch" && (this.emit(r ? "touchcancel" : "touchend" + c, m), this.releaseInteractionDataForPointerId(f.pointerId));
      }
    }, e.prototype.onPointerCancel = function(t) {
      this.supportsTouchEvents && t.pointerType === "touch" || this.onPointerComplete(t, true, this.processPointerCancel);
    }, e.prototype.processPointerCancel = function(t, r) {
      var a = t.data, s = t.data.identifier;
      r.trackedPointers[s] !== void 0 && (delete r.trackedPointers[s], this.dispatchEvent(r, "pointercancel", t), a.pointerType === "touch" && this.dispatchEvent(r, "touchcancel", t));
    }, e.prototype.onPointerUp = function(t) {
      this.supportsTouchEvents && t.pointerType === "touch" || this.onPointerComplete(t, false, this.processPointerUp);
    }, e.prototype.processPointerUp = function(t, r, a) {
      var s = t.data, u = t.data.identifier, l = r.trackedPointers[u], c = s.pointerType === "touch", d = s.pointerType === "mouse" || s.pointerType === "pen", f = false;
      if (d) {
        var p = s.button === 2, m = InteractionTrackingData.FLAGS, y = p ? m.RIGHT_DOWN : m.LEFT_DOWN, x = l !== void 0 && l.flags & y;
        a ? (this.dispatchEvent(r, p ? "rightup" : "mouseup", t), x && (this.dispatchEvent(r, p ? "rightclick" : "click", t), f = true)) : x && this.dispatchEvent(r, p ? "rightupoutside" : "mouseupoutside", t), l && (p ? l.rightDown = false : l.leftDown = false);
      }
      a ? (this.dispatchEvent(r, "pointerup", t), c && this.dispatchEvent(r, "touchend", t), l && ((!d || f) && this.dispatchEvent(r, "pointertap", t), c && (this.dispatchEvent(r, "tap", t), l.over = false))) : l && (this.dispatchEvent(r, "pointerupoutside", t), c && this.dispatchEvent(r, "touchendoutside", t)), l && l.none && delete r.trackedPointers[u];
    }, e.prototype.onPointerMove = function(t) {
      if (!(this.supportsTouchEvents && t.pointerType === "touch")) {
        var r = this.normalizeToPointerData(t);
        (r[0].pointerType === "mouse" || r[0].pointerType === "pen") && (this._didMove = true, this.cursor = null);
        for (var a = r.length, s = 0; s < a; s++) {
          var u = r[s], l = this.getInteractionDataForPointerId(u), c = this.configureInteractionEventForDOMEvent(this.eventData, u, l);
          c.data.originalEvent = t, this.processInteractive(c, this.lastObjectRendered, this.processPointerMove, true), this.emit("pointermove", c), u.pointerType === "touch" && this.emit("touchmove", c), (u.pointerType === "mouse" || u.pointerType === "pen") && this.emit("mousemove", c);
        }
        r[0].pointerType === "mouse" && this.setCursorMode(this.cursor);
      }
    }, e.prototype.processPointerMove = function(t, r, a) {
      var s = t.data, u = s.pointerType === "touch", l = s.pointerType === "mouse" || s.pointerType === "pen";
      l && this.processPointerOverOut(t, r, a), (!this.moveWhenInside || a) && (this.dispatchEvent(r, "pointermove", t), u && this.dispatchEvent(r, "touchmove", t), l && this.dispatchEvent(r, "mousemove", t));
    }, e.prototype.onPointerOut = function(t) {
      if (!(this.supportsTouchEvents && t.pointerType === "touch")) {
        var r = this.normalizeToPointerData(t), a = r[0];
        a.pointerType === "mouse" && (this.mouseOverRenderer = false, this.setCursorMode(null));
        var s = this.getInteractionDataForPointerId(a), u = this.configureInteractionEventForDOMEvent(this.eventData, a, s);
        u.data.originalEvent = a, this.processInteractive(u, this.lastObjectRendered, this.processPointerOverOut, false), this.emit("pointerout", u), a.pointerType === "mouse" || a.pointerType === "pen" ? this.emit("mouseout", u) : this.releaseInteractionDataForPointerId(s.identifier);
      }
    }, e.prototype.processPointerOverOut = function(t, r, a) {
      var s = t.data, u = t.data.identifier, l = s.pointerType === "mouse" || s.pointerType === "pen", c = r.trackedPointers[u];
      a && !c && (c = r.trackedPointers[u] = new InteractionTrackingData(u)), c !== void 0 && (a && this.mouseOverRenderer ? (c.over || (c.over = true, this.delayDispatchEvent(r, "pointerover", t), l && this.delayDispatchEvent(r, "mouseover", t)), l && this.cursor === null && (this.cursor = r.cursor)) : c.over && (c.over = false, this.dispatchEvent(r, "pointerout", this.eventData), l && this.dispatchEvent(r, "mouseout", t), c.none && delete r.trackedPointers[u]));
    }, e.prototype.onPointerOver = function(t) {
      if (!(this.supportsTouchEvents && t.pointerType === "touch")) {
        var r = this.normalizeToPointerData(t), a = r[0], s = this.getInteractionDataForPointerId(a), u = this.configureInteractionEventForDOMEvent(this.eventData, a, s);
        u.data.originalEvent = a, a.pointerType === "mouse" && (this.mouseOverRenderer = true), this.emit("pointerover", u), (a.pointerType === "mouse" || a.pointerType === "pen") && this.emit("mouseover", u);
      }
    }, e.prototype.getInteractionDataForPointerId = function(t) {
      var r = t.pointerId, a;
      return r === MOUSE_POINTER_ID || t.pointerType === "mouse" ? a = this.mouse : this.activeInteractionData[r] ? a = this.activeInteractionData[r] : (a = this.interactionDataPool.pop() || new InteractionData(), a.identifier = r, this.activeInteractionData[r] = a), a.copyEvent(t), a;
    }, e.prototype.releaseInteractionDataForPointerId = function(t) {
      var r = this.activeInteractionData[t];
      r && (delete this.activeInteractionData[t], r.reset(), this.interactionDataPool.push(r));
    }, e.prototype.configureInteractionEventForDOMEvent = function(t, r, a) {
      return t.data = a, this.mapPositionToPoint(a.global, r.clientX, r.clientY), r.pointerType === "touch" && (r.globalX = a.global.x, r.globalY = a.global.y), a.originalEvent = r, t.reset(), t;
    }, e.prototype.normalizeToPointerData = function(t) {
      var r = [];
      if (this.supportsTouchEvents && t instanceof TouchEvent)
        for (var a = 0, s = t.changedTouches.length; a < s; a++) {
          var u = t.changedTouches[a];
          typeof u.button > "u" && (u.button = t.touches.length ? 1 : 0), typeof u.buttons > "u" && (u.buttons = t.touches.length ? 1 : 0), typeof u.isPrimary > "u" && (u.isPrimary = t.touches.length === 1 && t.type === "touchstart"), typeof u.width > "u" && (u.width = u.radiusX || 1), typeof u.height > "u" && (u.height = u.radiusY || 1), typeof u.tiltX > "u" && (u.tiltX = 0), typeof u.tiltY > "u" && (u.tiltY = 0), typeof u.pointerType > "u" && (u.pointerType = "touch"), typeof u.pointerId > "u" && (u.pointerId = u.identifier || 0), typeof u.pressure > "u" && (u.pressure = u.force || 0.5), typeof u.twist > "u" && (u.twist = 0), typeof u.tangentialPressure > "u" && (u.tangentialPressure = 0), typeof u.layerX > "u" && (u.layerX = u.offsetX = u.clientX), typeof u.layerY > "u" && (u.layerY = u.offsetY = u.clientY), u.isNormalized = true, r.push(u);
        }
      else if (!globalThis.MouseEvent || t instanceof MouseEvent && (!this.supportsPointerEvents || !(t instanceof globalThis.PointerEvent))) {
        var l = t;
        typeof l.isPrimary > "u" && (l.isPrimary = true), typeof l.width > "u" && (l.width = 1), typeof l.height > "u" && (l.height = 1), typeof l.tiltX > "u" && (l.tiltX = 0), typeof l.tiltY > "u" && (l.tiltY = 0), typeof l.pointerType > "u" && (l.pointerType = "mouse"), typeof l.pointerId > "u" && (l.pointerId = MOUSE_POINTER_ID), typeof l.pressure > "u" && (l.pressure = 0.5), typeof l.twist > "u" && (l.twist = 0), typeof l.tangentialPressure > "u" && (l.tangentialPressure = 0), l.isNormalized = true, r.push(l);
      } else
        r.push(t);
      return r;
    }, e.prototype.destroy = function() {
      this.removeEvents(), this.removeTickerListener(), this.removeAllListeners(), this.renderer = null, this.mouse = null, this.eventData = null, this.interactionDOMElement = null, this.onPointerDown = null, this.processPointerDown = null, this.onPointerUp = null, this.processPointerUp = null, this.onPointerCancel = null, this.processPointerCancel = null, this.onPointerMove = null, this.processPointerMove = null, this.onPointerOut = null, this.processPointerOverOut = null, this.onPointerOver = null, this.search = null;
    }, e.extension = {
      name: "interaction",
      type: [
        ExtensionType.RendererPlugin,
        ExtensionType.CanvasRendererPlugin
      ]
    }, e;
  }(EventEmitter)
);
const li = class li2 extends ExtendedEventEmitter {
  constructor(e = {}) {
    super(), this.opts = e, this.name = this.opts.name;
  }
  bind(e) {
    this.bindEvents(e, true), this.bindNodeEvent(e, true);
  }
  unbind(e) {
    this.bindEvents(e, false), this.bindNodeEvent(e, false);
  }
  events() {
    return {
      hover: ["mouseover", "mouseout"],
      start: ["mousedown", "touchstart"],
      move: ["mousemove", "touchmove"],
      end: ["mouseup", "mouseupoutside", "touchend", "touchendoutside"]
    };
  }
  eventCallbacks(e) {
    return {
      hover: this.onHover(e),
      start: this.onStart(e),
      move: this.onMove(e),
      end: this.onEnd(e)
    };
  }
  nodeEvents(e) {
    return { [CHANGING]: this.onNodeChange() };
  }
  bindEvents(e, t) {
    t && (this.cbs = this.eventCallbacks(e));
    for (const [r, a] of Object.entries(this.events())) {
      const s = this.cbs[r];
      for (const u of a)
        t ? e.display.on(u, s) : e.display.off(u, s);
    }
    t || (this.cbs = null);
  }
  bindNodeEvent(e, t) {
    t && (this.nodeCbs = this.nodeEvents(e));
    for (const [r, a] of Object.entries(this.nodeCbs))
      t ? e.on(r, a) : e.off(r, a);
  }
  onNodeChange() {
    return function() {
      var e;
      (e = this.renderApp) != null && e.render && this.renderApp.render();
    };
  }
  onStart(e) {
    return function(t) {
      t.stopPropagation(), this.start = Date.now(), this.moved = false, this.data = t.data, this.data && this.parent && (this.lastPosition = this.data.getLocalPosition(this.parent), e.emit(SELECT, { event: t, action: "start" }));
    };
  }
  onEnd(e) {
    return function(t) {
      this.start && (t.stopPropagation(), this.data = null, this.lastPosition = null, this.start = false);
    };
  }
  onMove(e) {
    return function(t) {
      if (!this.start || !this.data || !this.lastPosition) return;
      const r = this.data.getLocalPosition(this.parent), a = r.x - this.lastPosition.x, s = r.y - this.lastPosition.y;
      this.lastPosition = r, this.delta = { x: a, y: s }, (a !== 0 || s !== 0) && (this.moved = true);
    };
  }
  onHover(e) {
    return function(t) {
      e.emit(HOVER, { action: t.type, event: t, source: "canvas" });
    };
  }
  static registerPlugin(e) {
    li2.plugins[li2.actionName(e)] = e;
  }
  static actionName(e) {
    return typeof e == "string" ? e : e.name;
  }
  static actionInstance(e) {
    return e instanceof li2 ? e : new li2.plugins[li2.actionName(e)]();
  }
  static bindActions(e, t = null) {
    if (e.display && e.type !== "trans") {
      t = t || Object.keys(li2.plugins), e.display.interactive = true, e.renderApp = e.creator().app, e.interactions = e.interactions || {}, e.interactions.base || t.unshift("base");
      for (const r of t) {
        const a = li2.actionName(r);
        if (e.interactions[a]) continue;
        if (!li2.plugins[a])
          throw new Error(`invalid action: ${a}`);
        const s = li2.actionInstance(r);
        s.bind(e), e.interactions[a] = s;
      }
    }
  }
  static unbindActions(e, t = null) {
    if (e.display && e.type !== "trans") {
      e.interactions = e.interactions || {}, t = t || Object.keys(li2.plugins);
      for (const r of t) {
        const a = li2.actionName(r);
        e.interactions[a] && (e.interactions[a].unbind(e), delete e.interactions[a]);
      }
      Object.keys(e.interactions).length === 0 && (e.display.interactive = false, e.renderApp = null, e.interactions = null);
    }
  }
};
Ct(li, "plugins", { base: li });
let Interaction = li;
const MODIFIERS = ["Meta", "Control"], Fn = class Fn2 extends ComponentBase {
  constructor(e) {
    super(e), this.hoverId = null, this.hoverBox = null, this.selected = null, this.selectedBox = null, this.withMulti = false, this.toggleSelectedId = null, this.changing = false, this.record = null;
  }
  get cropMode() {
    var e, t, r, a;
    return ((e = this.editor.opts) == null ? void 0 : e.cropMode) === "frame" || ((a = (r = (t = this.editor.player) == null ? void 0 : t.creator) == null ? void 0 : r.conf) == null ? void 0 : a.cropMode) === "frame";
  }
  events() {
    return {
      keydown: this.onKeyDown(),
      keyup: this.onKeyUp(),
      enable: this.onEnable(),
      [CHANGED]: this.onChanged(),
      [CHANGING]: this.onChanging(),
      [RESIZE]: this.onResize(),
      [SELECT]: this.onSelect(),
      [HOVER]: this.onHover()
    };
  }
  changeEvents() {
    return {
      history: ["undo", "redo"],
      starts: ["movestart", "rotatestart", "resizestart", "cropstart"],
      ends: ["moveend", "rotateend", "resizeend", "cropend", OP_END],
      move: "move",
      rotate: "rotate",
      resize: "resize",
      crop: "crop",
      "group-rotate": "group-rotate",
      [OP_DELETE]: OP_DELETE,
      [OP_ADD]: OP_ADD
    };
  }
  hideAll() {
    this.hideSelect(), this.hideHover();
  }
  onChanged() {
    return (e) => {
    };
  }
  onEnable() {
    return (e) => {
    };
  }
  onKey(e, t) {
  }
  onKeyDown() {
    return (e) => {
      const t = "keyboard";
      if (MODIFIERS.includes(e.key)) return this.enableMulti(true);
      const r = `${e.key}`.toLowerCase(), a = this.editor.responder === this.constructor.type;
      if (this.locked(t)) return e.preventDefault();
      if (e.mctrlKey && r === "c" && a) this.copy();
      else if (e.mctrlKey && r === "v" && a) this.paste();
      else {
        if (e.key !== "Backspace" || !a)
          return this.onKey(r, e);
        this.delete(this.selected);
      }
      this.lock(100, null, t), e.preventDefault();
    };
  }
  onKeyUp() {
    return (e) => {
      MODIFIERS.includes(e.key) && this.enableMulti(false);
      const t = `${e.key}`.toLowerCase();
      this.onKey(t, e);
    };
  }
  enableMulti(e) {
    this.withMulti = e;
  }
  delete(e, t = true, r = true) {
    if (!e) return;
    const a = (s) => {
      var l, c;
      if (s.children.length > 0)
        if (s.type === "scene") {
          const d = { removed: true, parent: null };
          s.allNodes.forEach((f) => {
            Fn2.apply(f, { to: d }, OP_DELETE);
          });
        } else if (s.type === "text" && s.speech) {
          const d = { removed: true, parent: null };
          s.children.filter((f) => f.type === "speech").forEach((f) => {
            Fn2.apply(f, { to: d }, OP_DELETE);
          });
        } else {
          const d = ["spine", "track"].includes(s.parent.type) ? s.creator() : s.parent;
          s.children.forEach((f) => {
            const p = { parent: d };
            p.start = f.startTime + s.startTime, f.conf.end && (p.end = f.endTime + s.startTime), Fn2.apply(f, { to: p }, OP_DELETE);
          });
        }
      const u = { removed: true, parent: null };
      s.prevSibling && (u.prevSibling = null), s.nextSibling && (u.nextSibling = null), s.type !== "trans" && (s.nextSibling && ((l = s.prevSibling) == null ? void 0 : l.type) !== "trans" && a(s.prevSibling), ((c = s.nextSibling) == null ? void 0 : c.type) === "trans" && a(s.nextSibling)), Fn2.apply(s, { to: u }, OP_DELETE);
    };
    if (e.nodes) {
      const s = Object.values(e.nodes);
      s.sort((u, l) => u.parents.length - l.parents.length), s.forEach((u) => a(u));
    } else a(e);
    t && e.emit(CHANGING, { action: OP_END }), r && (this.hideSelect(), this.editor.hideSelect());
  }
  copy() {
    var e;
    this.editor.copyNode = this.selected, (e = this.selectedBox) != null && e.addClass && this.selectedBox.addClass("copy", 300);
  }
  async paste(e = this.editor.copyNode, t = {}) {
    if (!e) return;
    var {
      emitEnd: r = true,
      nodes: a = null,
      action: s = OP_ADD,
      track: u = null,
      time: l = null
    } = t;
    a || (a = {}), r && this.editor.showLoading();
    const c = async (f, p, m) => {
      const y = { emitEnd: false, nodes: { [m]: p } };
      await this.paste(new EditorGroup(f), y);
    }, d = async (f) => {
      const p = await this.editor.cloneNode(f);
      a[f.id] = p;
      const m = {
        zIndex: f.zIndex,
        parent: f.parent,
        active: true
      };
      if (a[f.parent.id] && (m.parent = a[f.parent.id]), f.nextSibling && (m.nextSibling = f.nextSibling), l || l === 0) {
        let y = MAX;
        Object.values(a).forEach(
          (x) => y = Math.min(x.absStartTime, y)
        ), m.start = Math.max(0, f.startTime + l - y);
      }
      m.trackId = u ? u.id : f.trackId, Fn2.apply(p, { to: m }, s), f.type === "scene" ? await c(f.allNodes, p, f.id) : f.type === "text" && f.speech && await c(f.speech, p, f.id);
    };
    if (e.nodes) {
      const f = Object.values(e.nodes);
      if (f.map((p) => p.trackId).includes(u == null ? void 0 : u.id) && (u = null), l || l === 0) {
        let p = MAX;
        f.forEach(
          (m) => p = Math.min(m.absStartTime, p)
        );
      }
      f.sort((p, m) => p.parents.length - m.parents.length);
      for (const p of f) await d(p);
    } else
      (l || l === 0) && l - e.absStartTime, await d(e);
    return r && (e.emit(CHANGING, { action: OP_END }), this.editor.hideLoading()), a;
  }
  recordTarget() {
    var e;
    return (e = this.selected) != null && e.nodes ? Object.values(this.selected.nodes) : this.selected;
  }
  onHistoryChange(e) {
  }
  onChanging() {
    return (e) => {
      var s;
      if (!e.target) return;
      const t = this.recordTarget(), r = this.editor.currentTime, a = this.changeEvents();
      if (a.history.includes(e.action))
        this.onHistoryChange(e);
      else if (a.starts.includes(e.action)) {
        if (this.changing = true, !e.target.cropMode && this.selectedBox && this.selectedBox.show(false), ((s = this.selected) == null ? void 0 : s.id) === e.target.id) {
          const u = e.action.replace("start", "");
          this.record = new Record(u, t, { time: r });
        }
      } else if (a.ends.includes(e.action))
        this.changing = false, this.selectedBox && this.selected.id === e.target.id && this.selectedBox.show(true), this.lock(100, null, "select"), this.record && this.editor._history && (this.editor._history.append(this.record), this.record = null);
      else if (a[e.action]) {
        if (this.hoverId === e.target.id) {
          const u = this.hoverBox[e.action];
          u && typeof u == "function" ? u.call(this.hoverBox) : this.editor.log(
            `${this.constructor.name}.onChanging of evt.action:`,
            this.hoverId,
            e.action
          );
        }
        if (this.record || (this.record = new Record(e.action, t, {
          time: r
        })), this.record.contains(e.target.id) || e.target.nodes || (this.record.action === e.action ? this.record.addTarget(e.target) : this.editor.error(
          "target.id not include!",
          this.record.action,
          e.action,
          this.record.targets,
          e.target.id
        )), !e.target.nodes) {
          const u = { [e.target.id]: e.delta };
          this.record.merge(u);
        }
      } else
        this.editor.log(
          `${this.constructor.name} miss evt.action:`,
          e.action
        );
    };
  }
  onHover() {
    return (e) => {
      this.changing || (e.action === "mouseout" ? this.hideHover() : this.showHover(e.target, e));
    };
  }
  reset() {
    this.hideAll();
  }
  onResize() {
    return (e) => {
      this.container = this.editor.container, this.container && this.fit();
    };
  }
  fit(e = false) {
    var r;
    this.hideHover();
    const t = this.editor.scale;
    (r = this.selected) != null && r.fit && this.selected.fit(t), this.selectedBox && (e && this.selectedBox.addClass("ani", 300), this.selectedBox.fit(t));
  }
  onSelect() {
    return (e) => {
      var r;
      if (this.locked(`select-${((r = e.target) == null ? void 0 : r.id) || "NULL"}`)) return;
      const t = e.target;
      if (t || this.reset()) {
        if (this.constructor.type === "select" && !(t != null && t.display)) return;
        let a;
        if (this.withMulti || e.action === "multi" || t && t.groupId && t.groupId !== "NULL")
          if (Array.isArray(e.nodes) && e.nodes.length > 0)
            for (const s of e.nodes)
              a = this.multiSelect(s, a);
          else
            a = this.multiSelect(t);
        else
          a = t;
        this.showSelect(a, e);
      }
    };
  }
  multiSelect(e, t) {
    return !e || e.type === "creator" ? t : t instanceof EditorGroup ? t.toggleNode(e) : e.groupId && e.groupId !== "NULL" ? new EditorGroup(e) : t && t.id !== e.id ? new EditorGroup([t, e]) : e;
  }
  toggleSelect() {
    var e;
    if (this.selected instanceof EditorGroup) return this.hideHover();
    this.toggleSelectedId === ((e = this.selected) == null ? void 0 : e.id) ? (this.toggleSelectedId = null, this.hideSelect()) : this.selected && (this.toggleSelectedId = this.selected.id, this.hideHover());
  }
  hideSelect() {
    var e;
    if (((e = this.selected) == null ? void 0 : e.cropMode) === "frame") {
      if (this.constructor.type !== "select" || this.cropMode) return;
      this.selected.cropMode = false;
    }
    this.selectedBox && (this.selectedBox.remove(), this.selected instanceof EditorGroup && (this.selected.addEventsTo(this.editor, false), this.selected.nodes || this.selected.destroy()), this.selectedBox = null, this.selected = null, this.toggleSelectedId = null);
  }
  showSelect(e, t) {
    if (this.cropMode) {
      if (!e) return;
      e.cropMode = "frame";
    }
    if (this.hideSelect(), e && e.type !== "creator")
      return this.constructor.type === "select" && e.canvasEditNode && (e = e.canvasEditNode), this.selected = e, this.selected.addEventsTo && this.selected.addEventsTo(this.editor, true), this.selectedBox = this.createBox(e, true), this.selected instanceof EditorGroup && this.selected.appendTo(this.selectedBox), this.selected;
  }
  hideHover() {
    this.hoverId = null, this.hoverBox && (this.hoverBox.remove(), this.hoverBox = null);
  }
  showHover(e, t) {
    !e || e.type === "creator" || ((this.hoverId || this.hoverBox) && this.hideHover(), this.hoverBox = this.createBox(e, false, t), this.hoverBox && (this.hoverId = e.id));
  }
  createBox(e, t = false, r = null) {
    if (!this.container || !this.editor) return null;
    const { container: a } = this, { scale: s } = this.editor;
    return e.visible && e.getAnchor ? EditorBoxElement.create({
      node: e,
      scale: s,
      container: a,
      selected: t,
      event: r
    }) : null;
  }
  destroy() {
    super.destroy(), this.hideHover(), this.hideSelect();
  }
};
Ct(Fn, "type", "select");
let EditorSelectComponent = Fn;
const svgDataURL1$1 = '"data:image/svg+xml,%3Csvg width=%2720%27 height=%2720%27 viewBox=%270 0 48 48%27 fill=%27none%27 xmlns=%27http://www.w3.org/2000/svg%27%3E%3Crect width=%2748%27 height=%2748%27 fill=%27white%27 fill-opacity=%270.01%27/%3E%3Cpath d=%27M25.8927 16.0306L18.1145 8.25238C15.2506 5.38854 10.7031 5.2929 7.9572 8.03878C5.21132 10.7846 5.30696 15.3322 8.1708 18.1961L15.949 25.9742%27 stroke=%27%23FFF%27 stroke-width=%274%27 stroke-linecap=%27round%27 stroke-linejoin=%27round%27/%3E%3Cpath d=%27M31.9161 22.0706L39.6943 29.8488C42.5581 32.7126 42.9291 37.1231 39.9079 40.0061C36.8867 42.889 32.6144 42.6563 29.7506 39.7925L21.9724 32.0143%27 stroke=%27%23FFF%27 stroke-width=%274%27 stroke-linecap=%27round%27 stroke-linejoin=%27round%27/%3E%3Cpath d=%27M21.2384 21.0758L17.3493 17.1867%27 stroke=%27%23FFF%27 stroke-width=%274%27 stroke-linecap=%27round%27 stroke-linejoin=%27round%27/%3E%3Cpath d=%27M30.3131 30.1502L26.424 26.2612%27 stroke=%27%23FFF%27 stroke-width=%274%27 stroke-linecap=%27round%27 stroke-linejoin=%27round%27/%3E%3C/svg%3E"', svgDataURL2$1 = '"data:image/svg+xml,%3Csvg width=%2720%27 height=%2720%27 viewBox=%270 0 20 20%27 fill=%27none%27 xmlns=%27http://www.w3.org/2000/svg%27 aria-hidden=%27true%27%3E%3Cpath fill-rule=%27evenodd%27 clip-rule=%27evenodd%27 d=%27M15 3H10V10L5 6V14L10 10V17H15C16.1046 17 17 16.1046 17 15V5C17 3.89543 16.1046 3 15 3ZM10 10L15 6V14L10 10ZM5 2C3.34315 2 2 3.34315 2 5V15C2 16.6569 3.34315 18 5 18H15C16.6569 18 18 16.6569 18 15V5C18 3.34315 16.6569 2 15 2H5Z%27 fill=%27%23FFF%27%3E%3C/path%3E%3C/svg%3E"', svgDataURL3$1 = '"data:image/svg+xml,%3Csvg width=%2720%27 height=%2720%27 viewBox=%270 0 20 20%27 fill=%27none%27 xmlns=%27http://www.w3.org/2000/svg%27 aria-hidden=%27true%27%3E%3Cpath d=%27M12 3a1 1 0 0 0-1.68-.73l-3.88 3.6A.5.5 0 0 1 6.1 6H3.5C2.67 6 2 6.67 2 7.5v5c0 .83.67 1.5 1.5 1.5h2.6a.5.5 0 0 1 .34.13l3.88 3.6a1 1 0 0 0 1.68-.74V3.01ZM7.12 6.6 11 3v14l-3.88-3.6A1.5 1.5 0 0 0 6.1 13H3.5a.5.5 0 0 1-.5-.5v-5c0-.28.22-.5.5-.5h2.6c.38 0 .75-.14 1.02-.4Zm8.14-1.97a.5.5 0 0 1 .7.04 8 8 0 0 1 0 10.66.5.5 0 0 1-.74-.66 7 7 0 0 0 0-9.34.5.5 0 0 1 .04-.7Zm-1.18 8.3a.5.5 0 0 1-.18-.68 4.5 4.5 0 0 0 0-4.5.5.5 0 0 1 .86-.5 5.5 5.5 0 0 1 0 5.5.5.5 0 0 1-.68.18Z%27 fill=%27%23FFF%27%3E%3C/path%3E%3C/svg%3E"', svgDataURL4$1 = '"data:image/svg+xml,%3Csvg width=%2720%27 height=%2720%27 xmlns=%27http://www.w3.org/2000/svg%27%3E%3Cg fill=%27%23FFF%27 fill-rule=%27nonzero%27%3E%3Cpath d=%27M13.371 3.003a1 1 0 0 0-1.68-.73l-3.88 3.6a.5.5 0 0 1-.34.13h-2.6c-.83 0-1.5.67-1.5 1.5v5c0 .83.67 1.5 1.5 1.5h2.6a.5.5 0 0 1 .34.13l3.88 3.6a1 1 0 0 0 1.68-.74V3.003zm-4.88 3.6 3.88-3.6v14l-3.88-3.6a1.5 1.5 0 0 0-1.02-.4h-2.6a.5.5 0 0 1-.5-.5v-5c0-.28.22-.5.5-.5h2.6c.38 0 .75-.14 1.02-.4z%27/%3E%3Cpath d=%27m4.072 1.757.095.002 12.291 13.777a.901.901 0 0 1 .216.591.901.901 0 0 1-.216.592.727.727 0 0 1-1.035.086L3.542 3.201a.901.901 0 0 1-.216-.592c0-.214.073-.428.216-.591a.738.738 0 0 1 .625-.26z%27/%3E%3C/g%3E%3C/svg%3E"', styleList$7 = createStyleList$1();
styleList$7.push([
  104,
  `
  .mirae-clip[mira-editor-el] {
    display: flex;
    position: absolute;
    pointer-events: auto;
    user-select: none;
    -webkit-user-select: none;
    margin: 0;
    padding: 0;
  }
  .mirae-clip[mira-editor-el] .mirae-clip-handle {
    display: block;
    position: absolute;
    z-index: 6;
    width: 6px;
    height: 100%;
    max-width: 50%;
    background: var(--miraeSelBorderColor);
    pointer-events: auto;
    cursor: col-resize;
  }
  .mirae-clip[mira-editor-el] .mirae-clip-handle:before {
    position: absolute;
    content: "";
    background: #FFF;
    opacity: 0.6;
    height: 16px;
    width: 2px;
    border-radius: 2px;
    top: calc(50% - (16px/2));
  }
  .mirae-clip[mira-editor-el] .mirae-clip-handle.mirae-clip-handle-start {
    left: 0;
  }
  .mirae-clip[mira-editor-el] .mirae-clip-handle.mirae-clip-handle-start:before {
    left: 1px;
  }
  .mirae-clip[mira-editor-el] .mirae-clip-handle.mirae-clip-handle-end {
    right: 0;
  }
  .mirae-clip[mira-editor-el] .mirae-clip-handle.mirae-clip-handle-end:before {
    right: 1px;
  }
  .mirae-clip[mira-editor-el] .mirae-clip-pline[mira-editor-el] {
    pointer-events: none;
    display: block;
    position: absolute;
    left: 0;
    top: 0;
    width: 0;
    height: 0;
    border-color: var(--miraeHighlightColor);
    border-style: solid;
    border-width: 0;
    opacity: 0;
    transition-property: opacity;
    transition-duration: 0.3s;
  }
  .mirae-clip[mira-editor-el] .mirae-clip-pline[mira-editor-el].show {
    opacity: 0.5 !important;
  }
  .mirae-clip[mira-editor-el] .unlink-btn {
    pointer-events: auto;
    display: none;
    cursor: pointer;
    background-color: var(--miraeCropBorderColor);
    position: absolute;
    width: 18px;
    height: 18px;
    border-radius: 9px;
    left: -2px;
    top: 50%;
    z-index: 3;
    transform: translate(-50%, -50%);
    opacity: 0.8;
    background-position: center;
    background-size: 13px 13px;
    background-repeat: no-repeat;
    background-image: url(${svgDataURL1$1});
  }
  .mirae-clip[mira-editor-el] .unlink-btn:hover {
    opacity: 1;
    z-index: 999;
  }
  .mirae-clip[mira-editor-el] .unlink-btn:hover:after {
    content: '取消跟随';
    display: inline-block;
    position: absolute;
    left: calc(100% + 3px);
    top: 50%;
    padding: 0px 5px;
    height: 18px;
    background: rgba(54, 54, 91, 0.8);
    color: #FFF;
    font-size: 12px;
    line-height: 18px;
    white-space: nowrap;
    border-radius: 3px;
    transform: translateY(-50%);
  }
  .mirae-clip[mira-editor-el]:hover .unlink-btn {
    display: block;
  }
  .mirae-clip[mira-editor-el][vtype] {
    background-color: #000 !important;
    overflow: hidden;
  }
  .mirae-clip[mira-editor-el][vtype]:after {
    position: absolute;
    content: attr(data-vtitle);
    font-size: 12px;
    font-weight: 500;
    color: #FFF;
    background-color: transparent;
    opacity: 0.6;
    height: 15px;
    width: 100%;
    top: 0px;
    left: 0px;
    padding: 2px 3px;
  }
  .mirae-clip[mira-editor-el][vtype="trans"] {
    height: 32px !important;
  }
  .mirae-clip[mira-editor-el][vtype="video"] {
    height: 65px !important;
  }
  .mirae-clip[mira-editor-el][vtype="audio"] {
    height: 50px !important;
  }
  .mirae-clip[mira-editor-el][vtype="sticker"] {
    height: 36px !important;
  }
  .mirae-clip[mira-editor-el][vtype="text"] {
    height: 36px !important;
  }
  .mirae-clip[mira-editor-el].shadow {
    height: calc(100% - 4px);
    border: 2px dashed var(--miraeBorderColor);
    border-radius: 3px;
    background: #3A3A4D;
    opacity: 0.7;
    z-index: 6;
  }
  .mirae-clip[mira-editor-el].shadow.conflict {
    border-color: rgba(255, 255, 0, 0.1);
    background: rgba(255, 255, 255, 0.1);
  }
  .mirae-clip[mira-editor-el].shadow.conflict:before {
    content: "";
  }
  .mirae-clip[mira-editor-el].node {
    height: calc(100% - 4px);
    align-items: center;
    justify-content: center;
    border-radius: 3px;
    background: #556;
    transition-property: border, opacity;
    transition-duration: 0.3s;
    border: 1px solid #556;
    z-index: 1;
    --leftOffset: 0px;
  }
  .mirae-clip[mira-editor-el].node.hover-parent {
    border: 2px dashed var(--miraeHighlightColor);
  }
  .mirae-clip[mira-editor-el].node:before {
    pointer-events: none;
    white-space: nowrap;
    display: block;
    position: absolute;
    background: rgba(60, 60, 60, 0.9);
    color: #FFF;
    font-size: 12px;
    font-weight: 500;
    border-radius: 2px;
    padding: 0px 6px;
    text-transform: none;
    line-height: 18px;
    height: 18px;
    opacity: 0;
    top: 0;
    content: attr(data-info);
    left: calc(-2px + var(--leftOffset));
    transition-property: opacity, top;
    transition-duration: 0.3s;
  }
  .mirae-clip[mira-editor-el].node.disable {
    opacity: 0.35;
  }
  .mirae-clip[mira-editor-el].node:hover:before {
    opacity: 1;
    top: -23px;
  }
  .mirae-clip[mira-editor-el].node.no-info:before {
    display: none !important;
  }
  .mirae-clip[mira-editor-el].node.crop {
    background-color: transparent;
    height: calc(100% + 4px);
    pointer-events: auto;
    cursor: pointer;
  }
  .mirae-clip[mira-editor-el].node.crop .crop-info-label {
    pointer-events: none;
    white-space: nowrap;
    display: block;
    position: absolute;
    background: rgba(60, 60, 60, 0.9);
    color: #FFF;
    font-size: 12px;
    font-weight: 500;
    border-radius: 2px;
    padding: 0px 6px;
    text-transform: none;
    line-height: 15px;
    height: 15px;
    top: -20px;
  }
  .mirae-clip[mira-editor-el].node.crop:before {
    content: "";
    opacity: 1;
    margin: 0;
    padding: 0;
    display: block;
    position: absolute;
    background-color: rgba(0, 0, 0, 0.6);
    height: calc(100% + 4px);
    top: -2px !important;
    border-radius: 0;
    pointer-events: none;
    left: -2px;
    transform: translateX(-100%);
    width: var(--leftShadow);
  }
  .mirae-clip[mira-editor-el].node.crop:after {
    content: "";
    opacity: 1;
    margin: 0;
    padding: 0;
    display: block;
    position: absolute;
    background-color: rgba(0, 0, 0, 0.6);
    height: calc(100% + 4px);
    top: -2px !important;
    border-radius: 0;
    pointer-events: none;
    right: -2px;
    transform: translateX(100%);
    width: var(--rightShadow);
  }
  .mirae-clip[mira-editor-el].node.placeholder {
    border: 1px dotted #999;
    color: #FFF;
    font-size: 12px;
    white-space: nowrap;
    min-width: 500px;
  }
  .mirae-clip[mira-editor-el].node.placeholder:before {
    display: none;
  }
  .mirae-clip[mira-editor-el].node.video .preview-canvas {
    background-color: #000;
  }
  .mirae-clip[mira-editor-el].node.audio {
    color: #FFF;
    font-size: 12px;
  }
  .mirae-clip[mira-editor-el].node.audio .preview-canvas {
    background-color: #006D4C;
  }
  .mirae-clip[mira-editor-el].node.text {
    background: #1A2451;
    justify-content: flex-start;
  }
  .mirae-clip[mira-editor-el].node.text .preview-canvas {
    background: #1A2451;
    height: 100%;
    bottom: 0;
    z-index: 1;
  }
  .mirae-clip[mira-editor-el].node.text .text-view {
    pointer-events: none;
    margin-left: 5px;
    font-size: 12px;
    color: #FFF;
    white-space: nowrap;
    width: 100%;
    overflow: hidden;
    z-index: 2;
  }
  .mirae-clip[mira-editor-el].node.text.has-speech .text-view {
    margin-left: 25px;
  }
  .mirae-clip[mira-editor-el].node.text .audio-btn {
    display: none;
  }
  .mirae-clip[mira-editor-el].node.text.hover {
    background: #1A2451;
  }
  .mirae-clip[mira-editor-el].node.constraint-related {
    border: 2px dashed var(--miraeRefLineColor);
    transition-duration: 0s;
    z-index: 5;
  }
  .mirae-clip[mira-editor-el].node.moving {
    z-index: 8 !important;
  }
  .mirae-clip[mira-editor-el].node.moving:before {
    opacity: 0;
    top: 0;
  }
  .mirae-clip[mira-editor-el].node.move-parent {
    border: 2px dashed var(--miraeHighlightColor);
  }
  .mirae-clip[mira-editor-el].node.move-parent:before {
    opacity: 1;
    top: -23px;
    content: "跟随绑定";
    background: var(--miraeSelBorderColor);
  }
  .mirae-clip[mira-editor-el].node.hover {
    z-index: 3;
    border: 2px solid var(--miraeHighlightColor) !important;
  }
  .mirae-clip[mira-editor-el].node.hover.disable {
    opacity: 0.75;
  }
  .mirae-clip[mira-editor-el].node.auto-hover {
    z-index: 3;
    border: 2px solid var(--miraeHighlightColor) !important;
  }
  .mirae-clip[mira-editor-el].node.auto-hover .mirae-clip-pline {
    opacity: 0.3;
  }
  .mirae-clip[mira-editor-el].node.animate {
    transition-property: top, left;
    transition-duration: 0.3s;
  }
  .mirae-clip[mira-editor-el].node.selected {
    z-index: 5;
    border: 2px solid var(--miraeSelBorderColor) !important;
  }
  .mirae-clip[mira-editor-el].node.trans {
    z-index: 6;
    background-color: rgba(0, 0, 0, 0.8);
    border-width: 2px;
    height: 32px;
    transform: translateY(16.5px);
    background-position: center;
    background-size: 21px 21px;
    background-repeat: no-repeat;
    background-image: url(${svgDataURL2$1});
  }
  .mirae-clip[mira-editor-el].node.cut {
    opacity: 0.3;
    border: 2px dashed var(--miraeBorderColor) !important;
  }
  .mirae-clip[mira-editor-el].node.copy {
    opacity: 0.3;
    border: 2px solid var(--miraeBorderColor) !important;
  }
  .mirae-clip[mira-editor-el].node .canvas-ctr {
    pointer-events: none;
    position: absolute;
    height: 100%;
    width: 100%;
    border-radius: 2px;
    overflow: hidden;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  .mirae-clip[mira-editor-el].node .preview-canvas {
    pointer-events: none;
    position: absolute;
    left: 0;
    background: transparent;
  }
  .mirae-clip[mira-editor-el].node .audio-btn {
    pointer-events: auto;
    cursor: pointer;
    background-color: #004d52;
    position: absolute;
    width: 20px;
    height: 20px;
    border-radius: 5px;
    left: calc(26px + var(--leftOffset));
    top: 50%;
    z-index: 3;
    transform: translateY(-50%);
    background-position: center;
    background-size: 15px 15px;
    background-repeat: no-repeat;
    background-image: url(${svgDataURL3$1});
  }
  .mirae-clip[mira-editor-el].node .audio-btn:hover {
    background-color: #004d52;
  }
  .mirae-clip[mira-editor-el].node .audio-btn.audio-btn-off {
    background-color: rgba(54, 54, 91, 0.8);
    background-position: center;
    background-size: 15px 15px;
    background-repeat: no-repeat;
    background-image: url(${svgDataURL4$1});
  }
  .mirae-clip[mira-editor-el].node .audio-btn.audio-btn-off:hover {
    background-color: rgba(88, 88, 100, 0.8);
  }
  `,
  ""
]);
createStyleManager$1(styleList$7, createStyleOption$1());
styleList$7.locals && styleList$7.locals;
const AudioProcessor = {
  data: async (i2) => {
    const e = i2.getChannelData(0);
    let t = "const sample = " + ((s) => {
      const u = [];
      for (let l = 0, c = parseInt(s.length / 20); l < c; l++) {
        const d = s.slice(10 * l, 10 * (l + 1));
        u.push(Math.max.apply(null, d));
      }
      return u;
    }).toString() + `;
`;
    t += `self.onmessage = (event) => postMessage(sample(event.data));
`;
    const r = URL.createObjectURL(new Blob([t])), a = new Worker(r);
    return new Promise((s) => {
      a.postMessage(e), a.onmessage = (u) => {
        a.terminate(), s({
          data: u.data,
          duration: i2.duration,
          channels: i2.numberOfChannels
        });
      };
    });
  }
}, localeEn = {
  placeholderMessage: "Add materials and start your creation now~",
  //添加素材, 开始您的创作吧~
  selectAll: "Select All",
  // 全选
  cut: "cut",
  // 剪切
  copy: "copy",
  //复制
  paste: "paste",
  //粘贴
  combination: "Create combination",
  // 创建组合
  ungroup: "ungroup",
  // 取消组合
  delete: "delete",
  // 删除
  showFragment: "Show Fragment",
  // 显示片段
  hiddenFragment: "Hidden Fragment",
  // 隐藏片段
  asStrart: "Set select start",
  //设为选择开始
  asEnd: "Set select end"
  //设为选择开始
}, placeholderMessage = "Add media and start your creation now~", Cu = class Cu2 extends CustomHtmlElementBase {
  init() {
    return this.addClass(Cu2.TAG), super.init();
  }
  setTint(e) {
    this.set("data-tint", e);
  }
  static create(e) {
    return super.create(e).addMoveListener(e);
  }
};
Ct(Cu, "TAG", "mira-editor-button");
let EditorButtonComponent = Cu;
EditorButtonComponent.register();
class EditorClipHandleElement extends CustomHtmlElementBase {
  init() {
    return this.addClass("mirae-clip-handle"), super.init();
  }
}
Ct(EditorClipHandleElement, "TAG", "mira-editor-clip-handle");
EditorClipHandleElement.register();
class EditorClipPlineElement extends CustomHtmlElementBase {
  init() {
    return this.addClass("mirae-clip-pline"), super.init();
  }
  update(e, t, r) {
    this.setStyle({
      top: `${e - Math.max(r, 0)}px`,
      left: `${-2 - Math.max(t, 0)}px`,
      height: `${Math.abs(r)}px`,
      width: `${Math.abs(t) + 2}px`,
      borderLeftWidth: `${t > 0 ? 0 : 2}px`,
      borderRightWidth: `${t > 0 ? 2 : 0}px`,
      borderTopWidth: `${r > 0 ? 2 : 0}px`,
      borderBottomWidth: `${r > 0 ? 0 : 2}px`
    });
  }
}
Ct(EditorClipPlineElement, "TAG", "mira-editor-clip-pline");
EditorClipPlineElement.register();
var Rv = Object.defineProperty, Cv = (i2, e, t) => e in i2 ? Rv(i2, e, { enumerable: true, configurable: true, writable: true, value: t }) : i2[e] = t, hv = (i2, e, t) => Cv(i2, typeof e != "symbol" ? e + "" : e, t);
/*!
 * Vue.js v2.7.16
 * (c) 2014-2023 Evan You
 * Released under the MIT License.
 */
var emptyObject = Object.freeze({}), isArray = Array.isArray;
function isUndef(i2) {
  return i2 == null;
}
function isDef(i2) {
  return i2 != null;
}
function isTrue(i2) {
  return i2 === true;
}
function isFalse(i2) {
  return i2 === false;
}
function isPrimitive(i2) {
  return typeof i2 == "string" || typeof i2 == "number" || // $flow-disable-line
  typeof i2 == "symbol" || typeof i2 == "boolean";
}
function isFunction(i2) {
  return typeof i2 == "function";
}
function isObject(i2) {
  return i2 !== null && typeof i2 == "object";
}
var _toString = Object.prototype.toString;
function isPlainObject(i2) {
  return _toString.call(i2) === "[object Object]";
}
function isRegExp(i2) {
  return _toString.call(i2) === "[object RegExp]";
}
function isValidArrayIndex(i2) {
  var e = parseFloat(String(i2));
  return e >= 0 && Math.floor(e) === e && isFinite(i2);
}
function isPromise(i2) {
  return isDef(i2) && typeof i2.then == "function" && typeof i2.catch == "function";
}
function toString(i2) {
  return i2 == null ? "" : Array.isArray(i2) || isPlainObject(i2) && i2.toString === _toString ? JSON.stringify(i2, replacer, 2) : String(i2);
}
function replacer(i2, e) {
  return e && e.__v_isRef ? e.value : e;
}
function toNumber$1(i2) {
  var e = parseFloat(i2);
  return isNaN(e) ? i2 : e;
}
function makeMap(i2, e) {
  for (var t = /* @__PURE__ */ Object.create(null), r = i2.split(","), a = 0; a < r.length; a++)
    t[r[a]] = true;
  return e ? function(s) {
    return t[s.toLowerCase()];
  } : function(s) {
    return t[s];
  };
}
makeMap("slot,component", true);
var isReservedAttribute = makeMap("key,ref,slot,slot-scope,is");
function remove$2(i2, e) {
  var t = i2.length;
  if (t) {
    if (e === i2[t - 1]) {
      i2.length = t - 1;
      return;
    }
    var r = i2.indexOf(e);
    if (r > -1)
      return i2.splice(r, 1);
  }
}
var hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwn(i2, e) {
  return hasOwnProperty.call(i2, e);
}
function cached(i2) {
  var e = /* @__PURE__ */ Object.create(null);
  return function(t) {
    var r = e[t];
    return r || (e[t] = i2(t));
  };
}
var camelizeRE = /-(\w)/g, camelize = cached(function(i2) {
  return i2.replace(camelizeRE, function(e, t) {
    return t ? t.toUpperCase() : "";
  });
}), capitalize = cached(function(i2) {
  return i2.charAt(0).toUpperCase() + i2.slice(1);
}), hyphenateRE = /\B([A-Z])/g, hyphenate = cached(function(i2) {
  return i2.replace(hyphenateRE, "-$1").toLowerCase();
});
function polyfillBind(i2, e) {
  function t(r) {
    var a = arguments.length;
    return a ? a > 1 ? i2.apply(e, arguments) : i2.call(e, r) : i2.call(e);
  }
  return t._length = i2.length, t;
}
function nativeBind(i2, e) {
  return i2.bind(e);
}
var bind = Function.prototype.bind ? nativeBind : polyfillBind;
function toArray(i2, e) {
  e = e || 0;
  for (var t = i2.length - e, r = new Array(t); t--; )
    r[t] = i2[t + e];
  return r;
}
function extend(i2, e) {
  for (var t in e)
    i2[t] = e[t];
  return i2;
}
function toObject(i2) {
  for (var e = {}, t = 0; t < i2.length; t++)
    i2[t] && extend(e, i2[t]);
  return e;
}
function noop$1(i2, e, t) {
}
var no = function(i2, e, t) {
  return false;
}, identity = function(i2) {
  return i2;
};
function looseEqual(i2, e) {
  if (i2 === e)
    return true;
  var t = isObject(i2), r = isObject(e);
  if (t && r)
    try {
      var a = Array.isArray(i2), s = Array.isArray(e);
      if (a && s)
        return i2.length === e.length && i2.every(function(c, d) {
          return looseEqual(c, e[d]);
        });
      if (i2 instanceof Date && e instanceof Date)
        return i2.getTime() === e.getTime();
      if (!a && !s) {
        var u = Object.keys(i2), l = Object.keys(e);
        return u.length === l.length && u.every(function(c) {
          return looseEqual(i2[c], e[c]);
        });
      } else
        return false;
    } catch {
      return false;
    }
  else return !t && !r ? String(i2) === String(e) : false;
}
function looseIndexOf(i2, e) {
  for (var t = 0; t < i2.length; t++)
    if (looseEqual(i2[t], e))
      return t;
  return -1;
}
function once$1(i2) {
  var e = false;
  return function() {
    e || (e = true, i2.apply(this, arguments));
  };
}
function hasChanged(i2, e) {
  return i2 === e ? i2 === 0 && 1 / i2 !== 1 / e : i2 === i2 || e === e;
}
var SSR_ATTR = "data-server-rendered", ASSET_TYPES = ["component", "directive", "filter"], LIFECYCLE_HOOKS = [
  "beforeCreate",
  "created",
  "beforeMount",
  "mounted",
  "beforeUpdate",
  "updated",
  "beforeDestroy",
  "destroyed",
  "activated",
  "deactivated",
  "errorCaptured",
  "serverPrefetch",
  "renderTracked",
  "renderTriggered"
], config = {
  /**
   * Option merge strategies (used in core/util/options)
   */
  // $flow-disable-line
  optionMergeStrategies: /* @__PURE__ */ Object.create(null),
  /**
   * Whether to suppress warnings.
   */
  silent: false,
  /**
   * Show production mode tip message on boot?
   */
  productionTip: false,
  /**
   * Whether to enable devtools
   */
  devtools: false,
  /**
   * Whether to record perf
   */
  performance: false,
  /**
   * Error handler for watcher errors
   */
  errorHandler: null,
  /**
   * Warn handler for watcher warns
   */
  warnHandler: null,
  /**
   * Ignore certain custom elements
   */
  ignoredElements: [],
  /**
   * Custom user key aliases for v-on
   */
  // $flow-disable-line
  keyCodes: /* @__PURE__ */ Object.create(null),
  /**
   * Check if a tag is reserved so that it cannot be registered as a
   * component. This is platform-dependent and may be overwritten.
   */
  isReservedTag: no,
  /**
   * Check if an attribute is reserved so that it cannot be used as a component
   * prop. This is platform-dependent and may be overwritten.
   */
  isReservedAttr: no,
  /**
   * Check if a tag is an unknown element.
   * Platform-dependent.
   */
  isUnknownElement: no,
  /**
   * Get the namespace of an element
   */
  getTagNamespace: noop$1,
  /**
   * Parse the real tag name for the specific platform.
   */
  parsePlatformTagName: identity,
  /**
   * Check if an attribute must be bound using property, e.g. value
   * Platform-dependent.
   */
  mustUseProp: no,
  /**
   * Perform updates asynchronously. Intended to be used by Vue Test Utils
   * This will significantly reduce performance if set to false.
   */
  async: true,
  /**
   * Exposed for legacy reasons
   */
  _lifecycleHooks: LIFECYCLE_HOOKS
}, unicodeRegExp = /a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;
function isReserved(i2) {
  var e = (i2 + "").charCodeAt(0);
  return e === 36 || e === 95;
}
function def(i2, e, t, r) {
  Object.defineProperty(i2, e, {
    value: t,
    enumerable: false,
    writable: true,
    configurable: true
  });
}
var bailRE = new RegExp("[^".concat(unicodeRegExp.source, ".$_\\d]"));
function parsePath(i2) {
  if (!bailRE.test(i2)) {
    var e = i2.split(".");
    return function(t) {
      for (var r = 0; r < e.length; r++) {
        if (!t)
          return;
        t = t[e[r]];
      }
      return t;
    };
  }
}
var hasProto = "__proto__" in {}, inBrowser = typeof window < "u", UA = inBrowser && window.navigator.userAgent.toLowerCase(), isIE = UA && /msie|trident/.test(UA), isIE9 = UA && UA.indexOf("msie 9.0") > 0, isEdge = UA && UA.indexOf("edge/") > 0;
UA && UA.indexOf("android") > 0;
var isIOS = UA && /iphone|ipad|ipod|ios/.test(UA), isFF = UA && UA.match(/firefox\/(\d+)/), nativeWatch = {}.watch, supportsPassive = false;
if (inBrowser)
  try {
    var opts = {};
    Object.defineProperty(opts, "passive", {
      get: function() {
        supportsPassive = true;
      }
    }), window.addEventListener("test-passive", null, opts);
  } catch {
  }
var _isServer, isServerRendering = function() {
  return _isServer === void 0 && (!inBrowser && typeof window < "u" ? _isServer = window.process && window.process.env.VUE_ENV === "server" : _isServer = false), _isServer;
}, devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;
function isNative(i2) {
  return typeof i2 == "function" && /native code/.test(i2.toString());
}
var hasSymbol = typeof Symbol < "u" && isNative(Symbol) && typeof Reflect < "u" && isNative(Reflect.ownKeys), _Set$1;
typeof Set < "u" && isNative(Set) ? _Set$1 = Set : _Set$1 = /** @class */
function() {
  function i2() {
    this.set = /* @__PURE__ */ Object.create(null);
  }
  return i2.prototype.has = function(e) {
    return this.set[e] === true;
  }, i2.prototype.add = function(e) {
    this.set[e] = true;
  }, i2.prototype.clear = function() {
    this.set = /* @__PURE__ */ Object.create(null);
  }, i2;
}();
var currentInstance = null;
function setCurrentInstance(i2) {
  i2 === void 0 && (i2 = null), i2 || currentInstance && currentInstance._scope.off(), currentInstance = i2, i2 && i2._scope.on();
}
var VNode = (
  /** @class */
  function() {
    function i2(e, t, r, a, s, u, l, c) {
      this.tag = e, this.data = t, this.children = r, this.text = a, this.elm = s, this.ns = void 0, this.context = u, this.fnContext = void 0, this.fnOptions = void 0, this.fnScopeId = void 0, this.key = t && t.key, this.componentOptions = l, this.componentInstance = void 0, this.parent = void 0, this.raw = false, this.isStatic = false, this.isRootInsert = true, this.isComment = false, this.isCloned = false, this.isOnce = false, this.asyncFactory = c, this.asyncMeta = void 0, this.isAsyncPlaceholder = false;
    }
    return Object.defineProperty(i2.prototype, "child", {
      // DEPRECATED: alias for componentInstance for backwards compat.
      /* istanbul ignore next */
      get: function() {
        return this.componentInstance;
      },
      enumerable: false,
      configurable: true
    }), i2;
  }()
), createEmptyVNode = function(i2) {
  i2 === void 0 && (i2 = "");
  var e = new VNode();
  return e.text = i2, e.isComment = true, e;
};
function createTextVNode(i2) {
  return new VNode(void 0, void 0, void 0, String(i2));
}
function cloneVNode(i2) {
  var e = new VNode(
    i2.tag,
    i2.data,
    // #7975
    // clone children array to avoid mutating original in case of cloning
    // a child.
    i2.children && i2.children.slice(),
    i2.text,
    i2.elm,
    i2.context,
    i2.componentOptions,
    i2.asyncFactory
  );
  return e.ns = i2.ns, e.isStatic = i2.isStatic, e.key = i2.key, e.isComment = i2.isComment, e.fnContext = i2.fnContext, e.fnOptions = i2.fnOptions, e.fnScopeId = i2.fnScopeId, e.asyncMeta = i2.asyncMeta, e.isCloned = true, e;
}
var uid$2 = 0, pendingCleanupDeps = [], cleanupDeps = function() {
  for (var i2 = 0; i2 < pendingCleanupDeps.length; i2++) {
    var e = pendingCleanupDeps[i2];
    e.subs = e.subs.filter(function(t) {
      return t;
    }), e._pending = false;
  }
  pendingCleanupDeps.length = 0;
}, Dep = (
  /** @class */
  function() {
    function i2() {
      this._pending = false, this.id = uid$2++, this.subs = [];
    }
    return i2.prototype.addSub = function(e) {
      this.subs.push(e);
    }, i2.prototype.removeSub = function(e) {
      this.subs[this.subs.indexOf(e)] = null, this._pending || (this._pending = true, pendingCleanupDeps.push(this));
    }, i2.prototype.depend = function(e) {
      i2.target && i2.target.addDep(this);
    }, i2.prototype.notify = function(e) {
      for (var t = this.subs.filter(function(u) {
        return u;
      }), r = 0, a = t.length; r < a; r++) {
        var s = t[r];
        s.update();
      }
    }, i2;
  }()
);
Dep.target = null;
var targetStack = [];
function pushTarget(i2) {
  targetStack.push(i2), Dep.target = i2;
}
function popTarget() {
  targetStack.pop(), Dep.target = targetStack[targetStack.length - 1];
}
var arrayProto = Array.prototype, arrayMethods = Object.create(arrayProto), methodsToPatch = [
  "push",
  "pop",
  "shift",
  "unshift",
  "splice",
  "sort",
  "reverse"
];
methodsToPatch.forEach(function(i2) {
  var e = arrayProto[i2];
  def(arrayMethods, i2, function() {
    for (var t = [], r = 0; r < arguments.length; r++)
      t[r] = arguments[r];
    var a = e.apply(this, t), s = this.__ob__, u;
    switch (i2) {
      case "push":
      case "unshift":
        u = t;
        break;
      case "splice":
        u = t.slice(2);
        break;
    }
    return u && s.observeArray(u), s.dep.notify(), a;
  });
});
var arrayKeys = Object.getOwnPropertyNames(arrayMethods), NO_INITIAL_VALUE = {}, shouldObserve = true;
function toggleObserving(i2) {
  shouldObserve = i2;
}
var mockDep = {
  notify: noop$1,
  depend: noop$1,
  addSub: noop$1,
  removeSub: noop$1
}, Observer = (
  /** @class */
  function() {
    function i2(e, t, r) {
      if (t === void 0 && (t = false), r === void 0 && (r = false), this.value = e, this.shallow = t, this.mock = r, this.dep = r ? mockDep : new Dep(), this.vmCount = 0, def(e, "__ob__", this), isArray(e)) {
        if (!r)
          if (hasProto)
            e.__proto__ = arrayMethods;
          else
            for (var a = 0, s = arrayKeys.length; a < s; a++) {
              var u = arrayKeys[a];
              def(e, u, arrayMethods[u]);
            }
        t || this.observeArray(e);
      } else
        for (var l = Object.keys(e), a = 0; a < l.length; a++) {
          var u = l[a];
          defineReactive(e, u, NO_INITIAL_VALUE, void 0, t, r);
        }
    }
    return i2.prototype.observeArray = function(e) {
      for (var t = 0, r = e.length; t < r; t++)
        observe(e[t], false, this.mock);
    }, i2;
  }()
);
function observe(i2, e, t) {
  if (i2 && hasOwn(i2, "__ob__") && i2.__ob__ instanceof Observer)
    return i2.__ob__;
  if (shouldObserve && (t || !isServerRendering()) && (isArray(i2) || isPlainObject(i2)) && Object.isExtensible(i2) && !i2.__v_skip && !isRef(i2) && !(i2 instanceof VNode))
    return new Observer(i2, e, t);
}
function defineReactive(i2, e, t, r, a, s, u) {
  u === void 0 && (u = false);
  var l = new Dep(), c = Object.getOwnPropertyDescriptor(i2, e);
  if (!(c && c.configurable === false)) {
    var d = c && c.get, f = c && c.set;
    (!d || f) && (t === NO_INITIAL_VALUE || arguments.length === 2) && (t = i2[e]);
    var p = a ? t && t.__ob__ : observe(t, false, s);
    return Object.defineProperty(i2, e, {
      enumerable: true,
      configurable: true,
      get: function() {
        var m = d ? d.call(i2) : t;
        return Dep.target && (l.depend(), p && (p.dep.depend(), isArray(m) && dependArray(m))), isRef(m) && !a ? m.value : m;
      },
      set: function(m) {
        var y = d ? d.call(i2) : t;
        if (hasChanged(y, m)) {
          if (f)
            f.call(i2, m);
          else {
            if (d)
              return;
            if (!a && isRef(y) && !isRef(m)) {
              y.value = m;
              return;
            } else
              t = m;
          }
          p = a ? m && m.__ob__ : observe(m, false, s), l.notify();
        }
      }
    }), l;
  }
}
function set(i2, e, t) {
  if (!isReadonly(i2)) {
    var r = i2.__ob__;
    return isArray(i2) && isValidArrayIndex(e) ? (i2.length = Math.max(i2.length, e), i2.splice(e, 1, t), r && !r.shallow && r.mock && observe(t, false, true), t) : e in i2 && !(e in Object.prototype) ? (i2[e] = t, t) : i2._isVue || r && r.vmCount ? t : r ? (defineReactive(r.value, e, t, void 0, r.shallow, r.mock), r.dep.notify(), t) : (i2[e] = t, t);
  }
}
function del(i2, e) {
  if (isArray(i2) && isValidArrayIndex(e)) {
    i2.splice(e, 1);
    return;
  }
  var t = i2.__ob__;
  i2._isVue || t && t.vmCount || isReadonly(i2) || hasOwn(i2, e) && (delete i2[e], t && t.dep.notify());
}
function dependArray(i2) {
  for (var e = void 0, t = 0, r = i2.length; t < r; t++)
    e = i2[t], e && e.__ob__ && e.__ob__.dep.depend(), isArray(e) && dependArray(e);
}
function shallowReactive(i2) {
  return makeReactive(i2, true), def(i2, "__v_isShallow", true), i2;
}
function makeReactive(i2, e) {
  isReadonly(i2) || observe(
    i2,
    e,
    isServerRendering()
    /* ssr mock reactivity */
  );
}
function isReadonly(i2) {
  return !!(i2 && i2.__v_isReadonly);
}
function isRef(i2) {
  return !!(i2 && i2.__v_isRef === true);
}
function proxyWithRefUnwrap(i2, e, t) {
  Object.defineProperty(i2, t, {
    enumerable: true,
    configurable: true,
    get: function() {
      var r = e[t];
      if (isRef(r))
        return r.value;
      var a = r && r.__ob__;
      return a && a.dep.depend(), r;
    },
    set: function(r) {
      var a = e[t];
      isRef(a) && !isRef(r) ? a.value = r : e[t] = r;
    }
  });
}
var activeEffectScope, EffectScope = (
  /** @class */
  function() {
    function i2(e) {
      e === void 0 && (e = false), this.detached = e, this.active = true, this.effects = [], this.cleanups = [], this.parent = activeEffectScope, !e && activeEffectScope && (this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1);
    }
    return i2.prototype.run = function(e) {
      if (this.active) {
        var t = activeEffectScope;
        try {
          return activeEffectScope = this, e();
        } finally {
          activeEffectScope = t;
        }
      }
    }, i2.prototype.on = function() {
      activeEffectScope = this;
    }, i2.prototype.off = function() {
      activeEffectScope = this.parent;
    }, i2.prototype.stop = function(e) {
      if (this.active) {
        var t = void 0, r = void 0;
        for (t = 0, r = this.effects.length; t < r; t++)
          this.effects[t].teardown();
        for (t = 0, r = this.cleanups.length; t < r; t++)
          this.cleanups[t]();
        if (this.scopes)
          for (t = 0, r = this.scopes.length; t < r; t++)
            this.scopes[t].stop(true);
        if (!this.detached && this.parent && !e) {
          var a = this.parent.scopes.pop();
          a && a !== this && (this.parent.scopes[this.index] = a, a.index = this.index);
        }
        this.parent = void 0, this.active = false;
      }
    }, i2;
  }()
);
function recordEffectScope(i2, e) {
  e === void 0 && (e = activeEffectScope), e && e.active && e.effects.push(i2);
}
function getCurrentScope() {
  return activeEffectScope;
}
function resolveProvided(i2) {
  var e = i2._provided, t = i2.$parent && i2.$parent._provided;
  return t === e ? i2._provided = Object.create(t) : e;
}
var normalizeEvent = cached(function(i2) {
  var e = i2.charAt(0) === "&";
  i2 = e ? i2.slice(1) : i2;
  var t = i2.charAt(0) === "~";
  i2 = t ? i2.slice(1) : i2;
  var r = i2.charAt(0) === "!";
  return i2 = r ? i2.slice(1) : i2, {
    name: i2,
    once: t,
    capture: r,
    passive: e
  };
});
function createFnInvoker(i2, e) {
  function t() {
    var r = t.fns;
    if (isArray(r))
      for (var a = r.slice(), s = 0; s < a.length; s++)
        invokeWithErrorHandling(a[s], null, arguments, e, "v-on handler");
    else
      return invokeWithErrorHandling(r, null, arguments, e, "v-on handler");
  }
  return t.fns = i2, t;
}
function updateListeners(i2, e, t, r, a, s) {
  var u, l, c, d;
  for (u in i2)
    l = i2[u], c = e[u], d = normalizeEvent(u), isUndef(l) || (isUndef(c) ? (isUndef(l.fns) && (l = i2[u] = createFnInvoker(l, s)), isTrue(d.once) && (l = i2[u] = a(d.name, l, d.capture)), t(d.name, l, d.capture, d.passive, d.params)) : l !== c && (c.fns = l, i2[u] = c));
  for (u in e)
    isUndef(i2[u]) && (d = normalizeEvent(u), r(d.name, e[u], d.capture));
}
function mergeVNodeHook(i2, e, t) {
  i2 instanceof VNode && (i2 = i2.data.hook || (i2.data.hook = {}));
  var r, a = i2[e];
  function s() {
    t.apply(this, arguments), remove$2(r.fns, s);
  }
  isUndef(a) ? r = createFnInvoker([s]) : isDef(a.fns) && isTrue(a.merged) ? (r = a, r.fns.push(s)) : r = createFnInvoker([a, s]), r.merged = true, i2[e] = r;
}
function extractPropsFromVNodeData(i2, e, t) {
  var r = e.options.props;
  if (!isUndef(r)) {
    var a = {}, s = i2.attrs, u = i2.props;
    if (isDef(s) || isDef(u))
      for (var l in r) {
        var c = hyphenate(l);
        checkProp(a, u, l, c, true) || checkProp(a, s, l, c, false);
      }
    return a;
  }
}
function checkProp(i2, e, t, r, a) {
  if (isDef(e)) {
    if (hasOwn(e, t))
      return i2[t] = e[t], a || delete e[t], true;
    if (hasOwn(e, r))
      return i2[t] = e[r], a || delete e[r], true;
  }
  return false;
}
function simpleNormalizeChildren(i2) {
  for (var e = 0; e < i2.length; e++)
    if (isArray(i2[e]))
      return Array.prototype.concat.apply([], i2);
  return i2;
}
function normalizeChildren(i2) {
  return isPrimitive(i2) ? [createTextVNode(i2)] : isArray(i2) ? normalizeArrayChildren(i2) : void 0;
}
function isTextNode(i2) {
  return isDef(i2) && isDef(i2.text) && isFalse(i2.isComment);
}
function normalizeArrayChildren(i2, e) {
  var t = [], r, a, s, u;
  for (r = 0; r < i2.length; r++)
    a = i2[r], !(isUndef(a) || typeof a == "boolean") && (s = t.length - 1, u = t[s], isArray(a) ? a.length > 0 && (a = normalizeArrayChildren(a, "".concat(e || "", "_").concat(r)), isTextNode(a[0]) && isTextNode(u) && (t[s] = createTextVNode(u.text + a[0].text), a.shift()), t.push.apply(t, a)) : isPrimitive(a) ? isTextNode(u) ? t[s] = createTextVNode(u.text + a) : a !== "" && t.push(createTextVNode(a)) : isTextNode(a) && isTextNode(u) ? t[s] = createTextVNode(u.text + a.text) : (isTrue(i2._isVList) && isDef(a.tag) && isUndef(a.key) && isDef(e) && (a.key = "__vlist".concat(e, "_").concat(r, "__")), t.push(a)));
  return t;
}
function renderList(i2, e) {
  var t = null, r, a, s, u;
  if (isArray(i2) || typeof i2 == "string")
    for (t = new Array(i2.length), r = 0, a = i2.length; r < a; r++)
      t[r] = e(i2[r], r);
  else if (typeof i2 == "number")
    for (t = new Array(i2), r = 0; r < i2; r++)
      t[r] = e(r + 1, r);
  else if (isObject(i2))
    if (hasSymbol && i2[Symbol.iterator]) {
      t = [];
      for (var l = i2[Symbol.iterator](), c = l.next(); !c.done; )
        t.push(e(c.value, t.length)), c = l.next();
    } else
      for (s = Object.keys(i2), t = new Array(s.length), r = 0, a = s.length; r < a; r++)
        u = s[r], t[r] = e(i2[u], u, r);
  return isDef(t) || (t = []), t._isVList = true, t;
}
function renderSlot(i2, e, t, r) {
  var a = this.$scopedSlots[i2], s;
  a ? (t = t || {}, r && (t = extend(extend({}, r), t)), s = a(t) || (isFunction(e) ? e() : e)) : s = this.$slots[i2] || (isFunction(e) ? e() : e);
  var u = t && t.slot;
  return u ? this.$createElement("template", { slot: u }, s) : s;
}
function resolveFilter(i2) {
  return resolveAsset(this.$options, "filters", i2) || identity;
}
function isKeyNotMatch(i2, e) {
  return isArray(i2) ? i2.indexOf(e) === -1 : i2 !== e;
}
function checkKeyCodes(i2, e, t, r, a) {
  var s = config.keyCodes[e] || t;
  return a && r && !config.keyCodes[e] ? isKeyNotMatch(a, r) : s ? isKeyNotMatch(s, i2) : r ? hyphenate(r) !== e : i2 === void 0;
}
function bindObjectProps(i2, e, t, r, a) {
  if (t && isObject(t)) {
    isArray(t) && (t = toObject(t));
    var s = void 0, u = function(c) {
      if (c === "class" || c === "style" || isReservedAttribute(c))
        s = i2;
      else {
        var d = i2.attrs && i2.attrs.type;
        s = r || config.mustUseProp(e, d, c) ? i2.domProps || (i2.domProps = {}) : i2.attrs || (i2.attrs = {});
      }
      var f = camelize(c), p = hyphenate(c);
      if (!(f in s) && !(p in s) && (s[c] = t[c], a)) {
        var m = i2.on || (i2.on = {});
        m["update:".concat(c)] = function(y) {
          t[c] = y;
        };
      }
    };
    for (var l in t)
      u(l);
  }
  return i2;
}
function renderStatic(i2, e) {
  var t = this._staticTrees || (this._staticTrees = []), r = t[i2];
  return r && !e || (r = t[i2] = this.$options.staticRenderFns[i2].call(
    this._renderProxy,
    this._c,
    this
    // for render fns generated for functional component templates
  ), markStatic(r, "__static__".concat(i2), false)), r;
}
function markOnce(i2, e, t) {
  return markStatic(i2, "__once__".concat(e).concat(t ? "_".concat(t) : ""), true), i2;
}
function markStatic(i2, e, t) {
  if (isArray(i2))
    for (var r = 0; r < i2.length; r++)
      i2[r] && typeof i2[r] != "string" && markStaticNode(i2[r], "".concat(e, "_").concat(r), t);
  else
    markStaticNode(i2, e, t);
}
function markStaticNode(i2, e, t) {
  i2.isStatic = true, i2.key = e, i2.isOnce = t;
}
function bindObjectListeners(i2, e) {
  if (e && isPlainObject(e)) {
    var t = i2.on = i2.on ? extend({}, i2.on) : {};
    for (var r in e) {
      var a = t[r], s = e[r];
      t[r] = a ? [].concat(a, s) : s;
    }
  }
  return i2;
}
function resolveScopedSlots(i2, e, t, r) {
  e = e || { $stable: !t };
  for (var a = 0; a < i2.length; a++) {
    var s = i2[a];
    isArray(s) ? resolveScopedSlots(s, e, t) : s && (s.proxy && (s.fn.proxy = true), e[s.key] = s.fn);
  }
  return r && (e.$key = r), e;
}
function bindDynamicKeys(i2, e) {
  for (var t = 0; t < e.length; t += 2) {
    var r = e[t];
    typeof r == "string" && r && (i2[e[t]] = e[t + 1]);
  }
  return i2;
}
function prependModifier(i2, e) {
  return typeof i2 == "string" ? e + i2 : i2;
}
function installRenderHelpers(i2) {
  i2._o = markOnce, i2._n = toNumber$1, i2._s = toString, i2._l = renderList, i2._t = renderSlot, i2._q = looseEqual, i2._i = looseIndexOf, i2._m = renderStatic, i2._f = resolveFilter, i2._k = checkKeyCodes, i2._b = bindObjectProps, i2._v = createTextVNode, i2._e = createEmptyVNode, i2._u = resolveScopedSlots, i2._g = bindObjectListeners, i2._d = bindDynamicKeys, i2._p = prependModifier;
}
function resolveSlots(i2, e) {
  if (!i2 || !i2.length)
    return {};
  for (var t = {}, r = 0, a = i2.length; r < a; r++) {
    var s = i2[r], u = s.data;
    if (u && u.attrs && u.attrs.slot && delete u.attrs.slot, (s.context === e || s.fnContext === e) && u && u.slot != null) {
      var l = u.slot, c = t[l] || (t[l] = []);
      s.tag === "template" ? c.push.apply(c, s.children || []) : c.push(s);
    } else
      (t.default || (t.default = [])).push(s);
  }
  for (var d in t)
    t[d].every(isWhitespace) && delete t[d];
  return t;
}
function isWhitespace(i2) {
  return i2.isComment && !i2.asyncFactory || i2.text === " ";
}
function isAsyncPlaceholder(i2) {
  return i2.isComment && i2.asyncFactory;
}
function normalizeScopedSlots(i2, e, t, r) {
  var a, s = Object.keys(t).length > 0, u = e ? !!e.$stable : !s, l = e && e.$key;
  if (!e)
    a = {};
  else {
    if (e._normalized)
      return e._normalized;
    if (u && r && r !== emptyObject && l === r.$key && !s && !r.$hasNormal)
      return r;
    a = {};
    for (var c in e)
      e[c] && c[0] !== "$" && (a[c] = normalizeScopedSlot(i2, t, c, e[c]));
  }
  for (var d in t)
    d in a || (a[d] = proxyNormalSlot(t, d));
  return e && Object.isExtensible(e) && (e._normalized = a), def(a, "$stable", u), def(a, "$key", l), def(a, "$hasNormal", s), a;
}
function normalizeScopedSlot(i2, e, t, r) {
  var a = function() {
    var s = currentInstance;
    setCurrentInstance(i2);
    var u = arguments.length ? r.apply(null, arguments) : r({});
    u = u && typeof u == "object" && !isArray(u) ? [u] : normalizeChildren(u);
    var l = u && u[0];
    return setCurrentInstance(s), u && (!l || u.length === 1 && l.isComment && !isAsyncPlaceholder(l)) ? void 0 : u;
  };
  return r.proxy && Object.defineProperty(e, t, {
    get: a,
    enumerable: true,
    configurable: true
  }), a;
}
function proxyNormalSlot(i2, e) {
  return function() {
    return i2[e];
  };
}
function initSetup(i2) {
  var e = i2.$options, t = e.setup;
  if (t) {
    var r = i2._setupContext = createSetupContext(i2);
    setCurrentInstance(i2), pushTarget();
    var a = invokeWithErrorHandling(t, null, [i2._props || shallowReactive({}), r], i2, "setup");
    if (popTarget(), setCurrentInstance(), isFunction(a))
      e.render = a;
    else if (isObject(a))
      if (i2._setupState = a, a.__sfc) {
        var s = i2._setupProxy = {};
        for (var u in a)
          u !== "__sfc" && proxyWithRefUnwrap(s, a, u);
      } else
        for (var u in a)
          isReserved(u) || proxyWithRefUnwrap(i2, a, u);
  }
}
function createSetupContext(i2) {
  return {
    get attrs() {
      if (!i2._attrsProxy) {
        var e = i2._attrsProxy = {};
        def(e, "_v_attr_proxy", true), syncSetupProxy(e, i2.$attrs, emptyObject, i2, "$attrs");
      }
      return i2._attrsProxy;
    },
    get listeners() {
      if (!i2._listenersProxy) {
        var e = i2._listenersProxy = {};
        syncSetupProxy(e, i2.$listeners, emptyObject, i2, "$listeners");
      }
      return i2._listenersProxy;
    },
    get slots() {
      return initSlotsProxy(i2);
    },
    emit: bind(i2.$emit, i2),
    expose: function(e) {
      e && Object.keys(e).forEach(function(t) {
        return proxyWithRefUnwrap(i2, e, t);
      });
    }
  };
}
function syncSetupProxy(i2, e, t, r, a) {
  var s = false;
  for (var u in e)
    u in i2 ? e[u] !== t[u] && (s = true) : (s = true, defineProxyAttr(i2, u, r, a));
  for (var u in i2)
    u in e || (s = true, delete i2[u]);
  return s;
}
function defineProxyAttr(i2, e, t, r) {
  Object.defineProperty(i2, e, {
    enumerable: true,
    configurable: true,
    get: function() {
      return t[r][e];
    }
  });
}
function initSlotsProxy(i2) {
  return i2._slotsProxy || syncSetupSlots(i2._slotsProxy = {}, i2.$scopedSlots), i2._slotsProxy;
}
function syncSetupSlots(i2, e) {
  for (var t in e)
    i2[t] = e[t];
  for (var t in i2)
    t in e || delete i2[t];
}
function initRender(i2) {
  i2._vnode = null, i2._staticTrees = null;
  var e = i2.$options, t = i2.$vnode = e._parentVnode, r = t && t.context;
  i2.$slots = resolveSlots(e._renderChildren, r), i2.$scopedSlots = t ? normalizeScopedSlots(i2.$parent, t.data.scopedSlots, i2.$slots) : emptyObject, i2._c = function(s, u, l, c) {
    return createElement$1(i2, s, u, l, c, false);
  }, i2.$createElement = function(s, u, l, c) {
    return createElement$1(i2, s, u, l, c, true);
  };
  var a = t && t.data;
  defineReactive(i2, "$attrs", a && a.attrs || emptyObject, null, true), defineReactive(i2, "$listeners", e._parentListeners || emptyObject, null, true);
}
var currentRenderingInstance = null;
function renderMixin(i2) {
  installRenderHelpers(i2.prototype), i2.prototype.$nextTick = function(e) {
    return nextTick(e, this);
  }, i2.prototype._render = function() {
    var e = this, t = e.$options, r = t.render, a = t._parentVnode;
    a && e._isMounted && (e.$scopedSlots = normalizeScopedSlots(e.$parent, a.data.scopedSlots, e.$slots, e.$scopedSlots), e._slotsProxy && syncSetupSlots(e._slotsProxy, e.$scopedSlots)), e.$vnode = a;
    var s = currentInstance, u = currentRenderingInstance, l;
    try {
      setCurrentInstance(e), currentRenderingInstance = e, l = r.call(e._renderProxy, e.$createElement);
    } catch (c) {
      handleError(c, e, "render"), l = e._vnode;
    } finally {
      currentRenderingInstance = u, setCurrentInstance(s);
    }
    return isArray(l) && l.length === 1 && (l = l[0]), l instanceof VNode || (l = createEmptyVNode()), l.parent = a, l;
  };
}
function ensureCtor(i2, e) {
  return (i2.__esModule || hasSymbol && i2[Symbol.toStringTag] === "Module") && (i2 = i2.default), isObject(i2) ? e.extend(i2) : i2;
}
function createAsyncPlaceholder(i2, e, t, r, a) {
  var s = createEmptyVNode();
  return s.asyncFactory = i2, s.asyncMeta = { data: e, context: t, children: r, tag: a }, s;
}
function resolveAsyncComponent(i2, e) {
  if (isTrue(i2.error) && isDef(i2.errorComp))
    return i2.errorComp;
  if (isDef(i2.resolved))
    return i2.resolved;
  var t = currentRenderingInstance;
  if (t && isDef(i2.owners) && i2.owners.indexOf(t) === -1 && i2.owners.push(t), isTrue(i2.loading) && isDef(i2.loadingComp))
    return i2.loadingComp;
  if (t && !isDef(i2.owners)) {
    var r = i2.owners = [t], a = true, s = null, u = null;
    t.$on("hook:destroyed", function() {
      return remove$2(r, t);
    });
    var l = function(p) {
      for (var m = 0, y = r.length; m < y; m++)
        r[m].$forceUpdate();
      p && (r.length = 0, s !== null && (clearTimeout(s), s = null), u !== null && (clearTimeout(u), u = null));
    }, c = once$1(function(p) {
      i2.resolved = ensureCtor(p, e), a ? r.length = 0 : l(true);
    }), d = once$1(function(p) {
      isDef(i2.errorComp) && (i2.error = true, l(true));
    }), f = i2(c, d);
    return isObject(f) && (isPromise(f) ? isUndef(i2.resolved) && f.then(c, d) : isPromise(f.component) && (f.component.then(c, d), isDef(f.error) && (i2.errorComp = ensureCtor(f.error, e)), isDef(f.loading) && (i2.loadingComp = ensureCtor(f.loading, e), f.delay === 0 ? i2.loading = true : s = setTimeout(function() {
      s = null, isUndef(i2.resolved) && isUndef(i2.error) && (i2.loading = true, l(false));
    }, f.delay || 200)), isDef(f.timeout) && (u = setTimeout(function() {
      u = null, isUndef(i2.resolved) && d(null);
    }, f.timeout)))), a = false, i2.loading ? i2.loadingComp : i2.resolved;
  }
}
function getFirstComponentChild(i2) {
  if (isArray(i2))
    for (var e = 0; e < i2.length; e++) {
      var t = i2[e];
      if (isDef(t) && (isDef(t.componentOptions) || isAsyncPlaceholder(t)))
        return t;
    }
}
var SIMPLE_NORMALIZE = 1, ALWAYS_NORMALIZE = 2;
function createElement$1(i2, e, t, r, a, s) {
  return (isArray(t) || isPrimitive(t)) && (a = r, r = t, t = void 0), isTrue(s) && (a = ALWAYS_NORMALIZE), _createElement(i2, e, t, r, a);
}
function _createElement(i2, e, t, r, a) {
  if (isDef(t) && isDef(t.__ob__) || (isDef(t) && isDef(t.is) && (e = t.is), !e))
    return createEmptyVNode();
  isArray(r) && isFunction(r[0]) && (t = t || {}, t.scopedSlots = { default: r[0] }, r.length = 0), a === ALWAYS_NORMALIZE ? r = normalizeChildren(r) : a === SIMPLE_NORMALIZE && (r = simpleNormalizeChildren(r));
  var s, u;
  if (typeof e == "string") {
    var l = void 0;
    u = i2.$vnode && i2.$vnode.ns || config.getTagNamespace(e), config.isReservedTag(e) ? s = new VNode(config.parsePlatformTagName(e), t, r, void 0, void 0, i2) : (!t || !t.pre) && isDef(l = resolveAsset(i2.$options, "components", e)) ? s = createComponent(l, t, i2, r, e) : s = new VNode(e, t, r, void 0, void 0, i2);
  } else
    s = createComponent(e, t, i2, r);
  return isArray(s) ? s : isDef(s) ? (isDef(u) && applyNS(s, u), isDef(t) && registerDeepBindings(t), s) : createEmptyVNode();
}
function applyNS(i2, e, t) {
  if (i2.ns = e, i2.tag === "foreignObject" && (e = void 0, t = true), isDef(i2.children))
    for (var r = 0, a = i2.children.length; r < a; r++) {
      var s = i2.children[r];
      isDef(s.tag) && (isUndef(s.ns) || isTrue(t) && s.tag !== "svg") && applyNS(s, e, t);
    }
}
function registerDeepBindings(i2) {
  isObject(i2.style) && traverse(i2.style), isObject(i2.class) && traverse(i2.class);
}
function handleError(i2, e, t) {
  pushTarget();
  try {
    if (e)
      for (var r = e; r = r.$parent; ) {
        var a = r.$options.errorCaptured;
        if (a)
          for (var s = 0; s < a.length; s++)
            try {
              var u = a[s].call(r, i2, e, t) === false;
              if (u)
                return;
            } catch (l) {
              globalHandleError(l, r, "errorCaptured hook");
            }
      }
    globalHandleError(i2, e, t);
  } finally {
    popTarget();
  }
}
function invokeWithErrorHandling(i2, e, t, r, a) {
  var s;
  try {
    s = t ? i2.apply(e, t) : i2.call(e), s && !s._isVue && isPromise(s) && !s._handled && (s.catch(function(u) {
      return handleError(u, r, a + " (Promise/async)");
    }), s._handled = true);
  } catch (u) {
    handleError(u, r, a);
  }
  return s;
}
function globalHandleError(i2, e, t) {
  if (config.errorHandler)
    try {
      return config.errorHandler.call(null, i2, e, t);
    } catch (r) {
      r !== i2 && logError(r);
    }
  logError(i2);
}
function logError(i2, e, t) {
  if (inBrowser && typeof console < "u")
    console.error(i2);
  else
    throw i2;
}
var isUsingMicroTask = false, callbacks = [], pending = false;
function flushCallbacks() {
  pending = false;
  var i2 = callbacks.slice(0);
  callbacks.length = 0;
  for (var e = 0; e < i2.length; e++)
    i2[e]();
}
var timerFunc;
if (typeof Promise < "u" && isNative(Promise)) {
  var p_1 = Promise.resolve();
  timerFunc = function() {
    p_1.then(flushCallbacks), isIOS && setTimeout(noop$1);
  }, isUsingMicroTask = true;
} else if (!isIE && typeof MutationObserver < "u" && (isNative(MutationObserver) || // PhantomJS and iOS 7.x
MutationObserver.toString() === "[object MutationObserverConstructor]")) {
  var counter_1 = 1, observer = new MutationObserver(flushCallbacks), textNode_1 = document.createTextNode(String(counter_1));
  observer.observe(textNode_1, {
    characterData: true
  }), timerFunc = function() {
    counter_1 = (counter_1 + 1) % 2, textNode_1.data = String(counter_1);
  }, isUsingMicroTask = true;
} else typeof setImmediate < "u" && isNative(setImmediate) ? timerFunc = function() {
  setImmediate(flushCallbacks);
} : timerFunc = function() {
  setTimeout(flushCallbacks, 0);
};
function nextTick(i2, e) {
  var t;
  if (callbacks.push(function() {
    if (i2)
      try {
        i2.call(e);
      } catch (r) {
        handleError(r, e, "nextTick");
      }
    else t && t(e);
  }), pending || (pending = true, timerFunc()), !i2 && typeof Promise < "u")
    return new Promise(function(r) {
      t = r;
    });
}
var version = "2.7.16", seenObjects = new _Set$1();
function traverse(i2) {
  return _traverse(i2, seenObjects), seenObjects.clear(), i2;
}
function _traverse(i2, e) {
  var t, r, a = isArray(i2);
  if (!(!a && !isObject(i2) || i2.__v_skip || Object.isFrozen(i2) || i2 instanceof VNode)) {
    if (i2.__ob__) {
      var s = i2.__ob__.dep.id;
      if (e.has(s))
        return;
      e.add(s);
    }
    if (a)
      for (t = i2.length; t--; )
        _traverse(i2[t], e);
    else if (isRef(i2))
      _traverse(i2.value, e);
    else
      for (r = Object.keys(i2), t = r.length; t--; )
        _traverse(i2[r[t]], e);
  }
}
var uid$1 = 0, Watcher = (
  /** @class */
  function() {
    function i2(e, t, r, a, s) {
      recordEffectScope(
        this,
        // if the active effect scope is manually created (not a component scope),
        // prioritize it
        activeEffectScope && !activeEffectScope._vm ? activeEffectScope : e ? e._scope : void 0
      ), (this.vm = e) && s && (e._watcher = this), a ? (this.deep = !!a.deep, this.user = !!a.user, this.lazy = !!a.lazy, this.sync = !!a.sync, this.before = a.before) : this.deep = this.user = this.lazy = this.sync = false, this.cb = r, this.id = ++uid$1, this.active = true, this.post = false, this.dirty = this.lazy, this.deps = [], this.newDeps = [], this.depIds = new _Set$1(), this.newDepIds = new _Set$1(), this.expression = "", isFunction(t) ? this.getter = t : (this.getter = parsePath(t), this.getter || (this.getter = noop$1)), this.value = this.lazy ? void 0 : this.get();
    }
    return i2.prototype.get = function() {
      pushTarget(this);
      var e, t = this.vm;
      try {
        e = this.getter.call(t, t);
      } catch (r) {
        if (this.user)
          handleError(r, t, 'getter for watcher "'.concat(this.expression, '"'));
        else
          throw r;
      } finally {
        this.deep && traverse(e), popTarget(), this.cleanupDeps();
      }
      return e;
    }, i2.prototype.addDep = function(e) {
      var t = e.id;
      this.newDepIds.has(t) || (this.newDepIds.add(t), this.newDeps.push(e), this.depIds.has(t) || e.addSub(this));
    }, i2.prototype.cleanupDeps = function() {
      for (var e = this.deps.length; e--; ) {
        var t = this.deps[e];
        this.newDepIds.has(t.id) || t.removeSub(this);
      }
      var r = this.depIds;
      this.depIds = this.newDepIds, this.newDepIds = r, this.newDepIds.clear(), r = this.deps, this.deps = this.newDeps, this.newDeps = r, this.newDeps.length = 0;
    }, i2.prototype.update = function() {
      this.lazy ? this.dirty = true : this.sync ? this.run() : queueWatcher(this);
    }, i2.prototype.run = function() {
      if (this.active) {
        var e = this.get();
        if (e !== this.value || // Deep watchers and watchers on Object/Arrays should fire even
        // when the value is the same, because the value may
        // have mutated.
        isObject(e) || this.deep) {
          var t = this.value;
          if (this.value = e, this.user) {
            var r = 'callback for watcher "'.concat(this.expression, '"');
            invokeWithErrorHandling(this.cb, this.vm, [e, t], this.vm, r);
          } else
            this.cb.call(this.vm, e, t);
        }
      }
    }, i2.prototype.evaluate = function() {
      this.value = this.get(), this.dirty = false;
    }, i2.prototype.depend = function() {
      for (var e = this.deps.length; e--; )
        this.deps[e].depend();
    }, i2.prototype.teardown = function() {
      if (this.vm && !this.vm._isBeingDestroyed && remove$2(this.vm._scope.effects, this), this.active) {
        for (var e = this.deps.length; e--; )
          this.deps[e].removeSub(this);
        this.active = false, this.onStop && this.onStop();
      }
    }, i2;
  }()
);
function initEvents(i2) {
  i2._events = /* @__PURE__ */ Object.create(null), i2._hasHookEvent = false;
  var e = i2.$options._parentListeners;
  e && updateComponentListeners(i2, e);
}
var target$1;
function add$1(i2, e) {
  target$1.$on(i2, e);
}
function remove$1(i2, e) {
  target$1.$off(i2, e);
}
function createOnceHandler$1(i2, e) {
  var t = target$1;
  return function r() {
    var a = e.apply(null, arguments);
    a !== null && t.$off(i2, r);
  };
}
function updateComponentListeners(i2, e, t) {
  target$1 = i2, updateListeners(e, t || {}, add$1, remove$1, createOnceHandler$1, i2), target$1 = void 0;
}
function eventsMixin(i2) {
  var e = /^hook:/;
  i2.prototype.$on = function(t, r) {
    var a = this;
    if (isArray(t))
      for (var s = 0, u = t.length; s < u; s++)
        a.$on(t[s], r);
    else
      (a._events[t] || (a._events[t] = [])).push(r), e.test(t) && (a._hasHookEvent = true);
    return a;
  }, i2.prototype.$once = function(t, r) {
    var a = this;
    function s() {
      a.$off(t, s), r.apply(a, arguments);
    }
    return s.fn = r, a.$on(t, s), a;
  }, i2.prototype.$off = function(t, r) {
    var a = this;
    if (!arguments.length)
      return a._events = /* @__PURE__ */ Object.create(null), a;
    if (isArray(t)) {
      for (var s = 0, u = t.length; s < u; s++)
        a.$off(t[s], r);
      return a;
    }
    var l = a._events[t];
    if (!l)
      return a;
    if (!r)
      return a._events[t] = null, a;
    for (var c, d = l.length; d--; )
      if (c = l[d], c === r || c.fn === r) {
        l.splice(d, 1);
        break;
      }
    return a;
  }, i2.prototype.$emit = function(t) {
    var r = this, a = r._events[t];
    if (a) {
      a = a.length > 1 ? toArray(a) : a;
      for (var s = toArray(arguments, 1), u = 'event handler for "'.concat(t, '"'), l = 0, c = a.length; l < c; l++)
        invokeWithErrorHandling(a[l], r, s, r, u);
    }
    return r;
  };
}
var activeInstance = null;
function setActiveInstance(i2) {
  var e = activeInstance;
  return activeInstance = i2, function() {
    activeInstance = e;
  };
}
function initLifecycle(i2) {
  var e = i2.$options, t = e.parent;
  if (t && !e.abstract) {
    for (; t.$options.abstract && t.$parent; )
      t = t.$parent;
    t.$children.push(i2);
  }
  i2.$parent = t, i2.$root = t ? t.$root : i2, i2.$children = [], i2.$refs = {}, i2._provided = t ? t._provided : /* @__PURE__ */ Object.create(null), i2._watcher = null, i2._inactive = null, i2._directInactive = false, i2._isMounted = false, i2._isDestroyed = false, i2._isBeingDestroyed = false;
}
function lifecycleMixin(i2) {
  i2.prototype._update = function(e, t) {
    var r = this, a = r.$el, s = r._vnode, u = setActiveInstance(r);
    r._vnode = e, s ? r.$el = r.__patch__(s, e) : r.$el = r.__patch__(
      r.$el,
      e,
      t,
      false
      /* removeOnly */
    ), u(), a && (a.__vue__ = null), r.$el && (r.$el.__vue__ = r);
    for (var l = r; l && l.$vnode && l.$parent && l.$vnode === l.$parent._vnode; )
      l.$parent.$el = l.$el, l = l.$parent;
  }, i2.prototype.$forceUpdate = function() {
    var e = this;
    e._watcher && e._watcher.update();
  }, i2.prototype.$destroy = function() {
    var e = this;
    if (!e._isBeingDestroyed) {
      callHook$1(e, "beforeDestroy"), e._isBeingDestroyed = true;
      var t = e.$parent;
      t && !t._isBeingDestroyed && !e.$options.abstract && remove$2(t.$children, e), e._scope.stop(), e._data.__ob__ && e._data.__ob__.vmCount--, e._isDestroyed = true, e.__patch__(e._vnode, null), callHook$1(e, "destroyed"), e.$off(), e.$el && (e.$el.__vue__ = null), e.$vnode && (e.$vnode.parent = null);
    }
  };
}
function mountComponent(i2, e, t) {
  i2.$el = e, i2.$options.render || (i2.$options.render = createEmptyVNode), callHook$1(i2, "beforeMount");
  var r;
  r = function() {
    i2._update(i2._render(), t);
  };
  var a = {
    before: function() {
      i2._isMounted && !i2._isDestroyed && callHook$1(i2, "beforeUpdate");
    }
  };
  new Watcher(
    i2,
    r,
    noop$1,
    a,
    true
    /* isRenderWatcher */
  ), t = false;
  var s = i2._preWatchers;
  if (s)
    for (var u = 0; u < s.length; u++)
      s[u].run();
  return i2.$vnode == null && (i2._isMounted = true, callHook$1(i2, "mounted")), i2;
}
function updateChildComponent(i2, e, t, r, a) {
  var s = r.data.scopedSlots, u = i2.$scopedSlots, l = !!(s && !s.$stable || u !== emptyObject && !u.$stable || s && i2.$scopedSlots.$key !== s.$key || !s && i2.$scopedSlots.$key), c = !!(a || // has new static slots
  i2.$options._renderChildren || // has old static slots
  l), d = i2.$vnode;
  i2.$options._parentVnode = r, i2.$vnode = r, i2._vnode && (i2._vnode.parent = r), i2.$options._renderChildren = a;
  var f = r.data.attrs || emptyObject;
  i2._attrsProxy && syncSetupProxy(i2._attrsProxy, f, d.data && d.data.attrs || emptyObject, i2, "$attrs") && (c = true), i2.$attrs = f, t = t || emptyObject;
  var p = i2.$options._parentListeners;
  if (i2._listenersProxy && syncSetupProxy(i2._listenersProxy, t, p || emptyObject, i2, "$listeners"), i2.$listeners = i2.$options._parentListeners = t, updateComponentListeners(i2, t, p), e && i2.$options.props) {
    toggleObserving(false);
    for (var m = i2._props, y = i2.$options._propKeys || [], x = 0; x < y.length; x++) {
      var g = y[x], _ = i2.$options.props;
      m[g] = validateProp(g, _, e, i2);
    }
    toggleObserving(true), i2.$options.propsData = e;
  }
  c && (i2.$slots = resolveSlots(a, r.context), i2.$forceUpdate());
}
function isInInactiveTree(i2) {
  for (; i2 && (i2 = i2.$parent); )
    if (i2._inactive)
      return true;
  return false;
}
function activateChildComponent(i2, e) {
  if (e) {
    if (i2._directInactive = false, isInInactiveTree(i2))
      return;
  } else if (i2._directInactive)
    return;
  if (i2._inactive || i2._inactive === null) {
    i2._inactive = false;
    for (var t = 0; t < i2.$children.length; t++)
      activateChildComponent(i2.$children[t]);
    callHook$1(i2, "activated");
  }
}
function deactivateChildComponent(i2, e) {
  if (!(e && (i2._directInactive = true, isInInactiveTree(i2))) && !i2._inactive) {
    i2._inactive = true;
    for (var t = 0; t < i2.$children.length; t++)
      deactivateChildComponent(i2.$children[t]);
    callHook$1(i2, "deactivated");
  }
}
function callHook$1(i2, e, t, r) {
  r === void 0 && (r = true), pushTarget();
  var a = currentInstance, s = getCurrentScope();
  r && setCurrentInstance(i2);
  var u = i2.$options[e], l = "".concat(e, " hook");
  if (u)
    for (var c = 0, d = u.length; c < d; c++)
      invokeWithErrorHandling(u[c], i2, null, i2, l);
  i2._hasHookEvent && i2.$emit("hook:" + e), r && (setCurrentInstance(a), s && s.on()), popTarget();
}
var queue$1 = [], activatedChildren = [], has = {}, waiting = false, flushing = false, index$1 = 0;
function resetSchedulerState() {
  index$1 = queue$1.length = activatedChildren.length = 0, has = {}, waiting = flushing = false;
}
var currentFlushTimestamp = 0, getNow$1 = Date.now;
if (inBrowser && !isIE) {
  var performance_1 = window.performance;
  performance_1 && typeof performance_1.now == "function" && getNow$1() > document.createEvent("Event").timeStamp && (getNow$1 = function() {
    return performance_1.now();
  });
}
var sortCompareFn = function(i2, e) {
  if (i2.post) {
    if (!e.post)
      return 1;
  } else if (e.post)
    return -1;
  return i2.id - e.id;
};
function flushSchedulerQueue() {
  currentFlushTimestamp = getNow$1(), flushing = true;
  var i2, e;
  for (queue$1.sort(sortCompareFn), index$1 = 0; index$1 < queue$1.length; index$1++)
    i2 = queue$1[index$1], i2.before && i2.before(), e = i2.id, has[e] = null, i2.run();
  var t = activatedChildren.slice(), r = queue$1.slice();
  resetSchedulerState(), callActivatedHooks(t), callUpdatedHooks(r), cleanupDeps(), devtools && config.devtools && devtools.emit("flush");
}
function callUpdatedHooks(i2) {
  for (var e = i2.length; e--; ) {
    var t = i2[e], r = t.vm;
    r && r._watcher === t && r._isMounted && !r._isDestroyed && callHook$1(r, "updated");
  }
}
function queueActivatedComponent(i2) {
  i2._inactive = false, activatedChildren.push(i2);
}
function callActivatedHooks(i2) {
  for (var e = 0; e < i2.length; e++)
    i2[e]._inactive = true, activateChildComponent(
      i2[e],
      true
      /* true */
    );
}
function queueWatcher(i2) {
  var e = i2.id;
  if (has[e] == null && !(i2 === Dep.target && i2.noRecurse)) {
    if (has[e] = true, !flushing)
      queue$1.push(i2);
    else {
      for (var t = queue$1.length - 1; t > index$1 && queue$1[t].id > i2.id; )
        t--;
      queue$1.splice(t + 1, 0, i2);
    }
    waiting || (waiting = true, nextTick(flushSchedulerQueue));
  }
}
function initProvide(i2) {
  var e = i2.$options.provide;
  if (e) {
    var t = isFunction(e) ? e.call(i2) : e;
    if (!isObject(t))
      return;
    for (var r = resolveProvided(i2), a = hasSymbol ? Reflect.ownKeys(t) : Object.keys(t), s = 0; s < a.length; s++) {
      var u = a[s];
      Object.defineProperty(r, u, Object.getOwnPropertyDescriptor(t, u));
    }
  }
}
function initInjections(i2) {
  var e = resolveInject(i2.$options.inject, i2);
  e && (toggleObserving(false), Object.keys(e).forEach(function(t) {
    defineReactive(i2, t, e[t]);
  }), toggleObserving(true));
}
function resolveInject(i2, e) {
  if (i2) {
    for (var t = /* @__PURE__ */ Object.create(null), r = hasSymbol ? Reflect.ownKeys(i2) : Object.keys(i2), a = 0; a < r.length; a++) {
      var s = r[a];
      if (s !== "__ob__") {
        var u = i2[s].from;
        if (u in e._provided)
          t[s] = e._provided[u];
        else if ("default" in i2[s]) {
          var l = i2[s].default;
          t[s] = isFunction(l) ? l.call(e) : l;
        }
      }
    }
    return t;
  }
}
function FunctionalRenderContext(i2, e, t, r, a) {
  var s = this, u = a.options, l;
  hasOwn(r, "_uid") ? (l = Object.create(r), l._original = r) : (l = r, r = r._original);
  var c = isTrue(u._compiled), d = !c;
  this.data = i2, this.props = e, this.children = t, this.parent = r, this.listeners = i2.on || emptyObject, this.injections = resolveInject(u.inject, r), this.slots = function() {
    return s.$slots || normalizeScopedSlots(r, i2.scopedSlots, s.$slots = resolveSlots(t, r)), s.$slots;
  }, Object.defineProperty(this, "scopedSlots", {
    enumerable: true,
    get: function() {
      return normalizeScopedSlots(r, i2.scopedSlots, this.slots());
    }
  }), c && (this.$options = u, this.$slots = this.slots(), this.$scopedSlots = normalizeScopedSlots(r, i2.scopedSlots, this.$slots)), u._scopeId ? this._c = function(f, p, m, y) {
    var x = createElement$1(l, f, p, m, y, d);
    return x && !isArray(x) && (x.fnScopeId = u._scopeId, x.fnContext = r), x;
  } : this._c = function(f, p, m, y) {
    return createElement$1(l, f, p, m, y, d);
  };
}
installRenderHelpers(FunctionalRenderContext.prototype);
function createFunctionalComponent(i2, e, t, r, a) {
  var s = i2.options, u = {}, l = s.props;
  if (isDef(l))
    for (var c in l)
      u[c] = validateProp(c, l, e || emptyObject);
  else
    isDef(t.attrs) && mergeProps(u, t.attrs), isDef(t.props) && mergeProps(u, t.props);
  var d = new FunctionalRenderContext(t, u, a, r, i2), f = s.render.call(null, d._c, d);
  if (f instanceof VNode)
    return cloneAndMarkFunctionalResult(f, t, d.parent, s);
  if (isArray(f)) {
    for (var p = normalizeChildren(f) || [], m = new Array(p.length), y = 0; y < p.length; y++)
      m[y] = cloneAndMarkFunctionalResult(p[y], t, d.parent, s);
    return m;
  }
}
function cloneAndMarkFunctionalResult(i2, e, t, r, a) {
  var s = cloneVNode(i2);
  return s.fnContext = t, s.fnOptions = r, e.slot && ((s.data || (s.data = {})).slot = e.slot), s;
}
function mergeProps(i2, e) {
  for (var t in e)
    i2[camelize(t)] = e[t];
}
function getComponentName(i2) {
  return i2.name || i2.__name || i2._componentTag;
}
var componentVNodeHooks = {
  init: function(i2, e) {
    if (i2.componentInstance && !i2.componentInstance._isDestroyed && i2.data.keepAlive) {
      var t = i2;
      componentVNodeHooks.prepatch(t, t);
    } else {
      var r = i2.componentInstance = createComponentInstanceForVnode(i2, activeInstance);
      r.$mount(e ? i2.elm : void 0, e);
    }
  },
  prepatch: function(i2, e) {
    var t = e.componentOptions, r = e.componentInstance = i2.componentInstance;
    updateChildComponent(
      r,
      t.propsData,
      // updated props
      t.listeners,
      // updated listeners
      e,
      // new parent vnode
      t.children
      // new children
    );
  },
  insert: function(i2) {
    var e = i2.context, t = i2.componentInstance;
    t._isMounted || (t._isMounted = true, callHook$1(t, "mounted")), i2.data.keepAlive && (e._isMounted ? queueActivatedComponent(t) : activateChildComponent(
      t,
      true
      /* direct */
    ));
  },
  destroy: function(i2) {
    var e = i2.componentInstance;
    e._isDestroyed || (i2.data.keepAlive ? deactivateChildComponent(
      e,
      true
      /* direct */
    ) : e.$destroy());
  }
}, hooksToMerge = Object.keys(componentVNodeHooks);
function createComponent(i2, e, t, r, a) {
  if (!isUndef(i2)) {
    var s = t.$options._base;
    if (isObject(i2) && (i2 = s.extend(i2)), typeof i2 == "function") {
      var u;
      if (isUndef(i2.cid) && (u = i2, i2 = resolveAsyncComponent(u, s), i2 === void 0))
        return createAsyncPlaceholder(u, e, t, r, a);
      e = e || {}, resolveConstructorOptions(i2), isDef(e.model) && transformModel(i2.options, e);
      var l = extractPropsFromVNodeData(e, i2);
      if (isTrue(i2.options.functional))
        return createFunctionalComponent(i2, l, e, t, r);
      var c = e.on;
      if (e.on = e.nativeOn, isTrue(i2.options.abstract)) {
        var d = e.slot;
        e = {}, d && (e.slot = d);
      }
      installComponentHooks(e);
      var f = getComponentName(i2.options) || a, p = new VNode(
        // @ts-expect-error
        "vue-component-".concat(i2.cid).concat(f ? "-".concat(f) : ""),
        e,
        void 0,
        void 0,
        void 0,
        t,
        // @ts-expect-error
        { Ctor: i2, propsData: l, listeners: c, tag: a, children: r },
        u
      );
      return p;
    }
  }
}
function createComponentInstanceForVnode(i2, e) {
  var t = {
    _isComponent: true,
    _parentVnode: i2,
    parent: e
  }, r = i2.data.inlineTemplate;
  return isDef(r) && (t.render = r.render, t.staticRenderFns = r.staticRenderFns), new i2.componentOptions.Ctor(t);
}
function installComponentHooks(i2) {
  for (var e = i2.hook || (i2.hook = {}), t = 0; t < hooksToMerge.length; t++) {
    var r = hooksToMerge[t], a = e[r], s = componentVNodeHooks[r];
    a !== s && !(a && a._merged) && (e[r] = a ? mergeHook(s, a) : s);
  }
}
function mergeHook(i2, e) {
  var t = function(r, a) {
    i2(r, a), e(r, a);
  };
  return t._merged = true, t;
}
function transformModel(i2, e) {
  var t = i2.model && i2.model.prop || "value", r = i2.model && i2.model.event || "input";
  (e.attrs || (e.attrs = {}))[t] = e.model.value;
  var a = e.on || (e.on = {}), s = a[r], u = e.model.callback;
  isDef(s) ? (isArray(s) ? s.indexOf(u) === -1 : s !== u) && (a[r] = [u].concat(s)) : a[r] = u;
}
var warn = noop$1, strats = config.optionMergeStrategies;
function mergeData(i2, e, t) {
  if (t === void 0 && (t = true), !e)
    return i2;
  for (var r, a, s, u = hasSymbol ? Reflect.ownKeys(e) : Object.keys(e), l = 0; l < u.length; l++)
    r = u[l], r !== "__ob__" && (a = i2[r], s = e[r], !t || !hasOwn(i2, r) ? set(i2, r, s) : a !== s && isPlainObject(a) && isPlainObject(s) && mergeData(a, s));
  return i2;
}
function mergeDataOrFn(i2, e, t) {
  return t ? function() {
    var r = isFunction(e) ? e.call(t, t) : e, a = isFunction(i2) ? i2.call(t, t) : i2;
    return r ? mergeData(r, a) : a;
  } : e ? i2 ? function() {
    return mergeData(isFunction(e) ? e.call(this, this) : e, isFunction(i2) ? i2.call(this, this) : i2);
  } : e : i2;
}
strats.data = function(i2, e, t) {
  return t ? mergeDataOrFn(i2, e, t) : e && typeof e != "function" ? i2 : mergeDataOrFn(i2, e);
};
function mergeLifecycleHook(i2, e) {
  var t = e ? i2 ? i2.concat(e) : isArray(e) ? e : [e] : i2;
  return t && dedupeHooks(t);
}
function dedupeHooks(i2) {
  for (var e = [], t = 0; t < i2.length; t++)
    e.indexOf(i2[t]) === -1 && e.push(i2[t]);
  return e;
}
LIFECYCLE_HOOKS.forEach(function(i2) {
  strats[i2] = mergeLifecycleHook;
});
function mergeAssets(i2, e, t, r) {
  var a = Object.create(i2 || null);
  return e ? extend(a, e) : a;
}
ASSET_TYPES.forEach(function(i2) {
  strats[i2 + "s"] = mergeAssets;
});
strats.watch = function(i2, e, t, r) {
  if (i2 === nativeWatch && (i2 = void 0), e === nativeWatch && (e = void 0), !e)
    return Object.create(i2 || null);
  if (!i2)
    return e;
  var a = {};
  extend(a, i2);
  for (var s in e) {
    var u = a[s], l = e[s];
    u && !isArray(u) && (u = [u]), a[s] = u ? u.concat(l) : isArray(l) ? l : [l];
  }
  return a;
};
strats.props = strats.methods = strats.inject = strats.computed = function(i2, e, t, r) {
  if (!i2)
    return e;
  var a = /* @__PURE__ */ Object.create(null);
  return extend(a, i2), e && extend(a, e), a;
};
strats.provide = function(i2, e) {
  return i2 ? function() {
    var t = /* @__PURE__ */ Object.create(null);
    return mergeData(t, isFunction(i2) ? i2.call(this) : i2), e && mergeData(
      t,
      isFunction(e) ? e.call(this) : e,
      false
      // non-recursive
    ), t;
  } : e;
};
var defaultStrat = function(i2, e) {
  return e === void 0 ? i2 : e;
};
function normalizeProps(i2, e) {
  var t = i2.props;
  if (t) {
    var r = {}, a, s, u;
    if (isArray(t))
      for (a = t.length; a--; )
        s = t[a], typeof s == "string" && (u = camelize(s), r[u] = { type: null });
    else if (isPlainObject(t))
      for (var l in t)
        s = t[l], u = camelize(l), r[u] = isPlainObject(s) ? s : { type: s };
    i2.props = r;
  }
}
function normalizeInject(i2, e) {
  var t = i2.inject;
  if (t) {
    var r = i2.inject = {};
    if (isArray(t))
      for (var a = 0; a < t.length; a++)
        r[t[a]] = { from: t[a] };
    else if (isPlainObject(t))
      for (var s in t) {
        var u = t[s];
        r[s] = isPlainObject(u) ? extend({ from: s }, u) : { from: u };
      }
  }
}
function normalizeDirectives$1(i2) {
  var e = i2.directives;
  if (e)
    for (var t in e) {
      var r = e[t];
      isFunction(r) && (e[t] = { bind: r, update: r });
    }
}
function mergeOptions(i2, e, t) {
  if (isFunction(e) && (e = e.options), normalizeProps(e), normalizeInject(e), normalizeDirectives$1(e), !e._base && (e.extends && (i2 = mergeOptions(i2, e.extends, t)), e.mixins))
    for (var r = 0, a = e.mixins.length; r < a; r++)
      i2 = mergeOptions(i2, e.mixins[r], t);
  var s = {}, u;
  for (u in i2)
    l(u);
  for (u in e)
    hasOwn(i2, u) || l(u);
  function l(c) {
    var d = strats[c] || defaultStrat;
    s[c] = d(i2[c], e[c], t, c);
  }
  return s;
}
function resolveAsset(i2, e, t, r) {
  if (typeof t == "string") {
    var a = i2[e];
    if (hasOwn(a, t))
      return a[t];
    var s = camelize(t);
    if (hasOwn(a, s))
      return a[s];
    var u = capitalize(s);
    if (hasOwn(a, u))
      return a[u];
    var l = a[t] || a[s] || a[u];
    return l;
  }
}
function validateProp(i2, e, t, r) {
  var a = e[i2], s = !hasOwn(t, i2), u = t[i2], l = getTypeIndex(Boolean, a.type);
  if (l > -1) {
    if (s && !hasOwn(a, "default"))
      u = false;
    else if (u === "" || u === hyphenate(i2)) {
      var c = getTypeIndex(String, a.type);
      (c < 0 || l < c) && (u = true);
    }
  }
  if (u === void 0) {
    u = getPropDefaultValue(r, a, i2);
    var d = shouldObserve;
    toggleObserving(true), observe(u), toggleObserving(d);
  }
  return u;
}
function getPropDefaultValue(i2, e, t) {
  if (hasOwn(e, "default")) {
    var r = e.default;
    return i2 && i2.$options.propsData && i2.$options.propsData[t] === void 0 && i2._props[t] !== void 0 ? i2._props[t] : isFunction(r) && getType(e.type) !== "Function" ? r.call(i2) : r;
  }
}
var functionTypeCheckRE = /^\s*function (\w+)/;
function getType(i2) {
  var e = i2 && i2.toString().match(functionTypeCheckRE);
  return e ? e[1] : "";
}
function isSameType(i2, e) {
  return getType(i2) === getType(e);
}
function getTypeIndex(i2, e) {
  if (!isArray(e))
    return isSameType(e, i2) ? 0 : -1;
  for (var t = 0, r = e.length; t < r; t++)
    if (isSameType(e[t], i2))
      return t;
  return -1;
}
var sharedPropertyDefinition = {
  enumerable: true,
  configurable: true,
  get: noop$1,
  set: noop$1
};
function proxy(i2, e, t) {
  sharedPropertyDefinition.get = function() {
    return this[e][t];
  }, sharedPropertyDefinition.set = function(r) {
    this[e][t] = r;
  }, Object.defineProperty(i2, t, sharedPropertyDefinition);
}
function initState(i2) {
  var e = i2.$options;
  if (e.props && initProps$1(i2, e.props), initSetup(i2), e.methods && initMethods(i2, e.methods), e.data)
    initData(i2);
  else {
    var t = observe(i2._data = {});
    t && t.vmCount++;
  }
  e.computed && initComputed$1(i2, e.computed), e.watch && e.watch !== nativeWatch && initWatch(i2, e.watch);
}
function initProps$1(i2, e) {
  var t = i2.$options.propsData || {}, r = i2._props = shallowReactive({}), a = i2.$options._propKeys = [], s = !i2.$parent;
  s || toggleObserving(false);
  var u = function(c) {
    a.push(c);
    var d = validateProp(c, e, t, i2);
    defineReactive(
      r,
      c,
      d,
      void 0,
      true
      /* shallow */
    ), c in i2 || proxy(i2, "_props", c);
  };
  for (var l in e)
    u(l);
  toggleObserving(true);
}
function initData(i2) {
  var e = i2.$options.data;
  e = i2._data = isFunction(e) ? getData(e, i2) : e || {}, isPlainObject(e) || (e = {});
  var t = Object.keys(e), r = i2.$options.props;
  i2.$options.methods;
  for (var a = t.length; a--; ) {
    var s = t[a];
    r && hasOwn(r, s) || isReserved(s) || proxy(i2, "_data", s);
  }
  var u = observe(e);
  u && u.vmCount++;
}
function getData(i2, e) {
  pushTarget();
  try {
    return i2.call(e, e);
  } catch (t) {
    return handleError(t, e, "data()"), {};
  } finally {
    popTarget();
  }
}
var computedWatcherOptions = { lazy: true };
function initComputed$1(i2, e) {
  var t = i2._computedWatchers = /* @__PURE__ */ Object.create(null), r = isServerRendering();
  for (var a in e) {
    var s = e[a], u = isFunction(s) ? s : s.get;
    r || (t[a] = new Watcher(i2, u || noop$1, noop$1, computedWatcherOptions)), a in i2 || defineComputed(i2, a, s);
  }
}
function defineComputed(i2, e, t) {
  var r = !isServerRendering();
  isFunction(t) ? (sharedPropertyDefinition.get = r ? createComputedGetter(e) : createGetterInvoker(t), sharedPropertyDefinition.set = noop$1) : (sharedPropertyDefinition.get = t.get ? r && t.cache !== false ? createComputedGetter(e) : createGetterInvoker(t.get) : noop$1, sharedPropertyDefinition.set = t.set || noop$1), Object.defineProperty(i2, e, sharedPropertyDefinition);
}
function createComputedGetter(i2) {
  return function() {
    var e = this._computedWatchers && this._computedWatchers[i2];
    if (e)
      return e.dirty && e.evaluate(), Dep.target && e.depend(), e.value;
  };
}
function createGetterInvoker(i2) {
  return function() {
    return i2.call(this, this);
  };
}
function initMethods(i2, e) {
  i2.$options.props;
  for (var t in e)
    i2[t] = typeof e[t] != "function" ? noop$1 : bind(e[t], i2);
}
function initWatch(i2, e) {
  for (var t in e) {
    var r = e[t];
    if (isArray(r))
      for (var a = 0; a < r.length; a++)
        createWatcher(i2, t, r[a]);
    else
      createWatcher(i2, t, r);
  }
}
function createWatcher(i2, e, t, r) {
  return isPlainObject(t) && (r = t, t = t.handler), typeof t == "string" && (t = i2[t]), i2.$watch(e, t, r);
}
function stateMixin(i2) {
  var e = {};
  e.get = function() {
    return this._data;
  };
  var t = {};
  t.get = function() {
    return this._props;
  }, Object.defineProperty(i2.prototype, "$data", e), Object.defineProperty(i2.prototype, "$props", t), i2.prototype.$set = set, i2.prototype.$delete = del, i2.prototype.$watch = function(r, a, s) {
    var u = this;
    if (isPlainObject(a))
      return createWatcher(u, r, a, s);
    s = s || {}, s.user = true;
    var l = new Watcher(u, r, a, s);
    if (s.immediate) {
      var c = 'callback for immediate watcher "'.concat(l.expression, '"');
      pushTarget(), invokeWithErrorHandling(a, u, [l.value], u, c), popTarget();
    }
    return function() {
      l.teardown();
    };
  };
}
var uid = 0;
function initMixin$1(i2) {
  i2.prototype._init = function(e) {
    var t = this;
    t._uid = uid++, t._isVue = true, t.__v_skip = true, t._scope = new EffectScope(
      true
      /* detached */
    ), t._scope.parent = void 0, t._scope._vm = true, e && e._isComponent ? initInternalComponent(t, e) : t.$options = mergeOptions(resolveConstructorOptions(t.constructor), e || {}, t), t._renderProxy = t, t._self = t, initLifecycle(t), initEvents(t), initRender(t), callHook$1(
      t,
      "beforeCreate",
      void 0,
      false
      /* setContext */
    ), initInjections(t), initState(t), initProvide(t), callHook$1(t, "created"), t.$options.el && t.$mount(t.$options.el);
  };
}
function initInternalComponent(i2, e) {
  var t = i2.$options = Object.create(i2.constructor.options), r = e._parentVnode;
  t.parent = e.parent, t._parentVnode = r;
  var a = r.componentOptions;
  t.propsData = a.propsData, t._parentListeners = a.listeners, t._renderChildren = a.children, t._componentTag = a.tag, e.render && (t.render = e.render, t.staticRenderFns = e.staticRenderFns);
}
function resolveConstructorOptions(i2) {
  var e = i2.options;
  if (i2.super) {
    var t = resolveConstructorOptions(i2.super), r = i2.superOptions;
    if (t !== r) {
      i2.superOptions = t;
      var a = resolveModifiedOptions(i2);
      a && extend(i2.extendOptions, a), e = i2.options = mergeOptions(t, i2.extendOptions), e.name && (e.components[e.name] = i2);
    }
  }
  return e;
}
function resolveModifiedOptions(i2) {
  var e, t = i2.options, r = i2.sealedOptions;
  for (var a in t)
    t[a] !== r[a] && (e || (e = {}), e[a] = t[a]);
  return e;
}
function Vue(i2) {
  this._init(i2);
}
initMixin$1(Vue);
stateMixin(Vue);
eventsMixin(Vue);
lifecycleMixin(Vue);
renderMixin(Vue);
function initUse(i2) {
  i2.use = function(e) {
    var t = this._installedPlugins || (this._installedPlugins = []);
    if (t.indexOf(e) > -1)
      return this;
    var r = toArray(arguments, 1);
    return r.unshift(this), isFunction(e.install) ? e.install.apply(e, r) : isFunction(e) && e.apply(null, r), t.push(e), this;
  };
}
function initMixin(i2) {
  i2.mixin = function(e) {
    return this.options = mergeOptions(this.options, e), this;
  };
}
function initExtend(i2) {
  i2.cid = 0;
  var e = 1;
  i2.extend = function(t) {
    t = t || {};
    var r = this, a = r.cid, s = t._Ctor || (t._Ctor = {});
    if (s[a])
      return s[a];
    var u = getComponentName(t) || getComponentName(r.options), l = function(c) {
      this._init(c);
    };
    return l.prototype = Object.create(r.prototype), l.prototype.constructor = l, l.cid = e++, l.options = mergeOptions(r.options, t), l.super = r, l.options.props && initProps(l), l.options.computed && initComputed(l), l.extend = r.extend, l.mixin = r.mixin, l.use = r.use, ASSET_TYPES.forEach(function(c) {
      l[c] = r[c];
    }), u && (l.options.components[u] = l), l.superOptions = r.options, l.extendOptions = t, l.sealedOptions = extend({}, l.options), s[a] = l, l;
  };
}
function initProps(i2) {
  var e = i2.options.props;
  for (var t in e)
    proxy(i2.prototype, "_props", t);
}
function initComputed(i2) {
  var e = i2.options.computed;
  for (var t in e)
    defineComputed(i2.prototype, t, e[t]);
}
function initAssetRegisters(i2) {
  ASSET_TYPES.forEach(function(e) {
    i2[e] = function(t, r) {
      return r ? (e === "component" && isPlainObject(r) && (r.name = r.name || t, r = this.options._base.extend(r)), e === "directive" && isFunction(r) && (r = { bind: r, update: r }), this.options[e + "s"][t] = r, r) : this.options[e + "s"][t];
    };
  });
}
function _getComponentName(i2) {
  return i2 && (getComponentName(i2.Ctor.options) || i2.tag);
}
function matches(i2, e) {
  return isArray(i2) ? i2.indexOf(e) > -1 : typeof i2 == "string" ? i2.split(",").indexOf(e) > -1 : isRegExp(i2) ? i2.test(e) : false;
}
function pruneCache(i2, e) {
  var t = i2.cache, r = i2.keys, a = i2._vnode, s = i2.$vnode;
  for (var u in t) {
    var l = t[u];
    if (l) {
      var c = l.name;
      c && !e(c) && pruneCacheEntry(t, u, r, a);
    }
  }
  s.componentOptions.children = void 0;
}
function pruneCacheEntry(i2, e, t, r) {
  var a = i2[e];
  a && (!r || a.tag !== r.tag) && a.componentInstance.$destroy(), i2[e] = null, remove$2(t, e);
}
var patternTypes = [String, RegExp, Array], KeepAlive = {
  name: "keep-alive",
  abstract: true,
  props: {
    include: patternTypes,
    exclude: patternTypes,
    max: [String, Number]
  },
  methods: {
    cacheVNode: function() {
      var i2 = this, e = i2.cache, t = i2.keys, r = i2.vnodeToCache, a = i2.keyToCache;
      if (r) {
        var s = r.tag, u = r.componentInstance, l = r.componentOptions;
        e[a] = {
          name: _getComponentName(l),
          tag: s,
          componentInstance: u
        }, t.push(a), this.max && t.length > parseInt(this.max) && pruneCacheEntry(e, t[0], t, this._vnode), this.vnodeToCache = null;
      }
    }
  },
  created: function() {
    this.cache = /* @__PURE__ */ Object.create(null), this.keys = [];
  },
  destroyed: function() {
    for (var i2 in this.cache)
      pruneCacheEntry(this.cache, i2, this.keys);
  },
  mounted: function() {
    var i2 = this;
    this.cacheVNode(), this.$watch("include", function(e) {
      pruneCache(i2, function(t) {
        return matches(e, t);
      });
    }), this.$watch("exclude", function(e) {
      pruneCache(i2, function(t) {
        return !matches(e, t);
      });
    });
  },
  updated: function() {
    this.cacheVNode();
  },
  render: function() {
    var i2 = this.$slots.default, e = getFirstComponentChild(i2), t = e && e.componentOptions;
    if (t) {
      var r = _getComponentName(t), a = this, s = a.include, u = a.exclude;
      if (
        // not included
        s && (!r || !matches(s, r)) || // excluded
        u && r && matches(u, r)
      )
        return e;
      var l = this, c = l.cache, d = l.keys, f = e.key == null ? (
        // same constructor may get registered as different local components
        // so cid alone is not enough (#3269)
        t.Ctor.cid + (t.tag ? "::".concat(t.tag) : "")
      ) : e.key;
      c[f] ? (e.componentInstance = c[f].componentInstance, remove$2(d, f), d.push(f)) : (this.vnodeToCache = e, this.keyToCache = f), e.data.keepAlive = true;
    }
    return e || i2 && i2[0];
  }
}, builtInComponents = {
  KeepAlive
};
function initGlobalAPI(i2) {
  var e = {};
  e.get = function() {
    return config;
  }, Object.defineProperty(i2, "config", e), i2.util = {
    warn,
    extend,
    mergeOptions,
    defineReactive
  }, i2.set = set, i2.delete = del, i2.nextTick = nextTick, i2.observable = function(t) {
    return observe(t), t;
  }, i2.options = /* @__PURE__ */ Object.create(null), ASSET_TYPES.forEach(function(t) {
    i2.options[t + "s"] = /* @__PURE__ */ Object.create(null);
  }), i2.options._base = i2, extend(i2.options.components, builtInComponents), initUse(i2), initMixin(i2), initExtend(i2), initAssetRegisters(i2);
}
initGlobalAPI(Vue);
Object.defineProperty(Vue.prototype, "$isServer", {
  get: isServerRendering
});
Object.defineProperty(Vue.prototype, "$ssrContext", {
  get: function() {
    return this.$vnode && this.$vnode.ssrContext;
  }
});
Object.defineProperty(Vue, "FunctionalRenderContext", {
  value: FunctionalRenderContext
});
Vue.version = version;
var isReservedAttr = makeMap("style,class"), acceptValue = makeMap("input,textarea,option,select,progress"), mustUseProp = function(i2, e, t) {
  return t === "value" && acceptValue(i2) && e !== "button" || t === "selected" && i2 === "option" || t === "checked" && i2 === "input" || t === "muted" && i2 === "video";
}, isEnumeratedAttr = makeMap("contenteditable,draggable,spellcheck"), isValidContentEditableValue = makeMap("events,caret,typing,plaintext-only"), convertEnumeratedValue = function(i2, e) {
  return isFalsyAttrValue(e) || e === "false" ? "false" : (
    // allow arbitrary string value for contenteditable
    i2 === "contenteditable" && isValidContentEditableValue(e) ? e : "true"
  );
}, isBooleanAttr = makeMap("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible"), xlinkNS = "http://www.w3.org/1999/xlink", isXlink = function(i2) {
  return i2.charAt(5) === ":" && i2.slice(0, 5) === "xlink";
}, getXlinkProp = function(i2) {
  return isXlink(i2) ? i2.slice(6, i2.length) : "";
}, isFalsyAttrValue = function(i2) {
  return i2 == null || i2 === false;
};
function genClassForVnode(i2) {
  for (var e = i2.data, t = i2, r = i2; isDef(r.componentInstance); )
    r = r.componentInstance._vnode, r && r.data && (e = mergeClassData(r.data, e));
  for (; isDef(t = t.parent); )
    t && t.data && (e = mergeClassData(e, t.data));
  return renderClass(e.staticClass, e.class);
}
function mergeClassData(i2, e) {
  return {
    staticClass: concat(i2.staticClass, e.staticClass),
    class: isDef(i2.class) ? [i2.class, e.class] : e.class
  };
}
function renderClass(i2, e) {
  return isDef(i2) || isDef(e) ? concat(i2, stringifyClass(e)) : "";
}
function concat(i2, e) {
  return i2 ? e ? i2 + " " + e : i2 : e || "";
}
function stringifyClass(i2) {
  return Array.isArray(i2) ? stringifyArray(i2) : isObject(i2) ? stringifyObject(i2) : typeof i2 == "string" ? i2 : "";
}
function stringifyArray(i2) {
  for (var e = "", t, r = 0, a = i2.length; r < a; r++)
    isDef(t = stringifyClass(i2[r])) && t !== "" && (e && (e += " "), e += t);
  return e;
}
function stringifyObject(i2) {
  var e = "";
  for (var t in i2)
    i2[t] && (e && (e += " "), e += t);
  return e;
}
var namespaceMap = {
  svg: "http://www.w3.org/2000/svg",
  math: "http://www.w3.org/1998/Math/MathML"
}, isHTMLTag = makeMap("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"), isSVG = makeMap("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view", true), isReservedTag = function(i2) {
  return isHTMLTag(i2) || isSVG(i2);
};
function getTagNamespace(i2) {
  if (isSVG(i2))
    return "svg";
  if (i2 === "math")
    return "math";
}
var unknownElementCache = /* @__PURE__ */ Object.create(null);
function isUnknownElement(i2) {
  if (!inBrowser)
    return true;
  if (isReservedTag(i2))
    return false;
  if (i2 = i2.toLowerCase(), unknownElementCache[i2] != null)
    return unknownElementCache[i2];
  var e = document.createElement(i2);
  return i2.indexOf("-") > -1 ? unknownElementCache[i2] = e.constructor === window.HTMLUnknownElement || e.constructor === window.HTMLElement : unknownElementCache[i2] = /HTMLUnknownElement/.test(e.toString());
}
var isTextInputType = makeMap("text,number,password,search,email,tel,url");
function query(i2) {
  if (typeof i2 == "string") {
    var e = document.querySelector(i2);
    return e || document.createElement("div");
  } else
    return i2;
}
function createElement(i2, e) {
  var t = document.createElement(i2);
  return i2 !== "select" || e.data && e.data.attrs && e.data.attrs.multiple !== void 0 && t.setAttribute("multiple", "multiple"), t;
}
function createElementNS(i2, e) {
  return document.createElementNS(namespaceMap[i2], e);
}
function createTextNode(i2) {
  return document.createTextNode(i2);
}
function createComment(i2) {
  return document.createComment(i2);
}
function insertBefore(i2, e, t) {
  i2.insertBefore(e, t);
}
function removeChild(i2, e) {
  i2.removeChild(e);
}
function appendChild(i2, e) {
  i2.appendChild(e);
}
function parentNode(i2) {
  return i2.parentNode;
}
function nextSibling(i2) {
  return i2.nextSibling;
}
function tagName(i2) {
  return i2.tagName;
}
function setTextContent(i2, e) {
  i2.textContent = e;
}
function setStyleScope(i2, e) {
  i2.setAttribute(e, "");
}
var nodeOps = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  createElement,
  createElementNS,
  createTextNode,
  createComment,
  insertBefore,
  removeChild,
  appendChild,
  parentNode,
  nextSibling,
  tagName,
  setTextContent,
  setStyleScope
}), ref$1 = {
  create: function(i2, e) {
    registerRef(e);
  },
  update: function(i2, e) {
    i2.data.ref !== e.data.ref && (registerRef(i2, true), registerRef(e));
  },
  destroy: function(i2) {
    registerRef(i2, true);
  }
};
function registerRef(i2, e) {
  var t = i2.data.ref;
  if (isDef(t)) {
    var r = i2.context, a = i2.componentInstance || i2.elm, s = e ? null : a, u = e ? void 0 : a;
    if (isFunction(t)) {
      invokeWithErrorHandling(t, r, [s], r, "template ref function");
      return;
    }
    var l = i2.data.refInFor, c = typeof t == "string" || typeof t == "number", d = isRef(t), f = r.$refs;
    if (c || d) {
      if (l) {
        var p = c ? f[t] : t.value;
        e ? isArray(p) && remove$2(p, a) : isArray(p) ? p.includes(a) || p.push(a) : c ? (f[t] = [a], setSetupRef(r, t, f[t])) : t.value = [a];
      } else if (c) {
        if (e && f[t] !== a)
          return;
        f[t] = u, setSetupRef(r, t, s);
      } else if (d) {
        if (e && t.value !== a)
          return;
        t.value = s;
      }
    }
  }
}
function setSetupRef(i2, e, t) {
  var r = i2._setupState;
  r && hasOwn(r, e) && (isRef(r[e]) ? r[e].value = t : r[e] = t);
}
var emptyNode = new VNode("", {}, []), hooks = ["create", "activate", "update", "remove", "destroy"];
function sameVnode(i2, e) {
  return i2.key === e.key && i2.asyncFactory === e.asyncFactory && (i2.tag === e.tag && i2.isComment === e.isComment && isDef(i2.data) === isDef(e.data) && sameInputType(i2, e) || isTrue(i2.isAsyncPlaceholder) && isUndef(e.asyncFactory.error));
}
function sameInputType(i2, e) {
  if (i2.tag !== "input")
    return true;
  var t, r = isDef(t = i2.data) && isDef(t = t.attrs) && t.type, a = isDef(t = e.data) && isDef(t = t.attrs) && t.type;
  return r === a || isTextInputType(r) && isTextInputType(a);
}
function createKeyToOldIdx(i2, e, t) {
  var r, a, s = {};
  for (r = e; r <= t; ++r)
    a = i2[r].key, isDef(a) && (s[a] = r);
  return s;
}
function createPatchFunction(i2) {
  var e, t, r = {}, a = i2.modules, s = i2.nodeOps;
  for (e = 0; e < hooks.length; ++e)
    for (r[hooks[e]] = [], t = 0; t < a.length; ++t)
      isDef(a[t][hooks[e]]) && r[hooks[e]].push(a[t][hooks[e]]);
  function u(q) {
    return new VNode(s.tagName(q).toLowerCase(), {}, [], void 0, q);
  }
  function l(q, z) {
    function D() {
      --D.listeners === 0 && c(q);
    }
    return D.listeners = z, D;
  }
  function c(q) {
    var z = s.parentNode(q);
    isDef(z) && s.removeChild(z, q);
  }
  function d(q, z, D, X, k, I, P) {
    if (isDef(q.elm) && isDef(I) && (q = I[P] = cloneVNode(q)), q.isRootInsert = !k, !f(q, z, D, X)) {
      var G = q.data, W = q.children, V = q.tag;
      isDef(V) ? (q.elm = q.ns ? s.createElementNS(q.ns, V) : s.createElement(V, q), T(q), x(q, W, z), isDef(G) && _(q, z), y(D, q.elm, X)) : isTrue(q.isComment) ? (q.elm = s.createComment(q.text), y(D, q.elm, X)) : (q.elm = s.createTextNode(q.text), y(D, q.elm, X));
    }
  }
  function f(q, z, D, X) {
    var k = q.data;
    if (isDef(k)) {
      var I = isDef(q.componentInstance) && k.keepAlive;
      if (isDef(k = k.hook) && isDef(k = k.init) && k(
        q,
        false
        /* hydrating */
      ), isDef(q.componentInstance))
        return p(q, z), y(D, q.elm, X), isTrue(I) && m(q, z, D, X), true;
    }
  }
  function p(q, z) {
    isDef(q.data.pendingInsert) && (z.push.apply(z, q.data.pendingInsert), q.data.pendingInsert = null), q.elm = q.componentInstance.$el, g(q) ? (_(q, z), T(q)) : (registerRef(q), z.push(q));
  }
  function m(q, z, D, X) {
    for (var k, I = q; I.componentInstance; )
      if (I = I.componentInstance._vnode, isDef(k = I.data) && isDef(k = k.transition)) {
        for (k = 0; k < r.activate.length; ++k)
          r.activate[k](emptyNode, I);
        z.push(I);
        break;
      }
    y(D, q.elm, X);
  }
  function y(q, z, D) {
    isDef(q) && (isDef(D) ? s.parentNode(D) === q && s.insertBefore(q, z, D) : s.appendChild(q, z));
  }
  function x(q, z, D) {
    if (isArray(z))
      for (var X = 0; X < z.length; ++X)
        d(z[X], D, q.elm, null, true, z, X);
    else isPrimitive(q.text) && s.appendChild(q.elm, s.createTextNode(String(q.text)));
  }
  function g(q) {
    for (; q.componentInstance; )
      q = q.componentInstance._vnode;
    return isDef(q.tag);
  }
  function _(q, z) {
    for (var D = 0; D < r.create.length; ++D)
      r.create[D](emptyNode, q);
    e = q.data.hook, isDef(e) && (isDef(e.create) && e.create(emptyNode, q), isDef(e.insert) && z.push(q));
  }
  function T(q) {
    var z;
    if (isDef(z = q.fnScopeId))
      s.setStyleScope(q.elm, z);
    else
      for (var D = q; D; )
        isDef(z = D.context) && isDef(z = z.$options._scopeId) && s.setStyleScope(q.elm, z), D = D.parent;
    isDef(z = activeInstance) && z !== q.context && z !== q.fnContext && isDef(z = z.$options._scopeId) && s.setStyleScope(q.elm, z);
  }
  function E(q, z, D, X, k, I) {
    for (; X <= k; ++X)
      d(D[X], I, q, z, false, D, X);
  }
  function b(q) {
    var z, D, X = q.data;
    if (isDef(X))
      for (isDef(z = X.hook) && isDef(z = z.destroy) && z(q), z = 0; z < r.destroy.length; ++z)
        r.destroy[z](q);
    if (isDef(z = q.children))
      for (D = 0; D < q.children.length; ++D)
        b(q.children[D]);
  }
  function C(q, z, D) {
    for (; z <= D; ++z) {
      var X = q[z];
      isDef(X) && (isDef(X.tag) ? (w(X), b(X)) : c(X.elm));
    }
  }
  function w(q, z) {
    if (isDef(z) || isDef(q.data)) {
      var D, X = r.remove.length + 1;
      for (isDef(z) ? z.listeners += X : z = l(q.elm, X), isDef(D = q.componentInstance) && isDef(D = D._vnode) && isDef(D.data) && w(D, z), D = 0; D < r.remove.length; ++D)
        r.remove[D](q, z);
      isDef(D = q.data.hook) && isDef(D = D.remove) ? D(q, z) : z();
    } else
      c(q.elm);
  }
  function A(q, z, D, X, k) {
    for (var I = 0, P = 0, G = z.length - 1, W = z[0], V = z[G], K = D.length - 1, J = D[0], ae = D[K], re, he, ge, me, Te = !k; I <= G && P <= K; )
      isUndef(W) ? W = z[++I] : isUndef(V) ? V = z[--G] : sameVnode(W, J) ? (F(W, J, X, D, P), W = z[++I], J = D[++P]) : sameVnode(V, ae) ? (F(V, ae, X, D, K), V = z[--G], ae = D[--K]) : sameVnode(W, ae) ? (F(W, ae, X, D, K), Te && s.insertBefore(q, W.elm, s.nextSibling(V.elm)), W = z[++I], ae = D[--K]) : sameVnode(V, J) ? (F(V, J, X, D, P), Te && s.insertBefore(q, V.elm, W.elm), V = z[--G], J = D[++P]) : (isUndef(re) && (re = createKeyToOldIdx(z, I, G)), he = isDef(J.key) ? re[J.key] : S(J, z, I, G), isUndef(he) ? d(J, X, q, W.elm, false, D, P) : (ge = z[he], sameVnode(ge, J) ? (F(ge, J, X, D, P), z[he] = void 0, Te && s.insertBefore(q, ge.elm, W.elm)) : d(J, X, q, W.elm, false, D, P)), J = D[++P]);
    I > G ? (me = isUndef(D[K + 1]) ? null : D[K + 1].elm, E(q, me, D, P, K, X)) : P > K && C(z, I, G);
  }
  function S(q, z, D, X) {
    for (var k = D; k < X; k++) {
      var I = z[k];
      if (isDef(I) && sameVnode(q, I))
        return k;
    }
  }
  function F(q, z, D, X, k, I) {
    if (q !== z) {
      isDef(z.elm) && isDef(X) && (z = X[k] = cloneVNode(z));
      var P = z.elm = q.elm;
      if (isTrue(q.isAsyncPlaceholder)) {
        isDef(z.asyncFactory.resolved) ? B(q.elm, z, D) : z.isAsyncPlaceholder = true;
        return;
      }
      if (isTrue(z.isStatic) && isTrue(q.isStatic) && z.key === q.key && (isTrue(z.isCloned) || isTrue(z.isOnce))) {
        z.componentInstance = q.componentInstance;
        return;
      }
      var G, W = z.data;
      isDef(W) && isDef(G = W.hook) && isDef(G = G.prepatch) && G(q, z);
      var V = q.children, K = z.children;
      if (isDef(W) && g(z)) {
        for (G = 0; G < r.update.length; ++G)
          r.update[G](q, z);
        isDef(G = W.hook) && isDef(G = G.update) && G(q, z);
      }
      isUndef(z.text) ? isDef(V) && isDef(K) ? V !== K && A(P, V, K, D, I) : isDef(K) ? (isDef(q.text) && s.setTextContent(P, ""), E(P, null, K, 0, K.length - 1, D)) : isDef(V) ? C(V, 0, V.length - 1) : isDef(q.text) && s.setTextContent(P, "") : q.text !== z.text && s.setTextContent(P, z.text), isDef(W) && isDef(G = W.hook) && isDef(G = G.postpatch) && G(q, z);
    }
  }
  function M(q, z, D) {
    if (isTrue(D) && isDef(q.parent))
      q.parent.data.pendingInsert = z;
    else
      for (var X = 0; X < z.length; ++X)
        z[X].data.hook.insert(z[X]);
  }
  var U = makeMap("attrs,class,staticClass,staticStyle,key");
  function B(q, z, D, X) {
    var k, I = z.tag, P = z.data, G = z.children;
    if (X = X || P && P.pre, z.elm = q, isTrue(z.isComment) && isDef(z.asyncFactory))
      return z.isAsyncPlaceholder = true, true;
    if (isDef(P) && (isDef(k = P.hook) && isDef(k = k.init) && k(
      z,
      true
      /* hydrating */
    ), isDef(k = z.componentInstance)))
      return p(z, D), true;
    if (isDef(I)) {
      if (isDef(G))
        if (!q.hasChildNodes())
          x(z, G, D);
        else if (isDef(k = P) && isDef(k = k.domProps) && isDef(k = k.innerHTML)) {
          if (k !== q.innerHTML)
            return false;
        } else {
          for (var W = true, V = q.firstChild, K = 0; K < G.length; K++) {
            if (!V || !B(V, G[K], D, X)) {
              W = false;
              break;
            }
            V = V.nextSibling;
          }
          if (!W || V)
            return false;
        }
      if (isDef(P)) {
        var J = false;
        for (var ae in P)
          if (!U(ae)) {
            J = true, _(z, D);
            break;
          }
        !J && P.class && traverse(P.class);
      }
    } else q.data !== z.text && (q.data = z.text);
    return true;
  }
  return function(q, z, D, X) {
    if (isUndef(z)) {
      isDef(q) && b(q);
      return;
    }
    var k = false, I = [];
    if (isUndef(q))
      k = true, d(z, I);
    else {
      var P = isDef(q.nodeType);
      if (!P && sameVnode(q, z))
        F(q, z, I, null, null, X);
      else {
        if (P) {
          if (q.nodeType === 1 && q.hasAttribute(SSR_ATTR) && (q.removeAttribute(SSR_ATTR), D = true), isTrue(D) && B(q, z, I))
            return M(z, I, true), q;
          q = u(q);
        }
        var G = q.elm, W = s.parentNode(G);
        if (d(
          z,
          I,
          // extremely rare edge case: do not insert if old element is in a
          // leaving transition. Only happens when combining transition +
          // keep-alive + HOCs. (#4590)
          G._leaveCb ? null : W,
          s.nextSibling(G)
        ), isDef(z.parent))
          for (var V = z.parent, K = g(z); V; ) {
            for (var J = 0; J < r.destroy.length; ++J)
              r.destroy[J](V);
            if (V.elm = z.elm, K) {
              for (var ae = 0; ae < r.create.length; ++ae)
                r.create[ae](emptyNode, V);
              var re = V.data.hook.insert;
              if (re.merged)
                for (var he = re.fns.slice(1), ge = 0; ge < he.length; ge++)
                  he[ge]();
            } else
              registerRef(V);
            V = V.parent;
          }
        isDef(W) ? C([q], 0, 0) : isDef(q.tag) && b(q);
      }
    }
    return M(z, I, k), z.elm;
  };
}
var directives = {
  create: updateDirectives,
  update: updateDirectives,
  destroy: function(i2) {
    updateDirectives(i2, emptyNode);
  }
};
function updateDirectives(i2, e) {
  (i2.data.directives || e.data.directives) && _update(i2, e);
}
function _update(i2, e) {
  var t = i2 === emptyNode, r = e === emptyNode, a = normalizeDirectives(i2.data.directives, i2.context), s = normalizeDirectives(e.data.directives, e.context), u = [], l = [], c, d, f;
  for (c in s)
    d = a[c], f = s[c], d ? (f.oldValue = d.value, f.oldArg = d.arg, callHook(f, "update", e, i2), f.def && f.def.componentUpdated && l.push(f)) : (callHook(f, "bind", e, i2), f.def && f.def.inserted && u.push(f));
  if (u.length) {
    var p = function() {
      for (var m = 0; m < u.length; m++)
        callHook(u[m], "inserted", e, i2);
    };
    t ? mergeVNodeHook(e, "insert", p) : p();
  }
  if (l.length && mergeVNodeHook(e, "postpatch", function() {
    for (var m = 0; m < l.length; m++)
      callHook(l[m], "componentUpdated", e, i2);
  }), !t)
    for (c in a)
      s[c] || callHook(a[c], "unbind", i2, i2, r);
}
var emptyModifiers = /* @__PURE__ */ Object.create(null);
function normalizeDirectives(i2, e) {
  var t = /* @__PURE__ */ Object.create(null);
  if (!i2)
    return t;
  var r, a;
  for (r = 0; r < i2.length; r++) {
    if (a = i2[r], a.modifiers || (a.modifiers = emptyModifiers), t[getRawDirName(a)] = a, e._setupState && e._setupState.__sfc) {
      var s = a.def || resolveAsset(e, "_setupState", "v-" + a.name);
      typeof s == "function" ? a.def = {
        bind: s,
        update: s
      } : a.def = s;
    }
    a.def = a.def || resolveAsset(e.$options, "directives", a.name);
  }
  return t;
}
function getRawDirName(i2) {
  return i2.rawName || "".concat(i2.name, ".").concat(Object.keys(i2.modifiers || {}).join("."));
}
function callHook(i2, e, t, r, a) {
  var s = i2.def && i2.def[e];
  if (s)
    try {
      s(t.elm, i2, t, r, a);
    } catch (u) {
      handleError(u, t.context, "directive ".concat(i2.name, " ").concat(e, " hook"));
    }
}
var baseModules = [ref$1, directives];
function updateAttrs(i2, e) {
  var t = e.componentOptions;
  if (!(isDef(t) && t.Ctor.options.inheritAttrs === false) && !(isUndef(i2.data.attrs) && isUndef(e.data.attrs))) {
    var r, a, s, u = e.elm, l = i2.data.attrs || {}, c = e.data.attrs || {};
    (isDef(c.__ob__) || isTrue(c._v_attr_proxy)) && (c = e.data.attrs = extend({}, c));
    for (r in c)
      a = c[r], s = l[r], s !== a && setAttr(u, r, a, e.data.pre);
    (isIE || isEdge) && c.value !== l.value && setAttr(u, "value", c.value);
    for (r in l)
      isUndef(c[r]) && (isXlink(r) ? u.removeAttributeNS(xlinkNS, getXlinkProp(r)) : isEnumeratedAttr(r) || u.removeAttribute(r));
  }
}
function setAttr(i2, e, t, r) {
  r || i2.tagName.indexOf("-") > -1 ? baseSetAttr(i2, e, t) : isBooleanAttr(e) ? isFalsyAttrValue(t) ? i2.removeAttribute(e) : (t = e === "allowfullscreen" && i2.tagName === "EMBED" ? "true" : e, i2.setAttribute(e, t)) : isEnumeratedAttr(e) ? i2.setAttribute(e, convertEnumeratedValue(e, t)) : isXlink(e) ? isFalsyAttrValue(t) ? i2.removeAttributeNS(xlinkNS, getXlinkProp(e)) : i2.setAttributeNS(xlinkNS, e, t) : baseSetAttr(i2, e, t);
}
function baseSetAttr(i2, e, t) {
  if (isFalsyAttrValue(t))
    i2.removeAttribute(e);
  else {
    if (isIE && !isIE9 && i2.tagName === "TEXTAREA" && e === "placeholder" && t !== "" && !i2.__ieph) {
      var r = function(a) {
        a.stopImmediatePropagation(), i2.removeEventListener("input", r);
      };
      i2.addEventListener("input", r), i2.__ieph = true;
    }
    i2.setAttribute(e, t);
  }
}
var attrs = {
  create: updateAttrs,
  update: updateAttrs
};
function updateClass(i2, e) {
  var t = e.elm, r = e.data, a = i2.data;
  if (!(isUndef(r.staticClass) && isUndef(r.class) && (isUndef(a) || isUndef(a.staticClass) && isUndef(a.class)))) {
    var s = genClassForVnode(e), u = t._transitionClasses;
    isDef(u) && (s = concat(s, stringifyClass(u))), s !== t._prevClass && (t.setAttribute("class", s), t._prevClass = s);
  }
}
var klass = {
  create: updateClass,
  update: updateClass
}, RANGE_TOKEN = "__r", CHECKBOX_RADIO_TOKEN = "__c";
function normalizeEvents(i2) {
  if (isDef(i2[RANGE_TOKEN])) {
    var e = isIE ? "change" : "input";
    i2[e] = [].concat(i2[RANGE_TOKEN], i2[e] || []), delete i2[RANGE_TOKEN];
  }
  isDef(i2[CHECKBOX_RADIO_TOKEN]) && (i2.change = [].concat(i2[CHECKBOX_RADIO_TOKEN], i2.change || []), delete i2[CHECKBOX_RADIO_TOKEN]);
}
var target;
function createOnceHandler(i2, e, t) {
  var r = target;
  return function a() {
    var s = e.apply(null, arguments);
    s !== null && remove(i2, a, t, r);
  };
}
var useMicrotaskFix = isUsingMicroTask && !(isFF && Number(isFF[1]) <= 53);
function add(i2, e, t, r) {
  if (useMicrotaskFix) {
    var a = currentFlushTimestamp, s = e;
    e = s._wrapper = function(u) {
      if (
        // no bubbling, should always fire.
        // this is just a safety net in case event.timeStamp is unreliable in
        // certain weird environments...
        u.target === u.currentTarget || // event is fired after handler attachment
        u.timeStamp >= a || // bail for environments that have buggy event.timeStamp implementations
        // #9462 iOS 9 bug: event.timeStamp is 0 after history.pushState
        // #9681 QtWebEngine event.timeStamp is negative value
        u.timeStamp <= 0 || // #9448 bail if event is fired in another document in a multi-page
        // electron/nw.js app, since event.timeStamp will be using a different
        // starting reference
        u.target.ownerDocument !== document
      )
        return s.apply(this, arguments);
    };
  }
  target.addEventListener(i2, e, supportsPassive ? { capture: t, passive: r } : t);
}
function remove(i2, e, t, r) {
  (r || target).removeEventListener(
    i2,
    //@ts-expect-error
    e._wrapper || e,
    t
  );
}
function updateDOMListeners(i2, e) {
  if (!(isUndef(i2.data.on) && isUndef(e.data.on))) {
    var t = e.data.on || {}, r = i2.data.on || {};
    target = e.elm || i2.elm, normalizeEvents(t), updateListeners(t, r, add, remove, createOnceHandler, e.context), target = void 0;
  }
}
var events$1 = {
  create: updateDOMListeners,
  update: updateDOMListeners,
  // @ts-expect-error emptyNode has actually data
  destroy: function(i2) {
    return updateDOMListeners(i2, emptyNode);
  }
}, svgContainer;
function updateDOMProps(i2, e) {
  if (!(isUndef(i2.data.domProps) && isUndef(e.data.domProps))) {
    var t, r, a = e.elm, s = i2.data.domProps || {}, u = e.data.domProps || {};
    (isDef(u.__ob__) || isTrue(u._v_attr_proxy)) && (u = e.data.domProps = extend({}, u));
    for (t in s)
      t in u || (a[t] = "");
    for (t in u) {
      if (r = u[t], t === "textContent" || t === "innerHTML") {
        if (e.children && (e.children.length = 0), r === s[t])
          continue;
        a.childNodes.length === 1 && a.removeChild(a.childNodes[0]);
      }
      if (t === "value" && a.tagName !== "PROGRESS") {
        a._value = r;
        var l = isUndef(r) ? "" : String(r);
        shouldUpdateValue(a, l) && (a.value = l);
      } else if (t === "innerHTML" && isSVG(a.tagName) && isUndef(a.innerHTML)) {
        svgContainer = svgContainer || document.createElement("div"), svgContainer.innerHTML = "<svg>".concat(r, "</svg>");
        for (var c = svgContainer.firstChild; a.firstChild; )
          a.removeChild(a.firstChild);
        for (; c.firstChild; )
          a.appendChild(c.firstChild);
      } else if (
        // skip the update if old and new VDOM state is the same.
        // `value` is handled separately because the DOM value may be temporarily
        // out of sync with VDOM state due to focus, composition and modifiers.
        // This  #4521 by skipping the unnecessary `checked` update.
        r !== s[t]
      )
        try {
          a[t] = r;
        } catch {
        }
    }
  }
}
function shouldUpdateValue(i2, e) {
  return (
    //@ts-expect-error
    !i2.composing && (i2.tagName === "OPTION" || isNotInFocusAndDirty(i2, e) || isDirtyWithModifiers(i2, e))
  );
}
function isNotInFocusAndDirty(i2, e) {
  var t = true;
  try {
    t = document.activeElement !== i2;
  } catch {
  }
  return t && i2.value !== e;
}
function isDirtyWithModifiers(i2, e) {
  var t = i2.value, r = i2._vModifiers;
  if (isDef(r)) {
    if (r.number)
      return toNumber$1(t) !== toNumber$1(e);
    if (r.trim)
      return t.trim() !== e.trim();
  }
  return t !== e;
}
var domProps = {
  create: updateDOMProps,
  update: updateDOMProps
}, parseStyleText = cached(function(i2) {
  var e = {}, t = /;(?![^(]*\))/g, r = /:(.+)/;
  return i2.split(t).forEach(function(a) {
    if (a) {
      var s = a.split(r);
      s.length > 1 && (e[s[0].trim()] = s[1].trim());
    }
  }), e;
});
function normalizeStyleData(i2) {
  var e = normalizeStyleBinding(i2.style);
  return i2.staticStyle ? extend(i2.staticStyle, e) : e;
}
function normalizeStyleBinding(i2) {
  return Array.isArray(i2) ? toObject(i2) : typeof i2 == "string" ? parseStyleText(i2) : i2;
}
function getStyle(i2, e) {
  for (var t = {}, r, a = i2; a.componentInstance; )
    a = a.componentInstance._vnode, a && a.data && (r = normalizeStyleData(a.data)) && extend(t, r);
  (r = normalizeStyleData(i2.data)) && extend(t, r);
  for (var s = i2; s = s.parent; )
    s.data && (r = normalizeStyleData(s.data)) && extend(t, r);
  return t;
}
var cssVarRE = /^--/, importantRE = /\s*!important$/, setProp = function(i2, e, t) {
  if (cssVarRE.test(e))
    i2.style.setProperty(e, t);
  else if (importantRE.test(t))
    i2.style.setProperty(hyphenate(e), t.replace(importantRE, ""), "important");
  else {
    var r = normalize(e);
    if (Array.isArray(t))
      for (var a = 0, s = t.length; a < s; a++)
        i2.style[r] = t[a];
    else
      i2.style[r] = t;
  }
}, vendorNames = ["Webkit", "Moz", "ms"], emptyStyle, normalize = cached(function(i2) {
  if (emptyStyle = emptyStyle || document.createElement("div").style, i2 = camelize(i2), i2 !== "filter" && i2 in emptyStyle)
    return i2;
  for (var e = i2.charAt(0).toUpperCase() + i2.slice(1), t = 0; t < vendorNames.length; t++) {
    var r = vendorNames[t] + e;
    if (r in emptyStyle)
      return r;
  }
});
function updateStyle(i2, e) {
  var t = e.data, r = i2.data;
  if (!(isUndef(t.staticStyle) && isUndef(t.style) && isUndef(r.staticStyle) && isUndef(r.style))) {
    var a, s, u = e.elm, l = r.staticStyle, c = r.normalizedStyle || r.style || {}, d = l || c, f = normalizeStyleBinding(e.data.style) || {};
    e.data.normalizedStyle = isDef(f.__ob__) ? extend({}, f) : f;
    var p = getStyle(e);
    for (s in d)
      isUndef(p[s]) && setProp(u, s, "");
    for (s in p)
      a = p[s], setProp(u, s, a ?? "");
  }
}
var style = {
  create: updateStyle,
  update: updateStyle
}, whitespaceRE = /\s+/;
function addClass(i2, e) {
  if (!(!e || !(e = e.trim())))
    if (i2.classList)
      e.indexOf(" ") > -1 ? e.split(whitespaceRE).forEach(function(r) {
        return i2.classList.add(r);
      }) : i2.classList.add(e);
    else {
      var t = " ".concat(i2.getAttribute("class") || "", " ");
      t.indexOf(" " + e + " ") < 0 && i2.setAttribute("class", (t + e).trim());
    }
}
function removeClass(i2, e) {
  if (!(!e || !(e = e.trim())))
    if (i2.classList)
      e.indexOf(" ") > -1 ? e.split(whitespaceRE).forEach(function(a) {
        return i2.classList.remove(a);
      }) : i2.classList.remove(e), i2.classList.length || i2.removeAttribute("class");
    else {
      for (var t = " ".concat(i2.getAttribute("class") || "", " "), r = " " + e + " "; t.indexOf(r) >= 0; )
        t = t.replace(r, " ");
      t = t.trim(), t ? i2.setAttribute("class", t) : i2.removeAttribute("class");
    }
}
function resolveTransition(i2) {
  if (i2) {
    if (typeof i2 == "object") {
      var e = {};
      return i2.css !== false && extend(e, autoCssTransition(i2.name || "v")), extend(e, i2), e;
    } else if (typeof i2 == "string")
      return autoCssTransition(i2);
  }
}
var autoCssTransition = cached(function(i2) {
  return {
    enterClass: "".concat(i2, "-enter"),
    enterToClass: "".concat(i2, "-enter-to"),
    enterActiveClass: "".concat(i2, "-enter-active"),
    leaveClass: "".concat(i2, "-leave"),
    leaveToClass: "".concat(i2, "-leave-to"),
    leaveActiveClass: "".concat(i2, "-leave-active")
  };
}), hasTransition = inBrowser && !isIE9, TRANSITION = "transition", ANIMATION = "animation", transitionProp = "transition", transitionEndEvent = "transitionend", animationProp = "animation", animationEndEvent = "animationend";
hasTransition && (window.ontransitionend === void 0 && window.onwebkittransitionend !== void 0 && (transitionProp = "WebkitTransition", transitionEndEvent = "webkitTransitionEnd"), window.onanimationend === void 0 && window.onwebkitanimationend !== void 0 && (animationProp = "WebkitAnimation", animationEndEvent = "webkitAnimationEnd"));
var raf = inBrowser ? window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : setTimeout : (
  /* istanbul ignore next */
  function(i2) {
    return i2();
  }
);
function nextFrame(i2) {
  raf(function() {
    raf(i2);
  });
}
function addTransitionClass(i2, e) {
  var t = i2._transitionClasses || (i2._transitionClasses = []);
  t.indexOf(e) < 0 && (t.push(e), addClass(i2, e));
}
function removeTransitionClass(i2, e) {
  i2._transitionClasses && remove$2(i2._transitionClasses, e), removeClass(i2, e);
}
function whenTransitionEnds(i2, e, t) {
  var r = getTransitionInfo(i2, e), a = r.type, s = r.timeout, u = r.propCount;
  if (!a)
    return t();
  var l = a === TRANSITION ? transitionEndEvent : animationEndEvent, c = 0, d = function() {
    i2.removeEventListener(l, f), t();
  }, f = function(p) {
    p.target === i2 && ++c >= u && d();
  };
  setTimeout(function() {
    c < u && d();
  }, s + 1), i2.addEventListener(l, f);
}
var transformRE = /\b(transform|all)(,|$)/;
function getTransitionInfo(i2, e) {
  var t = window.getComputedStyle(i2), r = (t[transitionProp + "Delay"] || "").split(", "), a = (t[transitionProp + "Duration"] || "").split(", "), s = getTimeout(r, a), u = (t[animationProp + "Delay"] || "").split(", "), l = (t[animationProp + "Duration"] || "").split(", "), c = getTimeout(u, l), d, f = 0, p = 0;
  e === TRANSITION ? s > 0 && (d = TRANSITION, f = s, p = a.length) : e === ANIMATION ? c > 0 && (d = ANIMATION, f = c, p = l.length) : (f = Math.max(s, c), d = f > 0 ? s > c ? TRANSITION : ANIMATION : null, p = d ? d === TRANSITION ? a.length : l.length : 0);
  var m = d === TRANSITION && transformRE.test(t[transitionProp + "Property"]);
  return {
    type: d,
    timeout: f,
    propCount: p,
    hasTransform: m
  };
}
function getTimeout(i2, e) {
  for (; i2.length < e.length; )
    i2 = i2.concat(i2);
  return Math.max.apply(null, e.map(function(t, r) {
    return toMs(t) + toMs(i2[r]);
  }));
}
function toMs(i2) {
  return Number(i2.slice(0, -1).replace(",", ".")) * 1e3;
}
function enter(i2, e) {
  var t = i2.elm;
  isDef(t._leaveCb) && (t._leaveCb.cancelled = true, t._leaveCb());
  var r = resolveTransition(i2.data.transition);
  if (!isUndef(r) && !(isDef(t._enterCb) || t.nodeType !== 1)) {
    for (var a = r.css, s = r.type, u = r.enterClass, l = r.enterToClass, c = r.enterActiveClass, d = r.appearClass, f = r.appearToClass, p = r.appearActiveClass, m = r.beforeEnter, y = r.enter, x = r.afterEnter, g = r.enterCancelled, _ = r.beforeAppear, T = r.appear, E = r.afterAppear, b = r.appearCancelled, C = r.duration, w = activeInstance, A = activeInstance.$vnode; A && A.parent; )
      w = A.context, A = A.parent;
    var S = !w._isMounted || !i2.isRootInsert;
    if (!(S && !T && T !== "")) {
      var F = S && d ? d : u, M = S && p ? p : c, U = S && f ? f : l, B = S && _ || m, q = S && isFunction(T) ? T : y, z = S && E || x, D = S && b || g, X = toNumber$1(isObject(C) ? C.enter : C), k = a !== false && !isIE9, I = getHookArgumentsLength(q), P = t._enterCb = once$1(function() {
        k && (removeTransitionClass(t, U), removeTransitionClass(t, M)), P.cancelled ? (k && removeTransitionClass(t, F), D && D(t)) : z && z(t), t._enterCb = null;
      });
      i2.data.show || mergeVNodeHook(i2, "insert", function() {
        var G = t.parentNode, W = G && G._pending && G._pending[i2.key];
        W && W.tag === i2.tag && W.elm._leaveCb && W.elm._leaveCb(), q && q(t, P);
      }), B && B(t), k && (addTransitionClass(t, F), addTransitionClass(t, M), nextFrame(function() {
        removeTransitionClass(t, F), P.cancelled || (addTransitionClass(t, U), I || (isValidDuration(X) ? setTimeout(P, X) : whenTransitionEnds(t, s, P)));
      })), i2.data.show && (e && e(), q && q(t, P)), !k && !I && P();
    }
  }
}
function leave(i2, e) {
  var t = i2.elm;
  isDef(t._enterCb) && (t._enterCb.cancelled = true, t._enterCb());
  var r = resolveTransition(i2.data.transition);
  if (isUndef(r) || t.nodeType !== 1)
    return e();
  if (isDef(t._leaveCb))
    return;
  var a = r.css, s = r.type, u = r.leaveClass, l = r.leaveToClass, c = r.leaveActiveClass, d = r.beforeLeave, f = r.leave, p = r.afterLeave, m = r.leaveCancelled, y = r.delayLeave, x = r.duration, g = a !== false && !isIE9, _ = getHookArgumentsLength(f), T = toNumber$1(isObject(x) ? x.leave : x), E = t._leaveCb = once$1(function() {
    t.parentNode && t.parentNode._pending && (t.parentNode._pending[i2.key] = null), g && (removeTransitionClass(t, l), removeTransitionClass(t, c)), E.cancelled ? (g && removeTransitionClass(t, u), m && m(t)) : (e(), p && p(t)), t._leaveCb = null;
  });
  y ? y(b) : b();
  function b() {
    E.cancelled || (!i2.data.show && t.parentNode && ((t.parentNode._pending || (t.parentNode._pending = {}))[i2.key] = i2), d && d(t), g && (addTransitionClass(t, u), addTransitionClass(t, c), nextFrame(function() {
      removeTransitionClass(t, u), E.cancelled || (addTransitionClass(t, l), _ || (isValidDuration(T) ? setTimeout(E, T) : whenTransitionEnds(t, s, E)));
    })), f && f(t, E), !g && !_ && E());
  }
}
function isValidDuration(i2) {
  return typeof i2 == "number" && !isNaN(i2);
}
function getHookArgumentsLength(i2) {
  if (isUndef(i2))
    return false;
  var e = i2.fns;
  return isDef(e) ? getHookArgumentsLength(Array.isArray(e) ? e[0] : e) : (i2._length || i2.length) > 1;
}
function _enter(i2, e) {
  e.data.show !== true && enter(e);
}
var transition$1 = inBrowser ? {
  create: _enter,
  activate: _enter,
  remove: function(i2, e) {
    i2.data.show !== true ? leave(i2, e) : e();
  }
} : {}, platformModules = [attrs, klass, events$1, domProps, style, transition$1], modules = platformModules.concat(baseModules), patch = createPatchFunction({ nodeOps, modules });
isIE9 && document.addEventListener("selectionchange", function() {
  var i2 = document.activeElement;
  i2 && i2.vmodel && trigger(i2, "input");
});
var directive = {
  inserted: function(i2, e, t, r) {
    t.tag === "select" ? (r.elm && !r.elm._vOptions ? mergeVNodeHook(t, "postpatch", function() {
      directive.componentUpdated(i2, e, t);
    }) : setSelected(i2, e, t.context), i2._vOptions = [].map.call(i2.options, getValue)) : (t.tag === "textarea" || isTextInputType(i2.type)) && (i2._vModifiers = e.modifiers, e.modifiers.lazy || (i2.addEventListener("compositionstart", onCompositionStart), i2.addEventListener("compositionend", onCompositionEnd), i2.addEventListener("change", onCompositionEnd), isIE9 && (i2.vmodel = true)));
  },
  componentUpdated: function(i2, e, t) {
    if (t.tag === "select") {
      setSelected(i2, e, t.context);
      var r = i2._vOptions, a = i2._vOptions = [].map.call(i2.options, getValue);
      if (a.some(function(u, l) {
        return !looseEqual(u, r[l]);
      })) {
        var s = i2.multiple ? e.value.some(function(u) {
          return hasNoMatchingOption(u, a);
        }) : e.value !== e.oldValue && hasNoMatchingOption(e.value, a);
        s && trigger(i2, "change");
      }
    }
  }
};
function setSelected(i2, e, t) {
  actuallySetSelected(i2, e), (isIE || isEdge) && setTimeout(function() {
    actuallySetSelected(i2, e);
  }, 0);
}
function actuallySetSelected(i2, e, t) {
  var r = e.value, a = i2.multiple;
  if (!(a && !Array.isArray(r))) {
    for (var s, u, l = 0, c = i2.options.length; l < c; l++)
      if (u = i2.options[l], a)
        s = looseIndexOf(r, getValue(u)) > -1, u.selected !== s && (u.selected = s);
      else if (looseEqual(getValue(u), r)) {
        i2.selectedIndex !== l && (i2.selectedIndex = l);
        return;
      }
    a || (i2.selectedIndex = -1);
  }
}
function hasNoMatchingOption(i2, e) {
  return e.every(function(t) {
    return !looseEqual(t, i2);
  });
}
function getValue(i2) {
  return "_value" in i2 ? i2._value : i2.value;
}
function onCompositionStart(i2) {
  i2.target.composing = true;
}
function onCompositionEnd(i2) {
  i2.target.composing && (i2.target.composing = false, trigger(i2.target, "input"));
}
function trigger(i2, e) {
  var t = document.createEvent("HTMLEvents");
  t.initEvent(e, true, true), i2.dispatchEvent(t);
}
function locateNode(i2) {
  return i2.componentInstance && (!i2.data || !i2.data.transition) ? locateNode(i2.componentInstance._vnode) : i2;
}
var show = {
  bind: function(i2, e, t) {
    var r = e.value;
    t = locateNode(t);
    var a = t.data && t.data.transition, s = i2.__vOriginalDisplay = i2.style.display === "none" ? "" : i2.style.display;
    r && a ? (t.data.show = true, enter(t, function() {
      i2.style.display = s;
    })) : i2.style.display = r ? s : "none";
  },
  update: function(i2, e, t) {
    var r = e.value, a = e.oldValue;
    if (!r != !a) {
      t = locateNode(t);
      var s = t.data && t.data.transition;
      s ? (t.data.show = true, r ? enter(t, function() {
        i2.style.display = i2.__vOriginalDisplay;
      }) : leave(t, function() {
        i2.style.display = "none";
      })) : i2.style.display = r ? i2.__vOriginalDisplay : "none";
    }
  },
  unbind: function(i2, e, t, r, a) {
    a || (i2.style.display = i2.__vOriginalDisplay);
  }
}, platformDirectives = {
  model: directive,
  show
}, transitionProps = {
  name: String,
  appear: Boolean,
  css: Boolean,
  mode: String,
  type: String,
  enterClass: String,
  leaveClass: String,
  enterToClass: String,
  leaveToClass: String,
  enterActiveClass: String,
  leaveActiveClass: String,
  appearClass: String,
  appearActiveClass: String,
  appearToClass: String,
  duration: [Number, String, Object]
};
function getRealChild(i2) {
  var e = i2 && i2.componentOptions;
  return e && e.Ctor.options.abstract ? getRealChild(getFirstComponentChild(e.children)) : i2;
}
function extractTransitionData(i2) {
  var e = {}, t = i2.$options;
  for (var r in t.propsData)
    e[r] = i2[r];
  var a = t._parentListeners;
  for (var r in a)
    e[camelize(r)] = a[r];
  return e;
}
function placeholder(i2, e) {
  if (/\d-keep-alive$/.test(e.tag))
    return i2("keep-alive", {
      props: e.componentOptions.propsData
    });
}
function hasParentTransition(i2) {
  for (; i2 = i2.parent; )
    if (i2.data.transition)
      return true;
}
function isSameChild(i2, e) {
  return e.key === i2.key && e.tag === i2.tag;
}
var isNotTextNode = function(i2) {
  return i2.tag || isAsyncPlaceholder(i2);
}, isVShowDirective = function(i2) {
  return i2.name === "show";
}, Transition = {
  name: "transition",
  props: transitionProps,
  abstract: true,
  render: function(i2) {
    var e = this, t = this.$slots.default;
    if (t && (t = t.filter(isNotTextNode), !!t.length)) {
      var r = this.mode, a = t[0];
      if (hasParentTransition(this.$vnode))
        return a;
      var s = getRealChild(a);
      if (!s)
        return a;
      if (this._leaving)
        return placeholder(i2, a);
      var u = "__transition-".concat(this._uid, "-");
      s.key = s.key == null ? s.isComment ? u + "comment" : u + s.tag : isPrimitive(s.key) ? String(s.key).indexOf(u) === 0 ? s.key : u + s.key : s.key;
      var l = (s.data || (s.data = {})).transition = extractTransitionData(this), c = this._vnode, d = getRealChild(c);
      if (s.data.directives && s.data.directives.some(isVShowDirective) && (s.data.show = true), d && d.data && !isSameChild(s, d) && !isAsyncPlaceholder(d) && // #6687 component root is a comment node
      !(d.componentInstance && d.componentInstance._vnode.isComment)) {
        var f = d.data.transition = extend({}, l);
        if (r === "out-in")
          return this._leaving = true, mergeVNodeHook(f, "afterLeave", function() {
            e._leaving = false, e.$forceUpdate();
          }), placeholder(i2, a);
        if (r === "in-out") {
          if (isAsyncPlaceholder(s))
            return c;
          var p, m = function() {
            p();
          };
          mergeVNodeHook(l, "afterEnter", m), mergeVNodeHook(l, "enterCancelled", m), mergeVNodeHook(f, "delayLeave", function(y) {
            p = y;
          });
        }
      }
      return a;
    }
  }
}, props = extend({
  tag: String,
  moveClass: String
}, transitionProps);
delete props.mode;
var TransitionGroup = {
  props,
  beforeMount: function() {
    var i2 = this, e = this._update;
    this._update = function(t, r) {
      var a = setActiveInstance(i2);
      i2.__patch__(
        i2._vnode,
        i2.kept,
        false,
        // hydrating
        true
        // removeOnly (!important, avoids unnecessary moves)
      ), i2._vnode = i2.kept, a(), e.call(i2, t, r);
    };
  },
  render: function(i2) {
    for (var e = this.tag || this.$vnode.data.tag || "span", t = /* @__PURE__ */ Object.create(null), r = this.prevChildren = this.children, a = this.$slots.default || [], s = this.children = [], u = extractTransitionData(this), l = 0; l < a.length; l++) {
      var c = a[l];
      c.tag && c.key != null && String(c.key).indexOf("__vlist") !== 0 && (s.push(c), t[c.key] = c, (c.data || (c.data = {})).transition = u);
    }
    if (r) {
      for (var d = [], f = [], l = 0; l < r.length; l++) {
        var c = r[l];
        c.data.transition = u, c.data.pos = c.elm.getBoundingClientRect(), t[c.key] ? d.push(c) : f.push(c);
      }
      this.kept = i2(e, null, d), this.removed = f;
    }
    return i2(e, null, s);
  },
  updated: function() {
    var i2 = this.prevChildren, e = this.moveClass || (this.name || "v") + "-move";
    !i2.length || !this.hasMove(i2[0].elm, e) || (i2.forEach(callPendingCbs), i2.forEach(recordPosition), i2.forEach(applyTranslation), this._reflow = document.body.offsetHeight, i2.forEach(function(t) {
      if (t.data.moved) {
        var r = t.elm, a = r.style;
        addTransitionClass(r, e), a.transform = a.WebkitTransform = a.transitionDuration = "", r.addEventListener(transitionEndEvent, r._moveCb = function s(u) {
          u && u.target !== r || (!u || /transform$/.test(u.propertyName)) && (r.removeEventListener(transitionEndEvent, s), r._moveCb = null, removeTransitionClass(r, e));
        });
      }
    }));
  },
  methods: {
    hasMove: function(i2, e) {
      if (!hasTransition)
        return false;
      if (this._hasMove)
        return this._hasMove;
      var t = i2.cloneNode();
      i2._transitionClasses && i2._transitionClasses.forEach(function(a) {
        removeClass(t, a);
      }), addClass(t, e), t.style.display = "none", this.$el.appendChild(t);
      var r = getTransitionInfo(t);
      return this.$el.removeChild(t), this._hasMove = r.hasTransform;
    }
  }
};
function callPendingCbs(i2) {
  i2.elm._moveCb && i2.elm._moveCb(), i2.elm._enterCb && i2.elm._enterCb();
}
function recordPosition(i2) {
  i2.data.newPos = i2.elm.getBoundingClientRect();
}
function applyTranslation(i2) {
  var e = i2.data.pos, t = i2.data.newPos, r = e.left - t.left, a = e.top - t.top;
  if (r || a) {
    i2.data.moved = true;
    var s = i2.elm.style;
    s.transform = s.WebkitTransform = "translate(".concat(r, "px,").concat(a, "px)"), s.transitionDuration = "0s";
  }
}
var platformComponents = {
  Transition,
  TransitionGroup
};
Vue.config.mustUseProp = mustUseProp;
Vue.config.isReservedTag = isReservedTag;
Vue.config.isReservedAttr = isReservedAttr;
Vue.config.getTagNamespace = getTagNamespace;
Vue.config.isUnknownElement = isUnknownElement;
extend(Vue.options.directives, platformDirectives);
extend(Vue.options.components, platformComponents);
Vue.prototype.__patch__ = inBrowser ? patch : noop$1;
Vue.prototype.$mount = function(i2, e) {
  return i2 = i2 && inBrowser ? query(i2) : void 0, mountComponent(this, i2, e);
};
inBrowser && setTimeout(function() {
  config.devtools && devtools && devtools.emit("init", Vue);
}, 0);
function _typeof$1(i2) {
  "@babel/helpers - typeof";
  return _typeof$1 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, _typeof$1(i2);
}
var trimLeft = /^\s+/, trimRight = /\s+$/;
function tinycolor(i2, e) {
  if (i2 = i2 || "", e = e || {}, i2 instanceof tinycolor)
    return i2;
  if (!(this instanceof tinycolor))
    return new tinycolor(i2, e);
  var t = inputToRGB(i2);
  this._originalInput = i2, this._r = t.r, this._g = t.g, this._b = t.b, this._a = t.a, this._roundA = Math.round(100 * this._a) / 100, this._format = e.format || t.format, this._gradientType = e.gradientType, this._r < 1 && (this._r = Math.round(this._r)), this._g < 1 && (this._g = Math.round(this._g)), this._b < 1 && (this._b = Math.round(this._b)), this._ok = t.ok;
}
tinycolor.prototype = {
  isDark: function() {
    return this.getBrightness() < 128;
  },
  isLight: function() {
    return !this.isDark();
  },
  isValid: function() {
    return this._ok;
  },
  getOriginalInput: function() {
    return this._originalInput;
  },
  getFormat: function() {
    return this._format;
  },
  getAlpha: function() {
    return this._a;
  },
  getBrightness: function() {
    var i2 = this.toRgb();
    return (i2.r * 299 + i2.g * 587 + i2.b * 114) / 1e3;
  },
  getLuminance: function() {
    var i2 = this.toRgb(), e, t, r, a, s, u;
    return e = i2.r / 255, t = i2.g / 255, r = i2.b / 255, e <= 0.03928 ? a = e / 12.92 : a = Math.pow((e + 0.055) / 1.055, 2.4), t <= 0.03928 ? s = t / 12.92 : s = Math.pow((t + 0.055) / 1.055, 2.4), r <= 0.03928 ? u = r / 12.92 : u = Math.pow((r + 0.055) / 1.055, 2.4), 0.2126 * a + 0.7152 * s + 0.0722 * u;
  },
  setAlpha: function(i2) {
    return this._a = boundAlpha(i2), this._roundA = Math.round(100 * this._a) / 100, this;
  },
  toHsv: function() {
    var i2 = rgbToHsv(this._r, this._g, this._b);
    return {
      h: i2.h * 360,
      s: i2.s,
      v: i2.v,
      a: this._a
    };
  },
  toHsvString: function() {
    var i2 = rgbToHsv(this._r, this._g, this._b), e = Math.round(i2.h * 360), t = Math.round(i2.s * 100), r = Math.round(i2.v * 100);
    return this._a == 1 ? "hsv(" + e + ", " + t + "%, " + r + "%)" : "hsva(" + e + ", " + t + "%, " + r + "%, " + this._roundA + ")";
  },
  toHsl: function() {
    var i2 = rgbToHsl(this._r, this._g, this._b);
    return {
      h: i2.h * 360,
      s: i2.s,
      l: i2.l,
      a: this._a
    };
  },
  toHslString: function() {
    var i2 = rgbToHsl(this._r, this._g, this._b), e = Math.round(i2.h * 360), t = Math.round(i2.s * 100), r = Math.round(i2.l * 100);
    return this._a == 1 ? "hsl(" + e + ", " + t + "%, " + r + "%)" : "hsla(" + e + ", " + t + "%, " + r + "%, " + this._roundA + ")";
  },
  toHex: function(i2) {
    return rgbToHex(this._r, this._g, this._b, i2);
  },
  toHexString: function(i2) {
    return "#" + this.toHex(i2);
  },
  toHex8: function(i2) {
    return rgbaToHex(this._r, this._g, this._b, this._a, i2);
  },
  toHex8String: function(i2) {
    return "#" + this.toHex8(i2);
  },
  toRgb: function() {
    return {
      r: Math.round(this._r),
      g: Math.round(this._g),
      b: Math.round(this._b),
      a: this._a
    };
  },
  toRgbString: function() {
    return this._a == 1 ? "rgb(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ")" : "rgba(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ", " + this._roundA + ")";
  },
  toPercentageRgb: function() {
    return {
      r: Math.round(bound01(this._r, 255) * 100) + "%",
      g: Math.round(bound01(this._g, 255) * 100) + "%",
      b: Math.round(bound01(this._b, 255) * 100) + "%",
      a: this._a
    };
  },
  toPercentageRgbString: function() {
    return this._a == 1 ? "rgb(" + Math.round(bound01(this._r, 255) * 100) + "%, " + Math.round(bound01(this._g, 255) * 100) + "%, " + Math.round(bound01(this._b, 255) * 100) + "%)" : "rgba(" + Math.round(bound01(this._r, 255) * 100) + "%, " + Math.round(bound01(this._g, 255) * 100) + "%, " + Math.round(bound01(this._b, 255) * 100) + "%, " + this._roundA + ")";
  },
  toName: function() {
    return this._a === 0 ? "transparent" : this._a < 1 ? false : hexNames[rgbToHex(this._r, this._g, this._b, true)] || false;
  },
  toFilter: function(i2) {
    var e = "#" + rgbaToArgbHex(this._r, this._g, this._b, this._a), t = e, r = this._gradientType ? "GradientType = 1, " : "";
    if (i2) {
      var a = tinycolor(i2);
      t = "#" + rgbaToArgbHex(a._r, a._g, a._b, a._a);
    }
    return "progid:DXImageTransform.Microsoft.gradient(" + r + "startColorstr=" + e + ",endColorstr=" + t + ")";
  },
  toString: function(i2) {
    var e = !!i2;
    i2 = i2 || this._format;
    var t = false, r = this._a < 1 && this._a >= 0, a = !e && r && (i2 === "hex" || i2 === "hex6" || i2 === "hex3" || i2 === "hex4" || i2 === "hex8" || i2 === "name");
    return a ? i2 === "name" && this._a === 0 ? this.toName() : this.toRgbString() : (i2 === "rgb" && (t = this.toRgbString()), i2 === "prgb" && (t = this.toPercentageRgbString()), (i2 === "hex" || i2 === "hex6") && (t = this.toHexString()), i2 === "hex3" && (t = this.toHexString(true)), i2 === "hex4" && (t = this.toHex8String(true)), i2 === "hex8" && (t = this.toHex8String()), i2 === "name" && (t = this.toName()), i2 === "hsl" && (t = this.toHslString()), i2 === "hsv" && (t = this.toHsvString()), t || this.toHexString());
  },
  clone: function() {
    return tinycolor(this.toString());
  },
  _applyModification: function(i2, e) {
    var t = i2.apply(null, [this].concat([].slice.call(e)));
    return this._r = t._r, this._g = t._g, this._b = t._b, this.setAlpha(t._a), this;
  },
  lighten: function() {
    return this._applyModification(_lighten, arguments);
  },
  brighten: function() {
    return this._applyModification(_brighten, arguments);
  },
  darken: function() {
    return this._applyModification(_darken, arguments);
  },
  desaturate: function() {
    return this._applyModification(_desaturate, arguments);
  },
  saturate: function() {
    return this._applyModification(_saturate, arguments);
  },
  greyscale: function() {
    return this._applyModification(_greyscale, arguments);
  },
  spin: function() {
    return this._applyModification(_spin, arguments);
  },
  _applyCombination: function(i2, e) {
    return i2.apply(null, [this].concat([].slice.call(e)));
  },
  analogous: function() {
    return this._applyCombination(_analogous, arguments);
  },
  complement: function() {
    return this._applyCombination(_complement, arguments);
  },
  monochromatic: function() {
    return this._applyCombination(_monochromatic, arguments);
  },
  splitcomplement: function() {
    return this._applyCombination(_splitcomplement, arguments);
  },
  // Disabled until https://github.com/bgrins/TinyColor/issues/254
  // polyad: function (number) {
  //   return this._applyCombination(polyad, [number]);
  // },
  triad: function() {
    return this._applyCombination(polyad, [3]);
  },
  tetrad: function() {
    return this._applyCombination(polyad, [4]);
  }
};
tinycolor.fromRatio = function(i2, e) {
  if (_typeof$1(i2) == "object") {
    var t = {};
    for (var r in i2)
      i2.hasOwnProperty(r) && (r === "a" ? t[r] = i2[r] : t[r] = convertToPercentage(i2[r]));
    i2 = t;
  }
  return tinycolor(i2, e);
};
function inputToRGB(i2) {
  var e = {
    r: 0,
    g: 0,
    b: 0
  }, t = 1, r = null, a = null, s = null, u = false, l = false;
  return typeof i2 == "string" && (i2 = stringInputToObject(i2)), _typeof$1(i2) == "object" && (isValidCSSUnit(i2.r) && isValidCSSUnit(i2.g) && isValidCSSUnit(i2.b) ? (e = rgbToRgb(i2.r, i2.g, i2.b), u = true, l = String(i2.r).substr(-1) === "%" ? "prgb" : "rgb") : isValidCSSUnit(i2.h) && isValidCSSUnit(i2.s) && isValidCSSUnit(i2.v) ? (r = convertToPercentage(i2.s), a = convertToPercentage(i2.v), e = hsvToRgb(i2.h, r, a), u = true, l = "hsv") : isValidCSSUnit(i2.h) && isValidCSSUnit(i2.s) && isValidCSSUnit(i2.l) && (r = convertToPercentage(i2.s), s = convertToPercentage(i2.l), e = hslToRgb(i2.h, r, s), u = true, l = "hsl"), i2.hasOwnProperty("a") && (t = i2.a)), t = boundAlpha(t), {
    ok: u,
    format: i2.format || l,
    r: Math.min(255, Math.max(e.r, 0)),
    g: Math.min(255, Math.max(e.g, 0)),
    b: Math.min(255, Math.max(e.b, 0)),
    a: t
  };
}
function rgbToRgb(i2, e, t) {
  return {
    r: bound01(i2, 255) * 255,
    g: bound01(e, 255) * 255,
    b: bound01(t, 255) * 255
  };
}
function rgbToHsl(i2, e, t) {
  i2 = bound01(i2, 255), e = bound01(e, 255), t = bound01(t, 255);
  var r = Math.max(i2, e, t), a = Math.min(i2, e, t), s, u, l = (r + a) / 2;
  if (r == a)
    s = u = 0;
  else {
    var c = r - a;
    switch (u = l > 0.5 ? c / (2 - r - a) : c / (r + a), r) {
      case i2:
        s = (e - t) / c + (e < t ? 6 : 0);
        break;
      case e:
        s = (t - i2) / c + 2;
        break;
      case t:
        s = (i2 - e) / c + 4;
        break;
    }
    s /= 6;
  }
  return {
    h: s,
    s: u,
    l
  };
}
function hslToRgb(i2, e, t) {
  var r, a, s;
  i2 = bound01(i2, 360), e = bound01(e, 100), t = bound01(t, 100);
  function u(d, f, p) {
    return p < 0 && (p += 1), p > 1 && (p -= 1), p < 1 / 6 ? d + (f - d) * 6 * p : p < 1 / 2 ? f : p < 2 / 3 ? d + (f - d) * (2 / 3 - p) * 6 : d;
  }
  if (e === 0)
    r = a = s = t;
  else {
    var l = t < 0.5 ? t * (1 + e) : t + e - t * e, c = 2 * t - l;
    r = u(c, l, i2 + 1 / 3), a = u(c, l, i2), s = u(c, l, i2 - 1 / 3);
  }
  return {
    r: r * 255,
    g: a * 255,
    b: s * 255
  };
}
function rgbToHsv(i2, e, t) {
  i2 = bound01(i2, 255), e = bound01(e, 255), t = bound01(t, 255);
  var r = Math.max(i2, e, t), a = Math.min(i2, e, t), s, u, l = r, c = r - a;
  if (u = r === 0 ? 0 : c / r, r == a)
    s = 0;
  else {
    switch (r) {
      case i2:
        s = (e - t) / c + (e < t ? 6 : 0);
        break;
      case e:
        s = (t - i2) / c + 2;
        break;
      case t:
        s = (i2 - e) / c + 4;
        break;
    }
    s /= 6;
  }
  return {
    h: s,
    s: u,
    v: l
  };
}
function hsvToRgb(i2, e, t) {
  i2 = bound01(i2, 360) * 6, e = bound01(e, 100), t = bound01(t, 100);
  var r = Math.floor(i2), a = i2 - r, s = t * (1 - e), u = t * (1 - a * e), l = t * (1 - (1 - a) * e), c = r % 6, d = [t, u, s, s, l, t][c], f = [l, t, t, u, s, s][c], p = [s, s, l, t, t, u][c];
  return {
    r: d * 255,
    g: f * 255,
    b: p * 255
  };
}
function rgbToHex(i2, e, t, r) {
  var a = [pad2(Math.round(i2).toString(16)), pad2(Math.round(e).toString(16)), pad2(Math.round(t).toString(16))];
  return r && a[0].charAt(0) == a[0].charAt(1) && a[1].charAt(0) == a[1].charAt(1) && a[2].charAt(0) == a[2].charAt(1) ? a[0].charAt(0) + a[1].charAt(0) + a[2].charAt(0) : a.join("");
}
function rgbaToHex(i2, e, t, r, a) {
  var s = [pad2(Math.round(i2).toString(16)), pad2(Math.round(e).toString(16)), pad2(Math.round(t).toString(16)), pad2(convertDecimalToHex(r))];
  return a && s[0].charAt(0) == s[0].charAt(1) && s[1].charAt(0) == s[1].charAt(1) && s[2].charAt(0) == s[2].charAt(1) && s[3].charAt(0) == s[3].charAt(1) ? s[0].charAt(0) + s[1].charAt(0) + s[2].charAt(0) + s[3].charAt(0) : s.join("");
}
function rgbaToArgbHex(i2, e, t, r) {
  var a = [pad2(convertDecimalToHex(r)), pad2(Math.round(i2).toString(16)), pad2(Math.round(e).toString(16)), pad2(Math.round(t).toString(16))];
  return a.join("");
}
tinycolor.equals = function(i2, e) {
  return !i2 || !e ? false : tinycolor(i2).toRgbString() == tinycolor(e).toRgbString();
};
tinycolor.random = function() {
  return tinycolor.fromRatio({
    r: Math.random(),
    g: Math.random(),
    b: Math.random()
  });
};
function _desaturate(i2, e) {
  e = e === 0 ? 0 : e || 10;
  var t = tinycolor(i2).toHsl();
  return t.s -= e / 100, t.s = clamp01(t.s), tinycolor(t);
}
function _saturate(i2, e) {
  e = e === 0 ? 0 : e || 10;
  var t = tinycolor(i2).toHsl();
  return t.s += e / 100, t.s = clamp01(t.s), tinycolor(t);
}
function _greyscale(i2) {
  return tinycolor(i2).desaturate(100);
}
function _lighten(i2, e) {
  e = e === 0 ? 0 : e || 10;
  var t = tinycolor(i2).toHsl();
  return t.l += e / 100, t.l = clamp01(t.l), tinycolor(t);
}
function _brighten(i2, e) {
  e = e === 0 ? 0 : e || 10;
  var t = tinycolor(i2).toRgb();
  return t.r = Math.max(0, Math.min(255, t.r - Math.round(255 * -(e / 100)))), t.g = Math.max(0, Math.min(255, t.g - Math.round(255 * -(e / 100)))), t.b = Math.max(0, Math.min(255, t.b - Math.round(255 * -(e / 100)))), tinycolor(t);
}
function _darken(i2, e) {
  e = e === 0 ? 0 : e || 10;
  var t = tinycolor(i2).toHsl();
  return t.l -= e / 100, t.l = clamp01(t.l), tinycolor(t);
}
function _spin(i2, e) {
  var t = tinycolor(i2).toHsl(), r = (t.h + e) % 360;
  return t.h = r < 0 ? 360 + r : r, tinycolor(t);
}
function _complement(i2) {
  var e = tinycolor(i2).toHsl();
  return e.h = (e.h + 180) % 360, tinycolor(e);
}
function polyad(i2, e) {
  if (isNaN(e) || e <= 0)
    throw new Error("Argument to polyad must be a positive number");
  for (var t = tinycolor(i2).toHsl(), r = [tinycolor(i2)], a = 360 / e, s = 1; s < e; s++)
    r.push(tinycolor({
      h: (t.h + s * a) % 360,
      s: t.s,
      l: t.l
    }));
  return r;
}
function _splitcomplement(i2) {
  var e = tinycolor(i2).toHsl(), t = e.h;
  return [tinycolor(i2), tinycolor({
    h: (t + 72) % 360,
    s: e.s,
    l: e.l
  }), tinycolor({
    h: (t + 216) % 360,
    s: e.s,
    l: e.l
  })];
}
function _analogous(i2, e, t) {
  e = e || 6, t = t || 30;
  var r = tinycolor(i2).toHsl(), a = 360 / t, s = [tinycolor(i2)];
  for (r.h = (r.h - (a * e >> 1) + 720) % 360; --e; )
    r.h = (r.h + a) % 360, s.push(tinycolor(r));
  return s;
}
function _monochromatic(i2, e) {
  e = e || 6;
  for (var t = tinycolor(i2).toHsv(), r = t.h, a = t.s, s = t.v, u = [], l = 1 / e; e--; )
    u.push(tinycolor({
      h: r,
      s: a,
      v: s
    })), s = (s + l) % 1;
  return u;
}
tinycolor.mix = function(i2, e, t) {
  t = t === 0 ? 0 : t || 50;
  var r = tinycolor(i2).toRgb(), a = tinycolor(e).toRgb(), s = t / 100, u = {
    r: (a.r - r.r) * s + r.r,
    g: (a.g - r.g) * s + r.g,
    b: (a.b - r.b) * s + r.b,
    a: (a.a - r.a) * s + r.a
  };
  return tinycolor(u);
};
tinycolor.readability = function(i2, e) {
  var t = tinycolor(i2), r = tinycolor(e);
  return (Math.max(t.getLuminance(), r.getLuminance()) + 0.05) / (Math.min(t.getLuminance(), r.getLuminance()) + 0.05);
};
tinycolor.isReadable = function(i2, e, t) {
  var r = tinycolor.readability(i2, e), a, s;
  switch (s = false, a = validateWCAG2Parms(t), a.level + a.size) {
    case "AAsmall":
    case "AAAlarge":
      s = r >= 4.5;
      break;
    case "AAlarge":
      s = r >= 3;
      break;
    case "AAAsmall":
      s = r >= 7;
      break;
  }
  return s;
};
tinycolor.mostReadable = function(i2, e, t) {
  var r = null, a = 0, s, u, l, c;
  t = t || {}, u = t.includeFallbackColors, l = t.level, c = t.size;
  for (var d = 0; d < e.length; d++)
    s = tinycolor.readability(i2, e[d]), s > a && (a = s, r = tinycolor(e[d]));
  return tinycolor.isReadable(i2, r, {
    level: l,
    size: c
  }) || !u ? r : (t.includeFallbackColors = false, tinycolor.mostReadable(i2, ["#fff", "#000"], t));
};
var names = tinycolor.names = {
  aliceblue: "f0f8ff",
  antiquewhite: "faebd7",
  aqua: "0ff",
  aquamarine: "7fffd4",
  azure: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "000",
  blanchedalmond: "ffebcd",
  blue: "00f",
  blueviolet: "8a2be2",
  brown: "a52a2a",
  burlywood: "deb887",
  burntsienna: "ea7e5d",
  cadetblue: "5f9ea0",
  chartreuse: "7fff00",
  chocolate: "d2691e",
  coral: "ff7f50",
  cornflowerblue: "6495ed",
  cornsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "0ff",
  darkblue: "00008b",
  darkcyan: "008b8b",
  darkgoldenrod: "b8860b",
  darkgray: "a9a9a9",
  darkgreen: "006400",
  darkgrey: "a9a9a9",
  darkkhaki: "bdb76b",
  darkmagenta: "8b008b",
  darkolivegreen: "556b2f",
  darkorange: "ff8c00",
  darkorchid: "9932cc",
  darkred: "8b0000",
  darksalmon: "e9967a",
  darkseagreen: "8fbc8f",
  darkslateblue: "483d8b",
  darkslategray: "2f4f4f",
  darkslategrey: "2f4f4f",
  darkturquoise: "00ced1",
  darkviolet: "9400d3",
  deeppink: "ff1493",
  deepskyblue: "00bfff",
  dimgray: "696969",
  dimgrey: "696969",
  dodgerblue: "1e90ff",
  firebrick: "b22222",
  floralwhite: "fffaf0",
  forestgreen: "228b22",
  fuchsia: "f0f",
  gainsboro: "dcdcdc",
  ghostwhite: "f8f8ff",
  gold: "ffd700",
  goldenrod: "daa520",
  gray: "808080",
  green: "008000",
  greenyellow: "adff2f",
  grey: "808080",
  honeydew: "f0fff0",
  hotpink: "ff69b4",
  indianred: "cd5c5c",
  indigo: "4b0082",
  ivory: "fffff0",
  khaki: "f0e68c",
  lavender: "e6e6fa",
  lavenderblush: "fff0f5",
  lawngreen: "7cfc00",
  lemonchiffon: "fffacd",
  lightblue: "add8e6",
  lightcoral: "f08080",
  lightcyan: "e0ffff",
  lightgoldenrodyellow: "fafad2",
  lightgray: "d3d3d3",
  lightgreen: "90ee90",
  lightgrey: "d3d3d3",
  lightpink: "ffb6c1",
  lightsalmon: "ffa07a",
  lightseagreen: "20b2aa",
  lightskyblue: "87cefa",
  lightslategray: "789",
  lightslategrey: "789",
  lightsteelblue: "b0c4de",
  lightyellow: "ffffe0",
  lime: "0f0",
  limegreen: "32cd32",
  linen: "faf0e6",
  magenta: "f0f",
  maroon: "800000",
  mediumaquamarine: "66cdaa",
  mediumblue: "0000cd",
  mediumorchid: "ba55d3",
  mediumpurple: "9370db",
  mediumseagreen: "3cb371",
  mediumslateblue: "7b68ee",
  mediumspringgreen: "00fa9a",
  mediumturquoise: "48d1cc",
  mediumvioletred: "c71585",
  midnightblue: "191970",
  mintcream: "f5fffa",
  mistyrose: "ffe4e1",
  moccasin: "ffe4b5",
  navajowhite: "ffdead",
  navy: "000080",
  oldlace: "fdf5e6",
  olive: "808000",
  olivedrab: "6b8e23",
  orange: "ffa500",
  orangered: "ff4500",
  orchid: "da70d6",
  palegoldenrod: "eee8aa",
  palegreen: "98fb98",
  paleturquoise: "afeeee",
  palevioletred: "db7093",
  papayawhip: "ffefd5",
  peachpuff: "ffdab9",
  peru: "cd853f",
  pink: "ffc0cb",
  plum: "dda0dd",
  powderblue: "b0e0e6",
  purple: "800080",
  rebeccapurple: "663399",
  red: "f00",
  rosybrown: "bc8f8f",
  royalblue: "4169e1",
  saddlebrown: "8b4513",
  salmon: "fa8072",
  sandybrown: "f4a460",
  seagreen: "2e8b57",
  seashell: "fff5ee",
  sienna: "a0522d",
  silver: "c0c0c0",
  skyblue: "87ceeb",
  slateblue: "6a5acd",
  slategray: "708090",
  slategrey: "708090",
  snow: "fffafa",
  springgreen: "00ff7f",
  steelblue: "4682b4",
  tan: "d2b48c",
  teal: "008080",
  thistle: "d8bfd8",
  tomato: "ff6347",
  turquoise: "40e0d0",
  violet: "ee82ee",
  wheat: "f5deb3",
  white: "fff",
  whitesmoke: "f5f5f5",
  yellow: "ff0",
  yellowgreen: "9acd32"
}, hexNames = tinycolor.hexNames = flip(names);
function flip(i2) {
  var e = {};
  for (var t in i2)
    i2.hasOwnProperty(t) && (e[i2[t]] = t);
  return e;
}
function boundAlpha(i2) {
  return i2 = parseFloat(i2), (isNaN(i2) || i2 < 0 || i2 > 1) && (i2 = 1), i2;
}
function bound01(i2, e) {
  isOnePointZero(i2) && (i2 = "100%");
  var t = isPercentage(i2);
  return i2 = Math.min(e, Math.max(0, parseFloat(i2))), t && (i2 = parseInt(i2 * e, 10) / 100), Math.abs(i2 - e) < 1e-6 ? 1 : i2 % e / parseFloat(e);
}
function clamp01(i2) {
  return Math.min(1, Math.max(0, i2));
}
function parseIntFromHex(i2) {
  return parseInt(i2, 16);
}
function isOnePointZero(i2) {
  return typeof i2 == "string" && i2.indexOf(".") != -1 && parseFloat(i2) === 1;
}
function isPercentage(i2) {
  return typeof i2 == "string" && i2.indexOf("%") != -1;
}
function pad2(i2) {
  return i2.length == 1 ? "0" + i2 : "" + i2;
}
function convertToPercentage(i2) {
  return i2 <= 1 && (i2 = i2 * 100 + "%"), i2;
}
function convertDecimalToHex(i2) {
  return Math.round(parseFloat(i2) * 255).toString(16);
}
function convertHexToDecimal(i2) {
  return parseIntFromHex(i2) / 255;
}
var matchers = function() {
  var i2 = "[-\\+]?\\d+%?", e = "[-\\+]?\\d*\\.\\d+%?", t = "(?:" + e + ")|(?:" + i2 + ")", r = "[\\s|\\(]+(" + t + ")[,|\\s]+(" + t + ")[,|\\s]+(" + t + ")\\s*\\)?", a = "[\\s|\\(]+(" + t + ")[,|\\s]+(" + t + ")[,|\\s]+(" + t + ")[,|\\s]+(" + t + ")\\s*\\)?";
  return {
    CSS_UNIT: new RegExp(t),
    rgb: new RegExp("rgb" + r),
    rgba: new RegExp("rgba" + a),
    hsl: new RegExp("hsl" + r),
    hsla: new RegExp("hsla" + a),
    hsv: new RegExp("hsv" + r),
    hsva: new RegExp("hsva" + a),
    hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
    hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
  };
}();
function isValidCSSUnit(i2) {
  return !!matchers.CSS_UNIT.exec(i2);
}
function stringInputToObject(i2) {
  i2 = i2.replace(trimLeft, "").replace(trimRight, "").toLowerCase();
  var e = false;
  if (names[i2])
    i2 = names[i2], e = true;
  else if (i2 == "transparent")
    return {
      r: 0,
      g: 0,
      b: 0,
      a: 0,
      format: "name"
    };
  var t;
  return (t = matchers.rgb.exec(i2)) ? {
    r: t[1],
    g: t[2],
    b: t[3]
  } : (t = matchers.rgba.exec(i2)) ? {
    r: t[1],
    g: t[2],
    b: t[3],
    a: t[4]
  } : (t = matchers.hsl.exec(i2)) ? {
    h: t[1],
    s: t[2],
    l: t[3]
  } : (t = matchers.hsla.exec(i2)) ? {
    h: t[1],
    s: t[2],
    l: t[3],
    a: t[4]
  } : (t = matchers.hsv.exec(i2)) ? {
    h: t[1],
    s: t[2],
    v: t[3]
  } : (t = matchers.hsva.exec(i2)) ? {
    h: t[1],
    s: t[2],
    v: t[3],
    a: t[4]
  } : (t = matchers.hex8.exec(i2)) ? {
    r: parseIntFromHex(t[1]),
    g: parseIntFromHex(t[2]),
    b: parseIntFromHex(t[3]),
    a: convertHexToDecimal(t[4]),
    format: e ? "name" : "hex8"
  } : (t = matchers.hex6.exec(i2)) ? {
    r: parseIntFromHex(t[1]),
    g: parseIntFromHex(t[2]),
    b: parseIntFromHex(t[3]),
    format: e ? "name" : "hex"
  } : (t = matchers.hex4.exec(i2)) ? {
    r: parseIntFromHex(t[1] + "" + t[1]),
    g: parseIntFromHex(t[2] + "" + t[2]),
    b: parseIntFromHex(t[3] + "" + t[3]),
    a: convertHexToDecimal(t[4] + "" + t[4]),
    format: e ? "name" : "hex8"
  } : (t = matchers.hex3.exec(i2)) ? {
    r: parseIntFromHex(t[1] + "" + t[1]),
    g: parseIntFromHex(t[2] + "" + t[2]),
    b: parseIntFromHex(t[3] + "" + t[3]),
    format: e ? "name" : "hex"
  } : false;
}
function validateWCAG2Parms(i2) {
  var e, t;
  return i2 = i2 || {
    level: "AA",
    size: "small"
  }, e = (i2.level || "AA").toUpperCase(), t = (i2.size || "small").toLowerCase(), e !== "AA" && e !== "AAA" && (e = "AA"), t !== "small" && t !== "large" && (t = "small"), {
    level: e,
    size: t
  };
}
const colorColorUtil = {
  color: (i2, e) => tinycolor(i2).setAlpha(e / 100).toRgbString()
};
function getDefaultExportFromCjs(i2) {
  return i2 && i2.__esModule && Object.prototype.hasOwnProperty.call(i2, "default") ? i2.default : i2;
}
function getAugmentedNamespace(i2) {
  if (i2.__esModule) return i2;
  var e = i2.default;
  if (typeof e == "function") {
    var t = function r() {
      return this instanceof r ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments);
    };
    t.prototype = e.prototype;
  } else t = {};
  return Object.defineProperty(t, "__esModule", { value: true }), Object.keys(i2).forEach(function(r) {
    var a = Object.getOwnPropertyDescriptor(i2, r);
    Object.defineProperty(t, r, a.get ? a : {
      enumerable: true,
      get: function() {
        return i2[r];
      }
    });
  }), t;
}
var md5$1 = { exports: {} }, crypt = { exports: {} }, hasRequiredCrypt;
function requireCrypt() {
  return hasRequiredCrypt || (hasRequiredCrypt = 1, function() {
    var i2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", e = {
      // Bit-wise rotation left
      rotl: function(t, r) {
        return t << r | t >>> 32 - r;
      },
      // Bit-wise rotation right
      rotr: function(t, r) {
        return t << 32 - r | t >>> r;
      },
      // Swap big-endian to little-endian and vice versa
      endian: function(t) {
        if (t.constructor == Number)
          return e.rotl(t, 8) & 16711935 | e.rotl(t, 24) & 4278255360;
        for (var r = 0; r < t.length; r++)
          t[r] = e.endian(t[r]);
        return t;
      },
      // Generate an array of any length of random bytes
      randomBytes: function(t) {
        for (var r = []; t > 0; t--)
          r.push(Math.floor(Math.random() * 256));
        return r;
      },
      // Convert a byte array to big-endian 32-bit words
      bytesToWords: function(t) {
        for (var r = [], a = 0, s = 0; a < t.length; a++, s += 8)
          r[s >>> 5] |= t[a] << 24 - s % 32;
        return r;
      },
      // Convert big-endian 32-bit words to a byte array
      wordsToBytes: function(t) {
        for (var r = [], a = 0; a < t.length * 32; a += 8)
          r.push(t[a >>> 5] >>> 24 - a % 32 & 255);
        return r;
      },
      // Convert a byte array to a hex string
      bytesToHex: function(t) {
        for (var r = [], a = 0; a < t.length; a++)
          r.push((t[a] >>> 4).toString(16)), r.push((t[a] & 15).toString(16));
        return r.join("");
      },
      // Convert a hex string to a byte array
      hexToBytes: function(t) {
        for (var r = [], a = 0; a < t.length; a += 2)
          r.push(parseInt(t.substr(a, 2), 16));
        return r;
      },
      // Convert a byte array to a base-64 string
      bytesToBase64: function(t) {
        for (var r = [], a = 0; a < t.length; a += 3)
          for (var s = t[a] << 16 | t[a + 1] << 8 | t[a + 2], u = 0; u < 4; u++)
            a * 8 + u * 6 <= t.length * 8 ? r.push(i2.charAt(s >>> 6 * (3 - u) & 63)) : r.push("=");
        return r.join("");
      },
      // Convert a base-64 string to a byte array
      base64ToBytes: function(t) {
        t = t.replace(/[^A-Z0-9+\/]/ig, "");
        for (var r = [], a = 0, s = 0; a < t.length; s = ++a % 4)
          s != 0 && r.push((i2.indexOf(t.charAt(a - 1)) & Math.pow(2, -2 * s + 8) - 1) << s * 2 | i2.indexOf(t.charAt(a)) >>> 6 - s * 2);
        return r;
      }
    };
    crypt.exports = e;
  }()), crypt.exports;
}
var charenc_1, hasRequiredCharenc;
function requireCharenc() {
  if (hasRequiredCharenc) return charenc_1;
  hasRequiredCharenc = 1;
  var i2 = {
    // UTF-8 encoding
    utf8: {
      // Convert a string to a byte array
      stringToBytes: function(e) {
        return i2.bin.stringToBytes(unescape(encodeURIComponent(e)));
      },
      // Convert a byte array to a string
      bytesToString: function(e) {
        return decodeURIComponent(escape(i2.bin.bytesToString(e)));
      }
    },
    // Binary encoding
    bin: {
      // Convert a string to a byte array
      stringToBytes: function(e) {
        for (var t = [], r = 0; r < e.length; r++)
          t.push(e.charCodeAt(r) & 255);
        return t;
      },
      // Convert a byte array to a string
      bytesToString: function(e) {
        for (var t = [], r = 0; r < e.length; r++)
          t.push(String.fromCharCode(e[r]));
        return t.join("");
      }
    }
  };
  return charenc_1 = i2, charenc_1;
}
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
var isBuffer_1, hasRequiredIsBuffer$1;
function requireIsBuffer$1() {
  if (hasRequiredIsBuffer$1) return isBuffer_1;
  hasRequiredIsBuffer$1 = 1, isBuffer_1 = function(t) {
    return t != null && (i2(t) || e(t) || !!t._isBuffer);
  };
  function i2(t) {
    return !!t.constructor && typeof t.constructor.isBuffer == "function" && t.constructor.isBuffer(t);
  }
  function e(t) {
    return typeof t.readFloatLE == "function" && typeof t.slice == "function" && i2(t.slice(0, 0));
  }
  return isBuffer_1;
}
var hasRequiredMd5;
function requireMd5() {
  return hasRequiredMd5 || (hasRequiredMd5 = 1, function() {
    var i2 = requireCrypt(), e = requireCharenc().utf8, t = requireIsBuffer$1(), r = requireCharenc().bin, a = function(s, u) {
      s.constructor == String ? u && u.encoding === "binary" ? s = r.stringToBytes(s) : s = e.stringToBytes(s) : t(s) ? s = Array.prototype.slice.call(s, 0) : !Array.isArray(s) && s.constructor !== Uint8Array && (s = s.toString());
      for (var l = i2.bytesToWords(s), c = s.length * 8, d = 1732584193, f = -271733879, p = -1732584194, m = 271733878, y = 0; y < l.length; y++)
        l[y] = (l[y] << 8 | l[y] >>> 24) & 16711935 | (l[y] << 24 | l[y] >>> 8) & 4278255360;
      l[c >>> 5] |= 128 << c % 32, l[(c + 64 >>> 9 << 4) + 14] = c;
      for (var x = a._ff, g = a._gg, _ = a._hh, T = a._ii, y = 0; y < l.length; y += 16) {
        var E = d, b = f, C = p, w = m;
        d = x(d, f, p, m, l[y + 0], 7, -680876936), m = x(m, d, f, p, l[y + 1], 12, -389564586), p = x(p, m, d, f, l[y + 2], 17, 606105819), f = x(f, p, m, d, l[y + 3], 22, -1044525330), d = x(d, f, p, m, l[y + 4], 7, -176418897), m = x(m, d, f, p, l[y + 5], 12, 1200080426), p = x(p, m, d, f, l[y + 6], 17, -1473231341), f = x(f, p, m, d, l[y + 7], 22, -45705983), d = x(d, f, p, m, l[y + 8], 7, 1770035416), m = x(m, d, f, p, l[y + 9], 12, -1958414417), p = x(p, m, d, f, l[y + 10], 17, -42063), f = x(f, p, m, d, l[y + 11], 22, -1990404162), d = x(d, f, p, m, l[y + 12], 7, 1804603682), m = x(m, d, f, p, l[y + 13], 12, -40341101), p = x(p, m, d, f, l[y + 14], 17, -1502002290), f = x(f, p, m, d, l[y + 15], 22, 1236535329), d = g(d, f, p, m, l[y + 1], 5, -165796510), m = g(m, d, f, p, l[y + 6], 9, -1069501632), p = g(p, m, d, f, l[y + 11], 14, 643717713), f = g(f, p, m, d, l[y + 0], 20, -373897302), d = g(d, f, p, m, l[y + 5], 5, -701558691), m = g(m, d, f, p, l[y + 10], 9, 38016083), p = g(p, m, d, f, l[y + 15], 14, -660478335), f = g(f, p, m, d, l[y + 4], 20, -405537848), d = g(d, f, p, m, l[y + 9], 5, 568446438), m = g(m, d, f, p, l[y + 14], 9, -1019803690), p = g(p, m, d, f, l[y + 3], 14, -187363961), f = g(f, p, m, d, l[y + 8], 20, 1163531501), d = g(d, f, p, m, l[y + 13], 5, -1444681467), m = g(m, d, f, p, l[y + 2], 9, -51403784), p = g(p, m, d, f, l[y + 7], 14, 1735328473), f = g(f, p, m, d, l[y + 12], 20, -1926607734), d = _(d, f, p, m, l[y + 5], 4, -378558), m = _(m, d, f, p, l[y + 8], 11, -2022574463), p = _(p, m, d, f, l[y + 11], 16, 1839030562), f = _(f, p, m, d, l[y + 14], 23, -35309556), d = _(d, f, p, m, l[y + 1], 4, -1530992060), m = _(m, d, f, p, l[y + 4], 11, 1272893353), p = _(p, m, d, f, l[y + 7], 16, -155497632), f = _(f, p, m, d, l[y + 10], 23, -1094730640), d = _(d, f, p, m, l[y + 13], 4, 681279174), m = _(m, d, f, p, l[y + 0], 11, -358537222), p = _(p, m, d, f, l[y + 3], 16, -722521979), f = _(f, p, m, d, l[y + 6], 23, 76029189), d = _(d, f, p, m, l[y + 9], 4, -640364487), m = _(m, d, f, p, l[y + 12], 11, -421815835), p = _(p, m, d, f, l[y + 15], 16, 530742520), f = _(f, p, m, d, l[y + 2], 23, -995338651), d = T(d, f, p, m, l[y + 0], 6, -198630844), m = T(m, d, f, p, l[y + 7], 10, 1126891415), p = T(p, m, d, f, l[y + 14], 15, -1416354905), f = T(f, p, m, d, l[y + 5], 21, -57434055), d = T(d, f, p, m, l[y + 12], 6, 1700485571), m = T(m, d, f, p, l[y + 3], 10, -1894986606), p = T(p, m, d, f, l[y + 10], 15, -1051523), f = T(f, p, m, d, l[y + 1], 21, -2054922799), d = T(d, f, p, m, l[y + 8], 6, 1873313359), m = T(m, d, f, p, l[y + 15], 10, -30611744), p = T(p, m, d, f, l[y + 6], 15, -1560198380), f = T(f, p, m, d, l[y + 13], 21, 1309151649), d = T(d, f, p, m, l[y + 4], 6, -145523070), m = T(m, d, f, p, l[y + 11], 10, -1120210379), p = T(p, m, d, f, l[y + 2], 15, 718787259), f = T(f, p, m, d, l[y + 9], 21, -343485551), d = d + E >>> 0, f = f + b >>> 0, p = p + C >>> 0, m = m + w >>> 0;
      }
      return i2.endian([d, f, p, m]);
    };
    a._ff = function(s, u, l, c, d, f, p) {
      var m = s + (u & l | ~u & c) + (d >>> 0) + p;
      return (m << f | m >>> 32 - f) + u;
    }, a._gg = function(s, u, l, c, d, f, p) {
      var m = s + (u & c | l & ~c) + (d >>> 0) + p;
      return (m << f | m >>> 32 - f) + u;
    }, a._hh = function(s, u, l, c, d, f, p) {
      var m = s + (u ^ l ^ c) + (d >>> 0) + p;
      return (m << f | m >>> 32 - f) + u;
    }, a._ii = function(s, u, l, c, d, f, p) {
      var m = s + (l ^ (u | ~c)) + (d >>> 0) + p;
      return (m << f | m >>> 32 - f) + u;
    }, a._blocksize = 16, a._digestsize = 16, md5$1.exports = function(s, u) {
      if (s == null)
        throw new Error("Illegal argument " + s);
      var l = i2.wordsToBytes(a(s, u));
      return u && u.asBytes ? l : u && u.asString ? r.bytesToString(l) : i2.bytesToHex(l);
    };
  }()), md5$1.exports;
}
var md5Exports = requireMd5();
const md5 = /* @__PURE__ */ getDefaultExportFromCjs(md5Exports);
function commonjsRequire(i2) {
  throw new Error('Could not dynamically require "' + i2 + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var localforage$1 = { exports: {} };
/*!
    localForage -- Offline Storage, Improved
    Version 1.10.0
    https://localforage.github.io/localForage
    (c) 2013-2017 Mozilla, Apache License 2.0
*/
var hasRequiredLocalforage;
function requireLocalforage() {
  return hasRequiredLocalforage || (hasRequiredLocalforage = 1, function(i2, e) {
    (function(t) {
      i2.exports = t();
    })(function() {
      return function t(r, a, s) {
        function u(d, f) {
          if (!a[d]) {
            if (!r[d]) {
              var p = typeof commonjsRequire == "function" && commonjsRequire;
              if (!f && p) return p(d, true);
              if (l) return l(d, true);
              var m = new Error("Cannot find module '" + d + "'");
              throw m.code = "MODULE_NOT_FOUND", m;
            }
            var y = a[d] = { exports: {} };
            r[d][0].call(y.exports, function(x) {
              var g = r[d][1][x];
              return u(g || x);
            }, y, y.exports, t, r, a, s);
          }
          return a[d].exports;
        }
        for (var l = typeof commonjsRequire == "function" && commonjsRequire, c = 0; c < s.length; c++) u(s[c]);
        return u;
      }({ 1: [function(t, r, a) {
        (function(s) {
          var u = s.MutationObserver || s.WebKitMutationObserver, l;
          if (u) {
            var c = 0, d = new u(x), f = s.document.createTextNode("");
            d.observe(f, {
              characterData: true
            }), l = function() {
              f.data = c = ++c % 2;
            };
          } else if (!s.setImmediate && typeof s.MessageChannel < "u") {
            var p = new s.MessageChannel();
            p.port1.onmessage = x, l = function() {
              p.port2.postMessage(0);
            };
          } else "document" in s && "onreadystatechange" in s.document.createElement("script") ? l = function() {
            var _ = s.document.createElement("script");
            _.onreadystatechange = function() {
              x(), _.onreadystatechange = null, _.parentNode.removeChild(_), _ = null;
            }, s.document.documentElement.appendChild(_);
          } : l = function() {
            setTimeout(x, 0);
          };
          var m, y = [];
          function x() {
            m = true;
            for (var _, T, E = y.length; E; ) {
              for (T = y, y = [], _ = -1; ++_ < E; )
                T[_]();
              E = y.length;
            }
            m = false;
          }
          r.exports = g;
          function g(_) {
            y.push(_) === 1 && !m && l();
          }
        }).call(this, typeof window < "u" ? window : typeof self < "u" ? self : typeof window < "u" ? window : {});
      }, {}], 2: [function(t, r, a) {
        var s = t(1);
        function u() {
        }
        var l = {}, c = ["REJECTED"], d = ["FULFILLED"], f = ["PENDING"];
        r.exports = p;
        function p(w) {
          if (typeof w != "function")
            throw new TypeError("resolver must be a function");
          this.state = f, this.queue = [], this.outcome = void 0, w !== u && g(this, w);
        }
        p.prototype.catch = function(w) {
          return this.then(null, w);
        }, p.prototype.then = function(w, A) {
          if (typeof w != "function" && this.state === d || typeof A != "function" && this.state === c)
            return this;
          var S = new this.constructor(u);
          if (this.state !== f) {
            var F = this.state === d ? w : A;
            y(S, F, this.outcome);
          } else
            this.queue.push(new m(S, w, A));
          return S;
        };
        function m(w, A, S) {
          this.promise = w, typeof A == "function" && (this.onFulfilled = A, this.callFulfilled = this.otherCallFulfilled), typeof S == "function" && (this.onRejected = S, this.callRejected = this.otherCallRejected);
        }
        m.prototype.callFulfilled = function(w) {
          l.resolve(this.promise, w);
        }, m.prototype.otherCallFulfilled = function(w) {
          y(this.promise, this.onFulfilled, w);
        }, m.prototype.callRejected = function(w) {
          l.reject(this.promise, w);
        }, m.prototype.otherCallRejected = function(w) {
          y(this.promise, this.onRejected, w);
        };
        function y(w, A, S) {
          s(function() {
            var F;
            try {
              F = A(S);
            } catch (M) {
              return l.reject(w, M);
            }
            F === w ? l.reject(w, new TypeError("Cannot resolve promise with itself")) : l.resolve(w, F);
          });
        }
        l.resolve = function(w, A) {
          var S = _(x, A);
          if (S.status === "error")
            return l.reject(w, S.value);
          var F = S.value;
          if (F)
            g(w, F);
          else {
            w.state = d, w.outcome = A;
            for (var M = -1, U = w.queue.length; ++M < U; )
              w.queue[M].callFulfilled(A);
          }
          return w;
        }, l.reject = function(w, A) {
          w.state = c, w.outcome = A;
          for (var S = -1, F = w.queue.length; ++S < F; )
            w.queue[S].callRejected(A);
          return w;
        };
        function x(w) {
          var A = w && w.then;
          if (w && (typeof w == "object" || typeof w == "function") && typeof A == "function")
            return function() {
              A.apply(w, arguments);
            };
        }
        function g(w, A) {
          var S = false;
          function F(q) {
            S || (S = true, l.reject(w, q));
          }
          function M(q) {
            S || (S = true, l.resolve(w, q));
          }
          function U() {
            A(M, F);
          }
          var B = _(U);
          B.status === "error" && F(B.value);
        }
        function _(w, A) {
          var S = {};
          try {
            S.value = w(A), S.status = "success";
          } catch (F) {
            S.status = "error", S.value = F;
          }
          return S;
        }
        p.resolve = T;
        function T(w) {
          return w instanceof this ? w : l.resolve(new this(u), w);
        }
        p.reject = E;
        function E(w) {
          var A = new this(u);
          return l.reject(A, w);
        }
        p.all = b;
        function b(w) {
          var A = this;
          if (Object.prototype.toString.call(w) !== "[object Array]")
            return this.reject(new TypeError("must be an array"));
          var S = w.length, F = false;
          if (!S)
            return this.resolve([]);
          for (var M = new Array(S), U = 0, B = -1, q = new this(u); ++B < S; )
            z(w[B], B);
          return q;
          function z(D, X) {
            A.resolve(D).then(k, function(I) {
              F || (F = true, l.reject(q, I));
            });
            function k(I) {
              M[X] = I, ++U === S && !F && (F = true, l.resolve(q, M));
            }
          }
        }
        p.race = C;
        function C(w) {
          var A = this;
          if (Object.prototype.toString.call(w) !== "[object Array]")
            return this.reject(new TypeError("must be an array"));
          var S = w.length, F = false;
          if (!S)
            return this.resolve([]);
          for (var M = -1, U = new this(u); ++M < S; )
            B(w[M]);
          return U;
          function B(q) {
            A.resolve(q).then(function(z) {
              F || (F = true, l.resolve(U, z));
            }, function(z) {
              F || (F = true, l.reject(U, z));
            });
          }
        }
      }, { 1: 1 }], 3: [function(t, r, a) {
        (function(s) {
          typeof s.Promise != "function" && (s.Promise = t(2));
        }).call(this, typeof window < "u" ? window : typeof self < "u" ? self : typeof window < "u" ? window : {});
      }, { 2: 2 }], 4: [function(t, r, a) {
        var s = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(ue) {
          return typeof ue;
        } : function(ue) {
          return ue && typeof Symbol == "function" && ue.constructor === Symbol && ue !== Symbol.prototype ? "symbol" : typeof ue;
        };
        function u(ue, de) {
          if (!(ue instanceof de))
            throw new TypeError("Cannot call a class as a function");
        }
        function l() {
          try {
            if (typeof indexedDB < "u")
              return indexedDB;
            if (typeof webkitIndexedDB < "u")
              return webkitIndexedDB;
            if (typeof mozIndexedDB < "u")
              return mozIndexedDB;
            if (typeof OIndexedDB < "u")
              return OIndexedDB;
            if (typeof msIndexedDB < "u")
              return msIndexedDB;
          } catch {
            return;
          }
        }
        var c = l();
        function d() {
          try {
            if (!c || !c.open)
              return false;
            var ue = typeof openDatabase < "u" && /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent) && !/BlackBerry/.test(navigator.platform), de = typeof fetch == "function" && fetch.toString().indexOf("[native code") !== -1;
            return (!ue || de) && typeof indexedDB < "u" && // some outdated implementations of IDB that appear on Samsung
            // and HTC Android devices <4.4 are missing IDBKeyRange
            // See: https://github.com/mozilla/localForage/issues/128
            // See: https://github.com/mozilla/localForage/issues/272
            typeof IDBKeyRange < "u";
          } catch {
            return false;
          }
        }
        function f(ue, de) {
          ue = ue || [], de = de || {};
          try {
            return new Blob(ue, de);
          } catch (Ie) {
            if (Ie.name !== "TypeError")
              throw Ie;
            for (var pe = typeof BlobBuilder < "u" ? BlobBuilder : typeof MSBlobBuilder < "u" ? MSBlobBuilder : typeof MozBlobBuilder < "u" ? MozBlobBuilder : WebKitBlobBuilder, Me = new pe(), Re = 0; Re < ue.length; Re += 1)
              Me.append(ue[Re]);
            return Me.getBlob(de.type);
          }
        }
        typeof Promise > "u" && t(3);
        var p = Promise;
        function m(ue, de) {
          de && ue.then(function(pe) {
            de(null, pe);
          }, function(pe) {
            de(pe);
          });
        }
        function y(ue, de, pe) {
          typeof de == "function" && ue.then(de), typeof pe == "function" && ue.catch(pe);
        }
        function x(ue) {
          return typeof ue != "string" && (console.warn(ue + " used as a key, but it is not a string."), ue = String(ue)), ue;
        }
        function g() {
          if (arguments.length && typeof arguments[arguments.length - 1] == "function")
            return arguments[arguments.length - 1];
        }
        var _ = "local-forage-detect-blob-support", T = void 0, E = {}, b = Object.prototype.toString, C = "readonly", w = "readwrite";
        function A(ue) {
          for (var de = ue.length, pe = new ArrayBuffer(de), Me = new Uint8Array(pe), Re = 0; Re < de; Re++)
            Me[Re] = ue.charCodeAt(Re);
          return pe;
        }
        function S(ue) {
          return new p(function(de) {
            var pe = ue.transaction(_, w), Me = f([""]);
            pe.objectStore(_).put(Me, "key"), pe.onabort = function(Re) {
              Re.preventDefault(), Re.stopPropagation(), de(false);
            }, pe.oncomplete = function() {
              var Re = navigator.userAgent.match(/Chrome\/(\d+)/), Ie = navigator.userAgent.match(/Edge\//);
              de(Ie || !Re || parseInt(Re[1], 10) >= 43);
            };
          }).catch(function() {
            return false;
          });
        }
        function F(ue) {
          return typeof T == "boolean" ? p.resolve(T) : S(ue).then(function(de) {
            return T = de, T;
          });
        }
        function M(ue) {
          var de = E[ue.name], pe = {};
          pe.promise = new p(function(Me, Re) {
            pe.resolve = Me, pe.reject = Re;
          }), de.deferredOperations.push(pe), de.dbReady ? de.dbReady = de.dbReady.then(function() {
            return pe.promise;
          }) : de.dbReady = pe.promise;
        }
        function U(ue) {
          var de = E[ue.name], pe = de.deferredOperations.pop();
          if (pe)
            return pe.resolve(), pe.promise;
        }
        function B(ue, de) {
          var pe = E[ue.name], Me = pe.deferredOperations.pop();
          if (Me)
            return Me.reject(de), Me.promise;
        }
        function q(ue, de) {
          return new p(function(pe, Me) {
            if (E[ue.name] = E[ue.name] || K(), ue.db)
              if (de)
                M(ue), ue.db.close();
              else
                return pe(ue.db);
            var Re = [ue.name];
            de && Re.push(ue.version);
            var Ie = c.open.apply(c, Re);
            de && (Ie.onupgradeneeded = function(Fe) {
              var ze = Ie.result;
              try {
                ze.createObjectStore(ue.storeName), Fe.oldVersion <= 1 && ze.createObjectStore(_);
              } catch (Ze) {
                if (Ze.name === "ConstraintError")
                  console.warn('The database "' + ue.name + '" has been upgraded from version ' + Fe.oldVersion + " to version " + Fe.newVersion + ', but the storage "' + ue.storeName + '" already exists.');
                else
                  throw Ze;
              }
            }), Ie.onerror = function(Fe) {
              Fe.preventDefault(), Me(Ie.error);
            }, Ie.onsuccess = function() {
              var Fe = Ie.result;
              Fe.onversionchange = function(ze) {
                ze.target.close();
              }, pe(Fe), U(ue);
            };
          });
        }
        function z(ue) {
          return q(ue, false);
        }
        function D(ue) {
          return q(ue, true);
        }
        function X(ue, de) {
          if (!ue.db)
            return true;
          var pe = !ue.db.objectStoreNames.contains(ue.storeName), Me = ue.version < ue.db.version, Re = ue.version > ue.db.version;
          if (Me && (ue.version !== de && console.warn('The database "' + ue.name + `" can't be downgraded from version ` + ue.db.version + " to version " + ue.version + "."), ue.version = ue.db.version), Re || pe) {
            if (pe) {
              var Ie = ue.db.version + 1;
              Ie > ue.version && (ue.version = Ie);
            }
            return true;
          }
          return false;
        }
        function k(ue) {
          return new p(function(de, pe) {
            var Me = new FileReader();
            Me.onerror = pe, Me.onloadend = function(Re) {
              var Ie = btoa(Re.target.result || "");
              de({
                __local_forage_encoded_blob: true,
                data: Ie,
                type: ue.type
              });
            }, Me.readAsBinaryString(ue);
          });
        }
        function I(ue) {
          var de = A(atob(ue.data));
          return f([de], { type: ue.type });
        }
        function P(ue) {
          return ue && ue.__local_forage_encoded_blob;
        }
        function G(ue) {
          var de = this, pe = de._initReady().then(function() {
            var Me = E[de._dbInfo.name];
            if (Me && Me.dbReady)
              return Me.dbReady;
          });
          return y(pe, ue, ue), pe;
        }
        function W(ue) {
          M(ue);
          for (var de = E[ue.name], pe = de.forages, Me = 0; Me < pe.length; Me++) {
            var Re = pe[Me];
            Re._dbInfo.db && (Re._dbInfo.db.close(), Re._dbInfo.db = null);
          }
          return ue.db = null, z(ue).then(function(Ie) {
            return ue.db = Ie, X(ue) ? D(ue) : Ie;
          }).then(function(Ie) {
            ue.db = de.db = Ie;
            for (var Fe = 0; Fe < pe.length; Fe++)
              pe[Fe]._dbInfo.db = Ie;
          }).catch(function(Ie) {
            throw B(ue, Ie), Ie;
          });
        }
        function V(ue, de, pe, Me) {
          Me === void 0 && (Me = 1);
          try {
            var Re = ue.db.transaction(ue.storeName, de);
            pe(null, Re);
          } catch (Ie) {
            if (Me > 0 && (!ue.db || Ie.name === "InvalidStateError" || Ie.name === "NotFoundError"))
              return p.resolve().then(function() {
                if (!ue.db || Ie.name === "NotFoundError" && !ue.db.objectStoreNames.contains(ue.storeName) && ue.version <= ue.db.version)
                  return ue.db && (ue.version = ue.db.version + 1), D(ue);
              }).then(function() {
                return W(ue).then(function() {
                  V(ue, de, pe, Me - 1);
                });
              }).catch(pe);
            pe(Ie);
          }
        }
        function K() {
          return {
            // Running localForages sharing a database.
            forages: [],
            // Shared database.
            db: null,
            // Database readiness (promise).
            dbReady: null,
            // Deferred operations on the database.
            deferredOperations: []
          };
        }
        function J(ue) {
          var de = this, pe = {
            db: null
          };
          if (ue)
            for (var Me in ue)
              pe[Me] = ue[Me];
          var Re = E[pe.name];
          Re || (Re = K(), E[pe.name] = Re), Re.forages.push(de), de._initReady || (de._initReady = de.ready, de.ready = G);
          var Ie = [];
          function Fe() {
            return p.resolve();
          }
          for (var ze = 0; ze < Re.forages.length; ze++) {
            var Ze = Re.forages[ze];
            Ze !== de && Ie.push(Ze._initReady().catch(Fe));
          }
          var Ke = Re.forages.slice(0);
          return p.all(Ie).then(function() {
            return pe.db = Re.db, z(pe);
          }).then(function(Ye) {
            return pe.db = Ye, X(pe, de._defaultConfig.version) ? D(pe) : Ye;
          }).then(function(Ye) {
            pe.db = Re.db = Ye, de._dbInfo = pe;
            for (var dt = 0; dt < Ke.length; dt++) {
              var Pt = Ke[dt];
              Pt !== de && (Pt._dbInfo.db = pe.db, Pt._dbInfo.version = pe.version);
            }
          });
        }
        function ae(ue, de) {
          var pe = this;
          ue = x(ue);
          var Me = new p(function(Re, Ie) {
            pe.ready().then(function() {
              V(pe._dbInfo, C, function(Fe, ze) {
                if (Fe)
                  return Ie(Fe);
                try {
                  var Ze = ze.objectStore(pe._dbInfo.storeName), Ke = Ze.get(ue);
                  Ke.onsuccess = function() {
                    var Ye = Ke.result;
                    Ye === void 0 && (Ye = null), P(Ye) && (Ye = I(Ye)), Re(Ye);
                  }, Ke.onerror = function() {
                    Ie(Ke.error);
                  };
                } catch (Ye) {
                  Ie(Ye);
                }
              });
            }).catch(Ie);
          });
          return m(Me, de), Me;
        }
        function re(ue, de) {
          var pe = this, Me = new p(function(Re, Ie) {
            pe.ready().then(function() {
              V(pe._dbInfo, C, function(Fe, ze) {
                if (Fe)
                  return Ie(Fe);
                try {
                  var Ze = ze.objectStore(pe._dbInfo.storeName), Ke = Ze.openCursor(), Ye = 1;
                  Ke.onsuccess = function() {
                    var dt = Ke.result;
                    if (dt) {
                      var Pt = dt.value;
                      P(Pt) && (Pt = I(Pt));
                      var Ut = ue(Pt, dt.key, Ye++);
                      Ut !== void 0 ? Re(Ut) : dt.continue();
                    } else
                      Re();
                  }, Ke.onerror = function() {
                    Ie(Ke.error);
                  };
                } catch (dt) {
                  Ie(dt);
                }
              });
            }).catch(Ie);
          });
          return m(Me, de), Me;
        }
        function he(ue, de, pe) {
          var Me = this;
          ue = x(ue);
          var Re = new p(function(Ie, Fe) {
            var ze;
            Me.ready().then(function() {
              return ze = Me._dbInfo, b.call(de) === "[object Blob]" ? F(ze.db).then(function(Ze) {
                return Ze ? de : k(de);
              }) : de;
            }).then(function(Ze) {
              V(Me._dbInfo, w, function(Ke, Ye) {
                if (Ke)
                  return Fe(Ke);
                try {
                  var dt = Ye.objectStore(Me._dbInfo.storeName);
                  Ze === null && (Ze = void 0);
                  var Pt = dt.put(Ze, ue);
                  Ye.oncomplete = function() {
                    Ze === void 0 && (Ze = null), Ie(Ze);
                  }, Ye.onabort = Ye.onerror = function() {
                    var Ut = Pt.error ? Pt.error : Pt.transaction.error;
                    Fe(Ut);
                  };
                } catch (Ut) {
                  Fe(Ut);
                }
              });
            }).catch(Fe);
          });
          return m(Re, pe), Re;
        }
        function ge(ue, de) {
          var pe = this;
          ue = x(ue);
          var Me = new p(function(Re, Ie) {
            pe.ready().then(function() {
              V(pe._dbInfo, w, function(Fe, ze) {
                if (Fe)
                  return Ie(Fe);
                try {
                  var Ze = ze.objectStore(pe._dbInfo.storeName), Ke = Ze.delete(ue);
                  ze.oncomplete = function() {
                    Re();
                  }, ze.onerror = function() {
                    Ie(Ke.error);
                  }, ze.onabort = function() {
                    var Ye = Ke.error ? Ke.error : Ke.transaction.error;
                    Ie(Ye);
                  };
                } catch (Ye) {
                  Ie(Ye);
                }
              });
            }).catch(Ie);
          });
          return m(Me, de), Me;
        }
        function me(ue) {
          var de = this, pe = new p(function(Me, Re) {
            de.ready().then(function() {
              V(de._dbInfo, w, function(Ie, Fe) {
                if (Ie)
                  return Re(Ie);
                try {
                  var ze = Fe.objectStore(de._dbInfo.storeName), Ze = ze.clear();
                  Fe.oncomplete = function() {
                    Me();
                  }, Fe.onabort = Fe.onerror = function() {
                    var Ke = Ze.error ? Ze.error : Ze.transaction.error;
                    Re(Ke);
                  };
                } catch (Ke) {
                  Re(Ke);
                }
              });
            }).catch(Re);
          });
          return m(pe, ue), pe;
        }
        function Te(ue) {
          var de = this, pe = new p(function(Me, Re) {
            de.ready().then(function() {
              V(de._dbInfo, C, function(Ie, Fe) {
                if (Ie)
                  return Re(Ie);
                try {
                  var ze = Fe.objectStore(de._dbInfo.storeName), Ze = ze.count();
                  Ze.onsuccess = function() {
                    Me(Ze.result);
                  }, Ze.onerror = function() {
                    Re(Ze.error);
                  };
                } catch (Ke) {
                  Re(Ke);
                }
              });
            }).catch(Re);
          });
          return m(pe, ue), pe;
        }
        function _e(ue, de) {
          var pe = this, Me = new p(function(Re, Ie) {
            if (ue < 0) {
              Re(null);
              return;
            }
            pe.ready().then(function() {
              V(pe._dbInfo, C, function(Fe, ze) {
                if (Fe)
                  return Ie(Fe);
                try {
                  var Ze = ze.objectStore(pe._dbInfo.storeName), Ke = false, Ye = Ze.openKeyCursor();
                  Ye.onsuccess = function() {
                    var dt = Ye.result;
                    if (!dt) {
                      Re(null);
                      return;
                    }
                    ue === 0 || Ke ? Re(dt.key) : (Ke = true, dt.advance(ue));
                  }, Ye.onerror = function() {
                    Ie(Ye.error);
                  };
                } catch (dt) {
                  Ie(dt);
                }
              });
            }).catch(Ie);
          });
          return m(Me, de), Me;
        }
        function ye(ue) {
          var de = this, pe = new p(function(Me, Re) {
            de.ready().then(function() {
              V(de._dbInfo, C, function(Ie, Fe) {
                if (Ie)
                  return Re(Ie);
                try {
                  var ze = Fe.objectStore(de._dbInfo.storeName), Ze = ze.openKeyCursor(), Ke = [];
                  Ze.onsuccess = function() {
                    var Ye = Ze.result;
                    if (!Ye) {
                      Me(Ke);
                      return;
                    }
                    Ke.push(Ye.key), Ye.continue();
                  }, Ze.onerror = function() {
                    Re(Ze.error);
                  };
                } catch (Ye) {
                  Re(Ye);
                }
              });
            }).catch(Re);
          });
          return m(pe, ue), pe;
        }
        function Ae(ue, de) {
          de = g.apply(this, arguments);
          var pe = this.config();
          ue = typeof ue != "function" && ue || {}, ue.name || (ue.name = ue.name || pe.name, ue.storeName = ue.storeName || pe.storeName);
          var Me = this, Re;
          if (!ue.name)
            Re = p.reject("Invalid arguments");
          else {
            var Ie = ue.name === pe.name && Me._dbInfo.db, Fe = Ie ? p.resolve(Me._dbInfo.db) : z(ue).then(function(ze) {
              var Ze = E[ue.name], Ke = Ze.forages;
              Ze.db = ze;
              for (var Ye = 0; Ye < Ke.length; Ye++)
                Ke[Ye]._dbInfo.db = ze;
              return ze;
            });
            ue.storeName ? Re = Fe.then(function(ze) {
              if (ze.objectStoreNames.contains(ue.storeName)) {
                var Ze = ze.version + 1;
                M(ue);
                var Ke = E[ue.name], Ye = Ke.forages;
                ze.close();
                for (var dt = 0; dt < Ye.length; dt++) {
                  var Pt = Ye[dt];
                  Pt._dbInfo.db = null, Pt._dbInfo.version = Ze;
                }
                var Ut = new p(function(Dt, Qt) {
                  var Ft = c.open(ue.name, Ze);
                  Ft.onerror = function(Ur) {
                    var Ki = Ft.result;
                    Ki.close(), Qt(Ur);
                  }, Ft.onupgradeneeded = function() {
                    var Ur = Ft.result;
                    Ur.deleteObjectStore(ue.storeName);
                  }, Ft.onsuccess = function() {
                    var Ur = Ft.result;
                    Ur.close(), Dt(Ur);
                  };
                });
                return Ut.then(function(Dt) {
                  Ke.db = Dt;
                  for (var Qt = 0; Qt < Ye.length; Qt++) {
                    var Ft = Ye[Qt];
                    Ft._dbInfo.db = Dt, U(Ft._dbInfo);
                  }
                }).catch(function(Dt) {
                  throw (B(ue, Dt) || p.resolve()).catch(function() {
                  }), Dt;
                });
              }
            }) : Re = Fe.then(function(ze) {
              M(ue);
              var Ze = E[ue.name], Ke = Ze.forages;
              ze.close();
              for (var Ye = 0; Ye < Ke.length; Ye++) {
                var dt = Ke[Ye];
                dt._dbInfo.db = null;
              }
              var Pt = new p(function(Ut, Dt) {
                var Qt = c.deleteDatabase(ue.name);
                Qt.onerror = function() {
                  var Ft = Qt.result;
                  Ft && Ft.close(), Dt(Qt.error);
                }, Qt.onblocked = function() {
                  console.warn('dropInstance blocked for database "' + ue.name + '" until all open connections are closed');
                }, Qt.onsuccess = function() {
                  var Ft = Qt.result;
                  Ft && Ft.close(), Ut(Ft);
                };
              });
              return Pt.then(function(Ut) {
                Ze.db = Ut;
                for (var Dt = 0; Dt < Ke.length; Dt++) {
                  var Qt = Ke[Dt];
                  U(Qt._dbInfo);
                }
              }).catch(function(Ut) {
                throw (B(ue, Ut) || p.resolve()).catch(function() {
                }), Ut;
              });
            });
          }
          return m(Re, de), Re;
        }
        var ke = {
          _driver: "asyncStorage",
          _initStorage: J,
          _support: d(),
          iterate: re,
          getItem: ae,
          setItem: he,
          removeItem: ge,
          clear: me,
          length: Te,
          key: _e,
          keys: ye,
          dropInstance: Ae
        };
        function Pe() {
          return typeof openDatabase == "function";
        }
        var Ee = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", Oe = "~~local_forage_type~", $e = /^~~local_forage_type~([^~]+)~/, gt = "__lfsc__:", xt = gt.length, vt = "arbf", Xe = "blob", at = "si08", ct = "ui08", Rt = "uic8", It = "si16", er = "si32", $ = "ur16", Y = "ui32", ee = "fl32", be = "fl64", Se = xt + vt.length, Ne = Object.prototype.toString;
        function je(ue) {
          var de = ue.length * 0.75, pe = ue.length, Me, Re = 0, Ie, Fe, ze, Ze;
          ue[ue.length - 1] === "=" && (de--, ue[ue.length - 2] === "=" && de--);
          var Ke = new ArrayBuffer(de), Ye = new Uint8Array(Ke);
          for (Me = 0; Me < pe; Me += 4)
            Ie = Ee.indexOf(ue[Me]), Fe = Ee.indexOf(ue[Me + 1]), ze = Ee.indexOf(ue[Me + 2]), Ze = Ee.indexOf(ue[Me + 3]), Ye[Re++] = Ie << 2 | Fe >> 4, Ye[Re++] = (Fe & 15) << 4 | ze >> 2, Ye[Re++] = (ze & 3) << 6 | Ze & 63;
          return Ke;
        }
        function pt(ue) {
          var de = new Uint8Array(ue), pe = "", Me;
          for (Me = 0; Me < de.length; Me += 3)
            pe += Ee[de[Me] >> 2], pe += Ee[(de[Me] & 3) << 4 | de[Me + 1] >> 4], pe += Ee[(de[Me + 1] & 15) << 2 | de[Me + 2] >> 6], pe += Ee[de[Me + 2] & 63];
          return de.length % 3 === 2 ? pe = pe.substring(0, pe.length - 1) + "=" : de.length % 3 === 1 && (pe = pe.substring(0, pe.length - 2) + "=="), pe;
        }
        function oe(ue, de) {
          var pe = "";
          if (ue && (pe = Ne.call(ue)), ue && (pe === "[object ArrayBuffer]" || ue.buffer && Ne.call(ue.buffer) === "[object ArrayBuffer]")) {
            var Me, Re = gt;
            ue instanceof ArrayBuffer ? (Me = ue, Re += vt) : (Me = ue.buffer, pe === "[object Int8Array]" ? Re += at : pe === "[object Uint8Array]" ? Re += ct : pe === "[object Uint8ClampedArray]" ? Re += Rt : pe === "[object Int16Array]" ? Re += It : pe === "[object Uint16Array]" ? Re += $ : pe === "[object Int32Array]" ? Re += er : pe === "[object Uint32Array]" ? Re += Y : pe === "[object Float32Array]" ? Re += ee : pe === "[object Float64Array]" ? Re += be : de(new Error("Failed to get type for BinaryArray"))), de(Re + pt(Me));
          } else if (pe === "[object Blob]") {
            var Ie = new FileReader();
            Ie.onload = function() {
              var Fe = Oe + ue.type + "~" + pt(this.result);
              de(gt + Xe + Fe);
            }, Ie.readAsArrayBuffer(ue);
          } else
            try {
              de(JSON.stringify(ue));
            } catch (Fe) {
              console.error("Couldn't convert value into a JSON string: ", ue), de(null, Fe);
            }
        }
        function le(ue) {
          if (ue.substring(0, xt) !== gt)
            return JSON.parse(ue);
          var de = ue.substring(Se), pe = ue.substring(xt, Se), Me;
          if (pe === Xe && $e.test(de)) {
            var Re = de.match($e);
            Me = Re[1], de = de.substring(Re[0].length);
          }
          var Ie = je(de);
          switch (pe) {
            case vt:
              return Ie;
            case Xe:
              return f([Ie], { type: Me });
            case at:
              return new Int8Array(Ie);
            case ct:
              return new Uint8Array(Ie);
            case Rt:
              return new Uint8ClampedArray(Ie);
            case It:
              return new Int16Array(Ie);
            case $:
              return new Uint16Array(Ie);
            case er:
              return new Int32Array(Ie);
            case Y:
              return new Uint32Array(Ie);
            case ee:
              return new Float32Array(Ie);
            case be:
              return new Float64Array(Ie);
            default:
              throw new Error("Unkown type: " + pe);
          }
        }
        var Ue = {
          serialize: oe,
          deserialize: le,
          stringToBuffer: je,
          bufferToString: pt
        };
        function et(ue, de, pe, Me) {
          ue.executeSql("CREATE TABLE IF NOT EXISTS " + de.storeName + " (id INTEGER PRIMARY KEY, key unique, value)", [], pe, Me);
        }
        function lt(ue) {
          var de = this, pe = {
            db: null
          };
          if (ue)
            for (var Me in ue)
              pe[Me] = typeof ue[Me] != "string" ? ue[Me].toString() : ue[Me];
          var Re = new p(function(Ie, Fe) {
            try {
              pe.db = openDatabase(pe.name, String(pe.version), pe.description, pe.size);
            } catch (ze) {
              return Fe(ze);
            }
            pe.db.transaction(function(ze) {
              et(ze, pe, function() {
                de._dbInfo = pe, Ie();
              }, function(Ze, Ke) {
                Fe(Ke);
              });
            }, Fe);
          });
          return pe.serializer = Ue, Re;
        }
        function We(ue, de, pe, Me, Re, Ie) {
          ue.executeSql(pe, Me, Re, function(Fe, ze) {
            ze.code === ze.SYNTAX_ERR ? Fe.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name = ?", [de.storeName], function(Ze, Ke) {
              Ke.rows.length ? Ie(Ze, ze) : et(Ze, de, function() {
                Ze.executeSql(pe, Me, Re, Ie);
              }, Ie);
            }, Ie) : Ie(Fe, ze);
          }, Ie);
        }
        function te(ue, de) {
          var pe = this;
          ue = x(ue);
          var Me = new p(function(Re, Ie) {
            pe.ready().then(function() {
              var Fe = pe._dbInfo;
              Fe.db.transaction(function(ze) {
                We(ze, Fe, "SELECT * FROM " + Fe.storeName + " WHERE key = ? LIMIT 1", [ue], function(Ze, Ke) {
                  var Ye = Ke.rows.length ? Ke.rows.item(0).value : null;
                  Ye && (Ye = Fe.serializer.deserialize(Ye)), Re(Ye);
                }, function(Ze, Ke) {
                  Ie(Ke);
                });
              });
            }).catch(Ie);
          });
          return m(Me, de), Me;
        }
        function ne(ue, de) {
          var pe = this, Me = new p(function(Re, Ie) {
            pe.ready().then(function() {
              var Fe = pe._dbInfo;
              Fe.db.transaction(function(ze) {
                We(ze, Fe, "SELECT * FROM " + Fe.storeName, [], function(Ze, Ke) {
                  for (var Ye = Ke.rows, dt = Ye.length, Pt = 0; Pt < dt; Pt++) {
                    var Ut = Ye.item(Pt), Dt = Ut.value;
                    if (Dt && (Dt = Fe.serializer.deserialize(Dt)), Dt = ue(Dt, Ut.key, Pt + 1), Dt !== void 0) {
                      Re(Dt);
                      return;
                    }
                  }
                  Re();
                }, function(Ze, Ke) {
                  Ie(Ke);
                });
              });
            }).catch(Ie);
          });
          return m(Me, de), Me;
        }
        function fe(ue, de, pe, Me) {
          var Re = this;
          ue = x(ue);
          var Ie = new p(function(Fe, ze) {
            Re.ready().then(function() {
              de === void 0 && (de = null);
              var Ze = de, Ke = Re._dbInfo;
              Ke.serializer.serialize(de, function(Ye, dt) {
                dt ? ze(dt) : Ke.db.transaction(function(Pt) {
                  We(Pt, Ke, "INSERT OR REPLACE INTO " + Ke.storeName + " (key, value) VALUES (?, ?)", [ue, Ye], function() {
                    Fe(Ze);
                  }, function(Ut, Dt) {
                    ze(Dt);
                  });
                }, function(Pt) {
                  if (Pt.code === Pt.QUOTA_ERR) {
                    if (Me > 0) {
                      Fe(fe.apply(Re, [ue, Ze, pe, Me - 1]));
                      return;
                    }
                    ze(Pt);
                  }
                });
              });
            }).catch(ze);
          });
          return m(Ie, pe), Ie;
        }
        function qe(ue, de, pe) {
          return fe.apply(this, [ue, de, pe, 1]);
        }
        function Je(ue, de) {
          var pe = this;
          ue = x(ue);
          var Me = new p(function(Re, Ie) {
            pe.ready().then(function() {
              var Fe = pe._dbInfo;
              Fe.db.transaction(function(ze) {
                We(ze, Fe, "DELETE FROM " + Fe.storeName + " WHERE key = ?", [ue], function() {
                  Re();
                }, function(Ze, Ke) {
                  Ie(Ke);
                });
              });
            }).catch(Ie);
          });
          return m(Me, de), Me;
        }
        function ht(ue) {
          var de = this, pe = new p(function(Me, Re) {
            de.ready().then(function() {
              var Ie = de._dbInfo;
              Ie.db.transaction(function(Fe) {
                We(Fe, Ie, "DELETE FROM " + Ie.storeName, [], function() {
                  Me();
                }, function(ze, Ze) {
                  Re(Ze);
                });
              });
            }).catch(Re);
          });
          return m(pe, ue), pe;
        }
        function bt(ue) {
          var de = this, pe = new p(function(Me, Re) {
            de.ready().then(function() {
              var Ie = de._dbInfo;
              Ie.db.transaction(function(Fe) {
                We(Fe, Ie, "SELECT COUNT(key) as c FROM " + Ie.storeName, [], function(ze, Ze) {
                  var Ke = Ze.rows.item(0).c;
                  Me(Ke);
                }, function(ze, Ze) {
                  Re(Ze);
                });
              });
            }).catch(Re);
          });
          return m(pe, ue), pe;
        }
        function kt(ue, de) {
          var pe = this, Me = new p(function(Re, Ie) {
            pe.ready().then(function() {
              var Fe = pe._dbInfo;
              Fe.db.transaction(function(ze) {
                We(ze, Fe, "SELECT key FROM " + Fe.storeName + " WHERE id = ? LIMIT 1", [ue + 1], function(Ze, Ke) {
                  var Ye = Ke.rows.length ? Ke.rows.item(0).key : null;
                  Re(Ye);
                }, function(Ze, Ke) {
                  Ie(Ke);
                });
              });
            }).catch(Ie);
          });
          return m(Me, de), Me;
        }
        function Ar(ue) {
          var de = this, pe = new p(function(Me, Re) {
            de.ready().then(function() {
              var Ie = de._dbInfo;
              Ie.db.transaction(function(Fe) {
                We(Fe, Ie, "SELECT key FROM " + Ie.storeName, [], function(ze, Ze) {
                  for (var Ke = [], Ye = 0; Ye < Ze.rows.length; Ye++)
                    Ke.push(Ze.rows.item(Ye).key);
                  Me(Ke);
                }, function(ze, Ze) {
                  Re(Ze);
                });
              });
            }).catch(Re);
          });
          return m(pe, ue), pe;
        }
        function Sr(ue) {
          return new p(function(de, pe) {
            ue.transaction(function(Me) {
              Me.executeSql("SELECT name FROM sqlite_master WHERE type='table' AND name <> '__WebKitDatabaseInfoTable__'", [], function(Re, Ie) {
                for (var Fe = [], ze = 0; ze < Ie.rows.length; ze++)
                  Fe.push(Ie.rows.item(ze).name);
                de({
                  db: ue,
                  storeNames: Fe
                });
              }, function(Re, Ie) {
                pe(Ie);
              });
            }, function(Me) {
              pe(Me);
            });
          });
        }
        function Vt(ue, de) {
          de = g.apply(this, arguments);
          var pe = this.config();
          ue = typeof ue != "function" && ue || {}, ue.name || (ue.name = ue.name || pe.name, ue.storeName = ue.storeName || pe.storeName);
          var Me = this, Re;
          return ue.name ? Re = new p(function(Ie) {
            var Fe;
            ue.name === pe.name ? Fe = Me._dbInfo.db : Fe = openDatabase(ue.name, "", "", 0), ue.storeName ? Ie({
              db: Fe,
              storeNames: [ue.storeName]
            }) : Ie(Sr(Fe));
          }).then(function(Ie) {
            return new p(function(Fe, ze) {
              Ie.db.transaction(function(Ze) {
                function Ke(Ut) {
                  return new p(function(Dt, Qt) {
                    Ze.executeSql("DROP TABLE IF EXISTS " + Ut, [], function() {
                      Dt();
                    }, function(Ft, Ur) {
                      Qt(Ur);
                    });
                  });
                }
                for (var Ye = [], dt = 0, Pt = Ie.storeNames.length; dt < Pt; dt++)
                  Ye.push(Ke(Ie.storeNames[dt]));
                p.all(Ye).then(function() {
                  Fe();
                }).catch(function(Ut) {
                  ze(Ut);
                });
              }, function(Ze) {
                ze(Ze);
              });
            });
          }) : Re = p.reject("Invalid arguments"), m(Re, de), Re;
        }
        var jr = {
          _driver: "webSQLStorage",
          _initStorage: lt,
          _support: Pe(),
          iterate: ne,
          getItem: te,
          setItem: qe,
          removeItem: Je,
          clear: ht,
          length: bt,
          key: kt,
          keys: Ar,
          dropInstance: Vt
        };
        function tr() {
          try {
            return typeof localStorage < "u" && "setItem" in localStorage && // in IE8 typeof localStorage.setItem === 'object'
            !!localStorage.setItem;
          } catch {
            return false;
          }
        }
        function _r(ue, de) {
          var pe = ue.name + "/";
          return ue.storeName !== de.storeName && (pe += ue.storeName + "/"), pe;
        }
        function wr() {
          var ue = "_localforage_support_test";
          try {
            return localStorage.setItem(ue, true), localStorage.removeItem(ue), false;
          } catch {
            return true;
          }
        }
        function xr() {
          return !wr() || localStorage.length > 0;
        }
        function Mr(ue) {
          var de = this, pe = {};
          if (ue)
            for (var Me in ue)
              pe[Me] = ue[Me];
          return pe.keyPrefix = _r(ue, de._defaultConfig), xr() ? (de._dbInfo = pe, pe.serializer = Ue, p.resolve()) : p.reject();
        }
        function Or(ue) {
          var de = this, pe = de.ready().then(function() {
            for (var Me = de._dbInfo.keyPrefix, Re = localStorage.length - 1; Re >= 0; Re--) {
              var Ie = localStorage.key(Re);
              Ie.indexOf(Me) === 0 && localStorage.removeItem(Ie);
            }
          });
          return m(pe, ue), pe;
        }
        function hi(ue, de) {
          var pe = this;
          ue = x(ue);
          var Me = pe.ready().then(function() {
            var Re = pe._dbInfo, Ie = localStorage.getItem(Re.keyPrefix + ue);
            return Ie && (Ie = Re.serializer.deserialize(Ie)), Ie;
          });
          return m(Me, de), Me;
        }
        function Rr(ue, de) {
          var pe = this, Me = pe.ready().then(function() {
            for (var Re = pe._dbInfo, Ie = Re.keyPrefix, Fe = Ie.length, ze = localStorage.length, Ze = 1, Ke = 0; Ke < ze; Ke++) {
              var Ye = localStorage.key(Ke);
              if (Ye.indexOf(Ie) === 0) {
                var dt = localStorage.getItem(Ye);
                if (dt && (dt = Re.serializer.deserialize(dt)), dt = ue(dt, Ye.substring(Fe), Ze++), dt !== void 0)
                  return dt;
              }
            }
          });
          return m(Me, de), Me;
        }
        function ci(ue, de) {
          var pe = this, Me = pe.ready().then(function() {
            var Re = pe._dbInfo, Ie;
            try {
              Ie = localStorage.key(ue);
            } catch {
              Ie = null;
            }
            return Ie && (Ie = Ie.substring(Re.keyPrefix.length)), Ie;
          });
          return m(Me, de), Me;
        }
        function Ri(ue) {
          var de = this, pe = de.ready().then(function() {
            for (var Me = de._dbInfo, Re = localStorage.length, Ie = [], Fe = 0; Fe < Re; Fe++) {
              var ze = localStorage.key(Fe);
              ze.indexOf(Me.keyPrefix) === 0 && Ie.push(ze.substring(Me.keyPrefix.length));
            }
            return Ie;
          });
          return m(pe, ue), pe;
        }
        function fi(ue) {
          var de = this, pe = de.keys().then(function(Me) {
            return Me.length;
          });
          return m(pe, ue), pe;
        }
        function Ir(ue, de) {
          var pe = this;
          ue = x(ue);
          var Me = pe.ready().then(function() {
            var Re = pe._dbInfo;
            localStorage.removeItem(Re.keyPrefix + ue);
          });
          return m(Me, de), Me;
        }
        function Zr(ue, de, pe) {
          var Me = this;
          ue = x(ue);
          var Re = Me.ready().then(function() {
            de === void 0 && (de = null);
            var Ie = de;
            return new p(function(Fe, ze) {
              var Ze = Me._dbInfo;
              Ze.serializer.serialize(de, function(Ke, Ye) {
                if (Ye)
                  ze(Ye);
                else
                  try {
                    localStorage.setItem(Ze.keyPrefix + ue, Ke), Fe(Ie);
                  } catch (dt) {
                    (dt.name === "QuotaExceededError" || dt.name === "NS_ERROR_DOM_QUOTA_REACHED") && ze(dt), ze(dt);
                  }
              });
            });
          });
          return m(Re, pe), Re;
        }
        function Xi(ue, de) {
          if (de = g.apply(this, arguments), ue = typeof ue != "function" && ue || {}, !ue.name) {
            var pe = this.config();
            ue.name = ue.name || pe.name, ue.storeName = ue.storeName || pe.storeName;
          }
          var Me = this, Re;
          return ue.name ? Re = new p(function(Ie) {
            ue.storeName ? Ie(_r(ue, Me._defaultConfig)) : Ie(ue.name + "/");
          }).then(function(Ie) {
            for (var Fe = localStorage.length - 1; Fe >= 0; Fe--) {
              var ze = localStorage.key(Fe);
              ze.indexOf(Ie) === 0 && localStorage.removeItem(ze);
            }
          }) : Re = p.reject("Invalid arguments"), m(Re, de), Re;
        }
        var Ai = {
          _driver: "localStorageWrapper",
          _initStorage: Mr,
          _support: tr(),
          iterate: Rr,
          getItem: hi,
          setItem: Zr,
          removeItem: Ir,
          clear: Or,
          length: fi,
          key: ci,
          keys: Ri,
          dropInstance: Xi
        }, rs = function(ue, de) {
          return ue === de || typeof ue == "number" && typeof de == "number" && isNaN(ue) && isNaN(de);
        }, Mi = function(ue, de) {
          for (var pe = ue.length, Me = 0; Me < pe; ) {
            if (rs(ue[Me], de))
              return true;
            Me++;
          }
          return false;
        }, Ja = Array.isArray || function(ue) {
          return Object.prototype.toString.call(ue) === "[object Array]";
        }, Qr = {}, Za = {}, Vi = {
          INDEXEDDB: ke,
          WEBSQL: jr,
          LOCALSTORAGE: Ai
        }, is = [Vi.INDEXEDDB._driver, Vi.WEBSQL._driver, Vi.LOCALSTORAGE._driver], Hi = ["dropInstance"], Yi = ["clear", "getItem", "iterate", "key", "keys", "length", "removeItem", "setItem"].concat(Hi), Bn = {
          description: "",
          driver: is.slice(),
          name: "localforage",
          // Default DB size is _JUST UNDER_ 5MB, as it's the highest size
          // we can use without a prompt.
          size: 4980736,
          storeName: "keyvaluepairs",
          version: 1
        };
        function ns(ue, de) {
          ue[de] = function() {
            var pe = arguments;
            return ue.ready().then(function() {
              return ue[de].apply(ue, pe);
            });
          };
        }
        function $n() {
          for (var ue = 1; ue < arguments.length; ue++) {
            var de = arguments[ue];
            if (de)
              for (var pe in de)
                de.hasOwnProperty(pe) && (Ja(de[pe]) ? arguments[0][pe] = de[pe].slice() : arguments[0][pe] = de[pe]);
          }
          return arguments[0];
        }
        var as = function() {
          function ue(de) {
            u(this, ue);
            for (var pe in Vi)
              if (Vi.hasOwnProperty(pe)) {
                var Me = Vi[pe], Re = Me._driver;
                this[pe] = Re, Qr[Re] || this.defineDriver(Me);
              }
            this._defaultConfig = $n({}, Bn), this._config = $n({}, this._defaultConfig, de), this._driverSet = null, this._initDriver = null, this._ready = false, this._dbInfo = null, this._wrapLibraryMethodsWithReady(), this.setDriver(this._config.driver).catch(function() {
            });
          }
          return ue.prototype.config = function(de) {
            if ((typeof de > "u" ? "undefined" : s(de)) === "object") {
              if (this._ready)
                return new Error("Can't call config() after localforage has been used.");
              for (var pe in de) {
                if (pe === "storeName" && (de[pe] = de[pe].replace(/\W/g, "_")), pe === "version" && typeof de[pe] != "number")
                  return new Error("Database version must be a number.");
                this._config[pe] = de[pe];
              }
              return "driver" in de && de.driver ? this.setDriver(this._config.driver) : true;
            } else return typeof de == "string" ? this._config[de] : this._config;
          }, ue.prototype.defineDriver = function(de, pe, Me) {
            var Re = new p(function(Ie, Fe) {
              try {
                var ze = de._driver, Ze = new Error("Custom driver not compliant; see https://mozilla.github.io/localForage/#definedriver");
                if (!de._driver) {
                  Fe(Ze);
                  return;
                }
                for (var Ke = Yi.concat("_initStorage"), Ye = 0, dt = Ke.length; Ye < dt; Ye++) {
                  var Pt = Ke[Ye], Ut = !Mi(Hi, Pt);
                  if ((Ut || de[Pt]) && typeof de[Pt] != "function") {
                    Fe(Ze);
                    return;
                  }
                }
                var Dt = function() {
                  for (var Ft = function(Un) {
                    return function() {
                      var Gn = new Error("Method " + Un + " is not implemented by the current driver"), Dn = p.reject(Gn);
                      return m(Dn, arguments[arguments.length - 1]), Dn;
                    };
                  }, Ur = 0, Ki = Hi.length; Ur < Ki; Ur++) {
                    var jn = Hi[Ur];
                    de[jn] || (de[jn] = Ft(jn));
                  }
                };
                Dt();
                var Qt = function(Ft) {
                  Qr[ze] && console.info("Redefining LocalForage driver: " + ze), Qr[ze] = de, Za[ze] = Ft, Ie();
                };
                "_support" in de ? de._support && typeof de._support == "function" ? de._support().then(Qt, Fe) : Qt(!!de._support) : Qt(true);
              } catch (Ft) {
                Fe(Ft);
              }
            });
            return y(Re, pe, Me), Re;
          }, ue.prototype.driver = function() {
            return this._driver || null;
          }, ue.prototype.getDriver = function(de, pe, Me) {
            var Re = Qr[de] ? p.resolve(Qr[de]) : p.reject(new Error("Driver not found."));
            return y(Re, pe, Me), Re;
          }, ue.prototype.getSerializer = function(de) {
            var pe = p.resolve(Ue);
            return y(pe, de), pe;
          }, ue.prototype.ready = function(de) {
            var pe = this, Me = pe._driverSet.then(function() {
              return pe._ready === null && (pe._ready = pe._initDriver()), pe._ready;
            });
            return y(Me, de, de), Me;
          }, ue.prototype.setDriver = function(de, pe, Me) {
            var Re = this;
            Ja(de) || (de = [de]);
            var Ie = this._getSupportedDrivers(de);
            function Fe() {
              Re._config.driver = Re.driver();
            }
            function ze(Ye) {
              return Re._extend(Ye), Fe(), Re._ready = Re._initStorage(Re._config), Re._ready;
            }
            function Ze(Ye) {
              return function() {
                var dt = 0;
                function Pt() {
                  for (; dt < Ye.length; ) {
                    var Ut = Ye[dt];
                    return dt++, Re._dbInfo = null, Re._ready = null, Re.getDriver(Ut).then(ze).catch(Pt);
                  }
                  Fe();
                  var Dt = new Error("No available storage method found.");
                  return Re._driverSet = p.reject(Dt), Re._driverSet;
                }
                return Pt();
              };
            }
            var Ke = this._driverSet !== null ? this._driverSet.catch(function() {
              return p.resolve();
            }) : p.resolve();
            return this._driverSet = Ke.then(function() {
              var Ye = Ie[0];
              return Re._dbInfo = null, Re._ready = null, Re.getDriver(Ye).then(function(dt) {
                Re._driver = dt._driver, Fe(), Re._wrapLibraryMethodsWithReady(), Re._initDriver = Ze(Ie);
              });
            }).catch(function() {
              Fe();
              var Ye = new Error("No available storage method found.");
              return Re._driverSet = p.reject(Ye), Re._driverSet;
            }), y(this._driverSet, pe, Me), this._driverSet;
          }, ue.prototype.supports = function(de) {
            return !!Za[de];
          }, ue.prototype._extend = function(de) {
            $n(this, de);
          }, ue.prototype._getSupportedDrivers = function(de) {
            for (var pe = [], Me = 0, Re = de.length; Me < Re; Me++) {
              var Ie = de[Me];
              this.supports(Ie) && pe.push(Ie);
            }
            return pe;
          }, ue.prototype._wrapLibraryMethodsWithReady = function() {
            for (var de = 0, pe = Yi.length; de < pe; de++)
              ns(this, Yi[de]);
          }, ue.prototype.createInstance = function(de) {
            return new ue(de);
          }, ue;
        }(), ss = new as();
        r.exports = ss;
      }, { 3: 3 }] }, {}, [4])(4);
    });
  }(localforage$1)), localforage$1.exports;
}
var localforageExports = requireLocalforage();
const localforage = /* @__PURE__ */ getDefaultExportFromCjs(localforageExports), { createObjectURL, revokeObjectURL } = URL, awaitObj = {}, setAwaitObj = {}, now = Date.now();
localforage.iterate((i2, e) => {
  now - i2.updated < 1296e6 || localforage.removeItem(e);
});
const defaultOut = {
  contentType: (i2) => i2 && i2.includes("/") ? `.${i2.split("/")[1].toUpperCase()}` : "",
  cachedResource: async (i2, e) => {
    const t = md5(i2);
    e && e({ key: t, total: 1048576, loaded: 1 });
    let r = await async function(a) {
      return awaitObj[a] || (awaitObj[a] = localforage.getItem(a)), await awaitObj[a];
    }(t);
    return r && r.data ? (r.url = createObjectURL(r.data), r) : (awaitObj[t] = async function(a, s = null) {
      if (!a.startsWith("http")) return { url: a };
      const u = md5(a);
      return setAwaitObj[u] || (setAwaitObj[u] = new Promise(function(l) {
        const c = new XMLHttpRequest();
        c.addEventListener("load", () => {
          const d = c.getResponseHeader("Content-Type");
          l({ data: c.response, type: d });
        }), c.addEventListener("error", (d) => l({ url: a })), c.addEventListener("progress", (d) => {
          s && s(d);
        }), c.open("get", a), c.responseType = "blob", c.send();
      })), setAwaitObj[u];
    }(i2, (a) => {
      const { total: s, loaded: u } = a;
      e && e({ key: t, total: s, loaded: u });
    }), r = await awaitObj[t], r.data && function(a, s) {
      s && s.data && (s.updated = Date.now(), localforage.setItem(a, s), s.url = createObjectURL(s.data));
    }(t, r), r);
  },
  forceCacheNode: async (i2, e) => await defaultOut.cacheNode(i2, e, true),
  cacheNode: async (i2, e, t = false) => {
    var r, a;
    const { type: s, src: u, path: l, url: c, fontFamily: d, font: f, preload: p } = i2.conf;
    let m = u || l || c;
    if (s === "text" && d != null && d.startsWith("http") && (t || p !== false)) {
      const { url: y } = await defaultOut.cachedResource(d, e);
      i2.cachedFontFamily = y;
    } else if (s === "richtext" && f && (t || p !== false)) {
      const y = Array.isArray(f) ? f : [f];
      for (const x of y) {
        x.format = i2.fontFormat(x);
        const { url: g } = await defaultOut.cachedResource(x.src, e);
        x.cachedSrc = g;
      }
      i2.conf.font = y;
    } else if (s === "mixin" && i2.conf.mixin && p !== false) {
      if (i2.conf.mixin.startsWith("http")) m = i2.conf.mixin;
      else {
        const g = i2.conf.ver || i2.conf.version || "1.0";
        m = new URL(
          `./${i2.conf.mixin}.js?version=${g}`,
          i2.rootConf("mns")
        );
      }
      const { url: y, type: x } = await defaultOut.cachedResource(`${m}`, e);
      i2.conf.mixin = y;
    } else if (["image", "gif"].includes(s) && m && (t || p)) {
      const { url: y, type: x } = await defaultOut.cachedResource(m, e);
      if (i2.conf.cachedSrc = y, i2.conf.srcType = defaultOut.contentType(x), (r = i2.conf.motion) == null ? void 0 : r.src) {
        const { url: g, type: _ } = await defaultOut.cachedResource(
          (a = i2.conf.motion) == null ? void 0 : a.src,
          e
        );
        i2.conf.motion.cachedSrc = g;
      }
    } else if (["audio", "speech", "video"].includes(s) && m && (t || p)) {
      const { url: y } = await defaultOut.cachedResource(m, e);
      i2.conf.cachedSrc = y;
      const x = m.split("/");
      i2.conf.srcFile = x[x.length - 1];
    }
  }
}, TimeUtil = {
  secToHms: (i2, e = 0) => {
    i2 = i2.toFixed(e);
    const t = Math.floor(i2 / 3600).toString();
    let r = Math.floor((i2 - 3600 * t) / 60).toString();
    t > 0 && (r = r.padStart(2, "0"));
    let a = Math.floor(i2 - 3600 * t - 60 * r).toString();
    return r.length > 0 && (a = a.padStart(2, "0")), `${t > 0 ? t + ":" : ""}${r}:${a}${e > 0 ? (i2 - Math.floor(i2)).toFixed(e).replace("0.", ".") : ""}`;
  }
}, DomUtil = {
  innerSize: (i2) => {
    const e = window.getComputedStyle(i2), t = parseInt(e.paddingTop) + parseInt(e.paddingBottom), r = parseInt(e.paddingLeft) + parseInt(e.paddingRight);
    return { width: i2.clientWidth - r, height: i2.clientHeight - t };
  }
}, Utils = {
  ColorUtil: colorColorUtil,
  CacheUtil: defaultOut,
  TimeUtil,
  DomUtil
};
var lib$5 = {}, hasRequiredLib$5;
function requireLib$5() {
  if (hasRequiredLib$5) return lib$5;
  hasRequiredLib$5 = 1, Object.defineProperty(lib$5, "__esModule", {
    value: true
  });
  var i2 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(s) {
    return typeof s;
  } : function(s) {
    return s && typeof Symbol == "function" && s.constructor === Symbol && s !== Symbol.prototype ? "symbol" : typeof s;
  }, e = typeof window < "u" && typeof window.document < "u", t = (typeof self > "u" ? "undefined" : i2(self)) === "object" && self.constructor && self.constructor.name === "DedicatedWorkerGlobalScope", r = typeof process < "u" && process.versions != null && process.versions.node != null, a = function() {
    return typeof window < "u" && window.name === "nodejs" || navigator.userAgent.includes("Node.js") || navigator.userAgent.includes("jsdom");
  };
  return lib$5.isBrowser = e, lib$5.isWebWorker = t, lib$5.isNode = r, lib$5.isJsDom = a, lib$5;
}
var lib$4 = {}, requestAnimationFrame$1 = {}, hasRequiredRequestAnimationFrame;
function requireRequestAnimationFrame() {
  if (hasRequiredRequestAnimationFrame) return requestAnimationFrame$1;
  hasRequiredRequestAnimationFrame = 1;
  var i2 = 16;
  if (Date.now && Date.prototype.getTime || (Date.now = function() {
    return (/* @__PURE__ */ new Date()).getTime();
  }), !(window.performance && window.performance.now)) {
    var e = Date.now();
    window.performance || (window.performance = {}), window.performance.now = () => Date.now() - e;
  }
  for (var t = Date.now(), r = ["ms", "moz", "webkit", "o"], a = 0; a < r.length && !window.requestAnimationFrame; ++a) {
    var s = r[a];
    window.requestAnimationFrame = window[s + "RequestAnimationFrame"], window.cancelAnimationFrame = window[s + "CancelAnimationFrame"] || window[s + "CancelRequestAnimationFrame"];
  }
  return window.requestAnimationFrame || (window.requestAnimationFrame = (u) => {
    if (typeof u != "function")
      throw new TypeError(u + "is not a function");
    var l = Date.now(), c = i2 + t - l;
    return c < 0 && (c = 0), t = l, setTimeout(() => {
      t = Date.now(), u(performance.now());
    }, c);
  }), window.cancelAnimationFrame || (window.cancelAnimationFrame = (u) => clearTimeout(u)), requestAnimationFrame$1;
}
var core = {}, _const = {}, hasRequired_const;
function require_const() {
  if (hasRequired_const) return _const;
  hasRequired_const = 1, Object.defineProperty(_const, "__esModule", {
    value: true
  }), _const.WRAP_MODES = _const.URL_FILE_EXTENSION = _const.UPDATE_PRIORITY = _const.TRANSFORM_MODE = _const.TEXT_GRADIENT = _const.SVG_SIZE = _const.SHAPES = _const.SCALE_MODES = _const.RENDERER_TYPE = _const.RAD_TO_DEG = _const.PRECISION = _const.PI_2 = _const.GC_MODES = _const.DRAW_MODES = _const.DEG_TO_RAD = _const.DATA_URI = _const.BLEND_MODES = void 0;
  var i2 = Math.PI * 2;
  _const.PI_2 = i2;
  var e = 180 / Math.PI;
  _const.RAD_TO_DEG = e;
  var t = Math.PI / 180;
  _const.DEG_TO_RAD = t;
  var r = {
    UNKNOWN: 0,
    WEBGL: 1,
    CANVAS: 2
  };
  _const.RENDERER_TYPE = r;
  var a = {
    NORMAL: 0,
    // 正常
    ADD: 1,
    // 线性加深(添加)
    MULTIPLY: 2,
    // 正片叠底
    SCREEN: 3,
    // 滤色
    OVERLAY: 4,
    // 叠加
    DARKEN: 5,
    // 变暗
    LIGHTEN: 6,
    // 变亮
    COLOR_DODGE: 7,
    // 颜色减淡
    COLOR_BURN: 8,
    // 颜色加深
    HARD_LIGHT: 9,
    // 强光
    SOFT_LIGHT: 10,
    // 柔光
    DIFFERENCE: 11,
    // 差值
    EXCLUSION: 12,
    // 排除: 与“差值”模式相似但对比度更低的效果
    HUE: 13,
    // 色相: 用基色的明亮度和饱和度以及混合色的色相创建结果色
    SATURATION: 14,
    // 饱和度: 用基色的明亮度和色相以及混合色的饱和度创建结果色
    COLOR: 15,
    // 颜色: 用基色的明亮度以及混合色的色相和饱和度创建结果色
    LUMINOSITY: 16,
    // 明度: 用基色的色相和饱和度以及混合色的明亮度创建结果色
    NORMAL_NPM: 17,
    // webgl的NORMAL, not-premultiplied, only for webgl
    ADD_NPM: 18,
    // webgl的ADD, not-premultiplied, only for webgl
    SCREEN_NPM: 19
    // webgl的SCREEN, not-premultiplied, only for webgl
  };
  _const.BLEND_MODES = a;
  var s = {
    POINTS: 0,
    LINES: 1,
    LINE_LOOP: 2,
    LINE_STRIP: 3,
    TRIANGLES: 4,
    TRIANGLE_STRIP: 5,
    TRIANGLE_FAN: 6
  };
  _const.DRAW_MODES = s;
  var u = {
    LINEAR: 0,
    NEAREST: 1
  };
  _const.SCALE_MODES = u;
  var l = {
    CLAMP: 0,
    REPEAT: 1,
    MIRRORED_REPEAT: 2
  };
  _const.WRAP_MODES = l;
  var c = {
    AUTO: 0,
    MANUAL: 1
  };
  _const.GC_MODES = c;
  var d = /\.(\w{3,4})(?:$|\?|#)/i;
  _const.URL_FILE_EXTENSION = d;
  var f = /^\s*data:(?:([\w-]+)\/([\w+.-]+))?(?:;charset=([\w-]+))?(?:;(base64))?,(.*)/i;
  _const.DATA_URI = f;
  var p = /<svg[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*>/i;
  _const.SVG_SIZE = p;
  var m = {
    POLY: 0,
    RECT: 1,
    CIRC: 2,
    ELIP: 3,
    RREC: 4
  };
  _const.SHAPES = m;
  var y = {
    LOW: "lowp",
    MEDIUM: "mediump",
    HIGH: "highp"
  };
  _const.PRECISION = y;
  var x = {
    STATIC: 0,
    DYNAMIC: 1
  };
  _const.TRANSFORM_MODE = x;
  var g = {
    LINEAR_VERTICAL: 0,
    LINEAR_HORIZONTAL: 1
  };
  _const.TEXT_GRADIENT = g;
  var _ = {
    INTERACTION: 50,
    HIGH: 25,
    NORMAL: 0,
    LOW: -25,
    UTILITY: -50
  };
  return _const.UPDATE_PRIORITY = _, _const;
}
var math$1 = {}, Point = {}, hasRequiredPoint;
function requirePoint() {
  if (hasRequiredPoint) return Point;
  hasRequiredPoint = 1, Object.defineProperty(Point, "__esModule", {
    value: true
  }), Point.default = void 0;
  let i2 = class Mm {
    constructor(t, r) {
      t === void 0 && (t = 0), r === void 0 && (r = 0), this.x = t, this.y = r;
    }
    clone() {
      return new Mm(this.x, this.y);
    }
    copy(t) {
      this.set(t.x, t.y);
    }
    equals(t) {
      return t.x === this.x && t.y === this.y;
    }
    set(t, r) {
      this.x = t || 0, this.y = r || (r !== 0 ? this.x : 0);
    }
    dot(t) {
      this.x = this.x * t.x, this.x = this.y * t.y;
    }
  };
  return Point.default = i2, Point;
}
var ObservablePoint = {}, hasRequiredObservablePoint;
function requireObservablePoint() {
  if (hasRequiredObservablePoint) return ObservablePoint;
  hasRequiredObservablePoint = 1, Object.defineProperty(ObservablePoint, "__esModule", {
    value: true
  }), ObservablePoint.default = void 0;
  let i2 = class Om {
    constructor(t, r, a, s) {
      a === void 0 && (a = 0), s === void 0 && (s = 0), this._x = a, this._y = s, this.cb = t, this.scope = r;
    }
    clone(t, r) {
      t === void 0 && (t = null), r === void 0 && (r = null);
      var a = t || this.cb, s = r || this.scope;
      return new Om(a, s, this._x, this._y);
    }
    set(t, r) {
      var a = t || 0, s = r || (r !== 0 ? a : 0);
      (this._x !== a || this._y !== s) && (this._x = a, this._y = s, this.cb.call(this.scope));
    }
    copy(t) {
      (this._x !== t.x || this._y !== t.y) && (this._x = t.x, this._y = t.y, this.cb.call(this.scope));
    }
    equals(t) {
      return t.x === this._x && t.y === this._y;
    }
    get x() {
      return this._x;
    }
    set x(t) {
      this._x !== t && (this._x = t, this.cb.call(this.scope));
    }
    get y() {
      return this._y;
    }
    set y(t) {
      this._y !== t && (this._y = t, this.cb.call(this.scope));
    }
    dot(t) {
      this.x = this.x * t.x, this.x = this.y * t.y;
    }
  };
  return ObservablePoint.default = i2, ObservablePoint;
}
var Matrix = {}, hasRequiredMatrix;
function requireMatrix() {
  if (hasRequiredMatrix) return Matrix;
  hasRequiredMatrix = 1, Object.defineProperty(Matrix, "__esModule", {
    value: true
  }), Matrix.default = void 0;
  var i2 = t(requirePoint()), e = require_const();
  function t(a) {
    return a && a.__esModule ? a : { default: a };
  }
  let r = class wu {
    constructor(s, u, l, c, d, f) {
      s === void 0 && (s = 1), u === void 0 && (u = 0), l === void 0 && (l = 0), c === void 0 && (c = 1), d === void 0 && (d = 0), f === void 0 && (f = 0), this.a = s, this.b = u, this.c = l, this.d = c, this.tx = d, this.ty = f, this.array = null;
    }
    /**
     * Creates a Matrix object based on the given array. The Element to Matrix mapping order is as follows:
     *
     * a = array[0]
     * b = array[1]
     * c = array[3]
     * d = array[4]
     * tx = array[2]
     * ty = array[5]
     *
     * @param {number[]} array - The array that the matrix will be populated from.
     */
    fromArray(s) {
      this.a = s[0], this.b = s[1], this.c = s[3], this.d = s[4], this.tx = s[2], this.ty = s[5];
    }
    /**
     * sets the matrix properties
     *
     * @param {number} a - Matrix component
     * @param {number} b - Matrix component
     * @param {number} c - Matrix component
     * @param {number} d - Matrix component
     * @param {number} tx - Matrix component
     * @param {number} ty - Matrix component
     *
     * @return {InkPaint.Matrix} This matrix. Good for chaining method calls.
     */
    set(s, u, l, c, d, f) {
      return this.a = s, this.b = u, this.c = l, this.d = c, this.tx = d, this.ty = f, this;
    }
    /**
     * Creates an array from the current Matrix object.
     *
     * @param {boolean} transpose - Whether we need to transpose the matrix or not
     * @param {Float32Array} [out=new Float32Array(9)] - If provided the array will be assigned to out
     * @return {number[]} the newly created array which contains the matrix
     */
    toArray(s, u) {
      this.array || (this.array = new Float32Array(9));
      var l = u || this.array;
      return s ? (l[0] = this.a, l[1] = this.b, l[2] = 0, l[3] = this.c, l[4] = this.d, l[5] = 0, l[6] = this.tx, l[7] = this.ty, l[8] = 1) : (l[0] = this.a, l[1] = this.c, l[2] = this.tx, l[3] = this.b, l[4] = this.d, l[5] = this.ty, l[6] = 0, l[7] = 0, l[8] = 1), l;
    }
    /**
     * Get a new position with the current transformation applied.
     * Can be used to go from a child's coordinate space to the world coordinate space. (e.g. rendering)
     *
     * @param {InkPaint.Point} pos - The origin
     * @param {InkPaint.Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)
     * @return {InkPaint.Point} The new point, transformed through this matrix
     */
    apply(s, u) {
      u = u || new i2.default();
      var l = s.x, c = s.y;
      return u.x = this.a * l + this.c * c + this.tx, u.y = this.b * l + this.d * c + this.ty, u;
    }
    /**
     * Get a new position with the inverse of the current transformation applied.
     * Can be used to go from the world coordinate space to a child's coordinate space. (e.g. input)
     *
     * @param {InkPaint.Point} pos - The origin
     * @param {InkPaint.Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)
     * @return {InkPaint.Point} The new point, inverse-transformed through this matrix
     */
    applyInverse(s, u) {
      u = u || new i2.default();
      var l = 1 / (this.a * this.d + this.c * -this.b), c = s.x, d = s.y;
      return u.x = this.d * l * c + -this.c * l * d + (this.ty * this.c - this.tx * this.d) * l, u.y = this.a * l * d + -this.b * l * c + (-this.ty * this.a + this.tx * this.b) * l, u;
    }
    /**
     * Translates the matrix on the x and y.
     *
     * @param {number} x How much to translate x by
     * @param {number} y How much to translate y by
     * @return {InkPaint.Matrix} This matrix. Good for chaining method calls.
     */
    translate(s, u) {
      return this.tx += s, this.ty += u, this;
    }
    /**
     * Applies a scale transformation to the matrix.
     *
     * @param {number} x The amount to scale horizontally
     * @param {number} y The amount to scale vertically
     * @return {InkPaint.Matrix} This matrix. Good for chaining method calls.
     */
    scale(s, u) {
      return this.a *= s, this.d *= u, this.c *= s, this.b *= u, this.tx *= s, this.ty *= u, this;
    }
    /**
     * Applies a rotation transformation to the matrix.
     *
     * @param {number} angle - The angle in radians.
     * @return {InkPaint.Matrix} This matrix. Good for chaining method calls.
     */
    rotate(s) {
      var u = Math.cos(s), l = Math.sin(s), c = this.a, d = this.c, f = this.tx;
      return this.a = c * u - this.b * l, this.b = c * l + this.b * u, this.c = d * u - this.d * l, this.d = d * l + this.d * u, this.tx = f * u - this.ty * l, this.ty = f * l + this.ty * u, this;
    }
    /**
     * Appends the given Matrix to this Matrix.
     *
     * @param {InkPaint.Matrix} matrix - The matrix to append.
     * @return {InkPaint.Matrix} This matrix. Good for chaining method calls.
     */
    append(s) {
      var u = this.a, l = this.b, c = this.c, d = this.d;
      return this.a = s.a * u + s.b * c, this.b = s.a * l + s.b * d, this.c = s.c * u + s.d * c, this.d = s.c * l + s.d * d, this.tx = s.tx * u + s.ty * c + this.tx, this.ty = s.tx * l + s.ty * d + this.ty, this;
    }
    /**
     * Sets the matrix based on all the available properties
     *
     * @param {number} x - Position on the x axis
     * @param {number} y - Position on the y axis
     * @param {number} pivotX - Pivot on the x axis
     * @param {number} pivotY - Pivot on the y axis
     * @param {number} scaleX - Scale on the x axis
     * @param {number} scaleY - Scale on the y axis
     * @param {number} rotation - Rotation in radians
     * @param {number} skewX - Skew on the x axis
     * @param {number} skewY - Skew on the y axis
     * @return {InkPaint.Matrix} This matrix. Good for chaining method calls.
     */
    setTransform(s, u, l, c, d, f, p, m, y) {
      return this.a = Math.cos(p + y) * d, this.b = Math.sin(p + y) * d, this.c = -Math.sin(p - m) * f, this.d = Math.cos(p - m) * f, this.tx = s - (l * this.a + c * this.c), this.ty = u - (l * this.b + c * this.d), this;
    }
    /**
     * Prepends the given Matrix to this Matrix.
     *
     * @param {InkPaint.Matrix} matrix - The matrix to prepend
     * @return {InkPaint.Matrix} This matrix. Good for chaining method calls.
     */
    prepend(s) {
      var u = this.tx;
      if (s.a !== 1 || s.b !== 0 || s.c !== 0 || s.d !== 1) {
        var l = this.a, c = this.c;
        this.a = l * s.a + this.b * s.c, this.b = l * s.b + this.b * s.d, this.c = c * s.a + this.d * s.c, this.d = c * s.b + this.d * s.d;
      }
      return this.tx = u * s.a + this.ty * s.c + s.tx, this.ty = u * s.b + this.ty * s.d + s.ty, this;
    }
    /**
     * Decomposes the matrix (x, y, scaleX, scaleY, and rotation) and sets the properties on to a transform.
     *
     * @param {InkPaint.Transform|InkPaint.TransformStatic} transform - The transform to apply the properties to.
     * @return {InkPaint.Transform|InkPaint.TransformStatic} The transform with the newly applied properties
     */
    decompose(s) {
      var u = this.a, l = this.b, c = this.c, d = this.d, f = -Math.atan2(-c, d), p = Math.atan2(l, u), m = Math.abs(f + p);
      return m < 1e-5 || Math.abs(e.PI_2 - m) < 1e-5 ? (s.rotation = p, s.skew.x = s.skew.y = 0) : (s.rotation = 0, s.skew.x = f, s.skew.y = p), s.scale.x = Math.sqrt(u * u + l * l), s.scale.y = Math.sqrt(c * c + d * d), s.position.x = this.tx, s.position.y = this.ty, s;
    }
    /**
     * Inverts this matrix
     *
     * @return {InkPaint.Matrix} This matrix. Good for chaining method calls.
     */
    invert() {
      var s = this.a, u = this.b, l = this.c, c = this.d, d = this.tx, f = s * c - u * l;
      return this.a = c / f, this.b = -u / f, this.c = -l / f, this.d = s / f, this.tx = (l * this.ty - c * d) / f, this.ty = -(s * this.ty - u * d) / f, this;
    }
    /**
     * Resets this Matix to an identity (default) matrix.
     *
     * @return {InkPaint.Matrix} This matrix. Good for chaining method calls.
     */
    identity() {
      return this.a = 1, this.b = 0, this.c = 0, this.d = 1, this.tx = 0, this.ty = 0, this;
    }
    /**
     * Creates a new Matrix object with the same values as this one.
     *
     * @return {InkPaint.Matrix} A copy of this matrix. Good for chaining method calls.
     */
    clone() {
      var s = new wu();
      return s.a = this.a, s.b = this.b, s.c = this.c, s.d = this.d, s.tx = this.tx, s.ty = this.ty, s;
    }
    /**
     * Changes the values of the given matrix to be the same as the ones in this matrix
     *
     * @param {InkPaint.Matrix} matrix - The matrix to copy from.
     * @return {InkPaint.Matrix} The matrix given in parameter with its values updated.
     */
    copy(s) {
      return s.a = this.a, s.b = this.b, s.c = this.c, s.d = this.d, s.tx = this.tx, s.ty = this.ty, s;
    }
    /**
     * A default (identity) matrix
     *
     * @static
     * @const
     */
    static get IDENTITY() {
      return new wu();
    }
    /**
     * A temp matrix
     *
     * @static
     * @const
     */
    static get TEMP_MATRIX() {
      return new wu();
    }
  };
  return Matrix.default = r, Matrix;
}
var GroupD8 = {}, hasRequiredGroupD8;
function requireGroupD8() {
  if (hasRequiredGroupD8) return GroupD8;
  hasRequiredGroupD8 = 1, Object.defineProperty(GroupD8, "__esModule", {
    value: true
  }), GroupD8.default = void 0;
  var i2 = e(requireMatrix());
  function e(m) {
    return m && m.__esModule ? m : { default: m };
  }
  var t = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1], r = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1], a = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1], s = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1], u = [], l = [];
  function c(m) {
    return m < 0 ? -1 : m > 0 ? 1 : 0;
  }
  function d() {
    for (var m = 0; m < 16; m++) {
      var y = [];
      l.push(y);
      for (var x = 0; x < 16; x++)
        for (var g = c(t[m] * t[x] + a[m] * r[x]), _ = c(r[m] * t[x] + s[m] * r[x]), T = c(t[m] * a[x] + a[m] * s[x]), E = c(r[m] * a[x] + s[m] * s[x]), b = 0; b < 16; b++)
          if (t[b] === g && r[b] === _ && a[b] === T && s[b] === E) {
            y.push(b);
            break;
          }
    }
    for (var C = 0; C < 16; C++) {
      var w = new i2.default();
      w.set(t[C], r[C], a[C], s[C], 0, 0), u.push(w);
    }
  }
  d();
  var f = {
    E: 0,
    SE: 1,
    S: 2,
    SW: 3,
    W: 4,
    NW: 5,
    N: 6,
    NE: 7,
    MIRROR_VERTICAL: 8,
    MIRROR_HORIZONTAL: 12,
    uX: (m) => t[m],
    uY: (m) => r[m],
    vX: (m) => a[m],
    vY: (m) => s[m],
    inv: (m) => m & 8 ? m & 15 : -m & 7,
    add: (m, y) => l[m][y],
    sub: (m, y) => l[m][f.inv(y)],
    rotate180: (m) => m ^ 4,
    isVertical: (m) => (m & 3) === 2,
    byDirection: (m, y) => Math.abs(m) * 2 <= Math.abs(y) ? y >= 0 ? f.S : f.N : Math.abs(y) * 2 <= Math.abs(m) ? m > 0 ? f.E : f.W : y > 0 ? m > 0 ? f.SE : f.SW : m > 0 ? f.NE : f.NW,
    matrixAppendRotationInv: function(m, y, x, g) {
      x === void 0 && (x = 0), g === void 0 && (g = 0);
      var _ = u[f.inv(y)];
      _.tx = x, _.ty = g, m.append(_);
    }
  }, p = f;
  return GroupD8.default = p, GroupD8;
}
var Circle = {}, Rectangle = {}, hasRequiredRectangle;
function requireRectangle() {
  if (hasRequiredRectangle) return Rectangle;
  hasRequiredRectangle = 1, Object.defineProperty(Rectangle, "__esModule", {
    value: true
  }), Rectangle.default = void 0;
  var i2 = require_const();
  let e = class Cm {
    constructor(r, a, s, u) {
      r === void 0 && (r = 0), a === void 0 && (a = 0), s === void 0 && (s = 0), u === void 0 && (u = 0), this.x = Number(r), this.y = Number(a), this.width = Number(s), this.height = Number(u), this.type = i2.SHAPES.RECT;
    }
    get left() {
      return this.x;
    }
    get right() {
      return this.x + this.width;
    }
    get top() {
      return this.y;
    }
    get bottom() {
      return this.y + this.height;
    }
    static get EMPTY() {
      return new Cm(0, 0, 0, 0);
    }
    clone() {
      return new Cm(this.x, this.y, this.width, this.height);
    }
    copy(r) {
      return this.x = r.x, this.y = r.y, this.width = r.width, this.height = r.height, this;
    }
    contains(r, a) {
      return this.width <= 0 || this.height <= 0 ? false : r >= this.x && r < this.x + this.width && a >= this.y && a < this.y + this.height;
    }
    pad(r, a) {
      r = r || 0, a = a || (a !== 0 ? r : 0), this.x -= r, this.y -= a, this.width += r * 2, this.height += a * 2;
    }
    fit(r) {
      var a = Math.max(this.x, r.x), s = Math.min(this.x + this.width, r.x + r.width), u = Math.max(this.y, r.y), l = Math.min(this.y + this.height, r.y + r.height);
      this.x = a, this.width = Math.max(s - a, 0), this.y = u, this.height = Math.max(l - u, 0);
    }
    /**
     * Enlarges this rectangle to include the passed rectangle.
     *
     * @param {InkPaint.Rectangle} rectangle - The rectangle to include.
     */
    enlarge(r) {
      var a = Math.min(this.x, r.x), s = Math.max(this.x + this.width, r.x + r.width), u = Math.min(this.y, r.y), l = Math.max(this.y + this.height, r.y + r.height);
      this.x = a, this.width = s - a, this.y = u, this.height = l - u;
    }
    ceil(r, a) {
      r === void 0 && (r = 1), a === void 0 && (a = 1e-3);
      var s = Math.ceil((this.x + this.width - a) * r) / r, u = Math.ceil((this.y + this.height - a) * r) / r;
      this.x = Math.floor((this.x + a) * r) / r, this.y = Math.floor((this.y + a) * r) / r, this.width = s - this.x, this.height = u - this.y;
    }
    toString() {
      return "Rect:: " + this.x + "_" + this.y + "_" + this.width + "_" + this.height;
    }
  };
  return Rectangle.default = e, Rectangle;
}
var hasRequiredCircle;
function requireCircle() {
  if (hasRequiredCircle) return Circle;
  hasRequiredCircle = 1, Object.defineProperty(Circle, "__esModule", {
    value: true
  }), Circle.default = void 0;
  var i2 = t(requireRectangle()), e = require_const();
  function t(a) {
    return a && a.__esModule ? a : { default: a };
  }
  let r = class Im {
    /**
     * @param {number} [x=0] - The X coordinate of the center of this circle
     * @param {number} [y=0] - The Y coordinate of the center of this circle
     * @param {number} [radius=0] - The radius of the circle
     */
    constructor(s, u, l) {
      s === void 0 && (s = 0), u === void 0 && (u = 0), l === void 0 && (l = 0), this.x = s, this.y = u, this.radius = l, this.type = e.SHAPES.CIRC;
    }
    /**
     * Creates a clone of this Circle instance
     *
     * @return {InkPaint.Circle} a copy of the Circle
     */
    clone() {
      return new Im(this.x, this.y, this.radius);
    }
    /**
     * Checks whether the x and y coordinates given are contained within this circle
     *
     * @param {number} x - The X coordinate of the point to test
     * @param {number} y - The Y coordinate of the point to test
     * @return {boolean} Whether the x/y coordinates are within this Circle
     */
    contains(s, u) {
      if (this.radius <= 0)
        return false;
      var l = this.radius * this.radius, c = this.x - s, d = this.y - u;
      return c *= c, d *= d, c + d <= l;
    }
    /**
     * Returns the framing rectangle of the circle as a Rectangle object
     *
     * @return {InkPaint.Rectangle} the framing rectangle
     */
    getBounds() {
      return new i2.default(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);
    }
  };
  return Circle.default = r, Circle;
}
var Ellipse = {}, hasRequiredEllipse;
function requireEllipse() {
  if (hasRequiredEllipse) return Ellipse;
  hasRequiredEllipse = 1, Object.defineProperty(Ellipse, "__esModule", {
    value: true
  }), Ellipse.default = void 0;
  var i2 = t(requireRectangle()), e = require_const();
  function t(a) {
    return a && a.__esModule ? a : { default: a };
  }
  let r = class Pm {
    /**
     * @param {number} [x=0] - The X coordinate of the center of this ellipse
     * @param {number} [y=0] - The Y coordinate of the center of this ellipse
     * @param {number} [halfWidth=0] - The half width of this ellipse
     * @param {number} [halfHeight=0] - The half height of this ellipse
     */
    constructor(s, u, l, c) {
      s === void 0 && (s = 0), u === void 0 && (u = 0), l === void 0 && (l = 0), c === void 0 && (c = 0), this.x = s, this.y = u, this.width = l, this.height = c, this.type = e.SHAPES.ELIP;
    }
    /**
     * Creates a clone of this Ellipse instance
     *
     * @return {InkPaint.Ellipse} a copy of the ellipse
     */
    clone() {
      return new Pm(this.x, this.y, this.width, this.height);
    }
    /**
     * Checks whether the x and y coordinates given are contained within this ellipse
     *
     * @param {number} x - The X coordinate of the point to test
     * @param {number} y - The Y coordinate of the point to test
     * @return {boolean} Whether the x/y coords are within this ellipse
     */
    contains(s, u) {
      if (this.width <= 0 || this.height <= 0)
        return false;
      var l = (s - this.x) / this.width, c = (u - this.y) / this.height;
      return l *= l, c *= c, l + c <= 1;
    }
    /**
     * Returns the framing rectangle of the ellipse as a Rectangle object
     *
     * @return {InkPaint.Rectangle} the framing rectangle
     */
    getBounds() {
      return new i2.default(this.x - this.width, this.y - this.height, this.width, this.height);
    }
  };
  return Ellipse.default = r, Ellipse;
}
var Polygon = {}, hasRequiredPolygon;
function requirePolygon() {
  if (hasRequiredPolygon) return Polygon;
  hasRequiredPolygon = 1, Object.defineProperty(Polygon, "__esModule", {
    value: true
  }), Polygon.default = void 0;
  var i2 = t(requirePoint()), e = require_const();
  function t(a) {
    return a && a.__esModule ? a : { default: a };
  }
  let r = class qm {
    constructor() {
      for (var s = arguments.length, u = new Array(s), l = 0; l < s; l++)
        u[l] = arguments[l];
      if (Array.isArray(u[0]) && (u = u[0]), u[0] instanceof i2.default) {
        for (var c = [], d = 0, f = u.length; d < f; d++)
          c.push(u[d].x, u[d].y);
        u = c;
      }
      this.closed = true, this.points = u, this.type = e.SHAPES.POLY;
    }
    /**
     * Creates a clone of this polygon
     *
     * @return {InkPaint.Polygon} a copy of the polygon
     */
    clone() {
      return new qm(this.points.slice());
    }
    /**
     * Closes the polygon, adding points if necessary.
     *
     */
    close() {
      var s = this.points;
      (s[0] !== s[s.length - 2] || s[1] !== s[s.length - 1]) && s.push(s[0], s[1]);
    }
    /**
     * Checks whether the x and y coordinates passed to this function are contained within this polygon
     *
     * @param {number} x - The X coordinate of the point to test
     * @param {number} y - The Y coordinate of the point to test
     * @return {boolean} Whether the x/y coordinates are within this polygon
     */
    contains(s, u) {
      for (var l = false, c = this.points.length / 2, d = 0, f = c - 1; d < c; f = d++) {
        var p = this.points[d * 2], m = this.points[d * 2 + 1], y = this.points[f * 2], x = this.points[f * 2 + 1], g = m > u != x > u && s < (y - p) * ((u - m) / (x - m)) + p;
        g && (l = !l);
      }
      return l;
    }
  };
  return Polygon.default = r, Polygon;
}
var RoundedRectangle = {}, hasRequiredRoundedRectangle;
function requireRoundedRectangle() {
  if (hasRequiredRoundedRectangle) return RoundedRectangle;
  hasRequiredRoundedRectangle = 1, Object.defineProperty(RoundedRectangle, "__esModule", {
    value: true
  }), RoundedRectangle.default = void 0;
  var i2 = require_const();
  let e = class km {
    /**
     * @param {number} [x=0] - The X coordinate of the upper-left corner of the rounded rectangle
     * @param {number} [y=0] - The Y coordinate of the upper-left corner of the rounded rectangle
     * @param {number} [width=0] - The overall width of this rounded rectangle
     * @param {number} [height=0] - The overall height of this rounded rectangle
     * @param {number} [radius=20] - Controls the radius of the rounded corners
     */
    constructor(r, a, s, u, l) {
      r === void 0 && (r = 0), a === void 0 && (a = 0), s === void 0 && (s = 0), u === void 0 && (u = 0), l === void 0 && (l = 20), this.x = r, this.y = a, this.width = s, this.height = u, this.radius = l, this.type = i2.SHAPES.RREC;
    }
    /**
     * Creates a clone of this Rounded Rectangle
     *
     * @return {InkPaint.RoundedRectangle} a copy of the rounded rectangle
     */
    clone() {
      return new km(this.x, this.y, this.width, this.height, this.radius);
    }
    /**
     * Checks whether the x and y coordinates given are contained within this Rounded Rectangle
     *
     * @param {number} x - The X coordinate of the point to test
     * @param {number} y - The Y coordinate of the point to test
     * @return {boolean} Whether the x/y coordinates are within this Rounded Rectangle
     */
    contains(r, a) {
      if (this.width <= 0 || this.height <= 0)
        return false;
      if (r >= this.x && r <= this.x + this.width && a >= this.y && a <= this.y + this.height) {
        if (a >= this.y + this.radius && a <= this.y + this.height - this.radius || r >= this.x + this.radius && r <= this.x + this.width - this.radius)
          return true;
        var s = r - (this.x + this.radius), u = a - (this.y + this.radius), l = this.radius * this.radius;
        if (s * s + u * u <= l || (s = r - (this.x + this.width - this.radius), s * s + u * u <= l) || (u = a - (this.y + this.height - this.radius), s * s + u * u <= l) || (s = r - (this.x + this.radius), s * s + u * u <= l))
          return true;
      }
      return false;
    }
  };
  return RoundedRectangle.default = e, RoundedRectangle;
}
var hasRequiredMath$1;
function requireMath$1() {
  return hasRequiredMath$1 || (hasRequiredMath$1 = 1, function(i2) {
    Object.defineProperty(i2, "__esModule", {
      value: true
    }), Object.defineProperty(i2, "Circle", {
      enumerable: true,
      get: function() {
        return s.default;
      }
    }), Object.defineProperty(i2, "Ellipse", {
      enumerable: true,
      get: function() {
        return u.default;
      }
    }), Object.defineProperty(i2, "GroupD8", {
      enumerable: true,
      get: function() {
        return a.default;
      }
    }), Object.defineProperty(i2, "Matrix", {
      enumerable: true,
      get: function() {
        return r.default;
      }
    }), Object.defineProperty(i2, "ObservablePoint", {
      enumerable: true,
      get: function() {
        return t.default;
      }
    }), Object.defineProperty(i2, "Point", {
      enumerable: true,
      get: function() {
        return e.default;
      }
    }), Object.defineProperty(i2, "Polygon", {
      enumerable: true,
      get: function() {
        return l.default;
      }
    }), Object.defineProperty(i2, "Rectangle", {
      enumerable: true,
      get: function() {
        return c.default;
      }
    }), Object.defineProperty(i2, "RoundedRectangle", {
      enumerable: true,
      get: function() {
        return d.default;
      }
    });
    var e = f(requirePoint()), t = f(requireObservablePoint()), r = f(requireMatrix()), a = f(requireGroupD8()), s = f(requireCircle()), u = f(requireEllipse()), l = f(requirePolygon()), c = f(requireRectangle()), d = f(requireRoundedRectangle());
    function f(p) {
      return p && p.__esModule ? p : { default: p };
    }
  }(math$1)), math$1;
}
var utils$3 = {}, earcut = { exports: {} }, hasRequiredEarcut;
function requireEarcut() {
  if (hasRequiredEarcut) return earcut.exports;
  hasRequiredEarcut = 1, earcut.exports = i2, earcut.exports.default = i2;
  function i2(k, I, P) {
    P = P || 2;
    var G = I && I.length, W = G ? I[0] * P : k.length, V = e(k, 0, W, P, true), K = [];
    if (!V || V.next === V.prev) return K;
    var J, ae, re, he, ge, me, Te;
    if (G && (V = c(k, I, V, P)), k.length > 80 * P) {
      J = re = k[0], ae = he = k[1];
      for (var _e = P; _e < W; _e += P)
        ge = k[_e], me = k[_e + 1], ge < J && (J = ge), me < ae && (ae = me), ge > re && (re = ge), me > he && (he = me);
      Te = Math.max(re - J, he - ae), Te = Te !== 0 ? 32767 / Te : 0;
    }
    return r(V, K, P, J, ae, Te, 0), K;
  }
  function e(k, I, P, G, W) {
    var V, K;
    if (W === X(k, I, P, G) > 0)
      for (V = I; V < P; V += G) K = q(V, k[V], k[V + 1], K);
    else
      for (V = P - G; V >= I; V -= G) K = q(V, k[V], k[V + 1], K);
    return K && C(K, K.next) && (z(K), K = K.next), K;
  }
  function t(k, I) {
    if (!k) return k;
    I || (I = k);
    var P = k, G;
    do
      if (G = false, !P.steiner && (C(P, P.next) || b(P.prev, P, P.next) === 0)) {
        if (z(P), P = I = P.prev, P === P.next) break;
        G = true;
      } else
        P = P.next;
    while (G || P !== I);
    return I;
  }
  function r(k, I, P, G, W, V, K) {
    if (k) {
      !K && V && y(k, G, W, V);
      for (var J = k, ae, re; k.prev !== k.next; ) {
        if (ae = k.prev, re = k.next, V ? s(k, G, W, V) : a(k)) {
          I.push(ae.i / P | 0), I.push(k.i / P | 0), I.push(re.i / P | 0), z(k), k = re.next, J = re.next;
          continue;
        }
        if (k = re, k === J) {
          K ? K === 1 ? (k = u(t(k), I, P), r(k, I, P, G, W, V, 2)) : K === 2 && l(k, I, P, G, W, V) : r(t(k), I, P, G, W, V, 1);
          break;
        }
      }
    }
  }
  function a(k) {
    var I = k.prev, P = k, G = k.next;
    if (b(I, P, G) >= 0) return false;
    for (var W = I.x, V = P.x, K = G.x, J = I.y, ae = P.y, re = G.y, he = W < V ? W < K ? W : K : V < K ? V : K, ge = J < ae ? J < re ? J : re : ae < re ? ae : re, me = W > V ? W > K ? W : K : V > K ? V : K, Te = J > ae ? J > re ? J : re : ae > re ? ae : re, _e = G.next; _e !== I; ) {
      if (_e.x >= he && _e.x <= me && _e.y >= ge && _e.y <= Te && T(W, J, V, ae, K, re, _e.x, _e.y) && b(_e.prev, _e, _e.next) >= 0) return false;
      _e = _e.next;
    }
    return true;
  }
  function s(k, I, P, G) {
    var W = k.prev, V = k, K = k.next;
    if (b(W, V, K) >= 0) return false;
    for (var J = W.x, ae = V.x, re = K.x, he = W.y, ge = V.y, me = K.y, Te = J < ae ? J < re ? J : re : ae < re ? ae : re, _e = he < ge ? he < me ? he : me : ge < me ? ge : me, ye = J > ae ? J > re ? J : re : ae > re ? ae : re, Ae = he > ge ? he > me ? he : me : ge > me ? ge : me, ke = g(Te, _e, I, P, G), Pe = g(ye, Ae, I, P, G), Ee = k.prevZ, Oe = k.nextZ; Ee && Ee.z >= ke && Oe && Oe.z <= Pe; ) {
      if (Ee.x >= Te && Ee.x <= ye && Ee.y >= _e && Ee.y <= Ae && Ee !== W && Ee !== K && T(J, he, ae, ge, re, me, Ee.x, Ee.y) && b(Ee.prev, Ee, Ee.next) >= 0 || (Ee = Ee.prevZ, Oe.x >= Te && Oe.x <= ye && Oe.y >= _e && Oe.y <= Ae && Oe !== W && Oe !== K && T(J, he, ae, ge, re, me, Oe.x, Oe.y) && b(Oe.prev, Oe, Oe.next) >= 0)) return false;
      Oe = Oe.nextZ;
    }
    for (; Ee && Ee.z >= ke; ) {
      if (Ee.x >= Te && Ee.x <= ye && Ee.y >= _e && Ee.y <= Ae && Ee !== W && Ee !== K && T(J, he, ae, ge, re, me, Ee.x, Ee.y) && b(Ee.prev, Ee, Ee.next) >= 0) return false;
      Ee = Ee.prevZ;
    }
    for (; Oe && Oe.z <= Pe; ) {
      if (Oe.x >= Te && Oe.x <= ye && Oe.y >= _e && Oe.y <= Ae && Oe !== W && Oe !== K && T(J, he, ae, ge, re, me, Oe.x, Oe.y) && b(Oe.prev, Oe, Oe.next) >= 0) return false;
      Oe = Oe.nextZ;
    }
    return true;
  }
  function u(k, I, P) {
    var G = k;
    do {
      var W = G.prev, V = G.next.next;
      !C(W, V) && w(W, G, G.next, V) && M(W, V) && M(V, W) && (I.push(W.i / P | 0), I.push(G.i / P | 0), I.push(V.i / P | 0), z(G), z(G.next), G = k = V), G = G.next;
    } while (G !== k);
    return t(G);
  }
  function l(k, I, P, G, W, V) {
    var K = k;
    do {
      for (var J = K.next.next; J !== K.prev; ) {
        if (K.i !== J.i && E(K, J)) {
          var ae = B(K, J);
          K = t(K, K.next), ae = t(ae, ae.next), r(K, I, P, G, W, V, 0), r(ae, I, P, G, W, V, 0);
          return;
        }
        J = J.next;
      }
      K = K.next;
    } while (K !== k);
  }
  function c(k, I, P, G) {
    var W = [], V, K, J, ae, re;
    for (V = 0, K = I.length; V < K; V++)
      J = I[V] * G, ae = V < K - 1 ? I[V + 1] * G : k.length, re = e(k, J, ae, G, false), re === re.next && (re.steiner = true), W.push(_(re));
    for (W.sort(d), V = 0; V < W.length; V++)
      P = f(W[V], P);
    return P;
  }
  function d(k, I) {
    return k.x - I.x;
  }
  function f(k, I) {
    var P = p(k, I);
    if (!P)
      return I;
    var G = B(P, k);
    return t(G, G.next), t(P, P.next);
  }
  function p(k, I) {
    var P = I, G = k.x, W = k.y, V = -1 / 0, K;
    do {
      if (W <= P.y && W >= P.next.y && P.next.y !== P.y) {
        var J = P.x + (W - P.y) * (P.next.x - P.x) / (P.next.y - P.y);
        if (J <= G && J > V && (V = J, K = P.x < P.next.x ? P : P.next, J === G))
          return K;
      }
      P = P.next;
    } while (P !== I);
    if (!K) return null;
    var ae = K, re = K.x, he = K.y, ge = 1 / 0, me;
    P = K;
    do
      G >= P.x && P.x >= re && G !== P.x && T(W < he ? G : V, W, re, he, W < he ? V : G, W, P.x, P.y) && (me = Math.abs(W - P.y) / (G - P.x), M(P, k) && (me < ge || me === ge && (P.x > K.x || P.x === K.x && m(K, P))) && (K = P, ge = me)), P = P.next;
    while (P !== ae);
    return K;
  }
  function m(k, I) {
    return b(k.prev, k, I.prev) < 0 && b(I.next, k, k.next) < 0;
  }
  function y(k, I, P, G) {
    var W = k;
    do
      W.z === 0 && (W.z = g(W.x, W.y, I, P, G)), W.prevZ = W.prev, W.nextZ = W.next, W = W.next;
    while (W !== k);
    W.prevZ.nextZ = null, W.prevZ = null, x(W);
  }
  function x(k) {
    var I, P, G, W, V, K, J, ae, re = 1;
    do {
      for (P = k, k = null, V = null, K = 0; P; ) {
        for (K++, G = P, J = 0, I = 0; I < re && (J++, G = G.nextZ, !!G); I++)
          ;
        for (ae = re; J > 0 || ae > 0 && G; )
          J !== 0 && (ae === 0 || !G || P.z <= G.z) ? (W = P, P = P.nextZ, J--) : (W = G, G = G.nextZ, ae--), V ? V.nextZ = W : k = W, W.prevZ = V, V = W;
        P = G;
      }
      V.nextZ = null, re *= 2;
    } while (K > 1);
    return k;
  }
  function g(k, I, P, G, W) {
    return k = (k - P) * W | 0, I = (I - G) * W | 0, k = (k | k << 8) & 16711935, k = (k | k << 4) & 252645135, k = (k | k << 2) & 858993459, k = (k | k << 1) & 1431655765, I = (I | I << 8) & 16711935, I = (I | I << 4) & 252645135, I = (I | I << 2) & 858993459, I = (I | I << 1) & 1431655765, k | I << 1;
  }
  function _(k) {
    var I = k, P = k;
    do
      (I.x < P.x || I.x === P.x && I.y < P.y) && (P = I), I = I.next;
    while (I !== k);
    return P;
  }
  function T(k, I, P, G, W, V, K, J) {
    return (W - K) * (I - J) >= (k - K) * (V - J) && (k - K) * (G - J) >= (P - K) * (I - J) && (P - K) * (V - J) >= (W - K) * (G - J);
  }
  function E(k, I) {
    return k.next.i !== I.i && k.prev.i !== I.i && !F(k, I) && // dones't intersect other edges
    (M(k, I) && M(I, k) && U(k, I) && // locally visible
    (b(k.prev, k, I.prev) || b(k, I.prev, I)) || // does not create opposite-facing sectors
    C(k, I) && b(k.prev, k, k.next) > 0 && b(I.prev, I, I.next) > 0);
  }
  function b(k, I, P) {
    return (I.y - k.y) * (P.x - I.x) - (I.x - k.x) * (P.y - I.y);
  }
  function C(k, I) {
    return k.x === I.x && k.y === I.y;
  }
  function w(k, I, P, G) {
    var W = S(b(k, I, P)), V = S(b(k, I, G)), K = S(b(P, G, k)), J = S(b(P, G, I));
    return !!(W !== V && K !== J || W === 0 && A(k, P, I) || V === 0 && A(k, G, I) || K === 0 && A(P, k, G) || J === 0 && A(P, I, G));
  }
  function A(k, I, P) {
    return I.x <= Math.max(k.x, P.x) && I.x >= Math.min(k.x, P.x) && I.y <= Math.max(k.y, P.y) && I.y >= Math.min(k.y, P.y);
  }
  function S(k) {
    return k > 0 ? 1 : k < 0 ? -1 : 0;
  }
  function F(k, I) {
    var P = k;
    do {
      if (P.i !== k.i && P.next.i !== k.i && P.i !== I.i && P.next.i !== I.i && w(P, P.next, k, I)) return true;
      P = P.next;
    } while (P !== k);
    return false;
  }
  function M(k, I) {
    return b(k.prev, k, k.next) < 0 ? b(k, I, k.next) >= 0 && b(k, k.prev, I) >= 0 : b(k, I, k.prev) < 0 || b(k, k.next, I) < 0;
  }
  function U(k, I) {
    var P = k, G = false, W = (k.x + I.x) / 2, V = (k.y + I.y) / 2;
    do
      P.y > V != P.next.y > V && P.next.y !== P.y && W < (P.next.x - P.x) * (V - P.y) / (P.next.y - P.y) + P.x && (G = !G), P = P.next;
    while (P !== k);
    return G;
  }
  function B(k, I) {
    var P = new D(k.i, k.x, k.y), G = new D(I.i, I.x, I.y), W = k.next, V = I.prev;
    return k.next = I, I.prev = k, P.next = W, W.prev = P, G.next = P, P.prev = G, V.next = G, G.prev = V, G;
  }
  function q(k, I, P, G) {
    var W = new D(k, I, P);
    return G ? (W.next = G.next, W.prev = G, G.next.prev = W, G.next = W) : (W.prev = W, W.next = W), W;
  }
  function z(k) {
    k.next.prev = k.prev, k.prev.next = k.next, k.prevZ && (k.prevZ.nextZ = k.nextZ), k.nextZ && (k.nextZ.prevZ = k.prevZ);
  }
  function D(k, I, P) {
    this.i = k, this.x = I, this.y = P, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = false;
  }
  i2.deviation = function(k, I, P, G) {
    var W = I && I.length, V = W ? I[0] * P : k.length, K = Math.abs(X(k, 0, V, P));
    if (W)
      for (var J = 0, ae = I.length; J < ae; J++) {
        var re = I[J] * P, he = J < ae - 1 ? I[J + 1] * P : k.length;
        K -= Math.abs(X(k, re, he, P));
      }
    var ge = 0;
    for (J = 0; J < G.length; J += 3) {
      var me = G[J] * P, Te = G[J + 1] * P, _e = G[J + 2] * P;
      ge += Math.abs(
        (k[me] - k[_e]) * (k[Te + 1] - k[me + 1]) - (k[me] - k[Te]) * (k[_e + 1] - k[me + 1])
      );
    }
    return K === 0 && ge === 0 ? 0 : Math.abs((ge - K) / K);
  };
  function X(k, I, P, G) {
    for (var W = 0, V = I, K = P - G; V < P; V += G)
      W += (k[K] - k[V]) * (k[V + 1] + k[K + 1]), K = V;
    return W;
  }
  return i2.flatten = function(k) {
    for (var I = k[0][0].length, P = { vertices: [], holes: [], dimensions: I }, G = 0, W = 0; W < k.length; W++) {
      for (var V = 0; V < k[W].length; V++)
        for (var K = 0; K < I; K++) P.vertices.push(k[W][V][K]);
      W > 0 && (G += k[W - 1].length, P.holes.push(G));
    }
    return P;
  }, earcut.exports;
}
var mixin$2 = {}, hasRequiredMixin$2;
function requireMixin$2() {
  if (hasRequiredMixin$2) return mixin$2;
  hasRequiredMixin$2 = 1, Object.defineProperty(mixin$2, "__esModule", {
    value: true
  }), mixin$2.delayMixin = t, mixin$2.mixin = i2, mixin$2.performMixins = r;
  function i2(a, s) {
    if (!(!a || !s))
      for (var u = Object.keys(s), l = 0; l < u.length; ++l) {
        var c = u[l];
        Object.defineProperty(a, c, Object.getOwnPropertyDescriptor(s, c));
      }
  }
  var e = [];
  function t(a, s) {
    e.push(a, s);
  }
  function r() {
    for (var a = 0; a < e.length; a += 2)
      i2(e[a], e[a + 1]);
    e.length = 0;
  }
  return mixin$2;
}
var eventemitter3$1 = { exports: {} }, hasRequiredEventemitter3$1;
function requireEventemitter3$1() {
  return hasRequiredEventemitter3$1 || (hasRequiredEventemitter3$1 = 1, function(i2) {
    var e = Object.prototype.hasOwnProperty, t = "~";
    function r() {
    }
    Object.create && (r.prototype = /* @__PURE__ */ Object.create(null), new r().__proto__ || (t = false));
    function a(u, l, c) {
      this.fn = u, this.context = l, this.once = c || false;
    }
    function s() {
      this._events = new r(), this._eventsCount = 0;
    }
    s.prototype.eventNames = function() {
      var u = [], l, c;
      if (this._eventsCount === 0) return u;
      for (c in l = this._events)
        e.call(l, c) && u.push(t ? c.slice(1) : c);
      return Object.getOwnPropertySymbols ? u.concat(Object.getOwnPropertySymbols(l)) : u;
    }, s.prototype.listeners = function(u, l) {
      var c = t ? t + u : u, d = this._events[c];
      if (l) return !!d;
      if (!d) return [];
      if (d.fn) return [d.fn];
      for (var f = 0, p = d.length, m = new Array(p); f < p; f++)
        m[f] = d[f].fn;
      return m;
    }, s.prototype.emit = function(u, l, c, d, f, p) {
      var m = t ? t + u : u;
      if (!this._events[m]) return false;
      var y = this._events[m], x = arguments.length, g, _;
      if (y.fn) {
        switch (y.once && this.removeListener(u, y.fn, void 0, true), x) {
          case 1:
            return y.fn.call(y.context), true;
          case 2:
            return y.fn.call(y.context, l), true;
          case 3:
            return y.fn.call(y.context, l, c), true;
          case 4:
            return y.fn.call(y.context, l, c, d), true;
          case 5:
            return y.fn.call(y.context, l, c, d, f), true;
          case 6:
            return y.fn.call(y.context, l, c, d, f, p), true;
        }
        for (_ = 1, g = new Array(x - 1); _ < x; _++)
          g[_ - 1] = arguments[_];
        y.fn.apply(y.context, g);
      } else {
        var T = y.length, E;
        for (_ = 0; _ < T; _++)
          switch (y[_].once && this.removeListener(u, y[_].fn, void 0, true), x) {
            case 1:
              y[_].fn.call(y[_].context);
              break;
            case 2:
              y[_].fn.call(y[_].context, l);
              break;
            case 3:
              y[_].fn.call(y[_].context, l, c);
              break;
            case 4:
              y[_].fn.call(y[_].context, l, c, d);
              break;
            default:
              if (!g) for (E = 1, g = new Array(x - 1); E < x; E++)
                g[E - 1] = arguments[E];
              y[_].fn.apply(y[_].context, g);
          }
      }
      return true;
    }, s.prototype.on = function(u, l, c) {
      var d = new a(l, c || this), f = t ? t + u : u;
      return this._events[f] ? this._events[f].fn ? this._events[f] = [this._events[f], d] : this._events[f].push(d) : (this._events[f] = d, this._eventsCount++), this;
    }, s.prototype.once = function(u, l, c) {
      var d = new a(l, c || this, true), f = t ? t + u : u;
      return this._events[f] ? this._events[f].fn ? this._events[f] = [this._events[f], d] : this._events[f].push(d) : (this._events[f] = d, this._eventsCount++), this;
    }, s.prototype.removeListener = function(u, l, c, d) {
      var f = t ? t + u : u;
      if (!this._events[f]) return this;
      if (!l)
        return --this._eventsCount === 0 ? this._events = new r() : delete this._events[f], this;
      var p = this._events[f];
      if (p.fn)
        p.fn === l && (!d || p.once) && (!c || p.context === c) && (--this._eventsCount === 0 ? this._events = new r() : delete this._events[f]);
      else {
        for (var m = 0, y = [], x = p.length; m < x; m++)
          (p[m].fn !== l || d && !p[m].once || c && p[m].context !== c) && y.push(p[m]);
        y.length ? this._events[f] = y.length === 1 ? y[0] : y : --this._eventsCount === 0 ? this._events = new r() : delete this._events[f];
      }
      return this;
    }, s.prototype.removeAllListeners = function(u) {
      var l;
      return u ? (l = t ? t + u : u, this._events[l] && (--this._eventsCount === 0 ? this._events = new r() : delete this._events[l])) : (this._events = new r(), this._eventsCount = 0), this;
    }, s.prototype.off = s.prototype.removeListener, s.prototype.addListener = s.prototype.on, s.prototype.setMaxListeners = function() {
      return this;
    }, s.prefixed = t, s.EventEmitter = s, i2.exports = s;
  }(eventemitter3$1)), eventemitter3$1.exports;
}
var pluginTarget = {}, hasRequiredPluginTarget;
function requirePluginTarget() {
  if (hasRequiredPluginTarget) return pluginTarget;
  hasRequiredPluginTarget = 1, Object.defineProperty(pluginTarget, "__esModule", {
    value: true
  }), pluginTarget.default = void 0;
  function i2(t) {
    t.__plugins = {}, t.registerPlugin = function(r, a) {
      t.__plugins[r] = a;
    }, t.prototype.initPlugins = function() {
      this.plugins = this.plugins || {};
      for (var r in t.__plugins)
        this.plugins[r] = new t.__plugins[r](this);
    }, t.prototype.destroyPlugins = function() {
      for (var r in this.plugins)
        this.plugins[r].destroy(), this.plugins[r] = null;
      this.plugins = null;
    };
  }
  var e = {
    mixin: function(t) {
      i2(t);
    }
  };
  return pluginTarget.default = e, pluginTarget;
}
var mapPremultipliedBlendModes = {}, hasRequiredMapPremultipliedBlendModes;
function requireMapPremultipliedBlendModes() {
  if (hasRequiredMapPremultipliedBlendModes) return mapPremultipliedBlendModes;
  hasRequiredMapPremultipliedBlendModes = 1, Object.defineProperty(mapPremultipliedBlendModes, "__esModule", {
    value: true
  }), mapPremultipliedBlendModes.default = e;
  var i2 = require_const();
  function e() {
    for (var t = [], r = [], a = 0; a < 32; a++)
      t[a] = a, r[a] = a;
    t[i2.BLEND_MODES.NORMAL_NPM] = i2.BLEND_MODES.NORMAL, t[i2.BLEND_MODES.ADD_NPM] = i2.BLEND_MODES.ADD, t[i2.BLEND_MODES.SCREEN_NPM] = i2.BLEND_MODES.SCREEN, r[i2.BLEND_MODES.NORMAL] = i2.BLEND_MODES.NORMAL_NPM, r[i2.BLEND_MODES.ADD] = i2.BLEND_MODES.ADD_NPM, r[i2.BLEND_MODES.SCREEN] = i2.BLEND_MODES.SCREEN_NPM;
    var s = [];
    return s.push(r), s.push(t), s;
  }
  return mapPremultipliedBlendModes;
}
var hasRequiredUtils$3;
function requireUtils$3() {
  return hasRequiredUtils$3 || (hasRequiredUtils$3 = 1, function(i2) {
    Object.defineProperty(i2, "__esModule", {
      value: true
    }), Object.defineProperty(i2, "EventEmitter", {
      enumerable: true,
      get: function() {
        return r.default;
      }
    }), i2.correctBlendMode = M, i2.decomposeDataUri = C, Object.defineProperty(i2, "earcut", {
      enumerable: true,
      get: function() {
        return e.default;
      }
    }), i2.getResolutionOfUrl = b, i2.getSvgSize = A, i2.getUrlFileExt = w, i2.hex2rgb = x, i2.hex2string = g, i2.inherit = z, i2.mixins = void 0, Object.defineProperty(i2, "pluginTarget", {
      enumerable: true,
      get: function() {
        return a.default;
      }
    }), i2.premultiplyBlendMode = void 0, i2.premultiplyRgba = B, i2.premultiplyTint = U, i2.premultiplyTintToRgba = q, i2.removeItems = p, i2.rgb2hex = _, i2.rgb2hsl = E, i2.sign = S, i2.str2rgb = T, i2.uid = m, i2.uuidvx = y;
    var e = d(requireEarcut()), t = c(requireMixin$2());
    i2.mixins = t;
    var r = d(requireEventemitter3$1()), a = d(requirePluginTarget()), s = require_const(), u = d(requireMapPremultipliedBlendModes());
    function l(D) {
      if (typeof WeakMap != "function") return null;
      var X = /* @__PURE__ */ new WeakMap(), k = /* @__PURE__ */ new WeakMap();
      return (l = function(I) {
        return I ? k : X;
      })(D);
    }
    function c(D, X) {
      if (D && D.__esModule)
        return D;
      if (D === null || typeof D != "object" && typeof D != "function")
        return { default: D };
      var k = l(X);
      if (k && k.has(D))
        return k.get(D);
      var I = {}, P = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var G in D)
        if (G !== "default" && Object.prototype.hasOwnProperty.call(D, G)) {
          var W = P ? Object.getOwnPropertyDescriptor(D, G) : null;
          W && (W.get || W.set) ? Object.defineProperty(I, G, W) : I[G] = D[G];
        }
      return I.default = D, k && k.set(D, I), I;
    }
    function d(D) {
      return D && D.__esModule ? D : { default: D };
    }
    var f = 0;
    function p(D, X, k) {
      var I = D.length;
      if (!(X >= I || k <= 0 || X < 0)) {
        k = X + k > I ? I - X : k;
        for (var P = I - k, G = X; G < P; ++G)
          D[G] = D[G + k];
        D.length = P;
      }
    }
    function m() {
      return ++f;
    }
    function y() {
      return "xxxxxxxx-xxxx-4xxx-yxxx".replace(/[xy]/g, (D) => {
        var X = Math.random() * 16 | 0, k = D === "x" ? X : X & 3 | 8;
        return k.toString(16);
      });
    }
    function x(D, X) {
      return X = X || [], X[0] = (D >> 16 & 255) / 255, X[1] = (D >> 8 & 255) / 255, X[2] = (D & 255) / 255, X;
    }
    function g(D) {
      return D = D.toString(16), D = "000000".substr(0, 6 - D.length) + D, "#" + D;
    }
    function _(D) {
      return (D[0] * 255 << 16) + (D[1] * 255 << 8) + (D[2] * 255 | 0);
    }
    function T(D, X) {
      X === void 0 && (X = 1);
      var k, I, P;
      return D.length === 4 ? (k = "0x" + D[1] + D[1], I = "0x" + D[2] + D[2], P = "0x" + D[3] + D[3]) : D.length === 7 && (k = "0x" + D[1] + D[2], I = "0x" + D[3] + D[4], P = "0x" + D[5] + D[6]), [Number(k) / X, Number(I) / X, Number(P) / X];
    }
    function E(D, X, k) {
      D /= 255, X /= 255, k /= 255;
      var I = Math.max(D, X, k), P = Math.min(D, X, k), G, W, V = (I + P) / 2;
      if (I == P)
        G = W = 0;
      else {
        var K = I - P;
        switch (W = V > 0.5 ? K / (2 - I - P) : K / (I + P), I) {
          case D:
            G = (X - k) / K + (X < k ? 6 : 0);
            break;
          case X:
            G = (k - D) / K + 2;
            break;
          case k:
            G = (D - X) / K + 4;
            break;
        }
        G /= 6;
      }
      return G *= 360, W *= 100, V *= 100, [G, W, V];
    }
    function b(D, X) {
      return X !== void 0 ? X : 1;
    }
    function C(D) {
      var X = s.DATA_URI.exec(D);
      if (X)
        return {
          mediaType: X[1] ? X[1].toLowerCase() : void 0,
          subType: X[2] ? X[2].toLowerCase() : void 0,
          charset: X[3] ? X[3].toLowerCase() : void 0,
          encoding: X[4] ? X[4].toLowerCase() : void 0,
          data: X[5]
        };
    }
    function w(D) {
      var X = s.URL_FILE_EXTENSION.exec(D);
      if (X) return X[1].toLowerCase();
    }
    function A(D) {
      var X = s.SVG_SIZE.exec(D), k = {};
      return X && (k[X[1]] = Math.round(parseFloat(X[3])), k[X[5]] = Math.round(parseFloat(X[7]))), k;
    }
    function S(D) {
      return D === 0 ? 0 : D < 0 ? -1 : 1;
    }
    var F = (0, u.default)();
    i2.premultiplyBlendMode = F;
    function M(D, X) {
      return F[X ? 1 : 0][D];
    }
    function U(D, X) {
      if (X === 1)
        return (X * 255 << 24) + D;
      if (X === 0)
        return 0;
      var k = D >> 16 & 255, I = D >> 8 & 255, P = D & 255;
      return k = k * X + 0.5 | 0, I = I * X + 0.5 | 0, P = P * X + 0.5 | 0, (X * 255 << 24) + (k << 16) + (I << 8) + P;
    }
    function B(D, X, k, I) {
      return k = k || new Float32Array(4), I || I === void 0 ? (k[0] = D[0] * X, k[1] = D[1] * X, k[2] = D[2] * X) : (k[0] = D[0], k[1] = D[1], k[2] = D[2]), k[3] = X, k;
    }
    function q(D, X, k, I) {
      return k = k || new Float32Array(4), k[0] = (D >> 16 & 255) / 255, k[1] = (D >> 8 & 255) / 255, k[2] = (D & 255) / 255, (I || I === void 0) && (k[0] *= X, k[1] *= X, k[2] *= X), k[3] = X, k;
    }
    function z(D, X) {
      for (var k in X.prototype)
        D.prototype[k] = X.prototype[k];
    }
  }(utils$3)), utils$3;
}
var settings = {}, maxRecommendedTextures = {}, hasRequiredMaxRecommendedTextures;
function requireMaxRecommendedTextures() {
  if (hasRequiredMaxRecommendedTextures) return maxRecommendedTextures;
  hasRequiredMaxRecommendedTextures = 1, Object.defineProperty(maxRecommendedTextures, "__esModule", {
    value: true
  }), maxRecommendedTextures.default = i2;
  function i2(e) {
    return e;
  }
  return maxRecommendedTextures;
}
var hasRequiredSettings;
function requireSettings() {
  if (hasRequiredSettings) return settings;
  hasRequiredSettings = 1, Object.defineProperty(settings, "__esModule", {
    value: true
  }), settings.default = void 0;
  var i2 = e(requireMaxRecommendedTextures());
  function e(r) {
    return r && r.__esModule ? r : { default: r };
  }
  var t = {
    TARGET_FPMS: 0.06,
    MIPMAP_TEXTURES: true,
    RESOLUTION: 1,
    FILTER_RESOLUTION: 1,
    SPRITE_MAX_TEXTURES: (0, i2.default)(32),
    SPRITE_BATCH_SIZE: 4096,
    RETINA_PREFIX: /@([0-9\.]+)x/,
    RENDER_OPTIONS: {
      view: null,
      antialias: false,
      forceFXAA: false,
      autoResize: false,
      transparent: false,
      backgroundColor: 0,
      clearBeforeRender: true,
      preserveDrawingBuffer: false,
      roundPixels: false,
      width: 800,
      height: 600,
      legacy: false
    },
    TRANSFORM_MODE: 0,
    GC_MODE: 0,
    GC_MAX_IDLE: 60 * 60,
    GC_MAX_CHECK_COUNT: 60 * 10,
    WRAP_MODE: 0,
    SCALE_MODE: 0,
    PRECISION_VERTEX: "highp",
    PRECISION_FRAGMENT: "mediump",
    CAN_UPLOAD_SAME_BUFFER: true,
    MESH_CANVAS_PADDING: 0
  };
  return settings.default = t, settings;
}
var ticker = {}, Ticker = {}, TickerListener = {}, hasRequiredTickerListener;
function requireTickerListener() {
  if (hasRequiredTickerListener) return TickerListener;
  hasRequiredTickerListener = 1, Object.defineProperty(TickerListener, "__esModule", {
    value: true
  }), TickerListener.default = void 0;
  let i2 = class {
    constructor(e, t, r, a) {
      t === void 0 && (t = null), r === void 0 && (r = 0), a === void 0 && (a = false), this.fn = e, this.context = t, this.priority = r, this.once = a, this.next = null, this.previous = null, this.destroyed = false;
    }
    match(e, t) {
      return t = t || null, this.fn === e && this.context === t;
    }
    emit(e) {
      this.fn && (this.context ? this.fn.call(this.context, e) : this.fn(e));
      var t = this.next;
      return this.once && this.destroy(true), this.destroyed && (this.next = null), t;
    }
    connect(e) {
      this.previous = e, e.next && (e.next.previous = this), this.next = e.next, e.next = this;
    }
    destroy(e) {
      if (e === void 0 && (e = false), !this.destroyed) {
        this.destroyed = true, this.fn = null, this.context = null, this.previous && (this.previous.next = this.next), this.next && (this.next.previous = this.previous);
        var t = this.next;
        return this.next = e ? null : t, this.previous = null, t;
      }
    }
  };
  return TickerListener.default = i2, TickerListener;
}
var hasRequiredTicker$1;
function requireTicker$1() {
  if (hasRequiredTicker$1) return Ticker;
  hasRequiredTicker$1 = 1, Object.defineProperty(Ticker, "__esModule", {
    value: true
  }), Ticker.default = void 0;
  var i2 = r(requireSettings()), e = require_const(), t = r(requireTickerListener());
  function r(s) {
    return s && s.__esModule ? s : { default: s };
  }
  let a = class {
    constructor() {
      this._head = new t.default(null, null, 1 / 0), this._requestId = null, this._maxElapsedMS = 100, this.autoStart = false, this.deltaTime = 1, this.elapsedMS = 1 / i2.default.TARGET_FPMS, this.lastTime = -1, this.speed = 1, this.started = false, this._tick = this._tick.bind(this);
    }
    _tick(s) {
      this._requestId = null, this.started && (this.update(s), this.started && this._requestId === null && this._head.next && (this._requestId = requestAnimationFrame(this._tick)));
    }
    _requestIfNeeded() {
      this._requestId === null && this._head.next && (this.lastTime = performance.now(), this._requestId = requestAnimationFrame(this._tick));
    }
    _cancelIfNeeded() {
      this._requestId !== null && (cancelAnimationFrame(this._requestId), this._requestId = null);
    }
    _startIfPossible() {
      this.started ? this._requestIfNeeded() : this.autoStart && this.start();
    }
    add(s, u, l) {
      return l === void 0 && (l = e.UPDATE_PRIORITY.NORMAL), this._addListener(new t.default(s, u, l));
    }
    addOnce(s, u, l) {
      return l === void 0 && (l = e.UPDATE_PRIORITY.NORMAL), this._addListener(new t.default(s, u, l, true));
    }
    _addListener(s) {
      var u = this._head.next, l = this._head;
      if (!u)
        s.connect(l);
      else {
        for (; u; ) {
          if (s.priority > u.priority) {
            s.connect(l);
            break;
          }
          l = u, u = u.next;
        }
        s.previous || s.connect(l);
      }
      return this._startIfPossible(), this;
    }
    remove(s, u) {
      for (var l = this._head.next; l; )
        l.match(s, u) ? l = l.destroy() : l = l.next;
      return this._head.next || this._cancelIfNeeded(), this;
    }
    start() {
      this.started || (this.started = true, this._requestIfNeeded());
    }
    stop() {
      this.started && (this.started = false, this._cancelIfNeeded());
    }
    destroy() {
      this.stop();
      for (var s = this._head.next; s; )
        s = s.destroy(true);
      this._head.destroy(), this._head = null;
    }
    update(s) {
      s === void 0 && (s = performance.now());
      var u;
      if (s > this.lastTime) {
        u = this.elapsedMS = s - this.lastTime, u > this._maxElapsedMS && (u = this._maxElapsedMS), this.deltaTime = u * i2.default.TARGET_FPMS * this.speed;
        for (var l = this._head, c = l.next; c; )
          c = c.emit(this.deltaTime);
        l.next || this._cancelIfNeeded();
      } else
        this.deltaTime = this.elapsedMS = 0;
      this.lastTime = s;
    }
    get FPS() {
      return 1e3 / this.elapsedMS;
    }
    get minFPS() {
      return 1e3 / this._maxElapsedMS;
    }
    set minFPS(s) {
      var u = Math.min(Math.max(0, s) / 1e3, i2.default.TARGET_FPMS);
      this._maxElapsedMS = 1 / u;
    }
  };
  return Ticker.default = a, Ticker;
}
var hasRequiredTicker;
function requireTicker() {
  return hasRequiredTicker || (hasRequiredTicker = 1, function(i2) {
    Object.defineProperty(i2, "__esModule", {
      value: true
    }), Object.defineProperty(i2, "Ticker", {
      enumerable: true,
      get: function() {
        return e.default;
      }
    }), i2.shared = void 0;
    var e = t(requireTicker$1());
    function t(a) {
      return a && a.__esModule ? a : { default: a };
    }
    var r = new e.default();
    i2.shared = r, r.autoStart = true, r.destroy = () => {
    };
  }(ticker)), ticker;
}
var CanvasRenderer = {}, SystemRenderer = {}, Doc = {}, lib$3 = {}, hasRequiredLib$4;
function requireLib$4() {
  if (hasRequiredLib$4) return lib$3;
  hasRequiredLib$4 = 1, Object.defineProperty(lib$3, "__esModule", {
    value: true
  });
  var i2 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(s) {
    return typeof s;
  } : function(s) {
    return s && typeof Symbol == "function" && s.constructor === Symbol && s !== Symbol.prototype ? "symbol" : typeof s;
  }, e = typeof window < "u" && typeof window.document < "u", t = (typeof self > "u" ? "undefined" : i2(self)) === "object" && self.constructor && self.constructor.name === "DedicatedWorkerGlobalScope", r = typeof process < "u" && process.versions != null && process.versions.node != null, a = function() {
    return typeof window < "u" && window.name === "nodejs" || navigator.userAgent.includes("Node.js") || navigator.userAgent.includes("jsdom");
  };
  return lib$3.isBrowser = e, lib$3.isWebWorker = t, lib$3.isNode = r, lib$3.isJsDom = a, lib$3;
}
var Canvas = {}, canvasGl = {}, browserIndex, hasRequiredBrowserIndex;
function requireBrowserIndex() {
  if (hasRequiredBrowserIndex) return browserIndex;
  hasRequiredBrowserIndex = 1;
  function i2(e, t, r) {
    if (e = e | 0, t = t | 0, !(e > 0 && t > 0))
      return null;
    const a = document.createElement("canvas");
    if (!a)
      return null;
    let s;
    a.width = e, a.height = t;
    try {
      s = a.getContext("webgl", r);
    } catch {
      try {
        s = a.getContext("experimental-webgl", r);
      } catch {
        return null;
      }
    }
    const u = s.getExtension, l = {
      destroy: function() {
        const f = u.call(s, "WEBGL_lose_context");
        f && f.loseContext();
      }
    }, c = {
      resize: function(f, p) {
        a.width = f, a.height = p;
      }
    }, d = s.getSupportedExtensions().slice();
    return d.push(
      "STACKGL_destroy_context",
      "STACKGL_resize_drawingbuffer"
    ), s.getSupportedExtensions = function() {
      return d.slice();
    }, s.getExtension = function(f) {
      const p = f.toLowerCase();
      return p === "stackgl_resize_drawingbuffer" ? c : p === "stackgl_destroy_context" ? l : u.call(s, f);
    }, s || null;
  }
  return browserIndex = i2, browserIndex;
}
var browser = {}, parseFont, hasRequiredParseFont;
function requireParseFont() {
  if (hasRequiredParseFont) return parseFont;
  hasRequiredParseFont = 1;
  const i2 = "bold|bolder|lighter|[1-9]00", e = "italic|oblique", t = "small-caps", r = "ultra-condensed|extra-condensed|condensed|semi-condensed|semi-expanded|expanded|extra-expanded|ultra-expanded", a = "px|pt|pc|in|cm|mm|%|em|ex|ch|rem|q", s = /'((\\'|[^'])+)'|"((\\"|[^"])+)"|[\w\s-]+/.source, u = new RegExp(`(${i2}) +`, "i"), l = new RegExp(`(${e}) +`, "i"), c = new RegExp(`(${t}) +`, "i"), d = new RegExp(`(${r}) +`, "i"), f = new RegExp(s, "g"), p = /^['"](.*)['"]$/, m = /\\(['"])/g, y = new RegExp(
    `([\\d\\.]+)(${a}) *((?:${s})( *, *(?:${s}))*)`
  ), x = {}, g = 16;
  return parseFont = (_) => {
    if (x[_]) return x[_];
    const T = y.exec(_);
    if (!T) return;
    const E = T[3].match(f).map((M) => M.trim().replace(p, "$1").replace(m, "$1")).filter((M) => !!M), b = {
      weight: "normal",
      style: "normal",
      stretch: "normal",
      variant: "normal",
      size: parseFloat(T[1]),
      unit: T[2],
      family: E.join(",")
    };
    let C, w, A, S;
    const F = _.substring(0, T.index);
    switch ((C = u.exec(F)) && (b.weight = C[1]), (w = l.exec(F)) && (b.style = w[1]), (A = c.exec(F)) && (b.variant = A[1]), (S = d.exec(F)) && (b.stretch = S[1]), b.unit) {
      case "pt":
        b.size /= 0.75;
        break;
      case "pc":
        b.size *= 16;
        break;
      case "in":
        b.size *= 96;
        break;
      case "cm":
        b.size *= 96 / 2.54;
        break;
      case "mm":
        b.size *= 96 / 25.4;
        break;
      case "%":
        break;
      case "em":
      case "rem":
        b.size *= g / 0.75;
        break;
      case "q":
        b.size *= 96 / 25.4 / 4;
        break;
    }
    return x[_] = b;
  }, parseFont;
}
var hasRequiredBrowser;
function requireBrowser() {
  if (hasRequiredBrowser) return browser;
  hasRequiredBrowser = 1;
  const i2 = requireParseFont();
  return browser.parseFont = i2, browser.createCanvas = function(e, t) {
    return Object.assign(document.createElement("canvas"), { width: e, height: t });
  }, browser.createImageData = function(e, t, r) {
    switch (arguments.length) {
      case 0:
        return new ImageData();
      case 1:
        return new ImageData(e);
      case 2:
        return new ImageData(e, t);
      default:
        return new ImageData(e, t, r);
    }
  }, browser.loadImage = function(e, t) {
    return new Promise(function(r, a) {
      const s = Object.assign(document.createElement("img"), t);
      function u() {
        s.onload = null, s.onerror = null;
      }
      s.onload = function() {
        u(), r(s);
      }, s.onerror = function() {
        u(), a(new Error('Failed to load the image "' + e + '"'));
      }, s.src = e;
    });
  }, browser;
}
var hasRequiredCanvasGl;
function requireCanvasGl() {
  return hasRequiredCanvasGl || (hasRequiredCanvasGl = 1, function(i2) {
    Object.defineProperty(i2, "__esModule", {
      value: true
    }), Object.defineProperty(i2, "Canvas", {
      enumerable: true,
      get: function() {
        return t.Canvas;
      }
    }), Object.defineProperty(i2, "CanvasGradient", {
      enumerable: true,
      get: function() {
        return t.CanvasGradient;
      }
    }), Object.defineProperty(i2, "CanvasPattern", {
      enumerable: true,
      get: function() {
        return t.CanvasPattern;
      }
    }), Object.defineProperty(i2, "CanvasRenderingContext2D", {
      enumerable: true,
      get: function() {
        return t.CanvasRenderingContext2D;
      }
    }), Object.defineProperty(i2, "Context2d", {
      enumerable: true,
      get: function() {
        return t.Context2d;
      }
    }), Object.defineProperty(i2, "DOMMatrix", {
      enumerable: true,
      get: function() {
        return t.DOMMatrix;
      }
    }), Object.defineProperty(i2, "DOMPoint", {
      enumerable: true,
      get: function() {
        return t.DOMPoint;
      }
    }), Object.defineProperty(i2, "Image", {
      enumerable: true,
      get: function() {
        return t.Image;
      }
    }), Object.defineProperty(i2, "ImageData", {
      enumerable: true,
      get: function() {
        return t.ImageData;
      }
    }), Object.defineProperty(i2, "JPEGStream", {
      enumerable: true,
      get: function() {
        return t.JPEGStream;
      }
    }), Object.defineProperty(i2, "PDFStream", {
      enumerable: true,
      get: function() {
        return t.PDFStream;
      }
    }), Object.defineProperty(i2, "PNGStream", {
      enumerable: true,
      get: function() {
        return t.PNGStream;
      }
    }), Object.defineProperty(i2, "createCanvas", {
      enumerable: true,
      get: function() {
        return t.createCanvas;
      }
    }), Object.defineProperty(i2, "createImageData", {
      enumerable: true,
      get: function() {
        return t.createImageData;
      }
    }), Object.defineProperty(i2, "deregisterAllFonts", {
      enumerable: true,
      get: function() {
        return t.deregisterAllFonts;
      }
    }), Object.defineProperty(i2, "gl", {
      enumerable: true,
      get: function() {
        return e.default;
      }
    }), Object.defineProperty(i2, "loadImage", {
      enumerable: true,
      get: function() {
        return t.loadImage;
      }
    }), Object.defineProperty(i2, "parseFont", {
      enumerable: true,
      get: function() {
        return t.parseFont;
      }
    }), Object.defineProperty(i2, "registerFont", {
      enumerable: true,
      get: function() {
        return t.registerFont;
      }
    });
    var e = r(requireBrowserIndex()), t = requireBrowser();
    function r(a) {
      return a && a.__esModule ? a : { default: a };
    }
  }(canvasGl)), canvasGl;
}
var poly = {}, hasRequiredPoly;
function requirePoly() {
  if (hasRequiredPoly) return poly;
  hasRequiredPoly = 1, Object.defineProperty(poly, "__esModule", {
    value: true
  }), poly.default = e;
  class i2 {
  }
  function e(t) {
    return t || i2;
  }
  return poly;
}
var glfix = {}, hasRequiredGlfix;
function requireGlfix() {
  if (hasRequiredGlfix) return glfix;
  hasRequiredGlfix = 1, Object.defineProperty(glfix, "__esModule", {
    value: true
  }), glfix.default = void 0;
  var i2 = {
    // Temporary fix https://github.com/stackgl/headless-gl/issues/170
    fixGetUniformLocation(t) {
      var r = t.getUniformLocation;
      t.getUniformLocation = function(a, s) {
        if (a._uniforms && !/\[\d+\]$/.test(s))
          for (var u = new RegExp(s + "\\[\\d+\\]$"), l = 0; l < a._uniforms.length; l++) {
            var c = a._uniforms[l].name;
            u.test(c) && (s = c);
          }
        return r.call(this, a, s);
      };
    },
    fixTexImage2D(t) {
      t.texImage2D;
    }
  }, e = i2;
  return glfix.default = e, glfix;
}
var hasRequiredCanvas$1;
function requireCanvas$1() {
  if (hasRequiredCanvas$1) return Canvas;
  hasRequiredCanvas$1 = 1, Object.defineProperty(Canvas, "__esModule", {
    value: true
  }), Canvas.default = void 0;
  var i2 = requireCanvasGl(), e = s(requirePoly()), t = s(requireGlfix()), r = requireUtils$3(), a = s(requireEventemitter3$1());
  function s(l) {
    return l && l.__esModule ? l : { default: l };
  }
  class u extends (0, e.default)(i2.Canvas) {
    constructor(c, d, f) {
      super(c, d, f), this._event = new a.default(), this._glResizeExt = null, this._gl = null, this._renderType = "2d", this.useTypedArray = false, this.rgbReverse = false, this.isPSCanvas = true, this.id = (0, r.uuidvx)();
    }
    // Get canvas context
    getContext(c, d) {
      if (this._renderType = c, c === "webgl") {
        if (this._gl) return this._gl;
        var {
          width: f,
          height: p
        } = this, m = (0, i2.gl)(f, p, d);
        return t.default.fixGetUniformLocation(m), t.default.fixTexImage2D(m), this._gl = m, this._glResizeExt = m.getExtension("STACKGL_resize_drawingbuffer"), this._ctx = super.getContext("2d", d), this._gl;
      } else
        this._ctx = super.getContext("2d", d);
      return super.getContext(c, d);
    }
    // Canvas Reset width and height
    get height() {
      return super.height;
    }
    set height(c) {
      this._glResizeExt && this._glResizeExt.resize(this.width, c), super.height = c;
    }
    get width() {
      return super.width;
    }
    set width(c) {
      this._glResizeExt && this._glResizeExt.resize(c, this.height), super.width = c;
    }
    get clientWidth() {
      return super.width;
    }
    get clientHeight() {
      return super.height;
    }
    // add and remove event listener
    addEventListener(c, d) {
      return this._event.addListener(c, d);
    }
    removeEventListener(c, d) {
      return d ? this._event.removeListener(c, d) : this._event.removeAllListeners(c);
    }
    _glBuffer() {
      var {
        width: c,
        height: d,
        _ctx: f,
        _gl: p
      } = this, m = new Uint8Array(c * d * 4);
      return p.readPixels(0, 0, c, d, p.RGBA, p.UNSIGNED_BYTE, m), Buffer.from(m);
    }
    _putImageData() {
      var c, {
        width: d,
        height: f,
        _ctx: p,
        _gl: m,
        useTypedArray: y
      } = this, x = new Uint8Array(d * f * 4);
      m.readPixels(0, 0, d, f, m.RGBA, m.UNSIGNED_BYTE, x), y ? c = (0, i2.createImageData)(new Uint8ClampedArray(x), d, f) : (c = p.getImageData(0, 0, d, f), this._fillImageData(c, x, d, f)), p.putImageData(c, 0, 0);
    }
    _reverseColor() {
      for (var c = [2, 1, 0, 3], {
        width: d,
        height: f,
        _ctx: p
      } = this, m = p.getImageData(0, 0, d, f), y = new Uint8Array(d * f * 4), x = 0; x < f; x++)
        for (var g = 0; g < d; g++)
          for (var _ = g, T = x, E = 0; E < 4; E++) {
            var b = 4 * (T * d + _) + c[E], C = 4 * (T * d + _) + E;
            y[b] = m.data[C];
          }
      var w = (0, i2.createImageData)(new Uint8ClampedArray(y), d, f);
      p.putImageData(w, 0, 0);
    }
    _fillImageData(c, d, f, p) {
      for (var m = this.rgbReverse ? [2, 1, 0, 3] : [0, 1, 2, 3], y = 0; y < p; y++)
        for (var x = 0; x < f; x++)
          for (var g = x, _ = p - y - 1, T = 0; T < 4; T++) {
            var E = 4 * (_ * f + g) + m[T], b = 4 * (y * f + g) + T;
            c.data[E] = d[b];
          }
      return c;
    }
    // Store buffer png jpg and other data
    toBuffer() {
      return this._gl ? this._glBuffer() : (this.rgbReverse && this._reverseColor(), super.toBuffer(...arguments));
    }
    toDataURL() {
      return this._gl ? this._putImageData() : this.rgbReverse && this._reverseColor(), super.toDataURL(...arguments);
    }
    createPNGStream() {
      return this._gl ? this._putImageData() : this.rgbReverse && this._reverseColor(), super.createPNGStream(...arguments);
    }
    createJPEGStream() {
      return this._gl ? this._putImageData() : this.rgbReverse && this._reverseColor(), super.createJPEGStream(...arguments);
    }
    createPDFStream() {
      return this._gl ? this._putImageData() : this.rgbReverse && this._reverseColor(), super.createPDFStream(...arguments);
    }
    destroy() {
      this._event.removeAllListeners(), this._event = null, this._glResizeExt = null, this._gl = null, this._ctx = null;
    }
  }
  return Canvas.default = u, Canvas;
}
var hasRequiredDoc;
function requireDoc() {
  if (hasRequiredDoc) return Doc;
  hasRequiredDoc = 1, Object.defineProperty(Doc, "__esModule", {
    value: true
  }), Doc.default = void 0;
  var i2 = requireLib$4(), e = t(requireCanvas$1());
  function t(s) {
    return s && s.__esModule ? s : { default: s };
  }
  var r = {
    createElement(s) {
      var u;
      switch (s) {
        case "canvas":
          u = new e.default(1, 1);
          break;
        default:
          u = new e.default(1, 1);
          break;
      }
      return u;
    }
  }, a = i2.isBrowser ? window.document : r;
  return Doc.default = a, Doc;
}
var Container = {}, DisplayObject = {}, Bounds = {}, hasRequiredBounds;
function requireBounds() {
  if (hasRequiredBounds) return Bounds;
  hasRequiredBounds = 1, Object.defineProperty(Bounds, "__esModule", {
    value: true
  }), Bounds.default = void 0;
  var i2 = requireMath$1();
  let e = class {
    constructor() {
      this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0, this.rect = null;
    }
    isEmpty() {
      return this.minX > this.maxX || this.minY > this.maxY;
    }
    clear() {
      this.updateID++, this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0;
    }
    getRectangle(t) {
      return this.minX > this.maxX || this.minY > this.maxY ? i2.Rectangle.EMPTY : (t = t || new i2.Rectangle(0, 0, 1, 1), t.x = this.minX, t.y = this.minY, t.width = this.maxX - this.minX, t.height = this.maxY - this.minY, t);
    }
    addPoint(t) {
      this.minX = Math.min(this.minX, t.x), this.maxX = Math.max(this.maxX, t.x), this.minY = Math.min(this.minY, t.y), this.maxY = Math.max(this.maxY, t.y);
    }
    addQuad(t) {
      var r = this.minX, a = this.minY, s = this.maxX, u = this.maxY, l = t[0], c = t[1];
      r = l < r ? l : r, a = c < a ? c : a, s = l > s ? l : s, u = c > u ? c : u, l = t[2], c = t[3], r = l < r ? l : r, a = c < a ? c : a, s = l > s ? l : s, u = c > u ? c : u, l = t[4], c = t[5], r = l < r ? l : r, a = c < a ? c : a, s = l > s ? l : s, u = c > u ? c : u, l = t[6], c = t[7], r = l < r ? l : r, a = c < a ? c : a, s = l > s ? l : s, u = c > u ? c : u, this.minX = r, this.minY = a, this.maxX = s, this.maxY = u;
    }
    addFrame(t, r, a, s, u) {
      var l = t.worldTransform, c = l.a, d = l.b, f = l.c, p = l.d, m = l.tx, y = l.ty, x = this.minX, g = this.minY, _ = this.maxX, T = this.maxY, E = c * r + f * a + m, b = d * r + p * a + y;
      x = E < x ? E : x, g = b < g ? b : g, _ = E > _ ? E : _, T = b > T ? b : T, E = c * s + f * a + m, b = d * s + p * a + y, x = E < x ? E : x, g = b < g ? b : g, _ = E > _ ? E : _, T = b > T ? b : T, E = c * r + f * u + m, b = d * r + p * u + y, x = E < x ? E : x, g = b < g ? b : g, _ = E > _ ? E : _, T = b > T ? b : T, E = c * s + f * u + m, b = d * s + p * u + y, x = E < x ? E : x, g = b < g ? b : g, _ = E > _ ? E : _, T = b > T ? b : T, this.minX = x, this.minY = g, this.maxX = _, this.maxY = T;
    }
    addVertices(t, r, a, s) {
      for (var u = t.worldTransform, l = u.a, c = u.b, d = u.c, f = u.d, p = u.tx, m = u.ty, y = this.minX, x = this.minY, g = this.maxX, _ = this.maxY, T = a; T < s; T += 2) {
        var E = r[T], b = r[T + 1], C = l * E + d * b + p, w = f * b + c * E + m;
        y = C < y ? C : y, x = w < x ? w : x, g = C > g ? C : g, _ = w > _ ? w : _;
      }
      this.minX = y, this.minY = x, this.maxX = g, this.maxY = _;
    }
    addBounds(t) {
      var r = this.minX, a = this.minY, s = this.maxX, u = this.maxY;
      this.minX = t.minX < r ? t.minX : r, this.minY = t.minY < a ? t.minY : a, this.maxX = t.maxX > s ? t.maxX : s, this.maxY = t.maxY > u ? t.maxY : u;
    }
    addBoundsMask(t, r) {
      var a = t.minX > r.minX ? t.minX : r.minX, s = t.minY > r.minY ? t.minY : r.minY, u = t.maxX < r.maxX ? t.maxX : r.maxX, l = t.maxY < r.maxY ? t.maxY : r.maxY;
      if (a <= u && s <= l) {
        var c = this.minX, d = this.minY, f = this.maxX, p = this.maxY;
        this.minX = a < c ? a : c, this.minY = s < d ? s : d, this.maxX = u > f ? u : f, this.maxY = l > p ? l : p;
      }
    }
    addBoundsArea(t, r) {
      var a = t.minX > r.x ? t.minX : r.x, s = t.minY > r.y ? t.minY : r.y, u = t.maxX < r.x + r.width ? t.maxX : r.x + r.width, l = t.maxY < r.y + r.height ? t.maxY : r.y + r.height;
      if (a <= u && s <= l) {
        var c = this.minX, d = this.minY, f = this.maxX, p = this.maxY;
        this.minX = a < c ? a : c, this.minY = s < d ? s : d, this.maxX = u > f ? u : f, this.maxY = l > p ? l : p;
      }
    }
  };
  return Bounds.default = e, Bounds;
}
var Transform = {}, TransformBase = {}, hasRequiredTransformBase;
function requireTransformBase() {
  if (hasRequiredTransformBase) return TransformBase;
  hasRequiredTransformBase = 1, Object.defineProperty(TransformBase, "__esModule", {
    value: true
  }), TransformBase.default = void 0;
  var i2 = requireMath$1();
  let e = class {
    constructor() {
      this.worldTransform = new i2.Matrix(), this.localTransform = new i2.Matrix(), this._worldID = 0, this._parentID = 0;
    }
    updateLocalTransform() {
    }
    updateTransform(t) {
      var r = t.worldTransform, a = this.worldTransform, s = this.localTransform;
      a.a = s.a * r.a + s.b * r.c, a.b = s.a * r.b + s.b * r.d, a.c = s.c * r.a + s.d * r.c, a.d = s.c * r.b + s.d * r.d, a.tx = s.tx * r.a + s.ty * r.c + r.tx, a.ty = s.tx * r.b + s.ty * r.d + r.ty, this._worldID++;
    }
  };
  return TransformBase.default = e, e.prototype.updateWorldTransform = e.prototype.updateTransform, e.IDENTITY = new e(), TransformBase;
}
var hasRequiredTransform;
function requireTransform() {
  if (hasRequiredTransform) return Transform;
  hasRequiredTransform = 1, Object.defineProperty(Transform, "__esModule", {
    value: true
  }), Transform.default = void 0;
  var i2 = requireMath$1(), e = t(requireTransformBase());
  function t(a) {
    return a && a.__esModule ? a : { default: a };
  }
  let r = class extends e.default {
    constructor() {
      super(), this.position = new i2.Point(0, 0), this.scale = new i2.Point(1, 1), this.flip = new i2.Point(1, 1), this.skew = new i2.ObservablePoint(this.updateSkew, this, 0, 0), this.pivot = new i2.Point(0, 0), this._rotation = 0, this._cx = 1, this._sx = 0, this._cy = 0, this._sy = 1;
    }
    updateSkew() {
      this._cx = Math.cos(this._rotation + this.skew._y), this._sx = Math.sin(this._rotation + this.skew._y), this._cy = -Math.sin(this._rotation - this.skew._x), this._sy = Math.cos(this._rotation - this.skew._x);
    }
    updateLocalTransform() {
      var a = this.localTransform;
      a.a = this._cx * this.scale.x * this.flip.x, a.b = this._sx * this.scale.x * this.flip.x, a.c = this._cy * this.scale.y * this.flip.y, a.d = this._sy * this.scale.y * this.flip.y, a.tx = this.position.x - (this.pivot.x * a.a + this.pivot.y * a.c), a.ty = this.position.y - (this.pivot.x * a.b + this.pivot.y * a.d);
    }
    updateTransform(a) {
      var s = this.localTransform;
      s.a = this._cx * this.scale.x * this.flip.x, s.b = this._sx * this.scale.x * this.flip.x, s.c = this._cy * this.scale.y * this.flip.y, s.d = this._sy * this.scale.y * this.flip.y, s.tx = this.position.x - (this.pivot.x * s.a + this.pivot.y * s.c), s.ty = this.position.y - (this.pivot.x * s.b + this.pivot.y * s.d);
      var u = a.worldTransform, l = this.worldTransform;
      l.a = s.a * u.a + s.b * u.c, l.b = s.a * u.b + s.b * u.d, l.c = s.c * u.a + s.d * u.c, l.d = s.c * u.b + s.d * u.d, l.tx = s.tx * u.a + s.ty * u.c + u.tx, l.ty = s.tx * u.b + s.ty * u.d + u.ty, this._worldID++;
    }
    setFromMatrix(a) {
      a.decompose(this);
    }
    get rotation() {
      return this._rotation;
    }
    set rotation(a) {
      this._rotation = a, this.updateSkew();
    }
  };
  return Transform.default = r, Transform;
}
var TransformStatic = {}, hasRequiredTransformStatic;
function requireTransformStatic() {
  if (hasRequiredTransformStatic) return TransformStatic;
  hasRequiredTransformStatic = 1, Object.defineProperty(TransformStatic, "__esModule", {
    value: true
  }), TransformStatic.default = void 0;
  var i2 = requireMath$1(), e = t(requireTransformBase());
  function t(a) {
    return a && a.__esModule ? a : { default: a };
  }
  let r = class extends e.default {
    constructor() {
      super(), this.position = new i2.ObservablePoint(this.onChange, this, 0, 0), this.scale = new i2.ObservablePoint(this.onChange, this, 1, 1), this.pivot = new i2.ObservablePoint(this.onChange, this, 0, 0), this.flip = new i2.ObservablePoint(this.onChange, this, 1, 1), this.skew = new i2.ObservablePoint(this.updateSkew, this, 0, 0), this._rotation = 0, this._cx = 1, this._sx = 0, this._cy = 0, this._sy = 1, this._localID = 0, this._currentLocalID = 0;
    }
    onChange() {
      this._localID++;
    }
    updateSkew() {
      this._cx = Math.cos(this._rotation + this.skew._y), this._sx = Math.sin(this._rotation + this.skew._y), this._cy = -Math.sin(this._rotation - this.skew._x), this._sy = Math.cos(this._rotation - this.skew._x), this._localID++;
    }
    updateLocalTransform() {
      var a = this.localTransform;
      this._localID !== this._currentLocalID && (a.a = this._cx * this.scale._x * this.flip._x, a.b = this._sx * this.scale._x * this.flip._x, a.c = this._cy * this.scale._y * this.flip._y, a.d = this._sy * this.scale._y * this.flip._y, a.tx = this.position._x - (this.pivot._x * a.a + this.pivot._y * a.c), a.ty = this.position._y - (this.pivot._x * a.b + this.pivot._y * a.d), this._currentLocalID = this._localID, this._parentID = -1);
    }
    updateTransform(a) {
      var s = this.localTransform;
      if (this._localID !== this._currentLocalID && (s.a = this._cx * this.scale._x * this.flip._x, s.b = this._sx * this.scale._x * this.flip._x, s.c = this._cy * this.scale._y * this.flip._y, s.d = this._sy * this.scale._y * this.flip._y, s.tx = this.position._x - (this.pivot._x * s.a + this.pivot._y * s.c), s.ty = this.position._y - (this.pivot._x * s.b + this.pivot._y * s.d), this._currentLocalID = this._localID, this._parentID = -1), this._parentID !== a._worldID) {
        var u = a.worldTransform, l = this.worldTransform;
        l.a = s.a * u.a + s.b * u.c, l.b = s.a * u.b + s.b * u.d, l.c = s.c * u.a + s.d * u.c, l.d = s.c * u.b + s.d * u.d, l.tx = s.tx * u.a + s.ty * u.c + u.tx, l.ty = s.tx * u.b + s.ty * u.d + u.ty, this._parentID = a._worldID, this._worldID++;
      }
    }
    setFromMatrix(a) {
      a.decompose(this), this._localID++;
    }
    get rotation() {
      return this._rotation;
    }
    set rotation(a) {
      this._rotation !== a && (this._rotation = a, this.updateSkew());
    }
  };
  return TransformStatic.default = r, TransformStatic;
}
var FXAAFilter = {}, Filter = {}, extractUniformsFromSrc = {}, src$1 = { exports: {} }, createContext_1, hasRequiredCreateContext;
function requireCreateContext() {
  if (hasRequiredCreateContext) return createContext_1;
  hasRequiredCreateContext = 1;
  var i2 = function(e, t) {
    var r = e.getContext("webgl", t) || e.getContext("experimental-webgl", t);
    if (!r)
      throw new Error("This browser does not support webGL. Try using the canvas renderer");
    return r;
  };
  return createContext_1 = i2, createContext_1;
}
var setVertexAttribArrays_1, hasRequiredSetVertexAttribArrays;
function requireSetVertexAttribArrays() {
  if (hasRequiredSetVertexAttribArrays) return setVertexAttribArrays_1;
  hasRequiredSetVertexAttribArrays = 1;
  var i2 = function(e, t, r) {
    var a;
    if (r) {
      var s = r.tempAttribState, u = r.attribState;
      for (a = 0; a < s.length; a++)
        s[a] = false;
      for (a = 0; a < t.length; a++)
        s[t[a].attribute.location] = true;
      for (a = 0; a < u.length; a++)
        u[a] !== s[a] && (u[a] = s[a], r.attribState[a] ? e.enableVertexAttribArray(a) : e.disableVertexAttribArray(a));
    } else
      for (a = 0; a < t.length; a++) {
        var l = t[a];
        e.enableVertexAttribArray(l.attribute.location);
      }
  };
  return setVertexAttribArrays_1 = i2, setVertexAttribArrays_1;
}
var GLBuffer, hasRequiredGLBuffer;
function requireGLBuffer() {
  if (hasRequiredGLBuffer) return GLBuffer;
  hasRequiredGLBuffer = 1;
  var i2 = new ArrayBuffer(0), e = function(t, r, a, s) {
    this.gl = t, this.buffer = t.createBuffer(), this.type = r || t.ARRAY_BUFFER, this.drawType = s || t.STATIC_DRAW, this.data = i2, a && this.upload(a), this._updateID = 0;
  };
  return e.prototype.upload = function(t, r, a) {
    a || this.bind();
    var s = this.gl;
    t = t || this.data, r = r || 0, this.data.byteLength >= t.byteLength ? s.bufferSubData(this.type, r, t) : s.bufferData(this.type, t, this.drawType), this.data = t;
  }, e.prototype.bind = function() {
    var t = this.gl;
    t.bindBuffer(this.type, this.buffer);
  }, e.createVertexBuffer = function(t, r, a) {
    return new e(t, t.ARRAY_BUFFER, r, a);
  }, e.createIndexBuffer = function(t, r, a) {
    return new e(t, t.ELEMENT_ARRAY_BUFFER, r, a);
  }, e.create = function(t, r, a, s) {
    return new e(t, r, a, s);
  }, e.prototype.destroy = function() {
    this.gl.deleteBuffer(this.buffer);
  }, GLBuffer = e, GLBuffer;
}
var GLTexture, hasRequiredGLTexture;
function requireGLTexture() {
  if (hasRequiredGLTexture) return GLTexture;
  hasRequiredGLTexture = 1;
  var i2 = function(t, r, a, s, u) {
    this.gl = t, this.texture = t.createTexture(), this.mipmap = false, this.premultiplyAlpha = false, this.width = r || -1, this.height = a || -1, this.format = s || t.RGBA, this.type = u || t.UNSIGNED_BYTE;
  };
  i2.prototype.upload = function(t) {
    this.bind();
    var r = this.gl;
    r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this.premultiplyAlpha);
    var a = t.videoWidth || t.width, s = t.videoHeight || t.height;
    s !== this.height || a !== this.width ? r.texImage2D(r.TEXTURE_2D, 0, this.format, this.format, this.type, t) : r.texSubImage2D(r.TEXTURE_2D, 0, 0, 0, this.format, this.type, t), this.width = a, this.height = s;
  };
  var e = false;
  return i2.prototype.uploadData = function(t, r, a) {
    this.bind();
    var s = this.gl;
    if (t instanceof Float32Array) {
      if (!e) {
        var u = s.getExtension("OES_texture_float");
        if (u)
          e = true;
        else
          throw new Error("floating point textures not available");
      }
      this.type = s.FLOAT;
    } else
      this.type = this.type || s.UNSIGNED_BYTE;
    s.pixelStorei(s.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this.premultiplyAlpha), r !== this.width || a !== this.height ? s.texImage2D(s.TEXTURE_2D, 0, this.format, r, a, 0, this.format, this.type, t || null) : s.texSubImage2D(s.TEXTURE_2D, 0, 0, 0, r, a, this.format, this.type, t || null), this.width = r, this.height = a;
  }, i2.prototype.bind = function(t) {
    var r = this.gl;
    t !== void 0 && r.activeTexture(r.TEXTURE0 + t), r.bindTexture(r.TEXTURE_2D, this.texture);
  }, i2.prototype.unbind = function() {
    var t = this.gl;
    t.bindTexture(t.TEXTURE_2D, null);
  }, i2.prototype.minFilter = function(t) {
    var r = this.gl;
    this.bind(), this.mipmap ? r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MIN_FILTER, t ? r.LINEAR_MIPMAP_LINEAR : r.NEAREST_MIPMAP_NEAREST) : r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MIN_FILTER, t ? r.LINEAR : r.NEAREST);
  }, i2.prototype.magFilter = function(t) {
    var r = this.gl;
    this.bind(), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MAG_FILTER, t ? r.LINEAR : r.NEAREST);
  }, i2.prototype.enableMipmap = function() {
    var t = this.gl;
    this.bind(), this.mipmap = true, t.generateMipmap(t.TEXTURE_2D);
  }, i2.prototype.enableLinearScaling = function() {
    this.minFilter(true), this.magFilter(true);
  }, i2.prototype.enableNearestScaling = function() {
    this.minFilter(false), this.magFilter(false);
  }, i2.prototype.enableWrapClamp = function() {
    var t = this.gl;
    this.bind(), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE);
  }, i2.prototype.enableWrapRepeat = function() {
    var t = this.gl;
    this.bind(), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.REPEAT), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.REPEAT);
  }, i2.prototype.enableWrapMirrorRepeat = function() {
    var t = this.gl;
    this.bind(), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.MIRRORED_REPEAT), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.MIRRORED_REPEAT);
  }, i2.prototype.destroy = function() {
    var t = this.gl;
    t.deleteTexture(this.texture);
  }, i2.fromSource = function(t, r, a) {
    var s = new i2(t);
    return s.premultiplyAlpha = a || false, s.upload(r), s;
  }, i2.fromData = function(t, r, a, s) {
    var u = new i2(t);
    return u.uploadData(r, a, s), u;
  }, GLTexture = i2, GLTexture;
}
var GLFramebuffer, hasRequiredGLFramebuffer;
function requireGLFramebuffer() {
  if (hasRequiredGLFramebuffer) return GLFramebuffer;
  hasRequiredGLFramebuffer = 1;
  var i2 = requireGLTexture(), e = function(t, r, a) {
    this.gl = t, this.framebuffer = t.createFramebuffer(), this.stencil = null, this.texture = null, this.width = r || 100, this.height = a || 100;
  };
  return e.prototype.enableTexture = function(t) {
    var r = this.gl;
    this.texture = t || new i2(r), this.texture.bind(), this.bind(), r.framebufferTexture2D(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0, r.TEXTURE_2D, this.texture.texture, 0);
  }, e.prototype.enableStencil = function() {
    if (!this.stencil) {
      var t = this.gl;
      this.stencil = t.createRenderbuffer(), t.bindRenderbuffer(t.RENDERBUFFER, this.stencil), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.RENDERBUFFER, this.stencil), t.renderbufferStorage(t.RENDERBUFFER, t.DEPTH_STENCIL, this.width, this.height);
    }
  }, e.prototype.clear = function(t, r, a, s) {
    this.bind();
    var u = this.gl;
    u.clearColor(t, r, a, s), u.clear(u.COLOR_BUFFER_BIT | u.DEPTH_BUFFER_BIT);
  }, e.prototype.bind = function() {
    var t = this.gl;
    t.bindFramebuffer(t.FRAMEBUFFER, this.framebuffer);
  }, e.prototype.unbind = function() {
    var t = this.gl;
    t.bindFramebuffer(t.FRAMEBUFFER, null);
  }, e.prototype.resize = function(t, r) {
    var a = this.gl;
    this.width = t, this.height = r, this.texture && this.texture.uploadData(null, t, r), this.stencil && (a.bindRenderbuffer(a.RENDERBUFFER, this.stencil), a.renderbufferStorage(a.RENDERBUFFER, a.DEPTH_STENCIL, t, r));
  }, e.prototype.destroy = function() {
    var t = this.gl;
    this.texture && this.texture.destroy(), t.deleteFramebuffer(this.framebuffer), this.gl = null, this.stencil = null, this.texture = null;
  }, e.createRGBA = function(t, r, a, s) {
    var u = i2.fromData(t, null, r, a);
    u.enableNearestScaling(), u.enableWrapClamp();
    var l = new e(t, r, a);
    return l.enableTexture(u), l.unbind(), l;
  }, e.createFloat32 = function(t, r, a, s) {
    var u = new i2.fromData(t, s, r, a);
    u.enableNearestScaling(), u.enableWrapClamp();
    var l = new e(t, r, a);
    return l.enableTexture(u), l.unbind(), l;
  }, GLFramebuffer = e, GLFramebuffer;
}
var compileProgram_1, hasRequiredCompileProgram;
function requireCompileProgram() {
  if (hasRequiredCompileProgram) return compileProgram_1;
  hasRequiredCompileProgram = 1;
  var i2 = function(t, r, a, s) {
    var u = e(t, t.VERTEX_SHADER, r), l = e(t, t.FRAGMENT_SHADER, a), c = t.createProgram();
    if (t.attachShader(c, u), t.attachShader(c, l), s)
      for (var d in s)
        t.bindAttribLocation(c, s[d], d);
    return t.linkProgram(c), t.getProgramParameter(c, t.LINK_STATUS) || (console.error("Pixi.js Error: Could not initialize shader."), console.error("gl.VALIDATE_STATUS", t.getProgramParameter(c, t.VALIDATE_STATUS)), console.error("gl.getError()", t.getError()), t.getProgramInfoLog(c) !== "" && console.warn("Pixi.js Warning: gl.getProgramInfoLog()", t.getProgramInfoLog(c)), t.deleteProgram(c), c = null), t.deleteShader(u), t.deleteShader(l), c;
  }, e = function(t, r, a) {
    var s = t.createShader(r);
    return t.shaderSource(s, a), t.compileShader(s), t.getShaderParameter(s, t.COMPILE_STATUS) ? s : (console.log(t.getShaderInfoLog(s)), null);
  };
  return compileProgram_1 = i2, compileProgram_1;
}
var mapType_1, hasRequiredMapType;
function requireMapType() {
  if (hasRequiredMapType) return mapType_1;
  hasRequiredMapType = 1;
  var i2 = function(r, a) {
    if (!e) {
      var s = Object.keys(t);
      e = {};
      for (var u = 0; u < s.length; ++u) {
        var l = s[u];
        e[r[l]] = t[l];
      }
    }
    return e[a];
  }, e = null, t = {
    FLOAT: "float",
    FLOAT_VEC2: "vec2",
    FLOAT_VEC3: "vec3",
    FLOAT_VEC4: "vec4",
    INT: "int",
    INT_VEC2: "ivec2",
    INT_VEC3: "ivec3",
    INT_VEC4: "ivec4",
    BOOL: "bool",
    BOOL_VEC2: "bvec2",
    BOOL_VEC3: "bvec3",
    BOOL_VEC4: "bvec4",
    FLOAT_MAT2: "mat2",
    FLOAT_MAT3: "mat3",
    FLOAT_MAT4: "mat4",
    SAMPLER_2D: "sampler2D"
  };
  return mapType_1 = i2, mapType_1;
}
var mapSize_1, hasRequiredMapSize;
function requireMapSize() {
  if (hasRequiredMapSize) return mapSize_1;
  hasRequiredMapSize = 1;
  var i2 = function(t) {
    return e[t];
  }, e = {
    float: 1,
    vec2: 2,
    vec3: 3,
    vec4: 4,
    int: 1,
    ivec2: 2,
    ivec3: 3,
    ivec4: 4,
    bool: 1,
    bvec2: 2,
    bvec3: 3,
    bvec4: 4,
    mat2: 4,
    mat3: 9,
    mat4: 16,
    sampler2D: 1
  };
  return mapSize_1 = i2, mapSize_1;
}
var extractAttributes_1, hasRequiredExtractAttributes;
function requireExtractAttributes() {
  if (hasRequiredExtractAttributes) return extractAttributes_1;
  hasRequiredExtractAttributes = 1;
  var i2 = requireMapType(), e = requireMapSize(), t = function(a, s) {
    for (var u = {}, l = a.getProgramParameter(s, a.ACTIVE_ATTRIBUTES), c = 0; c < l; c++) {
      var d = a.getActiveAttrib(s, c), f = i2(a, d.type);
      u[d.name] = {
        type: f,
        size: e(f),
        location: a.getAttribLocation(s, d.name),
        //TODO - make an attribute object
        pointer: r
      };
    }
    return u;
  }, r = function(a, s, u, l) {
    gl.vertexAttribPointer(this.location, this.size, a || gl.FLOAT, s || false, u || 0, l || 0);
  };
  return extractAttributes_1 = t, extractAttributes_1;
}
var defaultValue_1, hasRequiredDefaultValue;
function requireDefaultValue() {
  if (hasRequiredDefaultValue) return defaultValue_1;
  hasRequiredDefaultValue = 1;
  var i2 = function(t, r) {
    switch (t) {
      case "float":
        return 0;
      case "vec2":
        return new Float32Array(2 * r);
      case "vec3":
        return new Float32Array(3 * r);
      case "vec4":
        return new Float32Array(4 * r);
      case "int":
      case "sampler2D":
        return 0;
      case "ivec2":
        return new Int32Array(2 * r);
      case "ivec3":
        return new Int32Array(3 * r);
      case "ivec4":
        return new Int32Array(4 * r);
      case "bool":
        return false;
      case "bvec2":
        return e(2 * r);
      case "bvec3":
        return e(3 * r);
      case "bvec4":
        return e(4 * r);
      case "mat2":
        return new Float32Array([
          1,
          0,
          0,
          1
        ]);
      case "mat3":
        return new Float32Array([
          1,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          1
        ]);
      case "mat4":
        return new Float32Array([
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1
        ]);
    }
  }, e = function(t) {
    for (var r = new Array(t), a = 0; a < r.length; a++)
      r[a] = false;
    return r;
  };
  return defaultValue_1 = i2, defaultValue_1;
}
var extractUniforms_1, hasRequiredExtractUniforms;
function requireExtractUniforms() {
  if (hasRequiredExtractUniforms) return extractUniforms_1;
  hasRequiredExtractUniforms = 1;
  var i2 = requireMapType(), e = requireDefaultValue(), t = function(r, a) {
    for (var s = {}, u = r.getProgramParameter(a, r.ACTIVE_UNIFORMS), l = 0; l < u; l++) {
      var c = r.getActiveUniform(a, l), d = c.name.replace(/\[.*?\]/, ""), f = i2(r, c.type);
      s[d] = {
        type: f,
        size: c.size,
        location: r.getUniformLocation(a, d),
        value: e(f, c.size)
      };
    }
    return s;
  };
  return extractUniforms_1 = t, extractUniforms_1;
}
var setPrecision_1, hasRequiredSetPrecision;
function requireSetPrecision() {
  if (hasRequiredSetPrecision) return setPrecision_1;
  hasRequiredSetPrecision = 1;
  var i2 = function(e, t) {
    return e.substring(0, 9) !== "precision" ? "precision " + t + ` float;
` + e : e;
  };
  return setPrecision_1 = i2, setPrecision_1;
}
var generateUniformAccessObject_1, hasRequiredGenerateUniformAccessObject;
function requireGenerateUniformAccessObject() {
  if (hasRequiredGenerateUniformAccessObject) return generateUniformAccessObject_1;
  hasRequiredGenerateUniformAccessObject = 1;
  var i2 = function(u, l) {
    var c = { data: {} };
    c.gl = u;
    for (var d = Object.keys(l), f = 0; f < d.length; f++) {
      var p = d[f], m = p.split("."), y = m[m.length - 1], x = s(m, c), g = l[p];
      x.data[y] = g, x.gl = u, Object.defineProperty(x, y, {
        get: e(y),
        set: a(y, g)
      });
    }
    return c;
  }, e = function(u) {
    return function() {
      return this.data[u].value;
    };
  }, t = {
    float: function(u, l, c) {
      u.uniform1f(l, c);
    },
    vec2: function(u, l, c) {
      u.uniform2f(l, c[0], c[1]);
    },
    vec3: function(u, l, c) {
      u.uniform3f(l, c[0], c[1], c[2]);
    },
    vec4: function(u, l, c) {
      u.uniform4f(l, c[0], c[1], c[2], c[3]);
    },
    int: function(u, l, c) {
      u.uniform1i(l, c);
    },
    ivec2: function(u, l, c) {
      u.uniform2i(l, c[0], c[1]);
    },
    ivec3: function(u, l, c) {
      u.uniform3i(l, c[0], c[1], c[2]);
    },
    ivec4: function(u, l, c) {
      u.uniform4i(l, c[0], c[1], c[2], c[3]);
    },
    bool: function(u, l, c) {
      u.uniform1i(l, c);
    },
    bvec2: function(u, l, c) {
      u.uniform2i(l, c[0], c[1]);
    },
    bvec3: function(u, l, c) {
      u.uniform3i(l, c[0], c[1], c[2]);
    },
    bvec4: function(u, l, c) {
      u.uniform4i(l, c[0], c[1], c[2], c[3]);
    },
    mat2: function(u, l, c) {
      u.uniformMatrix2fv(l, false, c);
    },
    mat3: function(u, l, c) {
      u.uniformMatrix3fv(l, false, c);
    },
    mat4: function(u, l, c) {
      u.uniformMatrix4fv(l, false, c);
    },
    sampler2D: function(u, l, c) {
      u.uniform1i(l, c);
    }
  }, r = {
    float: function(u, l, c) {
      u.uniform1fv(l, c);
    },
    vec2: function(u, l, c) {
      u.uniform2fv(l, c);
    },
    vec3: function(u, l, c) {
      u.uniform3fv(l, c);
    },
    vec4: function(u, l, c) {
      u.uniform4fv(l, c);
    },
    int: function(u, l, c) {
      u.uniform1iv(l, c);
    },
    ivec2: function(u, l, c) {
      u.uniform2iv(l, c);
    },
    ivec3: function(u, l, c) {
      u.uniform3iv(l, c);
    },
    ivec4: function(u, l, c) {
      u.uniform4iv(l, c);
    },
    bool: function(u, l, c) {
      u.uniform1iv(l, c);
    },
    bvec2: function(u, l, c) {
      u.uniform2iv(l, c);
    },
    bvec3: function(u, l, c) {
      u.uniform3iv(l, c);
    },
    bvec4: function(u, l, c) {
      u.uniform4iv(l, c);
    },
    sampler2D: function(u, l, c) {
      u.uniform1iv(l, c);
    }
  };
  function a(u, l) {
    return function(c) {
      this.data[u].value = c;
      var d = this.data[u].location;
      l.size === 1 ? t[l.type](this.gl, d, c) : r[l.type](this.gl, d, c);
    };
  }
  function s(u, l) {
    for (var c = l, d = 0; d < u.length - 1; d++) {
      var f = c[u[d]] || { data: {} };
      c[u[d]] = f, c = f;
    }
    return c;
  }
  return generateUniformAccessObject_1 = i2, generateUniformAccessObject_1;
}
var GLShader, hasRequiredGLShader;
function requireGLShader() {
  if (hasRequiredGLShader) return GLShader;
  hasRequiredGLShader = 1;
  var i2 = requireCompileProgram(), e = requireExtractAttributes(), t = requireExtractUniforms(), r = requireSetPrecision(), a = requireGenerateUniformAccessObject(), s = function(u, l, c, d, f) {
    this.gl = u, d && (l = r(l, d), c = r(c, d)), this.program = i2(u, l, c, f), this.attributes = e(u, this.program), this.uniformData = t(u, this.program), this.uniforms = a(u, this.uniformData);
  };
  return s.prototype.bind = function() {
    return this.gl.useProgram(this.program), this;
  }, s.prototype.destroy = function() {
    this.attributes = null, this.uniformData = null, this.uniforms = null;
    var u = this.gl;
    u.deleteProgram(this.program);
  }, GLShader = s, GLShader;
}
var VertexArrayObject_1, hasRequiredVertexArrayObject;
function requireVertexArrayObject() {
  if (hasRequiredVertexArrayObject) return VertexArrayObject_1;
  hasRequiredVertexArrayObject = 1;
  var i2 = requireSetVertexAttribArrays();
  function e(t, r) {
    if (this.nativeVaoExtension = null, e.FORCE_NATIVE || (this.nativeVaoExtension = t.getExtension("OES_vertex_array_object") || t.getExtension("MOZ_OES_vertex_array_object") || t.getExtension("WEBKIT_OES_vertex_array_object")), this.nativeState = r, this.nativeVaoExtension) {
      this.nativeVao = this.nativeVaoExtension.createVertexArrayOES();
      var a = t.getParameter(t.MAX_VERTEX_ATTRIBS);
      this.nativeState = {
        tempAttribState: new Array(a),
        attribState: new Array(a)
      };
    }
    this.gl = t, this.attributes = [], this.indexBuffer = null, this.dirty = false;
  }
  return e.prototype.constructor = e, VertexArrayObject_1 = e, e.FORCE_NATIVE = false, e.prototype.bind = function() {
    if (this.nativeVao) {
      if (this.nativeVaoExtension.bindVertexArrayOES(this.nativeVao), this.dirty)
        return this.dirty = false, this.activate(), this;
      this.indexBuffer && this.indexBuffer.bind();
    } else
      this.activate();
    return this;
  }, e.prototype.unbind = function() {
    return this.nativeVao && this.nativeVaoExtension.bindVertexArrayOES(null), this;
  }, e.prototype.activate = function() {
    for (var t = this.gl, r = null, a = 0; a < this.attributes.length; a++) {
      var s = this.attributes[a];
      r !== s.buffer && (s.buffer.bind(), r = s.buffer), t.vertexAttribPointer(
        s.attribute.location,
        s.attribute.size,
        s.type || t.FLOAT,
        s.normalized || false,
        s.stride || 0,
        s.start || 0
      );
    }
    return i2(t, this.attributes, this.nativeState), this.indexBuffer && this.indexBuffer.bind(), this;
  }, e.prototype.addAttribute = function(t, r, a, s, u, l) {
    return this.attributes.push({
      buffer: t,
      attribute: r,
      location: r.location,
      type: a || this.gl.FLOAT,
      normalized: s || false,
      stride: u || 0,
      start: l || 0
    }), this.dirty = true, this;
  }, e.prototype.addIndex = function(t) {
    return this.indexBuffer = t, this.dirty = true, this;
  }, e.prototype.clear = function() {
    return this.nativeVao && this.nativeVaoExtension.bindVertexArrayOES(this.nativeVao), this.attributes.length = 0, this.indexBuffer = null, this;
  }, e.prototype.draw = function(t, r, a) {
    var s = this.gl;
    return this.indexBuffer ? s.drawElements(t, r || this.indexBuffer.data.length, s.UNSIGNED_SHORT, (a || 0) * 2) : s.drawArrays(t, a, r || this.getSize()), this;
  }, e.prototype.destroy = function() {
    this.gl = null, this.indexBuffer = null, this.attributes = null, this.nativeState = null, this.nativeVao && this.nativeVaoExtension.deleteVertexArrayOES(this.nativeVao), this.nativeVaoExtension = null, this.nativeVao = null;
  }, e.prototype.getSize = function() {
    var t = this.attributes[0];
    return t.buffer.data.length / (t.stride / 4 || t.attribute.size);
  }, VertexArrayObject_1;
}
var shader$1, hasRequiredShader$2;
function requireShader$2() {
  return hasRequiredShader$2 || (hasRequiredShader$2 = 1, shader$1 = {
    compileProgram: requireCompileProgram(),
    defaultValue: requireDefaultValue(),
    extractAttributes: requireExtractAttributes(),
    extractUniforms: requireExtractUniforms(),
    generateUniformAccessObject: requireGenerateUniformAccessObject(),
    setPrecision: requireSetPrecision(),
    mapSize: requireMapSize(),
    mapType: requireMapType()
  }), shader$1;
}
var hasRequiredSrc$1;
function requireSrc$1() {
  return hasRequiredSrc$1 || (hasRequiredSrc$1 = 1, function(i2) {
    var e = {
      createContext: requireCreateContext(),
      setVertexAttribArrays: requireSetVertexAttribArrays(),
      GLBuffer: requireGLBuffer(),
      GLFramebuffer: requireGLFramebuffer(),
      GLShader: requireGLShader(),
      GLTexture: requireGLTexture(),
      VertexArrayObject: requireVertexArrayObject(),
      shader: requireShader$2()
    };
    i2.exports && (i2.exports = e), typeof window < "u" && (window.PIXI = window.PIXI || {}, window.PIXI.glCore = e);
  }(src$1)), src$1.exports;
}
var hasRequiredExtractUniformsFromSrc;
function requireExtractUniformsFromSrc() {
  if (hasRequiredExtractUniformsFromSrc) return extractUniformsFromSrc;
  hasRequiredExtractUniformsFromSrc = 1, Object.defineProperty(extractUniformsFromSrc, "__esModule", {
    value: true
  }), extractUniformsFromSrc.default = r;
  var i2 = e(requireSrc$1());
  function e(s) {
    return s && s.__esModule ? s : { default: s };
  }
  var t = i2.default.shader.defaultValue;
  function r(s, u, l) {
    var c = a(s), d = a(u);
    return Object.assign(c, d);
  }
  function a(s) {
    for (var u = new RegExp("^(projectionMatrix|uSampler|filterArea|filterClamp)$"), l = {}, c, d = s.replace(/\s+/g, " ").split(/\s*[;}]\s*/), f = 0; f < d.length; f++) {
      var p = d[f].trim();
      if (p.indexOf("uniform") > -1) {
        var m = p.split(" "), y = m[1], x = m[2], g = 1;
        x.indexOf("[") > -1 && (c = x.split(/\[|]/), x = c[0], g *= Number(c[1])), x.match(u) || (l[x] = {
          value: t(y, g),
          name: x,
          type: y
        });
      }
    }
    return l;
  }
  return extractUniformsFromSrc;
}
var hasRequiredFilter$1;
function requireFilter$1() {
  if (hasRequiredFilter$1) return Filter;
  hasRequiredFilter$1 = 1, Object.defineProperty(Filter, "__esModule", {
    value: true
  }), Filter.default = void 0;
  var i2 = a(requireExtractUniformsFromSrc()), e = requireUtils$3(), t = require_const(), r = a(requireSettings());
  function a(l) {
    return l && l.__esModule ? l : { default: l };
  }
  var s = {};
  let u = class Sm {
    constructor(c, d, f) {
      this.vertexSrc = c || Sm.defaultVertexSrc, this.fragmentSrc = d || Sm.defaultFragmentSrc, this._blendMode = t.BLEND_MODES.NORMAL, this.uniformData = f || (0, i2.default)(this.vertexSrc, this.fragmentSrc, "projectionMatrix|uSampler"), this.uniforms = {};
      for (var p in this.uniformData)
        this.uniforms[p] = this.uniformData[p].value, this.uniformData[p].type && (this.uniformData[p].type = this.uniformData[p].type.toLowerCase());
      this.glShaders = {}, s[this.vertexSrc + this.fragmentSrc] || (s[this.vertexSrc + this.fragmentSrc] = (0, e.uid)()), this.glShaderKey = s[this.vertexSrc + this.fragmentSrc], this.padding = 4, this.resolution = r.default.FILTER_RESOLUTION, this.enabled = true, this.autoFit = true;
    }
    apply(c, d, f, p, m) {
      c.applyFilter(this, d, f, p);
    }
    get blendMode() {
      return this._blendMode;
    }
    set blendMode(c) {
      this._blendMode = c;
    }
    static get defaultVertexSrc() {
      return ["attribute vec2 aVertexPosition;", "attribute vec2 aTextureCoord;", "uniform mat3 projectionMatrix;", "uniform mat3 filterMatrix;", "varying vec2 vTextureCoord;", "varying vec2 vFilterCoord;", "void main(void){", "   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);", "   vFilterCoord = ( filterMatrix * vec3( aTextureCoord, 1.0)  ).xy;", "   vTextureCoord = aTextureCoord ;", "}"].join(`
`);
    }
    static get defaultFragmentSrc() {
      return [
        "varying vec2 vTextureCoord;",
        "varying vec2 vFilterCoord;",
        "uniform sampler2D uSampler;",
        "uniform sampler2D filterSampler;",
        "void main(void){",
        "   vec4 masky = texture2D(filterSampler, vFilterCoord);",
        "   vec4 sample = texture2D(uSampler, vTextureCoord);",
        "   vec4 color;",
        "   if(mod(vFilterCoord.x, 1.0) > 0.5)",
        "   {",
        "     color = vec4(1.0, 0.0, 0.0, 1.0);",
        "   }",
        "   else",
        "   {",
        "     color = vec4(0.0, 1.0, 0.0, 1.0);",
        "   }",
        // '   gl_FragColor = vec4(mod(vFilterCoord.x, 1.5), vFilterCoord.y,0.0,1.0);',
        "   gl_FragColor = mix(sample, masky, 0.5);",
        "   gl_FragColor *= sample.a;",
        "}"
      ].join(`
`);
    }
  };
  return Filter.default = u, Filter;
}
const __viteBrowserExternal = {}, __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: __viteBrowserExternal
}, Symbol.toStringTag, { value: "Module" })), require$$1$1 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
var hasRequiredFXAAFilter;
function requireFXAAFilter() {
  if (hasRequiredFXAAFilter) return FXAAFilter;
  hasRequiredFXAAFilter = 1, Object.defineProperty(FXAAFilter, "__esModule", {
    value: true
  }), FXAAFilter.default = void 0, e(requireSettings());
  var i2 = e(requireFilter$1());
  function e(r) {
    return r && r.__esModule ? r : { default: r };
  }
  let t = class extends i2.default {
    constructor() {
      super(
        // vertex shader
        `
attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;

varying vec2 v_rgbNW;
varying vec2 v_rgbNE;
varying vec2 v_rgbSW;
varying vec2 v_rgbSE;
varying vec2 v_rgbM;

uniform vec4 filterArea;

varying vec2 vTextureCoord;

vec2 mapCoord( vec2 coord )
{
    coord *= filterArea.xy;
    coord += filterArea.zw;

    return coord;
}

vec2 unmapCoord( vec2 coord )
{
    coord -= filterArea.zw;
    coord /= filterArea.xy;

    return coord;
}

void texcoords(vec2 fragCoord, vec2 resolution,
               out vec2 v_rgbNW, out vec2 v_rgbNE,
               out vec2 v_rgbSW, out vec2 v_rgbSE,
               out vec2 v_rgbM) {
    vec2 inverseVP = 1.0 / resolution.xy;
    v_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;
    v_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;
    v_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;
    v_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;
    v_rgbM = vec2(fragCoord * inverseVP);
}

void main(void) {

   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

   vTextureCoord = aTextureCoord;

   vec2 fragCoord = vTextureCoord * filterArea.xy;

   texcoords(fragCoord, filterArea.xy, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);
}`,
        // fragment shader
        `varying vec2 v_rgbNW;
varying vec2 v_rgbNE;
varying vec2 v_rgbSW;
varying vec2 v_rgbSE;
varying vec2 v_rgbM;

varying vec2 vTextureCoord;
uniform sampler2D uSampler;
uniform vec4 filterArea;

/**
 Basic FXAA implementation based on the code on geeks3d.com with the
 modification that the texture2DLod stuff was removed since it's
 unsupported by WebGL.
 
 --
 
 From:
 https://github.com/mitsuhiko/webgl-meincraft
 
 Copyright (c) 2011 by Armin Ronacher.
 
 Some rights reserved.
 
 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are
 met:
 
 * Redistributions of source code must retain the above copyright
 notice, this list of conditions and the following disclaimer.
 
 * Redistributions in binary form must reproduce the above
 copyright notice, this list of conditions and the following
 disclaimer in the documentation and/or other materials provided
 with the distribution.
 
 * The names of the contributors may not be used to endorse or
 promote products derived from this software without specific
 prior written permission.
 
 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef FXAA_REDUCE_MIN
#define FXAA_REDUCE_MIN   (1.0/ 128.0)
#endif
#ifndef FXAA_REDUCE_MUL
#define FXAA_REDUCE_MUL   (1.0 / 8.0)
#endif
#ifndef FXAA_SPAN_MAX
#define FXAA_SPAN_MAX     8.0
#endif

//optimized version for mobile, where dependent
//texture reads can be a bottleneck
vec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 resolution,
          vec2 v_rgbNW, vec2 v_rgbNE,
          vec2 v_rgbSW, vec2 v_rgbSE,
          vec2 v_rgbM) {
    vec4 color;
    mediump vec2 inverseVP = vec2(1.0 / resolution.x, 1.0 / resolution.y);
    vec3 rgbNW = texture2D(tex, v_rgbNW).xyz;
    vec3 rgbNE = texture2D(tex, v_rgbNE).xyz;
    vec3 rgbSW = texture2D(tex, v_rgbSW).xyz;
    vec3 rgbSE = texture2D(tex, v_rgbSE).xyz;
    vec4 texColor = texture2D(tex, v_rgbM);
    vec3 rgbM  = texColor.xyz;
    vec3 luma = vec3(0.299, 0.587, 0.114);
    float lumaNW = dot(rgbNW, luma);
    float lumaNE = dot(rgbNE, luma);
    float lumaSW = dot(rgbSW, luma);
    float lumaSE = dot(rgbSE, luma);
    float lumaM  = dot(rgbM,  luma);
    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));
    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));
    
    mediump vec2 dir;
    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));
    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));
    
    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *
                          (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);
    
    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);
    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),
              max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),
                  dir * rcpDirMin)) * inverseVP;
    
    vec3 rgbA = 0.5 * (
                       texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +
                       texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);
    vec3 rgbB = rgbA * 0.5 + 0.25 * (
                                     texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +
                                     texture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);
    
    float lumaB = dot(rgbB, luma);
    if ((lumaB < lumaMin) || (lumaB > lumaMax))
        color = vec4(rgbA, texColor.a);
    else
        color = vec4(rgbB, texColor.a);
    return color;
}

void main() {

      vec2 fragCoord = vTextureCoord * filterArea.xy;

      vec4 color;

    color = fxaa(uSampler, fragCoord, filterArea.xy, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);

      gl_FragColor = color;
}
`
      );
    }
  };
  return FXAAFilter.default = t, FXAAFilter;
}
var BlurFilter = {}, BlurXFilter = {}, generateBlurVertSource = {}, hasRequiredGenerateBlurVertSource;
function requireGenerateBlurVertSource() {
  if (hasRequiredGenerateBlurVertSource) return generateBlurVertSource;
  hasRequiredGenerateBlurVertSource = 1, Object.defineProperty(generateBlurVertSource, "__esModule", {
    value: true
  }), generateBlurVertSource.default = e;
  var i2 = ["attribute vec2 aVertexPosition;", "attribute vec2 aTextureCoord;", "uniform float strength;", "uniform mat3 projectionMatrix;", "varying vec2 vBlurTexCoords[%size%];", "void main(void)", "{", "gl_Position = vec4((projectionMatrix * vec3((aVertexPosition), 1.0)).xy, 0.0, 1.0);", "%blur%", "}"].join(`
`);
  function e(t, r) {
    var a = Math.ceil(t / 2), s = i2, u = "", l;
    r ? l = "vBlurTexCoords[%index%] = aTextureCoord + vec2(%sampleIndex% * strength, 0.0);" : l = "vBlurTexCoords[%index%] = aTextureCoord + vec2(0.0, %sampleIndex% * strength);";
    for (var c = 0; c < t; c++) {
      var d = l.replace("%index%", c);
      d = d.replace("%sampleIndex%", c - (a - 1) + ".0"), u += d, u += `
`;
    }
    return s = s.replace("%blur%", u), s = s.replace("%size%", t), s;
  }
  return generateBlurVertSource;
}
var generateBlurFragSource = {}, hasRequiredGenerateBlurFragSource;
function requireGenerateBlurFragSource() {
  if (hasRequiredGenerateBlurFragSource) return generateBlurFragSource;
  hasRequiredGenerateBlurFragSource = 1, Object.defineProperty(generateBlurFragSource, "__esModule", {
    value: true
  }), generateBlurFragSource.default = t;
  var i2 = {
    5: [0.153388, 0.221461, 0.250301],
    7: [0.071303, 0.131514, 0.189879, 0.214607],
    9: [0.028532, 0.067234, 0.124009, 0.179044, 0.20236],
    11: [93e-4, 0.028002, 0.065984, 0.121703, 0.175713, 0.198596],
    13: [2406e-6, 9255e-6, 0.027867, 0.065666, 0.121117, 0.174868, 0.197641],
    15: [489e-6, 2403e-6, 9246e-6, 0.02784, 0.065602, 0.120999, 0.174697, 0.197448]
  }, e = ["varying vec2 vBlurTexCoords[%size%];", "uniform sampler2D uSampler;", "void main(void)", "{", "    gl_FragColor = vec4(0.0);", "    %blur%", "}"].join(`
`);
  function t(r) {
    for (var a = i2[r], s = a.length, u = e, l = "", c = "gl_FragColor += texture2D(uSampler, vBlurTexCoords[%index%]) * %value%;", d, f = 0; f < r; f++) {
      var p = c.replace("%index%", f);
      d = f, f >= s && (d = r - f - 1), p = p.replace("%value%", a[d]), l += p, l += `
`;
    }
    return u = u.replace("%blur%", l), u = u.replace("%size%", r), u;
  }
  return generateBlurFragSource;
}
var getMaxBlurKernelSize = {}, hasRequiredGetMaxBlurKernelSize;
function requireGetMaxBlurKernelSize() {
  if (hasRequiredGetMaxBlurKernelSize) return getMaxBlurKernelSize;
  hasRequiredGetMaxBlurKernelSize = 1, Object.defineProperty(getMaxBlurKernelSize, "__esModule", {
    value: true
  }), getMaxBlurKernelSize.default = i2;
  function i2(e) {
    for (var t = e.getParameter(e.MAX_VARYING_VECTORS), r = 15; r > t; )
      r -= 2;
    return r;
  }
  return getMaxBlurKernelSize;
}
var hasRequiredBlurXFilter;
function requireBlurXFilter() {
  if (hasRequiredBlurXFilter) return BlurXFilter;
  hasRequiredBlurXFilter = 1, Object.defineProperty(BlurXFilter, "__esModule", {
    value: true
  }), BlurXFilter.default = void 0;
  var i2 = s(requireSettings()), e = s(requireFilter$1()), t = s(requireGenerateBlurVertSource()), r = s(requireGenerateBlurFragSource()), a = s(requireGetMaxBlurKernelSize());
  function s(l) {
    return l && l.__esModule ? l : { default: l };
  }
  let u = class extends e.default {
    constructor(l, c, d, f) {
      f = f || 5;
      var p = (0, t.default)(f, true), m = (0, r.default)(f);
      super(
        // vertex shader
        p,
        // fragment shader
        m
      ), this.resolution = d || i2.default.RESOLUTION, this._quality = 0, this.quality = c || 4, this.strength = l || 8, this.firstRun = true;
    }
    apply(l, c, d, f) {
      if (this.firstRun) {
        var p = l.renderer.gl, m = (0, a.default)(p);
        this.vertexSrc = (0, t.default)(m, true), this.fragmentSrc = (0, r.default)(m), this.firstRun = false;
      }
      if (this.uniforms.strength = 1 / d.size.width * (d.size.width / c.size.width), this.uniforms.strength *= this.strength, this.uniforms.strength /= this.passes, this.passes === 1)
        l.applyFilter(this, c, d, f);
      else {
        for (var y = l.getRenderTarget(true), x = c, g = y, _ = 0; _ < this.passes - 1; _++) {
          l.applyFilter(this, x, g, true);
          var T = g;
          g = x, x = T;
        }
        l.applyFilter(this, x, d, f), l.returnRenderTarget(y);
      }
    }
    get blur() {
      return this.strength;
    }
    set blur(l) {
      this.padding = Math.abs(l) * 2, this.strength = l;
    }
    get quality() {
      return this._quality;
    }
    set quality(l) {
      this._quality = l, this.passes = l;
    }
  };
  return BlurXFilter.default = u, BlurXFilter;
}
var BlurYFilter = {}, hasRequiredBlurYFilter;
function requireBlurYFilter() {
  if (hasRequiredBlurYFilter) return BlurYFilter;
  hasRequiredBlurYFilter = 1, Object.defineProperty(BlurYFilter, "__esModule", {
    value: true
  }), BlurYFilter.default = void 0;
  var i2 = l(requireSettings()), e = s(requireFilter$1()), t = s(requireGenerateBlurVertSource()), r = s(requireGenerateBlurFragSource()), a = s(requireGetMaxBlurKernelSize());
  function s(d) {
    return d && d.__esModule ? d : { default: d };
  }
  function u(d) {
    if (typeof WeakMap != "function") return null;
    var f = /* @__PURE__ */ new WeakMap(), p = /* @__PURE__ */ new WeakMap();
    return (u = function(m) {
      return m ? p : f;
    })(d);
  }
  function l(d, f) {
    if (d && d.__esModule)
      return d;
    if (d === null || typeof d != "object" && typeof d != "function")
      return { default: d };
    var p = u(f);
    if (p && p.has(d))
      return p.get(d);
    var m = {}, y = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var x in d)
      if (x !== "default" && Object.prototype.hasOwnProperty.call(d, x)) {
        var g = y ? Object.getOwnPropertyDescriptor(d, x) : null;
        g && (g.get || g.set) ? Object.defineProperty(m, x, g) : m[x] = d[x];
      }
    return m.default = d, p && p.set(d, m), m;
  }
  let c = class extends e.default {
    constructor(d, f, p, m) {
      m = m || 5;
      var y = (0, t.default)(m, false), x = (0, r.default)(m);
      super(
        // vertex shader
        y,
        // fragment shader
        x
      ), this.resolution = p || i2.RESOLUTION, this._quality = 0, this.quality = f || 4, this.strength = d || 8, this.firstRun = true;
    }
    apply(d, f, p, m) {
      if (this.firstRun) {
        var y = d.renderer.gl, x = (0, a.default)(y);
        this.vertexSrc = (0, t.default)(x, false), this.fragmentSrc = (0, r.default)(x), this.firstRun = false;
      }
      if (this.uniforms.strength = 1 / p.size.height * (p.size.height / f.size.height), this.uniforms.strength *= this.strength, this.uniforms.strength /= this.passes, this.passes === 1)
        d.applyFilter(this, f, p, m);
      else {
        for (var g = d.getRenderTarget(true), _ = f, T = g, E = 0; E < this.passes - 1; E++) {
          d.applyFilter(this, _, T, true);
          var b = T;
          T = _, _ = b;
        }
        d.applyFilter(this, _, p, m), d.returnRenderTarget(g);
      }
    }
    /**
     * Sets the strength of both the blur.
     *
     * @member {number}
     * @default 2
     */
    get blur() {
      return this.strength;
    }
    set blur(d) {
      this.padding = Math.abs(d) * 2, this.strength = d;
    }
    /**
     * Sets the quality of the blur by modifying the number of passes. More passes means higher
     * quaility bluring but the lower the performance.
     *
     * @member {number}
     * @default 4
     */
    get quality() {
      return this._quality;
    }
    set quality(d) {
      this._quality = d, this.passes = d;
    }
  };
  return BlurYFilter.default = c, BlurYFilter;
}
var hasRequiredBlurFilter;
function requireBlurFilter() {
  if (hasRequiredBlurFilter) return BlurFilter;
  hasRequiredBlurFilter = 1, Object.defineProperty(BlurFilter, "__esModule", {
    value: true
  }), BlurFilter.default = void 0;
  var i2 = a(requireSettings()), e = a(requireFilter$1()), t = a(requireBlurXFilter()), r = a(requireBlurYFilter());
  function a(u) {
    return u && u.__esModule ? u : { default: u };
  }
  let s = class extends e.default {
    constructor(u, l, c, d) {
      super(), this.blurXFilter = new t.default(u, l, c, d), this.blurYFilter = new r.default(u, l, c, d), this.padding = 0, this.resolution = c || i2.default.RESOLUTION, this.quality = l || 4, this.blur = u || 8;
    }
    apply(u, l, c) {
      var d = u.getRenderTarget(true);
      this.blurXFilter.apply(u, l, d, true), this.blurYFilter.apply(u, d, c, false), u.returnRenderTarget(d);
    }
    /**
     * Sets the strength of both the blurX and blurY properties simultaneously
     *
     * @member {number}
     * @default 2
     */
    get blur() {
      return this.blurXFilter.blur;
    }
    set blur(u) {
      this.blurXFilter.blur = this.blurYFilter.blur = u, this.padding = Math.max(Math.abs(this.blurXFilter.strength), Math.abs(this.blurYFilter.strength)) * 2;
    }
    /**
     * Sets the number of passes for blur. More passes means higher quaility bluring.
     *
     * @member {number}
     * @default 1
     */
    get quality() {
      return this.blurXFilter.quality;
    }
    set quality(u) {
      this.blurXFilter.quality = this.blurYFilter.quality = u;
    }
    /**
     * Sets the strength of the blurX property
     *
     * @member {number}
     * @default 2
     */
    get blurX() {
      return this.blurXFilter.blur;
    }
    set blurX(u) {
      this.blurXFilter.blur = u, this.padding = Math.max(Math.abs(this.blurXFilter.strength), Math.abs(this.blurYFilter.strength)) * 2;
    }
    /**
     * Sets the strength of the blurY property
     *
     * @member {number}
     * @default 2
     */
    get blurY() {
      return this.blurYFilter.blur;
    }
    set blurY(u) {
      this.blurYFilter.blur = u, this.padding = Math.max(Math.abs(this.blurXFilter.strength), Math.abs(this.blurYFilter.strength)) * 2;
    }
    get blendMode() {
      return this.blurYFilter._blendMode;
    }
    set blendMode(u) {
      this.blurYFilter._blendMode = u;
    }
  };
  return BlurFilter.default = s, BlurFilter;
}
var ChromaFilter = {}, hasRequiredChromaFilter;
function requireChromaFilter() {
  if (hasRequiredChromaFilter) return ChromaFilter;
  hasRequiredChromaFilter = 1, Object.defineProperty(ChromaFilter, "__esModule", {
    value: true
  }), ChromaFilter.default = void 0;
  var i2 = e(requireFilter$1());
  requireUtils$3();
  function e(r) {
    return r && r.__esModule ? r : { default: r };
  }
  let t = class extends i2.default {
    constructor(r, a, s, u, l) {
      a === void 0 && (a = 0.3), s === void 0 && (s = 0.1), u === void 0 && (u = 0.1), l === void 0 && (l = 0.5), super(
        // vertex shader
        `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);
    vTextureCoord = aTextureCoord;
}`,
        // fragment shader
        `varying vec2 vTextureCoord;

uniform sampler2D uSampler;
uniform vec3 uColor;
uniform float uSimilarity;
uniform float uSmoothness;
uniform float uSaturation;
uniform float uShadowness;

vec2 RGBtoUV(vec3 rgb) {
  return vec2(
    rgb.r * -0.169 + rgb.g * -0.331 + rgb.b *  0.5    + 0.5,
    rgb.r *  0.5   + rgb.g * -0.419 + rgb.b * -0.081  + 0.5
  );
}

vec4 ProcessChromaKey(vec2 uv) {
  vec4 rgba = texture2D(uSampler, uv);
  float chromaDist = distance(RGBtoUV(rgba.rgb), RGBtoUV(uColor));

  float diff = chromaDist - uSimilarity;
  float alpha = pow(clamp(diff / uSmoothness, 0., 1.), 1.5);
  rgba *= alpha;

  float sat = pow(clamp(diff / uSaturation, 0., 1.), 1.5);
  float luma = clamp(rgba.r * 0.2126 + rgba.g * 0.7152 + rgba.b * 0.0722, 0., 1.) * uShadowness;
  rgba.rgb = mix(vec3(luma, luma, luma), rgba.rgb, sat);

  return rgba;
}

void main(void) {
  gl_FragColor = ProcessChromaKey(vTextureCoord);
}
`
      ), this.color = r, this.similarity = Math.max(a, 1e-3), this.smoothness = Math.max(s, 1e-3), this.saturation = Math.max(u, 1e-3), this.shadowness = Math.max(l, 1e-3), this.glShaderKey = "chroma";
    }
    get color() {
      return this.uniforms.uColor;
    }
    set color(r) {
      this.uniforms.uColor = r;
    }
    get similarity() {
      return this.uniforms.uSimilarity;
    }
    set similarity(r) {
      this.uniforms.uSimilarity = r;
    }
    get smoothness() {
      return this.uniforms.uSmoothness;
    }
    set smoothness(r) {
      this.uniforms.uSmoothness = r;
    }
    get saturation() {
      return this.uniforms.uSaturation;
    }
    set saturation(r) {
      this.uniforms.uSaturation = r;
    }
    get shadowness() {
      return this.uniforms.uShadowness;
    }
    set shadowness(r) {
      this.uniforms.uShadowness = r;
    }
  };
  return ChromaFilter.default = t, ChromaFilter;
}
var DisplacementFilter = {}, hasRequiredDisplacementFilter;
function requireDisplacementFilter() {
  if (hasRequiredDisplacementFilter) return DisplacementFilter;
  hasRequiredDisplacementFilter = 1, Object.defineProperty(DisplacementFilter, "__esModule", {
    value: true
  }), DisplacementFilter.default = void 0;
  var i2 = r(requireFilter$1()), e = r(requireMatrix()), t = r(requirePoint());
  function r(s) {
    return s && s.__esModule ? s : { default: s };
  }
  let a = class extends i2.default {
    constructor(s, u) {
      var l = new e.default();
      s.renderable = false, super(
        // vertex shader
        `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;
uniform mat3 filterMatrix;

varying vec2 vTextureCoord;
varying vec2 vFilterCoord;

void main(void)
{
   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);
   vFilterCoord = ( filterMatrix * vec3( aTextureCoord, 1.0)  ).xy;
   vTextureCoord = aTextureCoord;
}`,
        // fragment shader
        `varying vec2 vFilterCoord;
varying vec2 vTextureCoord;

uniform vec2 scale;

uniform sampler2D uSampler;
uniform sampler2D mapSampler;

uniform vec4 filterArea;
uniform vec4 filterClamp;

void main(void)
{
  vec4 map =  texture2D(mapSampler, vFilterCoord);

  map -= 0.5;
  map.xy *= scale / filterArea.xy;

  gl_FragColor = texture2D(uSampler, clamp(vec2(vTextureCoord.x + map.x, vTextureCoord.y + map.y), filterClamp.xy, filterClamp.zw));
}
`
      ), this.maskSprite = s, this.maskMatrix = l, this.uniforms.mapSampler = s._texture, this.uniforms.filterMatrix = l, this.uniforms.scale = {
        x: 1,
        y: 1
      }, u == null && (u = 20), this.setScale(u, u);
    }
    setScale(s, u) {
      this.scale = new t.default(s, u);
    }
    apply(s, u, l) {
      this.uniforms.filterMatrix = s.calculateSpriteMatrix(this.maskMatrix, this.maskSprite), this.uniforms.scale.x = this.scale.x, this.uniforms.scale.y = this.scale.y, super.apply(s, u, l);
    }
    get map() {
      return this.uniforms.mapSampler;
    }
    set map(s) {
      this.uniforms.mapSampler = s;
    }
  };
  return DisplacementFilter.default = a, DisplacementFilter;
}
var TransitionFilter = {}, hasRequiredTransitionFilter;
function requireTransitionFilter() {
  if (hasRequiredTransitionFilter) return TransitionFilter;
  hasRequiredTransitionFilter = 1, Object.defineProperty(TransitionFilter, "__esModule", {
    value: true
  }), TransitionFilter.default = void 0;
  var i2 = e(requireFilter$1());
  function e(r) {
    return r && r.__esModule ? r : { default: r };
  }
  let t = class extends i2.default {
    constructor(r) {
      var a = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;
varying vec2 _uv;

void main(void) {
  vec2 _p = (projectionMatrix * vec3(aVertexPosition, 1.0)).xy;
  gl_Position = vec4(_p, 0.0, 1.0);
  vTextureCoord = aTextureCoord;
  _uv = vec2(0.5, 0.5) * (_p+vec2(1.0, 1.0));
}`, s = `precision highp float;

varying vec2 _uv;

uniform float progress;
uniform float ratio;
uniform vec2 _offset;

uniform sampler2D fromSampler;
uniform sampler2D toSampler;

vec4 getColor(sampler2D tex, vec2 uv) {
  return texture2D(tex, vec2(uv.x + _offset.x, 1.0 - (uv.y + _offset.y)));
}

vec4 getFromColor(vec2 uv) {
  return getColor(fromSampler, uv);
}

vec4 getToColor(vec2 uv) {
  return getColor(toSampler, uv);
}

\${transitionGlsl}

void main(void) {
  gl_FragColor = transition(_uv - _offset);
  //gl_FragColor = getFromColor(_uv);
}
`, u = r.glsl, l = [];
      for (var c of u.split(`
`))
        if (c = c.trim(), !c.startsWith("//"))
          if (c.startsWith("uniform ")) {
            var d = [];
            for (var f of c.replace(/\s+/g, " ").split(" ")) {
              if (f.startsWith("//")) break;
              d.push(f);
            }
            l.push(d.join(" "));
          } else
            l.push(c);
      u = l.join(`
`), s = s.replace("${transitionGlsl}", u), super(a, s), this.transition = r;
    }
    // apply(filterManager, input, output) {
    //   console.log('apply', this.uniforms);
    //   super.apply(filterManager, input, output);
    // }
    get prev() {
      return this.fromSprite;
    }
    get next() {
      return this.toSprite;
    }
    set prev(r) {
      this.setSprite("from", r);
    }
    set next(r) {
      this.setSprite("to", r);
    }
    get ratio() {
      return this.uniforms.ratio;
    }
    set ratio(r) {
      this.uniforms.ratio = r;
    }
    get offset() {
      return this.uniforms._offset;
    }
    set offset(r) {
      this.uniforms._offset = r;
    }
    set params(r) {
      var a = 2, {
        transition: s,
        uniforms: u
      } = this;
      for (var l in s.paramsTypes) {
        var c = l in r ? r[l] : s.defaultParams[l];
        if (s.paramsTypes[l] === "sampler2D")
          if (!c)
            console.warn("uniform[" + l + "]: A texture MUST be defined for uniform sampler2D of a texture");
          else {
            if (typeof c.bind != "function")
              throw new Error("uniform[" + l + "]: A gl-texture2d API-like object was expected");
            u[l] = c.bind(a++);
          }
        else
          u[l] = c;
      }
    }
    setSprite(r, a) {
      this[r + "Sprite"] = a, a.renderable = false, this.uniforms[r + "Sampler"] = a.texture;
    }
    updateProgress(r) {
      this.uniforms.progress = r;
    }
  };
  return TransitionFilter.default = t, TransitionFilter;
}
var ColorMatrixFilter = {}, hasRequiredColorMatrixFilter;
function requireColorMatrixFilter() {
  if (hasRequiredColorMatrixFilter) return ColorMatrixFilter;
  hasRequiredColorMatrixFilter = 1, Object.defineProperty(ColorMatrixFilter, "__esModule", {
    value: true
  }), ColorMatrixFilter.default = void 0, e(requireSettings());
  var i2 = e(requireFilter$1());
  function e(r) {
    return r && r.__esModule ? r : { default: r };
  }
  let t = class extends i2.default {
    constructor() {
      super(
        // vertex shader
        `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);
    vTextureCoord = aTextureCoord;
}`,
        // fragment shader
        `varying vec2 vTextureCoord;
uniform sampler2D uSampler;
uniform float m[20];
uniform float uAlpha;

void main(void)
{
    vec4 c = texture2D(uSampler, vTextureCoord);

    if (uAlpha == 0.0) {
        gl_FragColor = c;
        return;
    }

    // Un-premultiply alpha before applying the color matrix. See issue #3539.
    if (c.a > 0.0) {
      c.rgb /= c.a;
    }

    vec4 result;

    result.r = (m[0] * c.r);
        result.r += (m[1] * c.g);
        result.r += (m[2] * c.b);
        result.r += (m[3] * c.a);
        result.r += m[4];

    result.g = (m[5] * c.r);
        result.g += (m[6] * c.g);
        result.g += (m[7] * c.b);
        result.g += (m[8] * c.a);
        result.g += m[9];

    result.b = (m[10] * c.r);
       result.b += (m[11] * c.g);
       result.b += (m[12] * c.b);
       result.b += (m[13] * c.a);
       result.b += m[14];

    result.a = (m[15] * c.r);
       result.a += (m[16] * c.g);
       result.a += (m[17] * c.b);
       result.a += (m[18] * c.a);
       result.a += m[19];

    vec3 rgb = mix(c.rgb, result.rgb, uAlpha);

    // Premultiply alpha again.
    rgb *= result.a;

    gl_FragColor = vec4(rgb, result.a);
}
`
      ), this.init();
    }
    init() {
      this.uniforms.m = [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0], this.alpha = 1;
    }
    /**
     * Transforms current matrix and set the new one
     *
     * @param {number[]} matrix - 5x4 matrix
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    _loadMatrix(r, a) {
      a === void 0 && (a = false);
      var s = r;
      a && (this._multiply(s, this.uniforms.m, r), s = this._colorMatrix(s)), this.uniforms.m = s;
    }
    /**
     * Multiplies two mat5's
     *
     * @private
     * @param {number[]} out - 5x4 matrix the receiving matrix
     * @param {number[]} a - 5x4 matrix the first operand
     * @param {number[]} b - 5x4 matrix the second operand
     * @returns {number[]} 5x4 matrix
     */
    _multiply(r, a, s) {
      return r[0] = a[0] * s[0] + a[1] * s[5] + a[2] * s[10] + a[3] * s[15], r[1] = a[0] * s[1] + a[1] * s[6] + a[2] * s[11] + a[3] * s[16], r[2] = a[0] * s[2] + a[1] * s[7] + a[2] * s[12] + a[3] * s[17], r[3] = a[0] * s[3] + a[1] * s[8] + a[2] * s[13] + a[3] * s[18], r[4] = a[0] * s[4] + a[1] * s[9] + a[2] * s[14] + a[3] * s[19] + a[4], r[5] = a[5] * s[0] + a[6] * s[5] + a[7] * s[10] + a[8] * s[15], r[6] = a[5] * s[1] + a[6] * s[6] + a[7] * s[11] + a[8] * s[16], r[7] = a[5] * s[2] + a[6] * s[7] + a[7] * s[12] + a[8] * s[17], r[8] = a[5] * s[3] + a[6] * s[8] + a[7] * s[13] + a[8] * s[18], r[9] = a[5] * s[4] + a[6] * s[9] + a[7] * s[14] + a[8] * s[19] + a[9], r[10] = a[10] * s[0] + a[11] * s[5] + a[12] * s[10] + a[13] * s[15], r[11] = a[10] * s[1] + a[11] * s[6] + a[12] * s[11] + a[13] * s[16], r[12] = a[10] * s[2] + a[11] * s[7] + a[12] * s[12] + a[13] * s[17], r[13] = a[10] * s[3] + a[11] * s[8] + a[12] * s[13] + a[13] * s[18], r[14] = a[10] * s[4] + a[11] * s[9] + a[12] * s[14] + a[13] * s[19] + a[14], r[15] = a[15] * s[0] + a[16] * s[5] + a[17] * s[10] + a[18] * s[15], r[16] = a[15] * s[1] + a[16] * s[6] + a[17] * s[11] + a[18] * s[16], r[17] = a[15] * s[2] + a[16] * s[7] + a[17] * s[12] + a[18] * s[17], r[18] = a[15] * s[3] + a[16] * s[8] + a[17] * s[13] + a[18] * s[18], r[19] = a[15] * s[4] + a[16] * s[9] + a[17] * s[14] + a[18] * s[19] + a[19], r;
    }
    /**
     * Create a Float32 Array and normalize the offset component to 0-1
     *
     * @private
     * @param {number[]} matrix - 5x4 matrix
     * @return {number[]} 5x4 matrix with all values between 0-1
     */
    _colorMatrix(r) {
      var a = new Float32Array(r);
      return a[4] /= 255, a[9] /= 255, a[14] /= 255, a[19] /= 255, a;
    }
    /**
     * Adjusts brightness
     *
     * @param {number} b - value of the brigthness (0-1, where 0 is black)
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    brightness(r, a) {
      var s = [r, 0, 0, 0, 0, 0, r, 0, 0, 0, 0, 0, r, 0, 0, 0, 0, 0, 1, 0];
      this._loadMatrix(s, a);
    }
    /**
     * Set the matrices in grey scales
     *
     * @param {number} scale - value of the grey (0-1, where 0 is black)
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    greyscale(r, a) {
      var s = [r, r, r, 0, 0, r, r, r, 0, 0, r, r, r, 0, 0, 0, 0, 0, 1, 0];
      this._loadMatrix(s, a);
    }
    /**
     * Set the black and white matrice.
     *
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    blackAndWhite(r) {
      var a = [0.3, 0.6, 0.1, 0, 0, 0.3, 0.6, 0.1, 0, 0, 0.3, 0.6, 0.1, 0, 0, 0, 0, 0, 1, 0];
      this._loadMatrix(a, r);
    }
    /**
     * Set the hue property of the color
     *
     * @param {number} rotation - in degrees
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    hue(r, a) {
      r = (r || 0) / 180 * Math.PI;
      var s = Math.cos(r), u = Math.sin(r), l = Math.sqrt, c = 1 / 3, d = l(c), f = s + (1 - s) * c, p = c * (1 - s) - d * u, m = c * (1 - s) + d * u, y = c * (1 - s) + d * u, x = s + c * (1 - s), g = c * (1 - s) - d * u, _ = c * (1 - s) - d * u, T = c * (1 - s) + d * u, E = s + c * (1 - s), b = [f, p, m, 0, 0, y, x, g, 0, 0, _, T, E, 0, 0, 0, 0, 0, 1, 0];
      this._loadMatrix(b, a);
    }
    /**
     * Set the contrast matrix, increase the separation between dark and bright
     * Increase contrast : shadows darker and highlights brighter
     * Decrease contrast : bring the shadows up and the highlights down
     *
     * @param {number} amount - value of the contrast (0-1)
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    contrast(r, a) {
      var s = (r || 0) + 1, u = -0.5 * (s - 1), l = [s, 0, 0, 0, u, 0, s, 0, 0, u, 0, 0, s, 0, u, 0, 0, 0, 1, 0];
      this._loadMatrix(l, a);
    }
    /**
     * Set the saturation matrix, increase the separation between colors
     * Increase saturation : increase contrast, brightness, and sharpness
     *
     * @param {number} amount - The saturation amount (0-1)
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    saturate(r, a) {
      r === void 0 && (r = 0);
      var s = r * 2 / 3 + 1, u = (s - 1) * -0.5, l = [s, u, u, 0, 0, u, s, u, 0, 0, u, u, s, 0, 0, 0, 0, 0, 1, 0];
      this._loadMatrix(l, a);
    }
    /**
     * Desaturate image (remove color)
     *
     * Call the saturate function
     *
     */
    desaturate() {
      this.saturate(-1);
    }
    /**
     * Negative image (inverse of classic rgb matrix)
     *
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    negative(r) {
      var a = [-1, 0, 0, 1, 0, 0, -1, 0, 1, 0, 0, 0, -1, 1, 0, 0, 0, 0, 1, 0];
      this._loadMatrix(a, r);
    }
    /**
     * Sepia image
     *
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    sepia(r) {
      var a = [0.393, 0.7689999, 0.18899999, 0, 0, 0.349, 0.6859999, 0.16799999, 0, 0, 0.272, 0.5339999, 0.13099999, 0, 0, 0, 0, 0, 1, 0];
      this._loadMatrix(a, r);
    }
    /**
     * Color motion picture process invented in 1916 (thanks Dominic Szablewski)
     *
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    technicolor(r) {
      var a = [1.9125277891456083, -0.8545344976951645, -0.09155508482755585, 0, 11.793603434377337, -0.3087833385928097, 1.7658908555458428, -0.10601743074722245, 0, -70.35205161461398, -0.231103377548616, -0.7501899197440212, 1.847597816108189, 0, 30.950940869491138, 0, 0, 0, 1, 0];
      this._loadMatrix(a, r);
    }
    /**
     * Polaroid filter
     *
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    polaroid(r) {
      var a = [1.438, -0.062, -0.062, 0, 0, -0.122, 1.378, -0.122, 0, 0, -0.016, -0.016, 1.483, 0, 0, 0, 0, 0, 1, 0];
      this._loadMatrix(a, r);
    }
    /**
     * Filter who transforms : Red -> Blue and Blue -> Red
     *
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    toBGR(r) {
      var a = [0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0];
      this._loadMatrix(a, r);
    }
    /**
     * Color reversal film introduced by Eastman Kodak in 1935. (thanks Dominic Szablewski)
     *
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    kodachrome(r) {
      var a = [1.1285582396593525, -0.3967382283601348, -0.03992559172921793, 0, 63.72958762196502, -0.16404339962244616, 1.0835251566291304, -0.05498805115633132, 0, 24.732407896706203, -0.16786010706155763, -0.5603416277695248, 1.6014850761964943, 0, 35.62982807460946, 0, 0, 0, 1, 0];
      this._loadMatrix(a, r);
    }
    /**
     * Brown delicious browni filter (thanks Dominic Szablewski)
     *
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    browni(r) {
      var a = [0.5997023498159715, 0.34553243048391263, -0.2708298674538042, 0, 47.43192855600873, -0.037703249837783157, 0.8609577587992641, 0.15059552388459913, 0, -36.96841498319127, 0.24113635128153335, -0.07441037908422492, 0.44972182064877153, 0, -7.562075277591283, 0, 0, 0, 1, 0];
      this._loadMatrix(a, r);
    }
    /**
     * Vintage filter (thanks Dominic Szablewski)
     *
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    vintage(r) {
      var a = [0.6279345635605994, 0.3202183420819367, -0.03965408211312453, 0, 9.651285835294123, 0.02578397704808868, 0.6441188644374771, 0.03259127616149294, 0, 7.462829176470591, 0.0466055556782719, -0.0851232987247891, 0.5241648018700465, 0, 5.159190588235296, 0, 0, 0, 1, 0];
      this._loadMatrix(a, r);
    }
    /**
     * We don't know exactly what it does, kind of gradient map, but funny to play with!
     *
     * @param {number} desaturation - Tone values.
     * @param {number} toned - Tone values.
     * @param {string} lightColor - Tone values, example: `0xFFE580`
     * @param {string} darkColor - Tone values, example: `0xFFE580`
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    colorTone(r, a, s, u, l) {
      r = r || 0.2, a = a || 0.15, s = s || 16770432, u = u || 3375104;
      var c = (s >> 16 & 255) / 255, d = (s >> 8 & 255) / 255, f = (s & 255) / 255, p = (u >> 16 & 255) / 255, m = (u >> 8 & 255) / 255, y = (u & 255) / 255, x = [0.3, 0.59, 0.11, 0, 0, c, d, f, r, 0, p, m, y, a, 0, c - p, d - m, f - y, 0, 0];
      this._loadMatrix(x, l);
    }
    /**
     * Night effect
     *
     * @param {number} intensity - The intensity of the night effect.
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    night(r, a) {
      r = r || 0.1;
      var s = [r * -2, -r, 0, 0, 0, -r, 0, r, 0, 0, 0, r, r * 2, 0, 0, 0, 0, 0, 1, 0];
      this._loadMatrix(s, a);
    }
    /**
     * Predator effect
     *
     * Erase the current matrix by setting a new indepent one
     *
     * @param {number} amount - how much the predator feels his future victim
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    predator(r, a) {
      var s = [
        // row 1
        11.224130630493164 * r,
        -4.794486999511719 * r,
        -2.8746118545532227 * r,
        0 * r,
        0.40342438220977783 * r,
        // row 2
        -3.6330697536468506 * r,
        9.193157196044922 * r,
        -2.951810836791992 * r,
        0 * r,
        -1.316135048866272 * r,
        // row 3
        -3.2184197902679443 * r,
        -4.2375030517578125 * r,
        7.476448059082031 * r,
        0 * r,
        0.8044459223747253 * r,
        // row 4
        0,
        0,
        0,
        1,
        0
      ];
      this._loadMatrix(s, a);
    }
    /**
     * LSD effect
     *
     * Multiply the current matrix
     *
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    lsd(r) {
      var a = [2, -0.4, 0.5, 0, 0, -0.5, 2, -0.4, 0, 0, -0.4, -0.5, 3, 0, 0, 0, 0, 0, 1, 0];
      this._loadMatrix(a, r);
    }
    /**
     * Erase the current matrix by setting the default one
     *
     */
    reset() {
      var r = [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0];
      this._loadMatrix(r, false);
    }
    /**
     * The matrix of the color matrix filter
     *
     * @member {number[]}
     * @default [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0]
     */
    get matrix() {
      return this.uniforms.m;
    }
    set matrix(r) {
      this.uniforms.m = r;
    }
    /**
     * The opacity value to use when mixing the original and resultant colors.
     *
     * When the value is 0, the original color is used without modification.
     * When the value is 1, the result color is used.
     * When in the range (0, 1) the color is interpolated between the original and result by this amount.
     *
     * @member {number}
     * @default 1
     */
    get alpha() {
      return this.uniforms.uAlpha;
    }
    set alpha(r) {
      this.uniforms.uAlpha = r;
    }
  };
  return ColorMatrixFilter.default = t, t.prototype.grayscale = t.prototype.greyscale, ColorMatrixFilter;
}
var SimpleFilter$1 = {}, TextureMatrix = {}, hasRequiredTextureMatrix;
function requireTextureMatrix() {
  if (hasRequiredTextureMatrix) return TextureMatrix;
  hasRequiredTextureMatrix = 1, Object.defineProperty(TextureMatrix, "__esModule", {
    value: true
  }), TextureMatrix.default = void 0;
  var i2 = e(requireMatrix());
  function e(a) {
    return a && a.__esModule ? a : { default: a };
  }
  var t = new i2.default();
  let r = class {
    constructor(a, s) {
      this._texture = a, this.mapCoord = new i2.default(), this.uClampFrame = new Float32Array(4), this.uClampOffset = new Float32Array(2), this._lastTextureID = -1, this.clampOffset = 0, this.clampMargin = typeof s > "u" ? 0.5 : s;
    }
    get texture() {
      return this._texture;
    }
    set texture(a) {
      this._texture = a, this._lastTextureID = -1;
    }
    multiplyUvs(a, s) {
      s === void 0 && (s = a);
      for (var u = this.mapCoord, l = 0; l < a.length; l += 2) {
        var c = a[l], d = a[l + 1];
        s[l] = c * u.a + d * u.c + u.tx, s[l + 1] = c * u.b + d * u.d + u.ty;
      }
      return s;
    }
    update(a) {
      var s = this._texture;
      if (!s || !s.valid || !a && this._lastTextureID === s._updateID)
        return false;
      this._lastTextureID = s._updateID;
      var u = s._uvs;
      this.mapCoord.set(u.x1 - u.x0, u.y1 - u.y0, u.x3 - u.x0, u.y3 - u.y0, u.x0, u.y0);
      var l = s.orig, c = s.trim;
      c && (t.set(l.width / c.width, 0, 0, l.height / c.height, -c.x / c.width, -c.y / c.height), this.mapCoord.append(t));
      var d = s.baseTexture, f = this.uClampFrame, p = this.clampMargin / d.resolution, m = this.clampOffset;
      return f[0] = (s._frame.x + p + m) / d.width, f[1] = (s._frame.y + p + m) / d.height, f[2] = (s._frame.x + s._frame.width - p + m) / d.width, f[3] = (s._frame.y + s._frame.height - p + m) / d.height, this.uClampOffset[0] = m / d.realWidth, this.uClampOffset[1] = m / d.realHeight, true;
    }
  };
  return TextureMatrix.default = r, TextureMatrix;
}
var hasRequiredSimpleFilter;
function requireSimpleFilter() {
  if (hasRequiredSimpleFilter) return SimpleFilter$1;
  hasRequiredSimpleFilter = 1, Object.defineProperty(SimpleFilter$1, "__esModule", {
    value: true
  }), SimpleFilter$1.default = void 0;
  var i2 = r(requireFilter$1()), e = r(requireMatrix()), t = r(requireTextureMatrix());
  function r(s) {
    return s && s.__esModule ? s : { default: s };
  }
  class a extends i2.default {
    constructor(u) {
      var {
        key: l,
        vert: c,
        frag: d,
        render: f,
        vars: p
      } = u || {};
      if (f || (f = "vec4 render(sampler2D tex, vec2 uv, vec4 bg, vec4 mask, float alpha) { return bg; }"), c || (c = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;
uniform mat3 filterMatrix;

varying vec2 vTextureCoord;
varying vec2 vFilterCoord;

void main(void)
{
   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);
   vFilterCoord = ( filterMatrix * vec3( aTextureCoord, 1.0)  ).xy;
   vTextureCoord = aTextureCoord;
}`), !d) {
        var m = [];
        if (p) {
          for (var [y, x] of Object.entries(p))
            if (y) {
              var g = Array.isArray(x) ? "vec" + x.length : "float";
              m.push("uniform " + g + " " + y + ";");
            }
        }
        d = `varying vec2 vTextureCoord;
varying vec2 vFilterCoord; // for mask

uniform sampler2D uSampler;
uniform sampler2D uMask;

uniform vec2 uMaskAnchor;
uniform vec2 uMaskSize;
uniform float uMaskRotation;

uniform vec4 maskClamp;
uniform vec4 filterArea;
uniform vec4 filterClamp;
uniform vec2 uFrameSize;

uniform bool useMask;
uniform bool useBinaryMask;
uniform bool useReverseMask;

uniform float uStart;
uniform float uDuration;

\${uniforms}

\${render}

void main(void) {
  vec4 bg = texture2D(uSampler, vTextureCoord);
  vec4 mask = vec4(1.0);
  float alpha = 1.0;
  if (useMask) {
    float clip = step(3.5,
      step(maskClamp.x, vFilterCoord.x) +
      step(maskClamp.y, vFilterCoord.y) +
      step(vFilterCoord.x, maskClamp.z) +
      step(vFilterCoord.y, maskClamp.w));
    mask = texture2D(uMask, vFilterCoord);
    alpha = clamp(dot(mask.rgb, vec3(1.0, 1.0, 1.0)) * clip, 0.0, 1.0);
    if (useBinaryMask) alpha = step(0.01, alpha);
    if (useReverseMask) alpha = 1.0 - alpha;
  }
  vec4 color = render(uSampler, vTextureCoord, bg, mask, alpha);
  color = mix(bg, color, alpha);
  gl_FragColor = color;
}
`, d = d.replace("${uniforms}", m.join(`
`)).replace("${render}", f);
      }
      super(c, d), l && (this.glShaderKey = l), this.vars = p, this._maskMatrix = new e.default();
    }
    apply(u, l, c, d) {
      this.uniforms.uFrameSize && (this.uniforms.uFrameSize[0] = l.sourceFrame.width, this.uniforms.uFrameSize[1] = l.sourceFrame.height), this.uniforms.filterMatrix !== void 0 && this._mask && (this.uniforms.filterMatrix = u.calculateSpriteMatrix(this._maskMatrix, this._mask)), this._mask && (this.uniforms.uMaskAnchor = [this._mask.x, this._mask.y], this.uniforms.uMaskSize = [this._mask.width, this._mask.height], this.uniforms.uMaskRotation = this._mask.rotation, this.uniforms.useBinaryMask = !!this._mask.binaryMask, this.uniforms.useReverseMask = !!this._mask.reverseMask), super.apply(u, l, c, d);
    }
    set vars(u) {
      if (this._vars = u, !!u)
        for (var [l, c] of Object.entries(u))
          l && (this.uniforms[l] = c);
    }
    get vars() {
      return this._vars;
    }
    get mask() {
      return this._mask;
    }
    set mask(u) {
      if (this._mask = u, this.uniforms.uMask !== void 0)
        if (u) {
          var l = u.texture;
          l.transform || (l.transform = new t.default(l, 0)), l.transform.update(), this.uniforms.uMask = l, this.uniforms.useMask = true, this.uniforms.maskClamp = l.transform.uClampFrame;
        } else
          this.uniforms.useMask = false;
    }
    setTime(u, l) {
      this.uniforms.uStart = u, this.uniforms.uDuration = l;
    }
  }
  return SimpleFilter$1.default = a, SimpleFilter$1;
}
var hasRequiredDisplayObject;
function requireDisplayObject() {
  if (hasRequiredDisplayObject) return DisplayObject;
  hasRequiredDisplayObject = 1, Object.defineProperty(DisplayObject, "__esModule", {
    value: true
  }), DisplayObject.default = void 0;
  var i2 = g(requireEventemitter3$1()), e = require_const(), t = g(requireBounds()), r = g(requireSettings()), a = g(requireTransform()), s = requireUtils$3(), u = requireMath$1(), l = g(requireTransformStatic()), c = g(requireFXAAFilter()), d = g(requireBlurFilter()), f = g(requireChromaFilter()), p = g(requireDisplacementFilter()), m = g(requireTransitionFilter()), y = g(requireColorMatrixFilter()), x = g(requireSimpleFilter());
  function g(T) {
    return T && T.__esModule ? T : { default: T };
  }
  let _ = class Lm extends i2.default {
    constructor() {
      super();
      var E = r.default.TRANSFORM_MODE === e.TRANSFORM_MODE.STATIC ? l.default : a.default;
      this.tempDisplayObjectParent = null, this.transform = new E(), this.alpha = 1, this.visible = true, this.renderable = true, this.parent = null, this.worldAlpha = 1, this.filterArea = null, this.filters = [], this._enabledFilters = null, this._bounds = new t.default(), this._boundsID = 0, this._lastBoundsID = -1, this._boundsRect = null, this._localBoundsRect = null, this._mask = null, this._blur = 0, this._chroma = null, this._motion = null, this._fxaa = false, this.maskEnabled = true, this.destroyed = false, this.id = (0, s.uuidvx)();
    }
    get _tempDisplayObjectParent() {
      return this.tempDisplayObjectParent === null && (this.tempDisplayObjectParent = new Lm()), this.tempDisplayObjectParent;
    }
    updateTransform() {
      this.transform.updateTransform(this.parent.transform), this.worldAlpha = this.alpha * this.parent.worldAlpha, this._bounds.updateID++;
    }
    _recursivePostUpdateTransform() {
      this.parent ? (this.parent._recursivePostUpdateTransform(), this.transform.updateTransform(this.parent.transform)) : this.transform.updateTransform(this._tempDisplayObjectParent.transform);
    }
    getBounds(E, b) {
      return E || (this.parent ? (this._recursivePostUpdateTransform(), this.updateTransform()) : (this.parent = this._tempDisplayObjectParent, this.updateTransform(), this.parent = null)), this._boundsID !== this._lastBoundsID && this.maskEnabled && this.calculateBounds(), b || (this._boundsRect || (this._boundsRect = new u.Rectangle()), b = this._boundsRect), this._bounds.getRectangle(b);
    }
    getLocalBounds(E) {
      var b = this.transform, C = this.parent;
      this.parent = null, this.transform = this._tempDisplayObjectParent.transform, E || (this._localBoundsRect || (this._localBoundsRect = new u.Rectangle()), E = this._localBoundsRect);
      var w = this.getBounds(false, E);
      return this.parent = C, this.transform = b, w;
    }
    toGlobal(E, b, C) {
      return C === void 0 && (C = false), C || (this._recursivePostUpdateTransform(), this.parent ? this.displayObjectUpdateTransform() : (this.parent = this._tempDisplayObjectParent, this.displayObjectUpdateTransform(), this.parent = null)), this.worldTransform.apply(E, b);
    }
    getGlobalPosition(E, b) {
      return b === void 0 && (b = false), this.parent ? this.parent.toGlobal(this.position, E, b) : (E.x = this.position.x, E.y = this.position.y), E;
    }
    toLocal(E, b, C, w) {
      return b && (E = b.toGlobal(E, C, w)), w || (this._recursivePostUpdateTransform(), this.parent ? this.displayObjectUpdateTransform() : (this.parent = this._tempDisplayObjectParent, this.displayObjectUpdateTransform(), this.parent = null)), this.worldTransform.applyInverse(E, C);
    }
    copyFromProxy(E) {
      var b = (C) => {
        E[C] !== null && (this[C] = E[C]);
      };
      b("x"), b("y"), b("text"), b("style"), b("width"), b("height"), b("alpha"), b("rotation"), b("blendMode"), this.scale.copy(E.scale), this.anchor.copy(E.anchor);
    }
    substitute(E) {
      this.copyFromProxy(E);
      var {
        parent: b
      } = E;
      if (b) {
        var C = b.getChildIndex(E);
        b.removeChild(E), b.addChildAt(this, C);
      }
      E.destroy(), E = null;
    }
    renderWebGL(E) {
    }
    renderCanvas(E) {
    }
    setParent(E) {
      if (!E || !E.addChild)
        throw new Error("setParent: Argument must be a Container");
      return E.addChild(this), E;
    }
    setTransform(E, b, C, w, A, S, F, M, U) {
      return E === void 0 && (E = 0), b === void 0 && (b = 0), C === void 0 && (C = 1), w === void 0 && (w = 1), A === void 0 && (A = 0), S === void 0 && (S = 0), F === void 0 && (F = 0), M === void 0 && (M = 0), U === void 0 && (U = 0), this.position.x = E, this.position.y = b, this.scale.x = C || 1, this.scale.y = w || 1, this.rotation = A, this.skew.x = S, this.skew.y = F, this.pivot.x = M, this.pivot.y = U, this;
    }
    attr(E) {
      for (var b in E) {
        var C = E[b];
        switch (b) {
          case "scale":
            this.scale.x = C, this.scale.y = C;
            break;
          case "skew":
            this.skew.x = C, this.skew.y = C;
            break;
          case "rotate":
            this.rotation = C;
            break;
          case "opacity":
            this.alpha = C;
            break;
          default:
            this[b] = C;
        }
      }
    }
    getAttr(E) {
      var b;
      switch (E) {
        case "scale":
          b = this.scale.x;
          break;
        case "rotate":
          b = this.rotation;
          break;
        default:
          b = this[E];
      }
      return b;
    }
    get x() {
      return this.position.x;
    }
    set x(E) {
      this.transform.position.x = E;
    }
    get y() {
      return this.position.y;
    }
    set y(E) {
      this.transform.position.y = E;
    }
    get worldTransform() {
      return this.transform.worldTransform;
    }
    get localTransform() {
      return this.transform.localTransform;
    }
    get position() {
      return this.transform.position;
    }
    set position(E) {
      this.transform.position.copy(E);
    }
    get scale() {
      return this.transform.scale;
    }
    set scale(E) {
      this.transform.scale.copy(E);
    }
    get pivot() {
      return this.transform.pivot;
    }
    set pivot(E) {
      this.transform.pivot.copy(E);
    }
    get skew() {
      return this.transform.skew;
    }
    set skew(E) {
      this.transform.skew.copy(E);
    }
    get rotation() {
      return this.transform.rotation;
    }
    set rotation(E) {
      this.transform.rotation = E;
    }
    get worldVisible() {
      var E = this;
      do {
        if (!E.visible)
          return false;
        E = E.parent;
      } while (E);
      return true;
    }
    get mask() {
      return this._mask;
    }
    set mask(E) {
      this._mask && (this._mask.renderable = true, this._mask.isMask = false), this._mask = E, this._mask && (this._mask.renderable = false, this._mask.isMask = true);
    }
    hasFilters() {
      return !!(this.filters && this.filters.length);
    }
    addFilter(E) {
      try {
        var b = new x.default(E);
        return this.filters.push(b), b;
      } catch (C) {
        console.error(C);
        return;
      }
    }
    removeFilter(E) {
      this.filters = this.filters.filter((b) => b != E);
    }
    setFlip(E, b) {
      this.transform.flip.x = E ? -1 : 1, this.transform.flip.y = b ? -1 : 1;
    }
    setMotion(E, b) {
      var C = this.filters.find((w) => w instanceof p.default);
      if (!E) {
        C && (this.filters = this.filters.filter((w) => w != C));
        return;
      }
      return C ? (C.maskSprite = E, C.map = E._texture, C.setScale(b, b)) : (C = new p.default(E, b), this.filters.push(C)), C;
    }
    setTransition(E) {
      this.filters = this.filters.filter((C) => !(C instanceof m.default));
      var b = new m.default(E);
      return this.filters.push(b), b;
    }
    get colorMatrix() {
      return {
        matrix: this._colorMatrix,
        alpha: this._colorMatrixAlpha
      };
    }
    setColorMatrix(E, b) {
      b === void 0 && (b = 1), this._colorMatrix = E, this._colorMatrixAlpha = b;
      var C = this.filters.find((w) => w instanceof y.default);
      if (!Array.isArray(E) || !E.length) {
        C && (this.filters = this.filters.filter((w) => w != C));
        return;
      }
      return C ? C.init() : (C = new y.default(), this.filters.push(C)), C.alpha = b, E.map((w) => {
        var {
          key: A,
          value: S
        } = w;
        typeof C[A] == "function" && (S !== void 0 && !Array.isArray(S) && (S = [S]), S || (S = []), S.push(true), C[A].call(C, ...S));
      }), C;
    }
    set chroma(E) {
      if (E && typeof E == "object") {
        var {
          color: b,
          similarity: C = 0.3,
          smoothness: w = 0.1,
          saturation: A = 0.1,
          shadowness: S = 0.5
        } = E, F = (0, s.str2rgb)(b, 255);
        isNaN(F[0]) || isNaN(F[1]) || isNaN(F[2]) ? this._chroma = null : this._chroma = {
          color: b,
          rgbColor: F,
          similarity: C,
          smoothness: w,
          saturation: A,
          shadowness: S
        };
      } else
        this._chroma = null;
      var M = this.filters.find((X) => X instanceof f.default);
      if (!this._chroma) {
        M && (this.filters = this.filters.filter((X) => X != M));
        return;
      }
      var {
        rgbColor: U,
        similarity: B,
        smoothness: q,
        saturation: z,
        shadowness: D
      } = this._chroma;
      M ? (M.color = U, M.similarity = B, M.smoothness = q, M.saturation = z, M.shadowness = D) : (M = new f.default(U, B, q, z, D), this.filters.push(M));
    }
    get chroma() {
      return this._chroma;
    }
    set blur(E) {
      E === void 0 && (E = 0), this._blur = E;
      var b = this.filters.find((C) => C instanceof d.default);
      if (E <= 0) {
        b && (this.filters = this.filters.filter((C) => C != b));
        return;
      }
      if (b) return b.blur = E;
      b = new d.default(E), this.filters.push(b);
    }
    set fxaa(E) {
      this._fxaa = E;
      var b = this.filters.find((C) => C instanceof c.default);
      E === false ? b && (this.filters = this.filters.filter((C) => C != b)) : b || (b = new c.default(), this.filters.push(b));
    }
    get fxaa() {
      return this._fxaa;
    }
    get blur() {
      return this._blur;
    }
    destroy() {
      this.destroyed || (this.removeAllListeners(), this.parent && this.parent.removeChild(this), this.blur = 0, this.fxaa = false, this.filters = null, this.transform = null, this.parent = null, this._bounds = null, this._currentBounds = null, this._mask = null, this.filterArea = null, this.interactive = false, this.interactiveChildren = false, this.destroyed = true);
    }
  };
  return DisplayObject.default = _, _.prototype.displayObjectUpdateTransform = _.prototype.updateTransform, DisplayObject;
}
var hasRequiredContainer;
function requireContainer() {
  if (hasRequiredContainer) return Container;
  hasRequiredContainer = 1, Object.defineProperty(Container, "__esModule", {
    value: true
  }), Container.default = void 0;
  var i2 = requireUtils$3(), e = t(requireDisplayObject());
  function t(s) {
    return s && s.__esModule ? s : { default: s };
  }
  function r(s, u) {
    return s.zIndex === u.zIndex ? s._lastSortedIndex - u._lastSortedIndex : s.zIndex - u.zIndex;
  }
  let a = class extends e.default {
    constructor() {
      super(), this.children = [], this.sortableChildren = false, this.sortDirty = false;
    }
    onChildrenChange() {
    }
    addChild(s) {
      var u = arguments.length;
      if (u > 1)
        for (var l = 0; l < u; l++)
          this.addChild(arguments[l]);
      else
        s.parent && s.parent.removeChild(s), s.parent = this, this.sortDirty = true, s.transform._parentID = -1, this.children.push(s), this._boundsID++, this.onChildrenChange(this.children.length - 1), s.emit("added", this);
      return s;
    }
    addChildAt(s, u) {
      if (u < 0 || u > this.children.length)
        throw new Error(s + "addChildAt: The index " + u + " supplied is out of bounds " + this.children.length);
      return s.parent && s.parent.removeChild(s), s.parent = this, this.sortDirty = true, s.transform._parentID = -1, this.children.splice(u, 0, s), this._boundsID++, this.onChildrenChange(u), s.emit("added", this), s;
    }
    swapChildren(s, u) {
      if (s !== u) {
        var l = this.getChildIndex(s), c = this.getChildIndex(u);
        this.children[l] = u, this.children[c] = s, this.onChildrenChange(l < c ? l : c);
      }
    }
    getChildIndex(s) {
      var u = this.children.indexOf(s);
      if (u === -1)
        throw new Error("The supplied DisplayObject must be a child of the caller");
      return u;
    }
    setChildIndex(s, u) {
      if (u < 0 || u >= this.children.length)
        throw new Error("The index " + u + " supplied is out of bounds " + this.children.length);
      var l = this.getChildIndex(s);
      (0, i2.removeItems)(this.children, l, 1), this.children.splice(u, 0, s), this.onChildrenChange(u);
    }
    getChildAt(s) {
      if (s < 0 || s >= this.children.length)
        throw new Error("getChildAt: Index (" + s + ") does not exist.");
      return this.children[s];
    }
    removeChild(s) {
      var u = arguments.length;
      if (u > 1)
        for (var l = 0; l < u; l++)
          this.removeChild(arguments[l]);
      else {
        var c = this.children.indexOf(s);
        if (c === -1) return null;
        s.parent = null, s.transform._parentID = -1, (0, i2.removeItems)(this.children, c, 1), this._boundsID++, this.onChildrenChange(c), s.emit("removed", this);
      }
      return s;
    }
    removeChildAt(s) {
      var u = this.getChildAt(s);
      return u.parent = null, u.transform._parentID = -1, (0, i2.removeItems)(this.children, s, 1), this._boundsID++, this.onChildrenChange(s), u.emit("removed", this), u;
    }
    removeChildren(s, u) {
      s === void 0 && (s = 0);
      var l = s, c = typeof u == "number" ? u : this.children.length, d = c - l, f;
      if (d > 0 && d <= c) {
        f = this.children.splice(l, d);
        for (var p = 0; p < f.length; ++p)
          f[p].parent = null, f[p].transform && (f[p].transform._parentID = -1);
        this._boundsID++, this.onChildrenChange(s);
        for (var m = 0; m < f.length; ++m)
          f[m].emit("removed", this);
        return f;
      } else if (d === 0 && this.children.length === 0)
        return [];
      throw new RangeError("removeChildren: numeric values are outside the acceptable range.");
    }
    removeAllChildren() {
      for (var s = this.children.length - 1; s >= 0; s--)
        this.removeChild(this.children[s]);
    }
    sortChildren() {
      for (var s = false, u = 0, l = this.children.length; u < l; ++u) {
        var c = this.children[u];
        c._lastSortedIndex = u, !s && c.zIndex !== 0 && (s = true);
      }
      s && this.children.length > 1 && this.children.sort(r), this.sortDirty = false;
    }
    updateTransform() {
      this.sortableChildren && this.sortDirty && this.sortChildren(), this._boundsID++, this.transform.updateTransform(this.parent.transform), this.worldAlpha = this.alpha * this.parent.worldAlpha;
      for (var s = 0, u = this.children.length; s < u; ++s) {
        var l = this.children[s];
        l.visible && l.updateTransform();
      }
    }
    calculateBounds() {
      this._bounds.clear(), this._calculateBounds();
      for (var s = 0; s < this.children.length; s++) {
        var u = this.children[s];
        !u.visible || !u.renderable || (u.calculateBounds(), u._mask ? (u._mask.calculateBounds(), this._bounds.addBoundsMask(u._bounds, u._mask._bounds)) : u.filterArea ? this._bounds.addBoundsArea(u._bounds, u.filterArea) : this._bounds.addBounds(u._bounds));
      }
      this._lastBoundsID = this._boundsID;
    }
    _calculateBounds() {
    }
    renderWebGL(s) {
      if (!(!this.visible || this.worldAlpha <= 0 || !this.renderable))
        if (this._mask || this.hasFilters())
          this._renderAdvancedWebGL(s);
        else {
          this._renderWebGL(s);
          var u, l;
          for (u = 0, l = this.children.length; u < l; ++u)
            this.children[u].renderWebGL(s);
        }
    }
    _renderAdvancedWebGL(s) {
      s.flush();
      var u = this.filters, l = this._mask;
      if (u && u.length > 0) {
        this._enabledFilters || (this._enabledFilters = []), this._enabledFilters.length = 0;
        for (var c = 0; c < u.length; c++)
          u[c].enabled && this._enabledFilters.push(u[c]);
        this._enabledFilters.length && s.filterManager.pushFilter(this, this._enabledFilters);
      }
      l && s.maskManager.pushMask(this, this._mask), this._renderWebGL(s);
      for (var d = 0, f = this.children.length; d < f; d++)
        this.children[d].renderWebGL(s);
      s.flush(), l && s.maskManager.popMask(this, this._mask), u && this._enabledFilters && this._enabledFilters.length && s.filterManager.popFilter();
    }
    _renderWebGL(s) {
    }
    _renderCanvas(s) {
    }
    renderCanvas(s) {
      if (!(!this.visible || this.worldAlpha <= 0 || !this.renderable)) {
        this._mask && s.maskManager.pushMask(this._mask), this._renderCanvas(s);
        for (var u = 0, l = this.children.length; u < l; ++u)
          this.children[u].renderCanvas(s);
        this._mask && s.maskManager.popMask(s);
      }
    }
    destroy(s) {
      if (!this.destroyed) {
        super.destroy(), this.sortDirty = false;
        var u = typeof s == "boolean" ? s : s && s.children, l = this.removeChildren(0, this.children.length);
        if (u)
          for (var c = 0; c < l.length; ++c)
            l[c].destroy(s);
      }
    }
    destroyChildren(s) {
      for (var u = this.removeChildren(0, this.children.length), l = 0; l < u.length; ++l)
        u[l].destroy(s);
    }
    get width() {
      return this.scale.x * this.getLocalBounds().width;
    }
    set width(s) {
      var u = this.getLocalBounds().width;
      u !== 0 ? this.scale.x = s / u : this.scale.x = 1, this._width = s;
    }
    get height() {
      return this.scale.y * this.getLocalBounds().height;
    }
    set height(s) {
      var u = this.getLocalBounds().height;
      u !== 0 ? this.scale.y = s / u : this.scale.y = 1, this._height = s;
    }
  };
  return Container.default = a, a.prototype.containerUpdateTransform = a.prototype.updateTransform, Container;
}
var RenderTexture = {}, BaseRenderTexture = {}, BaseTexture = {}, Image$1 = {}, hasRequiredImage$2;
function requireImage$2() {
  if (hasRequiredImage$2) return Image$1;
  hasRequiredImage$2 = 1, Object.defineProperty(Image$1, "__esModule", {
    value: true
  }), Image$1.default = void 0;
  var i2 = a(requirePoly()), e = requireCanvasGl(), t = a(requireEventemitter3$1()), r = requireLib$4();
  function a(c) {
    return c && c.__esModule ? c : { default: c };
  }
  var s;
  class u extends (0, i2.default)(e.Image) {
    constructor() {
      super(...arguments), this.isPsImage = true;
    }
    addEventListener(d, f) {
      this._eventemitter || (this._eventemitter = new t.default()), this._eventemitter.once(d, f);
    }
    static convertToImageData(d, f) {
      f === void 0 && (f = false);
      var {
        width: p,
        height: m
      } = d;
      s || (s = (0, e.createCanvas)(p, m)), s.width = p, s.height = m;
      var y = s.getContext("2d");
      return f && (y.scale(1, -1), y.translate(0, -m)), y.clearRect(p, m), y.drawImage(d, 0, 0), y.getImageData(0, 0, p, m);
    }
    static convertToCanvas(d, f, p) {
      var m = (0, e.createCanvas)(f, p), y = m.getContext("2d");
      return y.putImageData(d, 0, 0), m;
    }
  }
  var l = r.isBrowser ? window.Image : u;
  return Image$1.default = l, Image$1;
}
var twiddle$1 = {}, hasRequiredTwiddle$1;
function requireTwiddle$1() {
  if (hasRequiredTwiddle$1) return twiddle$1;
  hasRequiredTwiddle$1 = 1;
  var i2 = 32;
  twiddle$1.INT_BITS = i2, twiddle$1.INT_MAX = 2147483647, twiddle$1.INT_MIN = -1 << i2 - 1, twiddle$1.sign = function(r) {
    return (r > 0) - (r < 0);
  }, twiddle$1.abs = function(r) {
    var a = r >> i2 - 1;
    return (r ^ a) - a;
  }, twiddle$1.min = function(r, a) {
    return a ^ (r ^ a) & -(r < a);
  }, twiddle$1.max = function(r, a) {
    return r ^ (r ^ a) & -(r < a);
  }, twiddle$1.isPow2 = function(r) {
    return !(r & r - 1) && !!r;
  }, twiddle$1.log2 = function(r) {
    var a, s;
    return a = (r > 65535) << 4, r >>>= a, s = (r > 255) << 3, r >>>= s, a |= s, s = (r > 15) << 2, r >>>= s, a |= s, s = (r > 3) << 1, r >>>= s, a |= s, a | r >> 1;
  }, twiddle$1.log10 = function(r) {
    return r >= 1e9 ? 9 : r >= 1e8 ? 8 : r >= 1e7 ? 7 : r >= 1e6 ? 6 : r >= 1e5 ? 5 : r >= 1e4 ? 4 : r >= 1e3 ? 3 : r >= 100 ? 2 : r >= 10 ? 1 : 0;
  }, twiddle$1.popCount = function(r) {
    return r = r - (r >>> 1 & 1431655765), r = (r & 858993459) + (r >>> 2 & 858993459), (r + (r >>> 4) & 252645135) * 16843009 >>> 24;
  };
  function e(r) {
    var a = 32;
    return r &= -r, r && a--, r & 65535 && (a -= 16), r & 16711935 && (a -= 8), r & 252645135 && (a -= 4), r & 858993459 && (a -= 2), r & 1431655765 && (a -= 1), a;
  }
  twiddle$1.countTrailingZeros = e, twiddle$1.nextPow2 = function(r) {
    return r += r === 0, --r, r |= r >>> 1, r |= r >>> 2, r |= r >>> 4, r |= r >>> 8, r |= r >>> 16, r + 1;
  }, twiddle$1.prevPow2 = function(r) {
    return r |= r >>> 1, r |= r >>> 2, r |= r >>> 4, r |= r >>> 8, r |= r >>> 16, r - (r >>> 1);
  }, twiddle$1.parity = function(r) {
    return r ^= r >>> 16, r ^= r >>> 8, r ^= r >>> 4, r &= 15, 27030 >>> r & 1;
  };
  var t = new Array(256);
  return function(r) {
    for (var a = 0; a < 256; ++a) {
      var s = a, u = a, l = 7;
      for (s >>>= 1; s; s >>>= 1)
        u <<= 1, u |= s & 1, --l;
      r[a] = u << l & 255;
    }
  }(t), twiddle$1.reverse = function(r) {
    return t[r & 255] << 24 | t[r >>> 8 & 255] << 16 | t[r >>> 16 & 255] << 8 | t[r >>> 24 & 255];
  }, twiddle$1.interleave2 = function(r, a) {
    return r &= 65535, r = (r | r << 8) & 16711935, r = (r | r << 4) & 252645135, r = (r | r << 2) & 858993459, r = (r | r << 1) & 1431655765, a &= 65535, a = (a | a << 8) & 16711935, a = (a | a << 4) & 252645135, a = (a | a << 2) & 858993459, a = (a | a << 1) & 1431655765, r | a << 1;
  }, twiddle$1.deinterleave2 = function(r, a) {
    return r = r >>> a & 1431655765, r = (r | r >>> 1) & 858993459, r = (r | r >>> 2) & 252645135, r = (r | r >>> 4) & 16711935, r = (r | r >>> 16) & 65535, r << 16 >> 16;
  }, twiddle$1.interleave3 = function(r, a, s) {
    return r &= 1023, r = (r | r << 16) & 4278190335, r = (r | r << 8) & 251719695, r = (r | r << 4) & 3272356035, r = (r | r << 2) & 1227133513, a &= 1023, a = (a | a << 16) & 4278190335, a = (a | a << 8) & 251719695, a = (a | a << 4) & 3272356035, a = (a | a << 2) & 1227133513, r |= a << 1, s &= 1023, s = (s | s << 16) & 4278190335, s = (s | s << 8) & 251719695, s = (s | s << 4) & 3272356035, s = (s | s << 2) & 1227133513, r | s << 2;
  }, twiddle$1.deinterleave3 = function(r, a) {
    return r = r >>> a & 1227133513, r = (r | r >>> 2) & 3272356035, r = (r | r >>> 4) & 251719695, r = (r | r >>> 8) & 4278190335, r = (r | r >>> 16) & 1023, r << 22 >> 22;
  }, twiddle$1.nextCombination = function(r) {
    var a = r | r - 1;
    return a + 1 | (~a & -~a) - 1 >>> e(r) + 1;
  }, twiddle$1;
}
var cache = {}, hasRequiredCache;
function requireCache() {
  if (hasRequiredCache) return cache;
  hasRequiredCache = 1, Object.defineProperty(cache, "__esModule", {
    value: true
  }), cache.TextureCache = cache.BaseTextureCache = void 0, cache.addToBaseTextureCache = a, cache.addToTextureCache = t, cache.deleteAllTextureCache = l, cache.destroyAllTextureCache = u, cache.destroyAndCleanAllCache = c, cache.destroyBaseTextureCache = d, cache.destroyTextureCache = f, cache.removeFromBaseTextureCache = s, cache.removeFromTextureCache = r;
  var i2 = /* @__PURE__ */ Object.create(null);
  cache.TextureCache = i2;
  var e = /* @__PURE__ */ Object.create(null);
  cache.BaseTextureCache = e, window.InkPaintCache = {
    TextureCache: i2,
    BaseTextureCache: e
  };
  function t(p, m) {
    m && (p.textureCacheIds.indexOf(m) === -1 && p.textureCacheIds.push(m), i2[m] = p);
  }
  function r(p) {
    if (typeof p == "string") {
      var m = i2[p];
      if (m) {
        var y = m.textureCacheIds.indexOf(p);
        return y > -1 && m.textureCacheIds.splice(y, 1), delete i2[p], m;
      }
    } else if (p && p.textureCacheIds) {
      for (var x = 0; x < p.textureCacheIds.length; ++x)
        i2[p.textureCacheIds[x]] === p && delete i2[p.textureCacheIds[x]];
      return p.textureCacheIds.length = 0, p;
    }
    return null;
  }
  function a(p, m) {
    m && (p.textureCacheIds.indexOf(m) === -1 && p.textureCacheIds.push(m), e[m] = p);
  }
  function s(p) {
    if (typeof p == "string") {
      var m = e[p];
      if (m) {
        var y = m.textureCacheIds.indexOf(p);
        return y > -1 && m.textureCacheIds.splice(y, 1), delete e[p], m;
      }
    } else if (p && p.textureCacheIds) {
      for (var x = 0; x < p.textureCacheIds.length; ++x)
        delete e[p.textureCacheIds[x]];
      return p.textureCacheIds.length = 0, p;
    }
    return null;
  }
  function u() {
    var p;
    for (p in i2)
      i2[p].destroy();
    for (p in e)
      e[p].destroy();
  }
  function l() {
    var p;
    for (p in i2)
      delete i2[p];
    for (p in e)
      delete e[p];
  }
  function c() {
    u(), l();
  }
  function d(p) {
    e[p] && (e[p].destroy(), delete e[p]);
  }
  function f(p) {
    i2[p] && (i2[p].destroy(), delete i2[p]);
  }
  return cache;
}
var hasRequiredBaseTexture;
function requireBaseTexture() {
  if (hasRequiredBaseTexture) return BaseTexture;
  hasRequiredBaseTexture = 1, Object.defineProperty(BaseTexture, "__esModule", {
    value: true
  }), BaseTexture.default = void 0;
  var i2 = u(requireImage$2()), e = u(requireSettings()), t = u(requireTwiddle$1()), r = u(requireEventemitter3$1()), a = requireUtils$3(), s = requireCache();
  requireBrowser();
  function u(c) {
    return c && c.__esModule ? c : { default: c };
  }
  let l = class Qa extends r.default {
    constructor(d, f, p) {
      super(), this.uid = (0, a.uid)(), this.touched = 0, this.width = 100, this.height = 100, this.realWidth = 100, this.realHeight = 100, this.resolution = p || e.default.RESOLUTION, this.scaleMode = f !== void 0 ? f : e.default.SCALE_MODE, this.hasLoaded = false, this.isLoading = false, this.image = null, this.source = null, this.imageType = null, this.sourceScale = 1, this.premultipliedAlpha = true, this.imageUrl = null, this.isPowerOfTwo = false, this.cutout = false, this.cutoutColors = null, this.mipmap = e.default.MIPMAP_TEXTURES, this.wrapMode = e.default.WRAP_MODE, this._glTextures = {}, this._enabled = 0, this._virtalBoundId = -1, this.destroyed = false, this.textureCacheIds = [], this.loadSource(d);
    }
    updateSource(d) {
      this.image || (this.image = new i2.default()), this.resetImage(this.image), this.loadSource(this.image), this.image.src = d, this.imageUrl = d, this.resolution = (0, a.getResolutionOfUrl)(d);
    }
    loadSource(d) {
      if (d) {
        var f = this.isLoading;
        this.hasLoaded = false, this.isLoading = false, f && this.source && this.removeHandler(this.source);
        var p = !this.source;
        this.source = d;
        var {
          src: m,
          width: y,
          height: x,
          complete: g,
          getContext: _,
          network: T
        } = d, E = y && x;
        (m && g || T && g || _) && E ? (this._updateImageType(), this._sourceLoaded(), p && this.emit("loaded", this)) : _ || (this.isLoading = true, d.onload = () => {
          this._updateImageType(), this.removeHandler(d), this.isLoading && (this.isLoading = false, this._sourceLoaded(), this.emit("loaded", this));
        }, d.onerror = () => {
          this.removeHandler(d), this.isLoading && (this.isLoading = false, this.emit("error", this));
        }, g && m && (this.removeHandler(d), this.isLoading = false, y && x ? (this._sourceLoaded(), f && this.emit("loaded", this)) : f && this.emit("error", this)));
      }
    }
    removeHandler(d) {
      d.onload = null, d.onerror = null;
    }
    resetImage(d) {
      d.src = "", d.width = 0, d.height = 0;
    }
    adaptedNodeCanvas() {
      var {
        source: d,
        cutout: f,
        cutoutColors: p
      } = this;
      d && d instanceof i2.default && d.isPsImage && (this.source = i2.default.convertToImageData(d));
    }
    update() {
      this.imageType !== "svg" && (this.realWidth = this.source.naturalWidth || this.source.videoWidth || this.source.width, this.realHeight = this.source.naturalHeight || this.source.videoHeight || this.source.height, this._updateDimensions()), this.emit("update", this);
    }
    _updateDimensions() {
      this.width = this.realWidth / this.resolution, this.height = this.realHeight / this.resolution, this.isPowerOfTwo = t.default.isPow2(this.realWidth) && t.default.isPow2(this.realHeight);
    }
    _updateImageType() {
      if (this.imageUrl) {
        var d = (0, a.decomposeDataUri)(this.imageUrl), f;
        if (d && d.mediaType === "image") {
          var p = d.subType.split("+")[0];
          f = (0, a.getUrlFileExt)("." + p);
        } else
          f = (0, a.getUrlFileExt)(this.imageUrl);
        this.imageType = f || "png";
      }
    }
    _sourceLoaded() {
      this.hasLoaded = true, this.update();
    }
    destroy() {
      this.imageUrl && (delete s.TextureCache[this.imageUrl], this.imageUrl = null, this.source.src = "", this.removeHandler(this.source)), this.image && (this.image.src = "", this.image = null), this.source = null, this.dispose(), (0, s.removeFromBaseTextureCache)(this), this.textureCacheIds = null, this.destroyed = true, this.cutout = false, this.cutoutColors = null;
    }
    dispose() {
      this.emit("dispose", this);
    }
    static fromImage(d, f, p, m) {
      var y = s.BaseTextureCache[d];
      if (!y) {
        var x = new i2.default();
        y = new Qa(x, p), y.imageUrl = d, m && (y.sourceScale = m), y.resolution = (0, a.getResolutionOfUrl)(d), x.src = d, (0, s.addToBaseTextureCache)(y, d);
      }
      return y;
    }
    static fromCanvas(d, f, p) {
      p === void 0 && (p = "canvas"), d.__paintId || (d.__paintId = p + "_" + (0, a.uid)());
      var m = s.BaseTextureCache[d.__paintId];
      return m || (m = new Qa(d, f), (0, s.addToBaseTextureCache)(m, d.__paintId)), m;
    }
    static from(d, f, p) {
      if (typeof d == "string")
        return Qa.fromImage(d, void 0, f, p);
      if (d instanceof HTMLImageElement) {
        var m = d.src, y = s.BaseTextureCache[m];
        return y || (y = new Qa(d, f), y.imageUrl = m, p && (y.sourceScale = p), y.resolution = (0, a.getResolutionOfUrl)(m), (0, s.addToBaseTextureCache)(y, m)), y;
      } else if (d instanceof HTMLCanvasElement)
        return Qa.fromCanvas(d, f);
      return d;
    }
  };
  return BaseTexture.default = l, BaseTexture;
}
var hasRequiredBaseRenderTexture;
function requireBaseRenderTexture() {
  if (hasRequiredBaseRenderTexture) return BaseRenderTexture;
  hasRequiredBaseRenderTexture = 1, Object.defineProperty(BaseRenderTexture, "__esModule", {
    value: true
  }), BaseRenderTexture.default = void 0;
  var i2 = t(requireBaseTexture()), e = t(requireSettings());
  function t(a) {
    return a && a.__esModule ? a : { default: a };
  }
  let r = class extends i2.default {
    constructor(a, s, u, l) {
      a === void 0 && (a = 100), s === void 0 && (s = 100), super(null, u), this.resolution = l || e.default.RESOLUTION, this.width = Math.ceil(a), this.height = Math.ceil(s), this.realWidth = this.width * this.resolution, this.realHeight = this.height * this.resolution, this.scaleMode = u !== void 0 ? u : e.default.SCALE_MODE, this.hasLoaded = true, this._glRenderTargets = {}, this._canvasRenderTarget = null, this.valid = false;
    }
    resize(a, s) {
      a = Math.ceil(a), s = Math.ceil(s), !(a === this.width && s === this.height) && (this.valid = a > 0 && s > 0, this.width = a, this.height = s, this.realWidth = this.width * this.resolution, this.realHeight = this.height * this.resolution, this.valid && this.emit("update", this));
    }
    destroy() {
      super.destroy(true), this.renderer = null;
    }
  };
  return BaseRenderTexture.default = r, BaseRenderTexture;
}
var Texture = {}, TextureUvs = {}, hasRequiredTextureUvs;
function requireTextureUvs() {
  if (hasRequiredTextureUvs) return TextureUvs;
  hasRequiredTextureUvs = 1, Object.defineProperty(TextureUvs, "__esModule", {
    value: true
  }), TextureUvs.default = void 0;
  var i2 = e(requireGroupD8());
  function e(r) {
    return r && r.__esModule ? r : { default: r };
  }
  let t = class {
    constructor() {
      this.x0 = 0, this.y0 = 0, this.x1 = 1, this.y1 = 0, this.x2 = 1, this.y2 = 1, this.x3 = 0, this.y3 = 1, this.uvsUint32 = new Uint32Array(4);
    }
    set(r, a, s) {
      var u = a.width, l = a.height;
      if (s) {
        var c = r.width / 2 / u, d = r.height / 2 / l, f = r.x / u + c, p = r.y / l + d;
        s = i2.default.add(s, i2.default.NW), this.x0 = f + c * i2.default.uX(s), this.y0 = p + d * i2.default.uY(s), s = i2.default.add(s, 2), this.x1 = f + c * i2.default.uX(s), this.y1 = p + d * i2.default.uY(s), s = i2.default.add(s, 2), this.x2 = f + c * i2.default.uX(s), this.y2 = p + d * i2.default.uY(s), s = i2.default.add(s, 2), this.x3 = f + c * i2.default.uX(s), this.y3 = p + d * i2.default.uY(s);
      } else
        this.x0 = r.x / u, this.y0 = r.y / l, this.x1 = (r.x + r.width) / u, this.y1 = r.y / l, this.x2 = (r.x + r.width) / u, this.y2 = (r.y + r.height) / l, this.x3 = r.x / u, this.y3 = (r.y + r.height) / l;
      this.uvsUint32[0] = (Math.round(this.y0 * 65535) & 65535) << 16 | Math.round(this.x0 * 65535) & 65535, this.uvsUint32[1] = (Math.round(this.y1 * 65535) & 65535) << 16 | Math.round(this.x1 * 65535) & 65535, this.uvsUint32[2] = (Math.round(this.y2 * 65535) & 65535) << 16 | Math.round(this.x2 * 65535) & 65535, this.uvsUint32[3] = (Math.round(this.y3 * 65535) & 65535) << 16 | Math.round(this.x3 * 65535) & 65535;
    }
  };
  return TextureUvs.default = t, TextureUvs;
}
var hasRequiredTexture$1;
function requireTexture$1() {
  if (hasRequiredTexture$1) return Texture;
  hasRequiredTexture$1 = 1, Object.defineProperty(Texture, "__esModule", {
    value: true
  }), Texture.default = void 0;
  var i2 = l(requireBaseTexture()), e = l(requireSettings()), t = l(requireTextureUvs()), r = l(requireEventemitter3$1()), a = requireMath$1(), s = requireUtils$3(), u = requireCache();
  function l(f) {
    return f && f.__esModule ? f : { default: f };
  }
  let c = class Si extends r.default {
    constructor(p, m, y, x, g, _) {
      if (super(), m ? this.hasDefaultFrame = true : (this.hasDefaultFrame = false, m = new a.Rectangle(0, 0, 1, 1)), this._uvs = null, this._cache = [], this.valid = false, this.destroyed = false, this.requiresUpdate = false, this.cutout = false, this.cutoutColors = null, this.trim = x, this.orig = y || m, this._frame = m, this._rotate = Number(g || 0), this._updateID = 0, this.transform = null, this.textureCacheIds = [], g === true)
        this._rotate = 2;
      else if (this._rotate % 2 !== 0)
        throw new Error("attempt to use diamond-shaped UVs.");
      this.id = (0, s.uuidvx)(), this.initBaseTexture(p, m), this.defaultAnchor = _ ? new a.Point(_.x, _.y) : new a.Point(0, 0);
    }
    initBaseTexture(p, m) {
      if (p instanceof Si && (p = p.baseTexture), this.baseTexture = p, this.addToCache(p.imageUrl), p.hasLoaded) {
        if (this.hasDefaultFrame)
          this.frame = m;
        else {
          var {
            width: y,
            height: x
          } = p;
          this.frame = new a.Rectangle(0, 0, y, x), p.on("update", this.onBaseTextureUpdated, this);
        }
        p.adaptedNodeCanvas();
      } else
        p.once("loaded", this.onBaseTextureLoaded, this);
      p.on("error", this.onBaseTextureError, this);
    }
    update() {
      this.baseTexture.update();
    }
    addToCache(p) {
      p && this._cache.indexOf(p) < 0 && this._cache.push(p);
    }
    updateSource(p, m) {
      m === void 0 && (m = false), this.baseTexture.imageUrl !== p && (m ? (this.addToCache(p), this.baseTexture = i2.default.fromImage(p), this.baseTexture.adaptedNodeCanvas()) : this.baseTexture.updateSource(p));
    }
    getImageUrl() {
      return this.baseTexture.imageUrl;
    }
    onBaseTextureLoaded(p) {
      if (this._updateID++, this.hasDefaultFrame)
        this.frame = this._frame;
      else {
        var {
          width: m,
          height: y
        } = p;
        this.frame = new a.Rectangle(0, 0, m, y);
      }
      p.adaptedNodeCanvas(), this.baseTexture.on("update", this.onBaseTextureUpdated, this), this.emit("update", this);
    }
    onBaseTextureError(p) {
      this.emit("error", p);
    }
    onBaseTextureUpdated(p) {
      this._updateID++, this.hasDefaultFrame || (this._frame.width = p.width, this._frame.height = p.height), p.adaptedNodeCanvas(), this.emit("update", this);
    }
    destroy(p) {
      if (!this.destroyed) {
        if (this.baseTexture) {
          if (p) {
            var {
              imageUrl: m
            } = this.baseTexture;
            u.TextureCache[m] && (0, u.removeFromTextureCache)(m);
            for (var y = 0; y < this._cache.length; y++) {
              var x = this._cache[y];
              (0, u.destroyBaseTextureCache)(x);
            }
            this.baseTexture.destroy();
          }
          this.baseTexture.off("update", this.onBaseTextureUpdated, this), this.baseTexture.off("loaded", this.onBaseTextureLoaded, this), this.baseTexture.off("error", this.onBaseTextureError, this), this.baseTexture = null;
        }
        this._cache.length = 0, this._cache = null, this._frame = null, this._uvs = null, this.trim = null, this.orig = null, this.valid = false, this.cutout = false, this.cutoutColors = null, this.destroyed = true, (0, u.removeFromTextureCache)(this), this.textureCacheIds = null;
      }
    }
    clone() {
      return new Si(this.baseTexture, this.frame, this.orig, this.trim, this.rotate, this.defaultAnchor);
    }
    _updateUvs() {
      this._uvs || (this._uvs = new t.default()), this._uvs.set(this._frame, this.baseTexture, this.rotate), this._updateID++;
    }
    get frame() {
      return this._frame;
    }
    set frame(p) {
      this._frame = p, this.hasDefaultFrame = true;
      var {
        x: m,
        y,
        width: x,
        height: g
      } = p, _ = m + x > this.baseTexture.width, T = y + g > this.baseTexture.height;
      if (_ || T) {
        var E = _ && T ? "and" : "or", b = "X: " + m + " + " + x + " = " + (m + x) + " > " + this.baseTexture.width, C = "Y: " + y + " + " + g + " = " + (y + g) + " > " + this.baseTexture.height;
        throw new Error("Texture Error: frame does not fit inside the base Texture dimensions: " + (b + " " + E + " " + C));
      }
      this.valid = x && g && this.baseTexture.hasLoaded, !this.trim && !this.rotate && (this.orig = p), this.valid && this._updateUvs();
    }
    get rotate() {
      return this._rotate;
    }
    set rotate(p) {
      this._rotate = p, this.valid && this._updateUvs();
    }
    get width() {
      return this.orig.width;
    }
    get height() {
      return this.orig.height;
    }
    static newEmpty() {
      return new Si(new i2.default());
    }
    static fromImage(p, m, y, x) {
      var g = u.TextureCache[p];
      return g || (m instanceof a.Rectangle ? g = new Si(i2.default.fromImage(p), m, y, x) : g = new Si(i2.default.fromImage(p, m, y, x)), (0, u.addToTextureCache)(g, p), g);
    }
    static fromFrame(p) {
      var m = u.TextureCache[p];
      if (!m)
        throw new Error('The frameId "' + p + '" does not exist in cache');
      return m;
    }
    static fromCanvas(p, m, y) {
      return y === void 0 && (y = "canvas"), new Si(i2.default.fromCanvas(p, m, y));
    }
    static from(p) {
      if (typeof p == "string") {
        var m = u.TextureCache[p];
        return m || Si.fromImage(p);
      } else {
        if (p instanceof Si)
          return p;
        if (p instanceof HTMLImageElement)
          return new Si(i2.default.from(p));
        if (p instanceof HTMLCanvasElement)
          return Si.fromCanvas(p, e.default.SCALE_MODE, "HTMLCanvasElement");
        if (p instanceof i2.default)
          return new Si(p);
      }
      return p;
    }
    static fromLoader(p, m, y) {
      var x = new i2.default(p, void 0, (0, s.getResolutionOfUrl)(m)), g = new Si(x);
      return x.imageUrl = m, y || (y = m), (0, u.addToBaseTextureCache)(g.baseTexture, y), (0, u.addToTextureCache)(g, y), y !== m && ((0, u.addToBaseTextureCache)(g.baseTexture, m), (0, u.addToTextureCache)(g, m)), g;
    }
  };
  Texture.default = c;
  function d(f) {
    f.destroy = () => {
    }, f.on = () => {
    }, f.once = () => {
    }, f.emit = () => {
    };
  }
  return c.EMPTY = new c(new i2.default()), d(c.EMPTY), d(c.EMPTY.baseTexture), Texture;
}
var hasRequiredRenderTexture;
function requireRenderTexture() {
  if (hasRequiredRenderTexture) return RenderTexture;
  hasRequiredRenderTexture = 1, Object.defineProperty(RenderTexture, "__esModule", {
    value: true
  }), RenderTexture.default = void 0;
  var i2 = t(requireBaseRenderTexture()), e = t(requireTexture$1());
  function t(a) {
    return a && a.__esModule ? a : { default: a };
  }
  let r = class Nm extends e.default {
    constructor(s, u) {
      var l = null;
      if (!(s instanceof i2.default)) {
        var c = arguments[1], d = arguments[2], f = arguments[3], p = arguments[4];
        console.warn("Please use RenderTexture.create(" + c + ", " + d + ") instead of the ctor directly."), l = arguments[0], u = null, s = new i2.default(c, d, f, p);
      }
      super(s, u), this.legacyRenderer = l, this.valid = true, this._updateUvs();
    }
    resize(s, u, l) {
      s = Math.ceil(s), u = Math.ceil(u), this.valid = s > 0 && u > 0, this._frame.width = this.orig.width = s, this._frame.height = this.orig.height = u, l || this.baseTexture.resize(s, u), this._updateUvs();
    }
    static create(s, u, l, c) {
      return new Nm(new i2.default(s, u, l, c));
    }
  };
  return RenderTexture.default = r, RenderTexture;
}
var hasRequiredSystemRenderer;
function requireSystemRenderer() {
  if (hasRequiredSystemRenderer) return SystemRenderer;
  hasRequiredSystemRenderer = 1, Object.defineProperty(SystemRenderer, "__esModule", {
    value: true
  }), SystemRenderer.default = void 0;
  var i2 = requireUtils$3(), e = requireMath$1(), t = require_const(), r = l(requireEventemitter3$1()), a = l(requireDoc()), s = l(requireSettings()), u = l(requireContainer());
  l(requireRenderTexture());
  function l(d) {
    return d && d.__esModule ? d : { default: d };
  }
  new e.Matrix();
  let c = class extends r.default {
    constructor(d, f, p, m) {
      super(), typeof f == "number" && (f = Object.assign({
        width: f,
        height: p || s.default.RENDER_OPTIONS.height
      }, m)), f = Object.assign({}, s.default.RENDER_OPTIONS, f), this.options = f, this.type = t.RENDERER_TYPE.UNKNOWN, this.screen = new e.Rectangle(0, 0, f.width, f.height), this.view = f.view || a.default.createElement("canvas"), this.resolution = f.resolution || s.default.RESOLUTION, this.transparent = f.transparent, this.autoResize = f.autoResize || false, this.blendModes = null, this.preserveDrawingBuffer = f.preserveDrawingBuffer, this.clearBeforeRender = f.clearBeforeRender, this.roundPixels = f.roundPixels, this._backgroundColor = 0, this._backgroundColorRgba = [0, 0, 0, 0], this._backgroundColorString = "#000000", this.backgroundColor = f.backgroundColor || this._backgroundColor, this._tempDisplayObjectParent = new u.default(), this._lastObjectRendered = this._tempDisplayObjectParent;
    }
    get width() {
      return this.view.width;
    }
    get height() {
      return this.view.height;
    }
    resize(d, f) {
      this.screen.width = d, this.screen.height = f, this.view.width = d * this.resolution, this.view.height = f * this.resolution, this.autoResize && (this.view.style.width = d + "px", this.view.style.height = f + "px");
    }
    destroy(d) {
      d && this.view.parentNode && this.view.parentNode.removeChild(this.view), this.type = t.RENDERER_TYPE.UNKNOWN, this.view = null, this.screen = null, this.resolution = 0, this.transparent = false, this.autoResize = false, this.blendModes = null, this.options = null, this.preserveDrawingBuffer = false, this.clearBeforeRender = false, this.roundPixels = false, this._backgroundColor = 0, this._backgroundColorRgba = null, this._backgroundColorString = null, this._tempDisplayObjectParent = null, this._lastObjectRendered = null;
    }
    get backgroundColor() {
      return this._backgroundColor;
    }
    set backgroundColor(d) {
      this._backgroundColor = d, this._backgroundColorString = (0, i2.hex2string)(d), (0, i2.hex2rgb)(d, this._backgroundColorRgba);
    }
  };
  return SystemRenderer.default = c, SystemRenderer;
}
var CanvasMaskManager = {}, hasRequiredCanvasMaskManager;
function requireCanvasMaskManager() {
  if (hasRequiredCanvasMaskManager) return CanvasMaskManager;
  hasRequiredCanvasMaskManager = 1, Object.defineProperty(CanvasMaskManager, "__esModule", {
    value: true
  }), CanvasMaskManager.default = void 0;
  var i2 = require_const();
  let e = class {
    constructor(t) {
      this.renderer = t;
    }
    pushMask(t) {
      var r = this.renderer;
      r.context.save();
      var a = t.alpha, s = t.transform.worldTransform, u = r.resolution;
      r.context.setTransform(s.a * u, s.b * u, s.c * u, s.d * u, s.tx * u, s.ty * u), t._texture || (this.renderGraphicsShape(t), r.context.clip()), t.worldAlpha = a;
    }
    renderGraphicsShape(t) {
      var r = this.renderer.context, a = t.graphicsData.length;
      if (a !== 0) {
        r.beginPath();
        for (var s = 0; s < a; s++) {
          var u = t.graphicsData[s], l = u.shape;
          if (u.type === i2.SHAPES.POLY) {
            var c = l.points, d = u.holes, f = void 0, p = void 0;
            r.moveTo(c[0], c[1]);
            for (var m = 2; m < c.length; m += 2)
              r.lineTo(c[m], c[m + 1]);
            if (c[0] === c[c.length - 2] && c[1] === c[c.length - 1] && r.closePath(), d.length > 0) {
              f = 0;
              for (var y = 0; y < c.length; y += 2)
                f += c[y] * c[y + 3] - c[y + 1] * c[y + 2];
              for (var x = 0; x < d.length; x++) {
                c = d[x].points, p = 0;
                for (var g = 0; g < c.length; g += 2)
                  p += c[g] * c[g + 3] - c[g + 1] * c[g + 2];
                if (r.moveTo(c[0], c[1]), p * f < 0)
                  for (var _ = 2; _ < c.length; _ += 2)
                    r.lineTo(c[_], c[_ + 1]);
                else
                  for (var T = c.length - 2; T >= 2; T -= 2)
                    r.lineTo(c[T], c[T + 1]);
              }
            }
          } else if (u.type === i2.SHAPES.RECT)
            r.rect(l.x, l.y, l.width, l.height), r.closePath();
          else if (u.type === i2.SHAPES.CIRC)
            r.arc(l.x, l.y, l.radius, 0, 2 * Math.PI), r.closePath();
          else if (u.type === i2.SHAPES.ELIP) {
            var E = l.width * 2, b = l.height * 2, C = l.x - E / 2, w = l.y - b / 2, A = 0.5522848, S = E / 2 * A, F = b / 2 * A, M = C + E, U = w + b, B = C + E / 2, q = w + b / 2;
            r.moveTo(C, q), r.bezierCurveTo(C, q - F, B - S, w, B, w), r.bezierCurveTo(B + S, w, M, q - F, M, q), r.bezierCurveTo(M, q + F, B + S, U, B, U), r.bezierCurveTo(B - S, U, C, q + F, C, q), r.closePath();
          } else if (u.type === i2.SHAPES.RREC) {
            var z = l.x, D = l.y, X = l.width, k = l.height, I = l.radius, P = Math.min(X, k) / 2 | 0;
            I = I > P ? P : I, r.moveTo(z, D + I), r.lineTo(z, D + k - I), r.quadraticCurveTo(z, D + k, z + I, D + k), r.lineTo(z + X - I, D + k), r.quadraticCurveTo(z + X, D + k, z + X, D + k - I), r.lineTo(z + X, D + I), r.quadraticCurveTo(z + X, D, z + X - I, D), r.lineTo(z + I, D), r.quadraticCurveTo(z, D, z, D + I), r.closePath();
          }
        }
      }
    }
    /**
     * Restores the current drawing context to the state it was before the mask was applied.
     *
     * @param {InkPaint.CanvasRenderer} renderer - The renderer context to use.
     */
    popMask(t) {
      t.context.restore(), t.invalidateBlendMode();
    }
    /**
     * Destroys this canvas mask manager.
     *
     */
    destroy() {
    }
  };
  return CanvasMaskManager.default = e, CanvasMaskManager;
}
var mapCanvasBlendModesToPixi = {}, canUseNewCanvasBlendModes = {}, hasRequiredCanUseNewCanvasBlendModes;
function requireCanUseNewCanvasBlendModes() {
  if (hasRequiredCanUseNewCanvasBlendModes) return canUseNewCanvasBlendModes;
  hasRequiredCanUseNewCanvasBlendModes = 1, Object.defineProperty(canUseNewCanvasBlendModes, "__esModule", {
    value: true
  }), canUseNewCanvasBlendModes.default = i2;
  function i2() {
    return true;
  }
  return canUseNewCanvasBlendModes;
}
var hasRequiredMapCanvasBlendModesToPixi;
function requireMapCanvasBlendModesToPixi() {
  if (hasRequiredMapCanvasBlendModesToPixi) return mapCanvasBlendModesToPixi;
  hasRequiredMapCanvasBlendModesToPixi = 1, Object.defineProperty(mapCanvasBlendModesToPixi, "__esModule", {
    value: true
  }), mapCanvasBlendModesToPixi.default = r;
  var i2 = require_const(), e = t(requireCanUseNewCanvasBlendModes());
  function t(a) {
    return a && a.__esModule ? a : { default: a };
  }
  function r(a) {
    return a === void 0 && (a = []), (0, e.default)() ? (a[i2.BLEND_MODES.NORMAL] = "source-over", a[i2.BLEND_MODES.ADD] = "lighter", a[i2.BLEND_MODES.MULTIPLY] = "multiply", a[i2.BLEND_MODES.SCREEN] = "screen", a[i2.BLEND_MODES.OVERLAY] = "overlay", a[i2.BLEND_MODES.DARKEN] = "darken", a[i2.BLEND_MODES.LIGHTEN] = "lighten", a[i2.BLEND_MODES.COLOR_DODGE] = "color-dodge", a[i2.BLEND_MODES.COLOR_BURN] = "color-burn", a[i2.BLEND_MODES.HARD_LIGHT] = "hard-light", a[i2.BLEND_MODES.SOFT_LIGHT] = "soft-light", a[i2.BLEND_MODES.DIFFERENCE] = "difference", a[i2.BLEND_MODES.EXCLUSION] = "exclusion", a[i2.BLEND_MODES.HUE] = "hue", a[i2.BLEND_MODES.SATURATION] = "saturate", a[i2.BLEND_MODES.COLOR] = "color", a[i2.BLEND_MODES.LUMINOSITY] = "luminosity") : (a[i2.BLEND_MODES.NORMAL] = "source-over", a[i2.BLEND_MODES.ADD] = "lighter", a[i2.BLEND_MODES.MULTIPLY] = "source-over", a[i2.BLEND_MODES.SCREEN] = "source-over", a[i2.BLEND_MODES.OVERLAY] = "source-over", a[i2.BLEND_MODES.DARKEN] = "source-over", a[i2.BLEND_MODES.LIGHTEN] = "source-over", a[i2.BLEND_MODES.COLOR_DODGE] = "source-over", a[i2.BLEND_MODES.COLOR_BURN] = "source-over", a[i2.BLEND_MODES.HARD_LIGHT] = "source-over", a[i2.BLEND_MODES.SOFT_LIGHT] = "source-over", a[i2.BLEND_MODES.DIFFERENCE] = "source-over", a[i2.BLEND_MODES.EXCLUSION] = "source-over", a[i2.BLEND_MODES.HUE] = "source-over", a[i2.BLEND_MODES.SATURATION] = "source-over", a[i2.BLEND_MODES.COLOR] = "source-over", a[i2.BLEND_MODES.LUMINOSITY] = "source-over"), a[i2.BLEND_MODES.NORMAL_NPM] = a[i2.BLEND_MODES.NORMAL], a[i2.BLEND_MODES.ADD_NPM] = a[i2.BLEND_MODES.ADD], a[i2.BLEND_MODES.SCREEN_NPM] = a[i2.BLEND_MODES.SCREEN], a;
  }
  return mapCanvasBlendModesToPixi;
}
var hasRequiredCanvasRenderer;
function requireCanvasRenderer() {
  if (hasRequiredCanvasRenderer) return CanvasRenderer;
  hasRequiredCanvasRenderer = 1, Object.defineProperty(CanvasRenderer, "__esModule", {
    value: true
  }), CanvasRenderer.default = void 0;
  var i2 = u(requireSystemRenderer()), e = u(requireCanvasMaskManager()), t = u(requireMapCanvasBlendModesToPixi()), r = requireUtils$3(), a = require_const(), s = u(requireSettings());
  function u(c) {
    return c && c.__esModule ? c : { default: c };
  }
  let l = class extends i2.default {
    constructor(c, d, f) {
      super("Canvas", c, d, f), this.type = a.RENDERER_TYPE.CANVAS, this.rootContext = this.view.getContext("2d", {
        alpha: this.transparent
      }), this.context = this.rootContext, this.refresh = true, this.maskManager = new e.default(this), this.smoothProperty = "imageSmoothingEnabled", this.rootContext.imageSmoothingEnabled || (this.rootContext.webkitImageSmoothingEnabled ? this.smoothProperty = "webkitImageSmoothingEnabled" : this.rootContext.mozImageSmoothingEnabled ? this.smoothProperty = "mozImageSmoothingEnabled" : this.rootContext.oImageSmoothingEnabled ? this.smoothProperty = "oImageSmoothingEnabled" : this.rootContext.msImageSmoothingEnabled && (this.smoothProperty = "msImageSmoothingEnabled")), this.initPlugins(), this.blendModes = (0, t.default)(), this._activeBlendMode = null, this.renderingToScreen = false;
      var {
        width: p,
        height: m,
        quality: y,
        anti: x
      } = this.options;
      this.resize(p, m), y && (this.context.quality = y), x && (this.context.antialias = x);
    }
    render(c, d, f, p, m) {
      if (this.view) {
        this.renderingToScreen = !d, this.emit("prerender");
        var y = this.resolution;
        this.context = this.rootContext;
        var x = this.context;
        if (d || (this._lastObjectRendered = c), !m) {
          var g = c.parent, _ = this._tempDisplayObjectParent.transform.worldTransform;
          p ? (p.copy(_), this._tempDisplayObjectParent.transform._worldID = -1) : _.identity(), c.parent = this._tempDisplayObjectParent, c.updateTransform(), c.parent = g;
        }
        x.save(), x.setTransform(1, 0, 0, 1, 0, 0), x.globalAlpha = 1, this._activeBlendMode = a.BLEND_MODES.NORMAL, x.globalCompositeOperation = this.blendModes[a.BLEND_MODES.NORMAL], (f !== void 0 ? f : this.clearBeforeRender) && this.renderingToScreen && (this.transparent ? x.clearRect(0, 0, this.width, this.height) : (x.fillStyle = this._backgroundColorString, x.fillRect(0, 0, this.width, this.height)));
        var T = this.context;
        this.context = x, c.renderCanvas(this), this.context = T, x.restore(), this.resolution = y, this.emit("postrender");
      }
    }
    clear(c) {
      var d = this.context;
      c = c || this._backgroundColorString, !this.transparent && c ? (d.fillStyle = c, d.fillRect(0, 0, this.width, this.height)) : d.clearRect(0, 0, this.width, this.height);
    }
    setBlendMode(c) {
      this._activeBlendMode !== c && (this._activeBlendMode = c, this.context.globalCompositeOperation = this.blendModes[c]);
    }
    destroy(c) {
      this.destroyPlugins(), super.destroy(c), this.context = null, this.refresh = true, this.maskManager.destroy(), this.maskManager = null, this.smoothProperty = null;
    }
    resize(c, d) {
      super.resize(c, d), this.smoothProperty && (this.rootContext[this.smoothProperty] = s.default.SCALE_MODE === a.SCALE_MODES.LINEAR);
    }
    invalidateBlendMode() {
      this._activeBlendMode = this.blendModes.indexOf(this.context.globalCompositeOperation);
    }
  };
  return CanvasRenderer.default = l, r.pluginTarget.mixin(l), CanvasRenderer;
}
var WebGLRenderer = {}, MaskManager = {}, WebGLManager = {}, hasRequiredWebGLManager;
function requireWebGLManager() {
  if (hasRequiredWebGLManager) return WebGLManager;
  hasRequiredWebGLManager = 1, Object.defineProperty(WebGLManager, "__esModule", {
    value: true
  }), WebGLManager.default = void 0;
  let i2 = class {
    constructor(e) {
      this.renderer = e, this.renderer.on("context", this.onContextChange, this);
    }
    onContextChange() {
    }
    destroy() {
      this.renderer.off("context", this.onContextChange, this), this.renderer = null;
    }
  };
  return WebGLManager.default = i2, WebGLManager;
}
var SpriteMaskFilter = {}, hasRequiredSpriteMaskFilter;
function requireSpriteMaskFilter() {
  if (hasRequiredSpriteMaskFilter) return SpriteMaskFilter;
  hasRequiredSpriteMaskFilter = 1, Object.defineProperty(SpriteMaskFilter, "__esModule", {
    value: true
  }), SpriteMaskFilter.default = void 0;
  var i2 = r(requireFilter$1()), e = requireMath$1(), t = r(requireTextureMatrix());
  function r(s) {
    return s && s.__esModule ? s : { default: s };
  }
  let a = class extends i2.default {
    /**
     * @param {InkPaint.Sprite} sprite - the target sprite
     */
    constructor(s) {
      var u = new e.Matrix();
      super(`attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;
uniform mat3 otherMatrix;

varying vec2 vMaskCoord;
varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = aTextureCoord;
    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;
}
`, `varying vec2 vMaskCoord;
varying vec2 vTextureCoord;

uniform sampler2D uSampler;
uniform sampler2D mask;
uniform float alpha;
uniform vec4 maskClamp;

uniform bool useBinaryMask;
uniform bool useReverseMask;

void main(void)
{
    float clip = step(3.5,
        step(maskClamp.x, vMaskCoord.x) +
        step(maskClamp.y, vMaskCoord.y) +
        step(vMaskCoord.x, maskClamp.z) +
        step(vMaskCoord.y, maskClamp.w));

    vec4 original = texture2D(uSampler, vTextureCoord);
    vec4 mask = texture2D(mask, vMaskCoord);
    float a = clamp(dot(mask.rgb, vec3(1.0, 1.0, 1.0)) * alpha * clip, 0.0, 1.0);
    if (useBinaryMask) a = step(0.01, alpha);
    if (useReverseMask) a = 1.0 - a;
    original *= a;
    gl_FragColor = original;
}
`), s.renderable = false, this.maskSprite = s, this.maskMatrix = u;
    }
    /**
     * Applies the filter
     *
     * @param {InkPaint.FilterManager} filterManager - The renderer to retrieve the filter from
     * @param {InkPaint.RenderTarget} input - The input render target.
     * @param {InkPaint.RenderTarget} output - The target to output to.
     * @param {boolean} clear - Should the output be cleared before rendering to it
     */
    apply(s, u, l, c) {
      var d = this.maskSprite, f = this.maskSprite.texture;
      f.valid && (f.transform || (f.transform = new t.default(f, 0)), f.transform.update(), this.uniforms.mask = f, this.uniforms.useBinaryMask = !!d.binaryMask, this.uniforms.useReverseMask = !!d.reverseMask, this.uniforms.otherMatrix = s.calculateSpriteMatrix(this.maskMatrix, d).prepend(f.transform.mapCoord), this.uniforms.alpha = d.worldAlpha, this.uniforms.maskClamp = f.transform.uClampFrame, s.applyFilter(this, u, l, c));
    }
  };
  return SpriteMaskFilter.default = a, SpriteMaskFilter;
}
var hasRequiredMaskManager;
function requireMaskManager() {
  if (hasRequiredMaskManager) return MaskManager;
  hasRequiredMaskManager = 1, Object.defineProperty(MaskManager, "__esModule", {
    value: true
  }), MaskManager.default = void 0;
  var i2 = t(requireWebGLManager()), e = t(requireSpriteMaskFilter());
  function t(a) {
    return a && a.__esModule ? a : { default: a };
  }
  let r = class extends i2.default {
    constructor(a) {
      super(a), this.scissor = false, this.scissorData = null, this.scissorRenderTarget = null, this.enableScissor = true, this.alphaMaskPool = [], this.alphaMaskIndex = 0;
    }
    pushMask(a, s) {
      if (s.texture)
        this.pushSpriteMask(a, s);
      else if (this.enableScissor && !this.scissor && this.renderer._activeRenderTarget.root && !this.renderer.stencilManager.stencilMaskStack.length && s.isFastRect()) {
        var u = s.worldTransform, l = Math.atan2(u.b, u.a);
        l = Math.round(l * (180 / Math.PI)), l % 90 ? this.pushStencilMask(s) : this.pushScissorMask(a, s);
      } else
        this.pushStencilMask(s);
    }
    popMask(a, s) {
      s.texture ? this.popSpriteMask(a, s) : this.enableScissor && !this.renderer.stencilManager.stencilMaskStack.length ? this.popScissorMask(a, s) : this.popStencilMask(a, s);
    }
    pushSpriteMask(a, s) {
      var u = this.alphaMaskPool[this.alphaMaskIndex];
      u || (u = this.alphaMaskPool[this.alphaMaskIndex] = [new e.default(s)]), u[0].resolution = this.renderer.resolution, u[0].maskSprite = s;
      var l = a.filterArea;
      a.filterArea = s.getBounds(true), this.renderer.filterManager.pushFilter(a, u), a.filterArea = l, this.alphaMaskIndex++;
    }
    popSpriteMask() {
      this.renderer.filterManager.popFilter(), this.alphaMaskIndex--;
    }
    pushStencilMask(a) {
      this.renderer.currentRenderer.stop(), this.renderer.stencilManager.pushStencil(a);
    }
    popStencilMask() {
      this.renderer.currentRenderer.stop(), this.renderer.stencilManager.popStencil();
    }
    pushScissorMask(a, s) {
      s.renderable = true;
      var u = this.renderer._activeRenderTarget, l = s.getBounds();
      l.fit(u.size), s.renderable = false, this.renderer.gl.enable(this.renderer.gl.SCISSOR_TEST);
      var c = this.renderer.resolution;
      this.renderer.gl.scissor(l.x * c, (u.root ? u.size.height - l.y - l.height : l.y) * c, l.width * c, l.height * c), this.scissorRenderTarget = u, this.scissorData = s, this.scissor = true;
    }
    popScissorMask() {
      this.scissorRenderTarget = null, this.scissorData = null, this.scissor = false;
      var a = this.renderer.gl;
      a.disable(a.SCISSOR_TEST);
    }
  };
  return MaskManager.default = r, MaskManager;
}
var StencilManager = {}, hasRequiredStencilManager;
function requireStencilManager() {
  if (hasRequiredStencilManager) return StencilManager;
  hasRequiredStencilManager = 1, Object.defineProperty(StencilManager, "__esModule", {
    value: true
  }), StencilManager.default = void 0;
  var i2 = e(requireWebGLManager());
  function e(r) {
    return r && r.__esModule ? r : { default: r };
  }
  let t = class extends i2.default {
    constructor(r) {
      super(r), this.stencilMaskStack = null;
    }
    setMaskStack(r) {
      this.stencilMaskStack = r;
      var a = this.renderer.gl;
      r.length === 0 ? a.disable(a.STENCIL_TEST) : a.enable(a.STENCIL_TEST);
    }
    pushStencil(r) {
      this.renderer.setObjectRenderer(this.renderer.plugins.graphics), this.renderer._activeRenderTarget.attachStencilBuffer();
      var a = this.renderer.gl, s = this.stencilMaskStack.length;
      s === 0 && a.enable(a.STENCIL_TEST), this.stencilMaskStack.push(r), a.colorMask(false, false, false, false), a.stencilFunc(a.EQUAL, s, this._getBitwiseMask()), a.stencilOp(a.KEEP, a.KEEP, a.INCR), this.renderer.plugins.graphics.render(r), this._useCurrent();
    }
    popStencil() {
      this.renderer.setObjectRenderer(this.renderer.plugins.graphics);
      var r = this.renderer.gl, a = this.stencilMaskStack.pop();
      this.stencilMaskStack.length === 0 ? (r.disable(r.STENCIL_TEST), r.clear(r.STENCIL_BUFFER_BIT), r.clearStencil(0)) : (r.colorMask(false, false, false, false), r.stencilOp(r.KEEP, r.KEEP, r.DECR), this.renderer.plugins.graphics.render(a), this._useCurrent());
    }
    _useCurrent() {
      var r = this.renderer.gl;
      r.colorMask(true, true, true, true), r.stencilFunc(r.EQUAL, this.stencilMaskStack.length, this._getBitwiseMask()), r.stencilOp(r.KEEP, r.KEEP, r.KEEP);
    }
    _getBitwiseMask() {
      return (1 << this.stencilMaskStack.length) - 1;
    }
    destroy() {
      i2.default.prototype.destroy.call(this), this.stencilMaskStack.stencilStack = null;
    }
  };
  return StencilManager.default = t, StencilManager;
}
var FilterManager = {}, RenderTarget = {}, hasRequiredRenderTarget;
function requireRenderTarget() {
  if (hasRequiredRenderTarget) return RenderTarget;
  hasRequiredRenderTarget = 1, Object.defineProperty(RenderTarget, "__esModule", {
    value: true
  }), RenderTarget.default = void 0;
  var i2 = requireMath$1(), e = require_const(), t = a(requireSettings()), r = requireSrc$1();
  function a(u) {
    return u && u.__esModule ? u : { default: u };
  }
  let s = class {
    constructor(u, l, c, d, f, p) {
      this.gl = u, this.frameBuffer = null, this.texture = null, this.clearColor = [0, 0, 0, 0], this.size = new i2.Rectangle(0, 0, 1, 1), this.resolution = f || t.default.RESOLUTION, this.projectionMatrix = new i2.Matrix(), this.transform = null, this.frame = null, this.defaultFrame = new i2.Rectangle(), this.destinationFrame = null, this.sourceFrame = null, this.stencilBuffer = null, this.stencilMaskStack = [], this.filterData = null, this.filterPoolKey = "", this.scaleMode = d !== void 0 ? d : t.default.SCALE_MODE, this.root = p || false, this.root ? (this.frameBuffer = new r.GLFramebuffer(u, 100, 100), this.frameBuffer.framebuffer = null) : (this.frameBuffer = r.GLFramebuffer.createRGBA(u, 100, 100), this.scaleMode === e.SCALE_MODES.NEAREST ? this.frameBuffer.texture.enableNearestScaling() : this.frameBuffer.texture.enableLinearScaling(), this.texture = this.frameBuffer.texture), this.setFrame(), this.resize(l, c);
    }
    /**
     * Clears the filter texture.
     *
     * @param {number[]} [clearColor=this.clearColor] - Array of [r,g,b,a] to clear the framebuffer
     */
    clear(u) {
      var l = u || this.clearColor;
      this.frameBuffer.clear(l[0], l[1], l[2], l[3]);
    }
    /**
     * Binds the stencil buffer.
     *
     */
    attachStencilBuffer() {
      this.root || this.frameBuffer.enableStencil();
    }
    /**
     * Sets the frame of the render target.
     *
     * @param {Rectangle} destinationFrame - The destination frame.
     * @param {Rectangle} sourceFrame - The source frame.
     */
    setFrame(u, l) {
      this.destinationFrame = u || this.destinationFrame || this.defaultFrame, this.sourceFrame = l || this.sourceFrame || this.destinationFrame;
    }
    /**
     * Binds the buffers and initialises the viewport.
     *
     */
    activate() {
      var u = this.gl;
      this.frameBuffer.bind(), this.calculateProjection(this.destinationFrame, this.sourceFrame), this.transform && this.projectionMatrix.append(this.transform), this.destinationFrame !== this.sourceFrame ? (u.enable(u.SCISSOR_TEST), u.scissor(this.destinationFrame.x | 0, this.destinationFrame.y | 0, this.destinationFrame.width * this.resolution | 0, this.destinationFrame.height * this.resolution | 0)) : u.disable(u.SCISSOR_TEST), u.viewport(this.destinationFrame.x | 0, this.destinationFrame.y | 0, this.destinationFrame.width * this.resolution | 0, this.destinationFrame.height * this.resolution | 0);
    }
    calculateProjection(u, l) {
      var c = this.projectionMatrix;
      l = l || u, c.identity(), this.root ? (c.a = 1 / u.width * 2, c.d = -1 / u.height * 2, c.tx = -1 - l.x * c.a, c.ty = 1 - l.y * c.d) : (c.a = 1 / u.width * 2, c.d = 1 / u.height * 2, c.tx = -1 - l.x * c.a, c.ty = -1 - l.y * c.d);
    }
    resize(u, l) {
      if (u = u | 0, l = l | 0, !(this.size.width === u && this.size.height === l)) {
        this.size.width = u, this.size.height = l, this.defaultFrame.width = u, this.defaultFrame.height = l, this.frameBuffer.resize(u * this.resolution, l * this.resolution);
        var c = this.frame || this.size;
        this.calculateProjection(c);
      }
    }
    /**
     * Destroys the render target.
     *
     */
    destroy() {
      this.frameBuffer.stencil && this.gl.deleteRenderbuffer(this.frameBuffer.stencil), this.frameBuffer.destroy(), this.frameBuffer = null, this.texture = null;
    }
  };
  return RenderTarget.default = s, RenderTarget;
}
var Quad = {}, createIndicesForQuads = {}, hasRequiredCreateIndicesForQuads;
function requireCreateIndicesForQuads() {
  if (hasRequiredCreateIndicesForQuads) return createIndicesForQuads;
  hasRequiredCreateIndicesForQuads = 1, Object.defineProperty(createIndicesForQuads, "__esModule", {
    value: true
  }), createIndicesForQuads.default = i2;
  function i2(e) {
    for (var t = e * 6, r = new Uint16Array(t), a = 0, s = 0; a < t; a += 6, s += 4)
      r[a + 0] = s + 0, r[a + 1] = s + 1, r[a + 2] = s + 2, r[a + 3] = s + 0, r[a + 4] = s + 2, r[a + 5] = s + 3;
    return r;
  }
  return createIndicesForQuads;
}
var hasRequiredQuad;
function requireQuad() {
  if (hasRequiredQuad) return Quad;
  hasRequiredQuad = 1, Object.defineProperty(Quad, "__esModule", {
    value: true
  }), Quad.default = void 0;
  var i2 = t(requireSrc$1()), e = t(requireCreateIndicesForQuads());
  function t(a) {
    return a && a.__esModule ? a : { default: a };
  }
  let r = class {
    constructor(a, s) {
      this.gl = a, this.vertices = new Float32Array([-1, -1, 1, -1, 1, 1, -1, 1]), this.uvs = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]), this.interleaved = new Float32Array(8 * 2);
      for (var u = 0; u < 4; u++)
        this.interleaved[u * 4] = this.vertices[u * 2], this.interleaved[u * 4 + 1] = this.vertices[u * 2 + 1], this.interleaved[u * 4 + 2] = this.uvs[u * 2], this.interleaved[u * 4 + 3] = this.uvs[u * 2 + 1];
      this.indices = (0, e.default)(1), this.vertexBuffer = i2.default.GLBuffer.createVertexBuffer(a, this.interleaved, a.STATIC_DRAW), this.indexBuffer = i2.default.GLBuffer.createIndexBuffer(a, this.indices, a.STATIC_DRAW), this.vao = new i2.default.VertexArrayObject(a, s);
    }
    initVao(a) {
      this.vao.clear().addIndex(this.indexBuffer).addAttribute(this.vertexBuffer, a.attributes.aVertexPosition, this.gl.FLOAT, false, 4 * 4, 0).addAttribute(this.vertexBuffer, a.attributes.aTextureCoord, this.gl.FLOAT, false, 4 * 4, 2 * 4);
    }
    map(a, s) {
      var u = 0, l = 0;
      return this.uvs[0] = u, this.uvs[1] = l, this.uvs[2] = u + s.width / a.width, this.uvs[3] = l, this.uvs[4] = u + s.width / a.width, this.uvs[5] = l + s.height / a.height, this.uvs[6] = u, this.uvs[7] = l + s.height / a.height, u = s.x, l = s.y, this.vertices[0] = u, this.vertices[1] = l, this.vertices[2] = u + s.width, this.vertices[3] = l, this.vertices[4] = u + s.width, this.vertices[5] = l + s.height, this.vertices[6] = u, this.vertices[7] = l + s.height, this;
    }
    upload() {
      for (var a = 0; a < 4; a++)
        this.interleaved[a * 4] = this.vertices[a * 2], this.interleaved[a * 4 + 1] = this.vertices[a * 2 + 1], this.interleaved[a * 4 + 2] = this.uvs[a * 2], this.interleaved[a * 4 + 3] = this.uvs[a * 2 + 1];
      return this.vertexBuffer.upload(this.interleaved), this;
    }
    destroy() {
      var a = this.gl;
      a.deleteBuffer(this.vertexBuffer), a.deleteBuffer(this.indexBuffer);
    }
  };
  return Quad.default = r, Quad;
}
var Shader = {}, hasRequiredShader$1;
function requireShader$1() {
  if (hasRequiredShader$1) return Shader;
  hasRequiredShader$1 = 1, Object.defineProperty(Shader, "__esModule", {
    value: true
  }), Shader.default = void 0;
  var i2 = requireSrc$1(), e = t(requireSettings());
  function t(s) {
    return s && s.__esModule ? s : { default: s };
  }
  function r(s, u) {
    if (s instanceof Array) {
      if (s[0].substring(0, 9) !== "precision") {
        var l = s.slice(0);
        return l.unshift("precision " + u + " float;"), l;
      }
    } else if (s.trim().substring(0, 9) !== "precision")
      return "precision " + u + ` float;
` + s;
    return s;
  }
  let a = class extends i2.GLShader {
    constructor(s, u, l, c, d) {
      super(s, r(u, d || e.default.PRECISION_VERTEX), r(l, d || e.default.PRECISION_FRAGMENT), void 0, c);
    }
  };
  return Shader.default = a, Shader;
}
var filterTransforms = {}, hasRequiredFilterTransforms;
function requireFilterTransforms() {
  if (hasRequiredFilterTransforms) return filterTransforms;
  hasRequiredFilterTransforms = 1, Object.defineProperty(filterTransforms, "__esModule", {
    value: true
  }), filterTransforms.calculateNormalizedScreenSpaceMatrix = t, filterTransforms.calculateScreenSpaceMatrix = e, filterTransforms.calculateSpriteMatrix = r;
  var i2 = requireMath$1();
  function e(a, s, u) {
    var l = a.identity();
    return l.translate(s.x / u.width, s.y / u.height), l.scale(u.width, u.height), l;
  }
  function t(a, s, u) {
    var l = a.identity();
    l.translate(s.x / u.width, s.y / u.height);
    var c = u.width / s.width, d = u.height / s.height;
    return l.scale(c, d), l;
  }
  function r(a, s, u, l) {
    var c = l._texture.orig, d = a.set(u.width, 0, 0, u.height, s.x, s.y), f = l.worldTransform.copy(i2.Matrix.TEMP_MATRIX);
    return f.invert(), d.prepend(f), d.scale(1 / c.width, 1 / c.height), d.translate(l.anchor.x, l.anchor.y), d;
  }
  return filterTransforms;
}
var hasRequiredFilterManager;
function requireFilterManager() {
  if (hasRequiredFilterManager) return FilterManager;
  hasRequiredFilterManager = 1, Object.defineProperty(FilterManager, "__esModule", {
    value: true
  }), FilterManager.default = void 0;
  var i2 = d(requireWebGLManager()), e = d(requireRenderTarget()), t = d(requireQuad()), r = requireMath$1(), a = d(requireShader$1()), s = c(requireFilterTransforms()), u = d(requireTwiddle$1());
  function l(y) {
    if (typeof WeakMap != "function") return null;
    var x = /* @__PURE__ */ new WeakMap(), g = /* @__PURE__ */ new WeakMap();
    return (l = function(_) {
      return _ ? g : x;
    })(y);
  }
  function c(y, x) {
    if (y && y.__esModule)
      return y;
    if (y === null || typeof y != "object" && typeof y != "function")
      return { default: y };
    var g = l(x);
    if (g && g.has(y))
      return g.get(y);
    var _ = {}, T = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var E in y)
      if (E !== "default" && Object.prototype.hasOwnProperty.call(y, E)) {
        var b = T ? Object.getOwnPropertyDescriptor(y, E) : null;
        b && (b.get || b.set) ? Object.defineProperty(_, E, b) : _[E] = y[E];
      }
    return _.default = y, g && g.set(y, _), _;
  }
  function d(y) {
    return y && y.__esModule ? y : { default: y };
  }
  class f {
    constructor() {
      this.renderTarget = null, this.target = null, this.resolution = 1, this.sourceFrame = new r.Rectangle(), this.destinationFrame = new r.Rectangle(), this.filters = [];
    }
    clear() {
      this.filters = null, this.target = null, this.renderTarget = null;
    }
  }
  var p = "screen";
  let m = class extends i2.default {
    constructor(y) {
      super(y), this.gl = this.renderer.gl, this.quad = new t.default(this.gl, y.state.attribState), this.shaderCache = {}, this.pool = {}, this.filterData = null, this.managedFilters = [], this.renderer.on("prerender", this.onPrerender, this), this._screenWidth = y.view.width, this._screenHeight = y.view.height;
    }
    pushFilter(y, x) {
      var g = this.renderer, _ = this.filterData;
      if (!_) {
        _ = this.renderer._activeRenderTarget.filterStack;
        var T = new f();
        T.sourceFrame = T.destinationFrame = this.renderer._activeRenderTarget.size, T.renderTarget = g._activeRenderTarget, this.renderer._activeRenderTarget.filterData = _ = {
          index: 0,
          stack: [T]
        }, this.filterData = _;
      }
      var E = _.stack[++_.index], b = _.stack[0].destinationFrame;
      E || (E = _.stack[_.index] = new f());
      var C = y.filterArea && y.filterArea.x === 0 && y.filterArea.y === 0 && y.filterArea.width === g.screen.width && y.filterArea.height === g.screen.height, w = x[0].resolution, A = x[0].padding | 0, S = C ? g.screen : y.filterArea || y.getBounds(true), F = E.sourceFrame, M = E.destinationFrame;
      F.x = (S.x * w | 0) / w, F.y = (S.y * w | 0) / w, F.width = (S.width * w | 0) / w, F.height = (S.height * w | 0) / w, C || (_.stack[0].renderTarget.transform || x[0].autoFit && F.fit(b), F.pad(A)), M.width = F.width, M.height = F.height;
      var U = this.getPotRenderTarget(g.gl, F.width, F.height, w);
      E.target = y, E.filters = x, E.resolution = w, E.renderTarget = U, U.setFrame(M, F), g.bindRenderTarget(U), U.clear();
    }
    popFilter() {
      var y = this.filterData, x = y.stack[y.index - 1], g = y.stack[y.index];
      this.quad.map(g.renderTarget.size, g.sourceFrame).upload();
      var _ = g.filters;
      if (_.length === 1)
        _[0].apply(this, g.renderTarget, x.renderTarget, false, g), this.freePotRenderTarget(g.renderTarget);
      else {
        var T = g.renderTarget, E = this.getPotRenderTarget(this.renderer.gl, g.sourceFrame.width, g.sourceFrame.height, g.resolution);
        E.setFrame(g.destinationFrame, g.sourceFrame), E.clear();
        var b = 0;
        for (b = 0; b < _.length - 1; ++b) {
          _[b].apply(this, T, E, true, g);
          var C = T;
          T = E, E = C;
        }
        _[b].apply(this, T, x.renderTarget, false, g), this.freePotRenderTarget(T), this.freePotRenderTarget(E);
      }
      g.clear(), y.index--, y.index === 0 && (this.filterData = null);
    }
    applyFilter(y, x, g, _) {
      var T = this.renderer, E = T.gl, b = y.glShaders[T.CONTEXT_UID];
      b || (y.glShaderKey ? (b = this.shaderCache[y.glShaderKey], b || (b = new a.default(this.gl, y.vertexSrc, y.fragmentSrc), y.glShaders[T.CONTEXT_UID] = this.shaderCache[y.glShaderKey] = b, this.managedFilters.push(y))) : (b = y.glShaders[T.CONTEXT_UID] = new a.default(this.gl, y.vertexSrc, y.fragmentSrc), this.managedFilters.push(y)), T.bindVao(null), this.quad.initVao(b)), T.bindVao(this.quad.vao), T.bindRenderTarget(g), _ && (E.disable(E.SCISSOR_TEST), T.clear(), E.enable(E.SCISSOR_TEST)), g === T.maskManager.scissorRenderTarget && T.maskManager.pushScissorMask(null, T.maskManager.scissorData), T.bindShader(b);
      var C = this.renderer.emptyTextures[0];
      this.renderer.boundTextures[0] = C, this.syncUniforms(b, y), T.state.setBlendMode(y.blendMode), E.activeTexture(E.TEXTURE0), E.bindTexture(E.TEXTURE_2D, x.texture.texture), this.quad.vao.draw(this.renderer.gl.TRIANGLES, 6, 0), E.bindTexture(E.TEXTURE_2D, C._glTextures[this.renderer.CONTEXT_UID].texture);
    }
    syncUniforms(y, x) {
      var g = x.uniformData, _ = x.uniforms, T = 1, E;
      if (y.uniforms.filterArea) {
        E = this.filterData.stack[this.filterData.index];
        var b = y.uniforms.filterArea;
        b[0] = E.renderTarget.size.width, b[1] = E.renderTarget.size.height, b[2] = E.sourceFrame.x, b[3] = E.sourceFrame.y, y.uniforms.filterArea = b;
      }
      if (y.uniforms.filterClamp) {
        E = E || this.filterData.stack[this.filterData.index];
        var C = y.uniforms.filterClamp;
        C[0] = 0, C[1] = 0, C[2] = (E.sourceFrame.width - 1) / E.renderTarget.size.width, C[3] = (E.sourceFrame.height - 1) / E.renderTarget.size.height, y.uniforms.filterClamp = C;
      }
      for (var w in g)
        if (y.uniforms.data[w]) {
          var A = g[w].type;
          if (A === "sampler2d" && _[w] !== 0) {
            if (_[w].baseTexture)
              y.uniforms[w] = this.renderer.bindTexture(_[w].baseTexture, T);
            else {
              y.uniforms[w] = T;
              var S = this.renderer.gl;
              this.renderer.boundTextures[T] = this.renderer.emptyTextures[T], S.activeTexture(S.TEXTURE0 + T), _[w].texture.bind();
            }
            T++;
          } else if (A === "mat3")
            _[w].a !== void 0 ? y.uniforms[w] = _[w].toArray(true) : y.uniforms[w] = _[w];
          else if (A === "vec2")
            if (_[w].x !== void 0) {
              var F = y.uniforms[w] || new Float32Array(2);
              F[0] = _[w].x, F[1] = _[w].y, y.uniforms[w] = F;
            } else
              y.uniforms[w] = _[w];
          else A === "float" ? y.uniforms.data[w].value !== g[w] && (y.uniforms[w] = _[w]) : y.uniforms[w] = _[w];
        }
    }
    getRenderTarget(y, x) {
      var g = this.filterData.stack[this.filterData.index], _ = this.getPotRenderTarget(this.renderer.gl, g.sourceFrame.width, g.sourceFrame.height, x || g.resolution);
      return _.setFrame(g.destinationFrame, g.sourceFrame), _;
    }
    returnRenderTarget(y) {
      this.freePotRenderTarget(y);
    }
    calculateScreenSpaceMatrix(y) {
      var x = this.filterData.stack[this.filterData.index];
      return s.calculateScreenSpaceMatrix(y, x.sourceFrame, x.renderTarget.size);
    }
    calculateNormalizedScreenSpaceMatrix(y) {
      var x = this.filterData.stack[this.filterData.index];
      return s.calculateNormalizedScreenSpaceMatrix(y, x.sourceFrame, x.renderTarget.size, x.destinationFrame);
    }
    calculateSpriteMatrix(y, x) {
      var g = this.filterData.stack[this.filterData.index];
      return s.calculateSpriteMatrix(y, g.sourceFrame, g.renderTarget.size, x);
    }
    destroy(y) {
      y === void 0 && (y = false);
      var x = this.renderer, g = this.managedFilters;
      x.off("prerender", this.onPrerender, this);
      for (var _ = 0; _ < g.length; _++)
        y || g[_].glShaders[x.CONTEXT_UID].destroy(), delete g[_].glShaders[x.CONTEXT_UID];
      this.shaderCache = {}, y ? this.pool = {} : this.emptyPool();
    }
    getPotRenderTarget(y, x, g, _) {
      var T = p;
      x *= _, g *= _, (x !== this._screenWidth || g !== this._screenHeight) && (x = u.default.nextPow2(x), g = u.default.nextPow2(g), T = (x & 65535) << 16 | g & 65535), this.pool[T] || (this.pool[T] = []);
      var E = this.pool[T].pop();
      if (!E) {
        var b = this.renderer.boundTextures[0];
        y.activeTexture(y.TEXTURE0), E = new e.default(y, x, g, null, 1), y.bindTexture(y.TEXTURE_2D, b._glTextures[this.renderer.CONTEXT_UID].texture);
      }
      return E.resolution = _, E.defaultFrame.width = E.size.width = x / _, E.defaultFrame.height = E.size.height = g / _, E.filterPoolKey = T, E;
    }
    emptyPool() {
      for (var y in this.pool) {
        var x = this.pool[y];
        if (x)
          for (var g = 0; g < x.length; g++)
            x[g].destroy(true);
      }
      this.pool = {};
    }
    freePotRenderTarget(y) {
      this.pool[y.filterPoolKey].push(y);
    }
    onPrerender() {
      if (this._screenWidth !== this.renderer.view.width || this._screenHeight !== this.renderer.view.height) {
        this._screenWidth = this.renderer.view.width, this._screenHeight = this.renderer.view.height;
        var y = this.pool[p];
        if (y)
          for (var x = 0; x < y.length; x++)
            y[x].destroy(true);
        this.pool[p] = [];
      }
    }
  };
  return FilterManager.default = m, FilterManager;
}
var ObjectRenderer = {}, hasRequiredObjectRenderer;
function requireObjectRenderer() {
  if (hasRequiredObjectRenderer) return ObjectRenderer;
  hasRequiredObjectRenderer = 1, Object.defineProperty(ObjectRenderer, "__esModule", {
    value: true
  }), ObjectRenderer.default = void 0;
  var i2 = e(requireWebGLManager());
  function e(r) {
    return r && r.__esModule ? r : { default: r };
  }
  let t = class extends i2.default {
    start() {
    }
    stop() {
      this.flush();
    }
    flush() {
    }
    render(r) {
    }
  };
  return ObjectRenderer.default = t, ObjectRenderer;
}
var TextureManager = {}, hasRequiredTextureManager;
function requireTextureManager() {
  if (hasRequiredTextureManager) return TextureManager;
  hasRequiredTextureManager = 1, Object.defineProperty(TextureManager, "__esModule", {
    value: true
  }), TextureManager.default = void 0;
  var i2 = requireSrc$1(), e = require_const(), t = a(requireRenderTarget()), r = requireUtils$3();
  function a(u) {
    return u && u.__esModule ? u : { default: u };
  }
  let s = class {
    constructor(u) {
      this.renderer = u, this.gl = u.gl, this._managedTextures = [];
    }
    bindTexture() {
    }
    getTexture() {
    }
    updateTexture(u, l) {
      var c = this.gl, d = !!u._glRenderTargets;
      if (!u.hasLoaded)
        return null;
      var f = this.renderer.boundTextures;
      if (l === void 0) {
        l = 0;
        for (var p = 0; p < f.length; ++p)
          if (f[p] === u) {
            l = p;
            break;
          }
      }
      f[l] = u, c.activeTexture(c.TEXTURE0 + l);
      var m = u._glTextures[this.renderer.CONTEXT_UID];
      if (m)
        d ? u._glRenderTargets[this.renderer.CONTEXT_UID].resize(u.width, u.height) : m.upload(u.source);
      else {
        if (d) {
          var y = new t.default(this.gl, u.width, u.height, u.scaleMode, u.resolution);
          y.resize(u.width, u.height), u._glRenderTargets[this.renderer.CONTEXT_UID] = y, m = y.texture, this.renderer._activeRenderTarget.root || this.renderer._activeRenderTarget.frameBuffer.bind();
        } else
          m = new i2.GLTexture(this.gl, null, null, null, null), m.bind(l), m.premultiplyAlpha = true, m.upload(u.source);
        u._glTextures[this.renderer.CONTEXT_UID] = m, u.on("update", this.updateTexture, this), u.on("dispose", this.destroyTexture, this), this._managedTextures.push(u), u.isPowerOfTwo ? (u.mipmap && m.enableMipmap(), u.wrapMode === e.WRAP_MODES.CLAMP ? m.enableWrapClamp() : u.wrapMode === e.WRAP_MODES.REPEAT ? m.enableWrapRepeat() : m.enableWrapMirrorRepeat()) : m.enableWrapClamp(), u.scaleMode === e.SCALE_MODES.NEAREST ? m.enableNearestScaling() : m.enableLinearScaling();
      }
      return m;
    }
    destroyTexture(u, l) {
      if (u = u.baseTexture || u, !!u.hasLoaded) {
        var c = this.renderer, d = c.CONTEXT_UID, f = u._glTextures, p = u._glRenderTargets;
        if (f[d] && (c.unbindTexture(u), f[d].destroy(), u.off("update", this.updateTexture, this), u.off("dispose", this.destroyTexture, this), delete f[d], !l)) {
          var m = this._managedTextures.indexOf(u);
          m !== -1 && (0, r.removeItems)(this._managedTextures, m, 1);
        }
        p && p[d] && (c._activeRenderTarget === p[d] && c.bindRenderTarget(c.rootRenderTarget), p[d].destroy(), delete p[d]);
      }
    }
    /**
     * Deletes all the textures from WebGL
     */
    removeAll() {
      for (var u = 0; u < this._managedTextures.length; ++u) {
        var l = this._managedTextures[u];
        l._glTextures[this.renderer.CONTEXT_UID] && delete l._glTextures[this.renderer.CONTEXT_UID];
      }
    }
    /**
     * Destroys this manager and removes all its textures
     */
    destroy() {
      for (var u = 0; u < this._managedTextures.length; ++u) {
        var l = this._managedTextures[u];
        this.destroyTexture(l, true), l.off("update", this.updateTexture, this), l.off("dispose", this.destroyTexture, this);
      }
      this._managedTextures = null;
    }
  };
  return TextureManager.default = s, TextureManager;
}
var TextureGarbageCollector = {}, hasRequiredTextureGarbageCollector;
function requireTextureGarbageCollector() {
  if (hasRequiredTextureGarbageCollector) return TextureGarbageCollector;
  hasRequiredTextureGarbageCollector = 1, Object.defineProperty(TextureGarbageCollector, "__esModule", {
    value: true
  }), TextureGarbageCollector.default = void 0;
  var i2 = require_const(), e = t(requireSettings());
  function t(a) {
    return a && a.__esModule ? a : { default: a };
  }
  let r = class {
    constructor(a) {
      this.renderer = a, this.count = 0, this.checkCount = 0, this.maxIdle = e.default.GC_MAX_IDLE, this.checkCountMax = e.default.GC_MAX_CHECK_COUNT, this.mode = e.default.GC_MODE;
    }
    update() {
      this.count++, this.mode !== i2.GC_MODES.MANUAL && (this.checkCount++, this.checkCount > this.checkCountMax && (this.checkCount = 0, this.run()));
    }
    run() {
      for (var a = this.renderer.textureManager, s = a._managedTextures, u = false, l = 0; l < s.length; l++) {
        var c = s[l];
        !c._glRenderTargets && this.count - c.touched > this.maxIdle && (a.destroyTexture(c, true), s[l] = null, u = true);
      }
      if (u) {
        for (var d = 0, f = 0; f < s.length; f++)
          s[f] !== null && (s[d++] = s[f]);
        s.length = d;
      }
    }
    unload(a) {
      var s = this.renderer.textureManager;
      a._texture && a._texture._glRenderTargets && s.destroyTexture(a._texture, true);
      for (var u = a.children.length - 1; u >= 0; u--)
        this.unload(a.children[u]);
    }
  };
  return TextureGarbageCollector.default = r, TextureGarbageCollector;
}
var WebGLState = {}, mapWebGLBlendModesToPixi = {}, hasRequiredMapWebGLBlendModesToPixi;
function requireMapWebGLBlendModesToPixi() {
  if (hasRequiredMapWebGLBlendModesToPixi) return mapWebGLBlendModesToPixi;
  hasRequiredMapWebGLBlendModesToPixi = 1, Object.defineProperty(mapWebGLBlendModesToPixi, "__esModule", {
    value: true
  }), mapWebGLBlendModesToPixi.default = e;
  var i2 = require_const();
  function e(t, r) {
    return r === void 0 && (r = []), r[i2.BLEND_MODES.NORMAL] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], r[i2.BLEND_MODES.ADD] = [t.ONE, t.ONE], r[i2.BLEND_MODES.MULTIPLY] = [t.DST_COLOR, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA], r[i2.BLEND_MODES.SCREEN] = [t.ONE, t.ONE_MINUS_SRC_COLOR, t.ONE, t.ONE_MINUS_SRC_ALPHA], r[i2.BLEND_MODES.OVERLAY] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], r[i2.BLEND_MODES.DARKEN] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], r[i2.BLEND_MODES.LIGHTEN] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], r[i2.BLEND_MODES.COLOR_DODGE] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], r[i2.BLEND_MODES.COLOR_BURN] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], r[i2.BLEND_MODES.HARD_LIGHT] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], r[i2.BLEND_MODES.SOFT_LIGHT] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], r[i2.BLEND_MODES.DIFFERENCE] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], r[i2.BLEND_MODES.EXCLUSION] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], r[i2.BLEND_MODES.HUE] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], r[i2.BLEND_MODES.SATURATION] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], r[i2.BLEND_MODES.COLOR] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], r[i2.BLEND_MODES.LUMINOSITY] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], r[i2.BLEND_MODES.NORMAL_NPM] = [t.SRC_ALPHA, t.ONE_MINUS_SRC_ALPHA, t.ONE, t.ONE_MINUS_SRC_ALPHA], r[i2.BLEND_MODES.ADD_NPM] = [t.SRC_ALPHA, t.ONE, t.ONE, t.ONE], r[i2.BLEND_MODES.SCREEN_NPM] = [t.SRC_ALPHA, t.ONE_MINUS_SRC_COLOR, t.ONE, t.ONE_MINUS_SRC_ALPHA], r;
  }
  return mapWebGLBlendModesToPixi;
}
var hasRequiredWebGLState;
function requireWebGLState() {
  if (hasRequiredWebGLState) return WebGLState;
  hasRequiredWebGLState = 1, Object.defineProperty(WebGLState, "__esModule", {
    value: true
  }), WebGLState.default = void 0;
  var i2 = e(requireMapWebGLBlendModesToPixi());
  function e(c) {
    return c && c.__esModule ? c : { default: c };
  }
  var t = 0, r = 1, a = 2, s = 3, u = 4;
  let l = class {
    constructor(c) {
      this.activeState = new Uint8Array(16), this.defaultState = new Uint8Array(16), this.defaultState[0] = 1, this.stackIndex = 0, this.stack = [], this.gl = c, this.maxAttribs = c.getParameter(c.MAX_VERTEX_ATTRIBS), this.attribState = {
        tempAttribState: new Array(this.maxAttribs),
        attribState: new Array(this.maxAttribs)
      }, this.blendModes = (0, i2.default)(c), this.nativeVaoExtension = c.getExtension("OES_vertex_array_object") || c.getExtension("MOZ_OES_vertex_array_object") || c.getExtension("WEBKIT_OES_vertex_array_object");
    }
    push() {
      var c = this.stack[this.stackIndex];
      c || (c = this.stack[this.stackIndex] = new Uint8Array(16)), ++this.stackIndex;
      for (var d = 0; d < this.activeState.length; d++)
        c[d] = this.activeState[d];
    }
    pop() {
      var c = this.stack[--this.stackIndex];
      this.setState(c);
    }
    setState(c) {
      this.setBlend(c[t]), this.setDepthTest(c[r]), this.setFrontFace(c[a]), this.setCullFace(c[s]), this.setBlendMode(c[u]);
    }
    setBlend(c) {
      c = c ? 1 : 0, this.activeState[t] !== c && (this.activeState[t] = c, this.gl[c ? "enable" : "disable"](this.gl.BLEND));
    }
    setBlendMode(c) {
      if (c !== this.activeState[u]) {
        this.activeState[u] = c;
        var d = this.blendModes[c];
        d.length === 2 ? this.gl.blendFunc(d[0], d[1]) : this.gl.blendFuncSeparate(d[0], d[1], d[2], d[3]);
      }
    }
    setDepthTest(c) {
      c = c ? 1 : 0, this.activeState[r] !== c && (this.activeState[r] = c, this.gl[c ? "enable" : "disable"](this.gl.DEPTH_TEST));
    }
    setCullFace(c) {
      c = c ? 1 : 0, this.activeState[s] !== c && (this.activeState[s] = c, this.gl[c ? "enable" : "disable"](this.gl.CULL_FACE));
    }
    setFrontFace(c) {
      c = c ? 1 : 0, this.activeState[a] !== c && (this.activeState[a] = c, this.gl.frontFace(this.gl[c ? "CW" : "CCW"]));
    }
    resetAttributes() {
      for (var c = 0; c < this.attribState.tempAttribState.length; c++)
        this.attribState.tempAttribState[c] = 0;
      for (var d = 0; d < this.attribState.attribState.length; d++)
        this.attribState.attribState[d] = 0;
      for (var f = 1; f < this.maxAttribs; f++)
        this.gl.disableVertexAttribArray(f);
    }
    resetToDefault() {
      this.nativeVaoExtension && this.nativeVaoExtension.bindVertexArrayOES(null), this.resetAttributes();
      for (var c = 0; c < this.activeState.length; ++c)
        this.activeState[c] = 32;
      this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, false), this.setState(this.defaultState);
    }
  };
  return WebGLState.default = l, WebGLState;
}
var mapWebGLDrawModesToPixi = {}, hasRequiredMapWebGLDrawModesToPixi;
function requireMapWebGLDrawModesToPixi() {
  if (hasRequiredMapWebGLDrawModesToPixi) return mapWebGLDrawModesToPixi;
  hasRequiredMapWebGLDrawModesToPixi = 1, Object.defineProperty(mapWebGLDrawModesToPixi, "__esModule", {
    value: true
  }), mapWebGLDrawModesToPixi.default = e;
  var i2 = require_const();
  function e(t, r) {
    return r === void 0 && (r = {}), r[i2.DRAW_MODES.POINTS] = t.POINTS, r[i2.DRAW_MODES.LINES] = t.LINES, r[i2.DRAW_MODES.LINE_LOOP] = t.LINE_LOOP, r[i2.DRAW_MODES.LINE_STRIP] = t.LINE_STRIP, r[i2.DRAW_MODES.TRIANGLES] = t.TRIANGLES, r[i2.DRAW_MODES.TRIANGLE_STRIP] = t.TRIANGLE_STRIP, r[i2.DRAW_MODES.TRIANGLE_FAN] = t.TRIANGLE_FAN, r;
  }
  return mapWebGLDrawModesToPixi;
}
var validateContext = {}, hasRequiredValidateContext;
function requireValidateContext() {
  if (hasRequiredValidateContext) return validateContext;
  hasRequiredValidateContext = 1, Object.defineProperty(validateContext, "__esModule", {
    value: true
  }), validateContext.default = i2;
  function i2(e) {
    var t = e.getContextAttributes();
    t.stencil || console.warn("Provided WebGL context does not have a stencil buffer, masks may not render correctly");
  }
  return validateContext;
}
var hasRequiredWebGLRenderer;
function requireWebGLRenderer() {
  if (hasRequiredWebGLRenderer) return WebGLRenderer;
  hasRequiredWebGLRenderer = 1, Object.defineProperty(WebGLRenderer, "__esModule", {
    value: true
  }), WebGLRenderer.default = void 0;
  var i2 = g(requireSystemRenderer()), e = g(requireMaskManager()), t = g(requireStencilManager()), r = g(requireFilterManager()), a = g(requireRenderTarget()), s = g(requireObjectRenderer()), u = g(requireTextureManager()), l = g(requireBaseTexture()), c = g(requireTextureGarbageCollector()), d = g(requireWebGLState()), f = g(requireMapWebGLDrawModesToPixi()), p = g(requireValidateContext()), m = requireUtils$3(), y = g(requireSrc$1()), x = require_const();
  function g(E) {
    return E && E.__esModule ? E : { default: E };
  }
  var _ = 0;
  let T = class extends i2.default {
    constructor(E, b, C) {
      super("WebGL", E, b, C), this.legacy = this.options.legacy, this.legacy && (y.default.VertexArrayObject.FORCE_NATIVE = true), this.type = x.RENDERER_TYPE.WEBGL, this.handleContextLost = this.handleContextLost.bind(this), this.handleContextRestored = this.handleContextRestored.bind(this), this.view.addEventListener("webglcontextlost", this.handleContextLost, false), this.view.addEventListener("webglcontextrestored", this.handleContextRestored, false), this._contextOptions = {
        alpha: this.transparent,
        antialias: this.options.antialias,
        premultipliedAlpha: this.transparent && this.transparent !== "notMultiplied",
        stencil: true,
        preserveDrawingBuffer: this.options.preserveDrawingBuffer,
        powerPreference: this.options.powerPreference
      }, this._backgroundColorRgba[3] = this.transparent ? 0 : 1, this.maskManager = new e.default(this), this.stencilManager = new t.default(this), this.emptyRenderer = new s.default(this), this.currentRenderer = this.emptyRenderer, this.textureManager = null, this.filterManager = null, this.initPlugins(), this.options.context && (0, p.default)(this.options.context), this.gl = this.options.context || y.default.createContext(this.view, this._contextOptions), this.CONTEXT_UID = _++, this.state = new d.default(this.gl), this.renderingToScreen = true, this.boundTextures = null, this._activeShader = null, this._activeVao = null, this._activeRenderTarget = null, this._initContext(), this.drawModes = (0, f.default)(this.gl), this._nextTextureLocation = 0, this.setBlendMode(0);
    }
    _initContext() {
      var E = this.gl;
      E.isContextLost() && E.getExtension("WEBGL_lose_context") && E.getExtension("WEBGL_lose_context").restoreContext();
      var b = E.getParameter(E.MAX_TEXTURE_IMAGE_UNITS);
      this._activeShader = null, this._activeVao = null, this.boundTextures = new Array(b), this.emptyTextures = new Array(b), this._unknownBoundTextures = false, this.textureManager = new u.default(this), this.filterManager = new r.default(this), this.textureGC = new c.default(this), this.state.resetToDefault(), this.rootRenderTarget = new a.default(E, this.width, this.height, null, this.resolution, true), this.rootRenderTarget.clearColor = this._backgroundColorRgba, this.bindRenderTarget(this.rootRenderTarget);
      var C = new y.default.GLTexture.fromData(E, null, 1, 1), w = {
        _glTextures: {}
      };
      w._glTextures[this.CONTEXT_UID] = {};
      for (var A = 0; A < b; A++) {
        var S = new l.default();
        S._glTextures[this.CONTEXT_UID] = C, this.boundTextures[A] = w, this.emptyTextures[A] = S, this.bindTexture(null, A);
      }
      this.emit("context", E), this.resize(this.screen.width, this.screen.height);
    }
    render(E, b, C, w, A) {
      if (this.renderingToScreen = !b, this.emit("prerender"), !(!this.gl || this.gl.isContextLost())) {
        if (this._nextTextureLocation = 0, b || (this._lastObjectRendered = E), !A) {
          var S = E.parent;
          E.parent = this._tempDisplayObjectParent, E.updateTransform(), E.parent = S;
        }
        this.bindRenderTexture(b, w), this.currentRenderer.start(), (C !== void 0 ? C : this.clearBeforeRender) && this._activeRenderTarget.clear(), E.renderWebGL(this), this.currentRenderer.flush(), this.textureGC.update(), this.emit("postrender");
      }
    }
    setObjectRenderer(E) {
      this.currentRenderer !== E && (this.currentRenderer.stop(), this.currentRenderer = E, this.currentRenderer.start());
    }
    flush() {
      this.setObjectRenderer(this.emptyRenderer);
    }
    resize(E, b) {
      i2.default.prototype.resize.call(this, E, b), this.rootRenderTarget.resize(E, b), this._activeRenderTarget === this.rootRenderTarget && (this.rootRenderTarget.activate(), this._activeShader && (this._activeShader.uniforms.projectionMatrix = this.rootRenderTarget.projectionMatrix.toArray(true)));
    }
    setBlendMode(E) {
      this.state.setBlendMode(E);
    }
    deleteTexture(E) {
      this.gl.deleteTexture(E);
    }
    clear(E) {
      this._activeRenderTarget.clear(E);
    }
    setTransform(E) {
      this._activeRenderTarget.transform = E;
    }
    clearRenderTexture(E, b) {
      var C = E.baseTexture, w = C._glRenderTargets[this.CONTEXT_UID];
      return w && w.clear(b), this;
    }
    bindRenderTexture(E, b) {
      var C;
      if (E) {
        var w = E.baseTexture;
        w._glRenderTargets[this.CONTEXT_UID] || this.textureManager.updateTexture(w, 0), this.unbindTexture(w), C = w._glRenderTargets[this.CONTEXT_UID], C.setFrame(E.frame);
      } else
        C = this.rootRenderTarget;
      return C.transform = b, this.bindRenderTarget(C), this;
    }
    bindRenderTarget(E) {
      return E !== this._activeRenderTarget && (this._activeRenderTarget = E, E.activate(), this._activeShader && (this._activeShader.uniforms.projectionMatrix = E.projectionMatrix.toArray(true)), this.stencilManager.setMaskStack(E.stencilMaskStack)), this;
    }
    bindShader(E, b) {
      return this._activeShader !== E && (this._activeShader = E, E.bind(), b !== false && (E.uniforms.projectionMatrix = this._activeRenderTarget.projectionMatrix.toArray(true))), this;
    }
    bindTexture(E, b, C) {
      if (E = E || this.emptyTextures[b], E = E.baseTexture || E, E.touched = this.textureGC.count, C)
        b = b || 0;
      else {
        for (var w = 0; w < this.boundTextures.length; w++)
          if (this.boundTextures[w] === E)
            return w;
        b === void 0 && (this._nextTextureLocation++, this._nextTextureLocation %= this.boundTextures.length, b = this.boundTextures.length - this._nextTextureLocation - 1);
      }
      var A = this.gl, S = E._glTextures[this.CONTEXT_UID];
      return S ? (this.boundTextures[b] = E, A.activeTexture(A.TEXTURE0 + b), A.bindTexture(A.TEXTURE_2D, S.texture)) : this.textureManager.updateTexture(E, b), b;
    }
    unbindTexture(E) {
      var b = this.gl;
      if (E = E.baseTexture || E, this._unknownBoundTextures) {
        this._unknownBoundTextures = false;
        for (var C = 0; C < this.boundTextures.length; C++)
          this.boundTextures[C] === this.emptyTextures[C] && (b.activeTexture(b.TEXTURE0 + C), b.bindTexture(b.TEXTURE_2D, this.emptyTextures[C]._glTextures[this.CONTEXT_UID].texture));
      }
      for (var w = 0; w < this.boundTextures.length; w++)
        this.boundTextures[w] === E && (this.boundTextures[w] = this.emptyTextures[w], b.activeTexture(b.TEXTURE0 + w), b.bindTexture(b.TEXTURE_2D, this.emptyTextures[w]._glTextures[this.CONTEXT_UID].texture));
      return this;
    }
    createVao() {
      return new y.default.VertexArrayObject(this.gl, this.state.attribState);
    }
    bindVao(E) {
      return this._activeVao === E ? this : (E ? E.bind() : this._activeVao && this._activeVao.unbind(), this._activeVao = E, this);
    }
    reset() {
      this.setObjectRenderer(this.emptyRenderer), this.bindVao(null), this._activeShader = null, this._activeRenderTarget = this.rootRenderTarget, this._unknownBoundTextures = true;
      for (var E = 0; E < this.boundTextures.length; E++)
        this.boundTextures[E] = this.emptyTextures[E];
      return this.rootRenderTarget.activate(), this.state.resetToDefault(), this;
    }
    handleContextLost(E) {
      E.preventDefault();
    }
    handleContextRestored() {
      this.textureManager.removeAll(), this.filterManager.destroy(true), this._initContext();
    }
    destroy(E) {
      this.destroyPlugins(), this.view.removeEventListener("webglcontextlost", this.handleContextLost), this.view.removeEventListener("webglcontextrestored", this.handleContextRestored), this.textureManager.destroy(), super.destroy(E), this.uid = 0, this.maskManager.destroy(), this.stencilManager.destroy(), this.filterManager.destroy(), this.maskManager = null, this.filterManager = null, this.textureManager = null, this.currentRenderer = null, this.handleContextLost = null, this.handleContextRestored = null, this._contextOptions = null, this.gl.useProgram(null), this.gl.getExtension("WEBGL_lose_context") && this.gl.getExtension("WEBGL_lose_context").loseContext(), this.gl = null;
    }
  };
  return WebGLRenderer.default = T, m.pluginTarget.mixin(T), WebGLRenderer;
}
var ProxyObj = {}, hasRequiredProxyObj;
function requireProxyObj() {
  if (hasRequiredProxyObj) return ProxyObj;
  hasRequiredProxyObj = 1, Object.defineProperty(ProxyObj, "__esModule", {
    value: true
  }), ProxyObj.default = void 0;
  var i2 = requireMath$1(), e = t(requireEventemitter3$1());
  function t(a) {
    return a && a.__esModule ? a : { default: a };
  }
  let r = class extends e.default {
    constructor() {
      super(), this.width = null, this.height = null, this.alpha = 1, this.worldAlpha = 1, this.rotation = 0, this.x = 0, this.y = 0, this.scale = new i2.Point(1, 1), this.anchor = new i2.Point(), this.transform = {}, this.blendMode = null, this.text = null, this.style = null, this.parent = null, this.isProxy = true;
    }
    attr(a) {
    }
    replaceFromParent(a) {
      var {
        parent: s
      } = this;
      if (s) {
        var u = s.getChildIndex(this);
        s.removeChild(this), s.addChildAt(a, u);
      }
    }
    updateStyle(a) {
      this.style || (this.style = {});
      for (var s in a) {
        var u = this.camelCase(s);
        u === "color" && (u = "fill"), this.style[u] = a[s];
      }
    }
    camelCase(a) {
      var s = /([\:\-\_]+(.))/g, u = /^moz([A-Z])/;
      return a.replace(s, function(l, c, d, f) {
        return f ? d.toUpperCase() : d;
      }).replace(u, "Moz$1");
    }
    destroy() {
      this.width = null, this.height = null, this.alpha = null, this.x = null, this.y = null, this.scale = null, this.pivot = null, this.anchor = null, this.text = null, this.style = null, this.transform = null, this.parent = null, this.removeAllListeners();
    }
  };
  return ProxyObj.default = r, ProxyObj;
}
var Sprite = {}, hasRequiredSprite;
function requireSprite() {
  if (hasRequiredSprite) return Sprite;
  hasRequiredSprite = 1, Object.defineProperty(Sprite, "__esModule", {
    value: true
  }), Sprite.default = void 0;
  var i2 = requireMath$1(), e = requireUtils$3(), t = require_const(), r = u(requireTexture$1()), a = u(requireContainer()), s = requireCache();
  function u(d) {
    return d && d.__esModule ? d : { default: d };
  }
  var l = new i2.Point();
  let c = class Eu extends a.default {
    constructor(f) {
      super(), this._anchor = new i2.ObservablePoint(this._onAnchorUpdate, this, f ? f.defaultAnchor.x : 0, f ? f.defaultAnchor.y : 0), this._texture = null, this._width = 0, this._height = 0, this._tint = null, this._tintRGB = null, this.tint = 16777215, this.blendMode = t.BLEND_MODES.NORMAL, this.shader = null, this.cachedTint = 16777215, this.texture = f || r.default.EMPTY, this.vertexData = new Float32Array(8), this.vertexTrimmedData = null, this._transformID = -1, this._textureID = -1, this._transformTrimmedID = -1, this._textureTrimmedID = -1, this.pluginName = "sprite", this.log = false;
    }
    _onTextureUpdate() {
      this._textureID = -1, this._textureTrimmedID = -1, this.cachedTint = 16777215, this._width && (this.scale.x = (0, e.sign)(this.scale.x) * this._width / this._texture.orig.width), this._height && (this.scale.y = (0, e.sign)(this.scale.y) * this._height / this._texture.orig.height);
    }
    _onAnchorUpdate() {
      this._transformID = -1, this._transformTrimmedID = -1;
    }
    calculateVertices() {
      if (!(this._transformID === this.transform._worldID && this._textureID === this._texture._updateID)) {
        this._transformID = this.transform._worldID, this._textureID = this._texture._updateID;
        var f = this._texture, p = this.transform.worldTransform, m = p.a, y = p.b, x = p.c, g = p.d, _ = p.tx, T = p.ty, E = this.vertexData, b = f.trim, C = f.orig, w = this._anchor, A = 0, S = 0, F = 0, M = 0;
        b ? (S = b.x - w._x * C.width, A = S + b.width, M = b.y - w._y * C.height, F = M + b.height) : (S = -w._x * C.width, A = S + C.width, M = -w._y * C.height, F = M + C.height), E[0] = m * S + x * M + _, E[1] = g * M + y * S + T, E[2] = m * A + x * M + _, E[3] = g * M + y * A + T, E[4] = m * A + x * F + _, E[5] = g * F + y * A + T, E[6] = m * S + x * F + _, E[7] = g * F + y * S + T;
      }
    }
    calculateTrimmedVertices() {
      if (!this.vertexTrimmedData)
        this.vertexTrimmedData = new Float32Array(8);
      else if (this._transformTrimmedID === this.transform._worldID && this._textureTrimmedID === this._texture._updateID)
        return;
      this._transformTrimmedID = this.transform._worldID, this._textureTrimmedID = this._texture._updateID;
      var f = this._texture, p = this.vertexTrimmedData, m = f.orig, y = this._anchor, x = this.transform.worldTransform, g = x.a, _ = x.b, T = x.c, E = x.d, b = x.tx, C = x.ty, w = -y._x * m.width, A = w + m.width, S = -y._y * m.height, F = S + m.height;
      p[0] = g * w + T * S + b, p[1] = E * S + _ * w + C, p[2] = g * A + T * S + b, p[3] = E * S + _ * A + C, p[4] = g * A + T * F + b, p[5] = E * F + _ * A + C, p[6] = g * w + T * F + b, p[7] = E * F + _ * w + C;
    }
    _renderWebGL(f) {
      this.calculateVertices(), f.setObjectRenderer(f.plugins[this.pluginName]), f.plugins[this.pluginName].render(this);
    }
    _renderCanvas(f) {
      f.plugins[this.pluginName].render(this);
    }
    _calculateBounds() {
      var f = this._texture.trim, p = this._texture.orig;
      !f || f.width === p.width && f.height === p.height ? (this.calculateVertices(), this._bounds.addQuad(this.vertexData)) : (this.calculateTrimmedVertices(), this._bounds.addQuad(this.vertexTrimmedData));
    }
    updateBaseTexture(f, p) {
      p === void 0 && (p = false), this.texture && this.texture.updateSource(f, p);
    }
    getLocalBounds(f) {
      return this.children.length === 0 ? (this._bounds.minX = this._texture.orig.width * -this._anchor._x, this._bounds.minY = this._texture.orig.height * -this._anchor._y, this._bounds.maxX = this._texture.orig.width * (1 - this._anchor._x), this._bounds.maxY = this._texture.orig.height * (1 - this._anchor._y), f || (this._localBoundsRect || (this._localBoundsRect = new i2.Rectangle()), f = this._localBoundsRect), this._bounds.getRectangle(f)) : super.getLocalBounds.call(this, f);
    }
    containsPoint(f) {
      this.worldTransform.applyInverse(f, l);
      var p = this._texture.orig.width, m = this._texture.orig.height, y = -p * this.anchor.x, x = 0;
      return l.x >= y && l.x < y + p && (x = -m * this.anchor.y, l.y >= x && l.y < x + m);
    }
    destroy(f) {
      if (!this.destroyed) {
        super.destroy(f), this._texture.off("update", this._onTextureUpdate, this), this._anchor = null;
        var p = typeof f == "boolean" ? f : f && f.texture;
        if (p) {
          var m = typeof f == "boolean" ? f : f && f.baseTexture;
          this._texture.destroy(!!m);
        }
        this._texture = null, this.shader = null;
      }
    }
    static from(f) {
      return new Eu(r.default.from(f));
    }
    static fromFrame(f) {
      var p = s.TextureCache[f];
      if (!p) throw new Error('The frameId "' + f + '" does not exist');
      return new Eu(p);
    }
    static fromImage(f, p, m) {
      return new Eu(r.default.fromImage(f, p, m));
    }
    get width() {
      return Math.abs(this.scale.x) * this._texture.orig.width;
    }
    set width(f) {
      var p = (0, e.sign)(this.scale.x) || 1;
      this.scale.x = p * f / this._texture.orig.width, this._width = f;
    }
    get height() {
      return Math.abs(this.scale.y) * this._texture.orig.height;
    }
    set height(f) {
      var p = (0, e.sign)(this.scale.y) || 1;
      this.scale.y = p * f / this._texture.orig.height, this._height = f;
    }
    get anchor() {
      return this._anchor;
    }
    set anchor(f) {
      this._anchor.copy(f);
    }
    get tint() {
      return this._tint;
    }
    set tint(f) {
      this._tint = f, this._tintRGB = (f >> 16) + (f & 65280) + ((f & 255) << 16);
    }
    get texture() {
      return this._texture;
    }
    set texture(f) {
      this._texture !== f && (this._texture = f || r.default.EMPTY, this.cachedTint = 16777215, this._textureID = -1, this._textureTrimmedID = -1, f && (f.baseTexture.hasLoaded ? this._onTextureUpdate() : f.once("update", this._onTextureUpdate, this)));
    }
  };
  return Sprite.default = c, Sprite;
}
var AnimatedSprite = {}, Maths = {}, hasRequiredMaths;
function requireMaths() {
  if (hasRequiredMaths) return Maths;
  hasRequiredMaths = 1, Object.defineProperty(Maths, "__esModule", {
    value: true
  }), Maths.default = void 0;
  var i2 = {
    sign(t) {
      return t = Number(t), t === 0 || isNaN(t) ? t : t > 0 ? 1 : -1;
    }
  }, e = i2;
  return Maths.default = e, Maths;
}
var hasRequiredAnimatedSprite;
function requireAnimatedSprite() {
  if (hasRequiredAnimatedSprite) return AnimatedSprite;
  hasRequiredAnimatedSprite = 1, Object.defineProperty(AnimatedSprite, "__esModule", {
    value: true
  }), AnimatedSprite.default = void 0;
  var i2 = s(requireSprite()), e = requireTicker(), t = s(requireMaths()), r = s(requireTexture$1()), a = require_const();
  function s(l) {
    return l && l.__esModule ? l : { default: l };
  }
  let u = class Rm extends i2.default {
    constructor(c, d) {
      super(c[0] instanceof r.default ? c[0] : c[0].texture), this._textures = null, this._durations = null, this.textures = c, this._autoUpdate = d !== false, this.animationSpeed = 1, this.loop = true, this.updateAnchor = false, this.onComplete = null, this.onFrameChange = null, this.onLoop = null, this._currentTime = 0, this.playing = false;
    }
    stop() {
      this.playing && (this.playing = false, this._autoUpdate && e.shared.remove(this.update, this));
    }
    play() {
      this.playing || (this.playing = true, this._autoUpdate && e.shared.add(this.update, this, a.UPDATE_PRIORITY.HIGH));
    }
    gotoAndStop(c) {
      this.stop();
      var d = this.currentFrame;
      this._currentTime = c, d !== this.currentFrame && this.updateTexture();
    }
    gotoAndPlay(c) {
      var d = this.currentFrame;
      this._currentTime = c, d !== this.currentFrame && this.updateTexture(), this.play();
    }
    update(c) {
      var d = this.animationSpeed * c, f = this.currentFrame;
      if (this._durations !== null) {
        var p = this._currentTime % 1 * this._durations[this.currentFrame];
        for (p += d / 60 * 1e3; p < 0; )
          this._currentTime--, p += this._durations[this.currentFrame];
        var m = t.default.sign(this.animationSpeed * c);
        for (this._currentTime = Math.floor(this._currentTime); p >= this._durations[this.currentFrame]; )
          p -= this._durations[this.currentFrame] * m, this._currentTime += m;
        this._currentTime += p / this._durations[this.currentFrame];
      } else
        this._currentTime += d;
      this._currentTime < 0 && !this.loop ? (this.gotoAndStop(0), this.onComplete && this.onComplete()) : this._currentTime >= this._textures.length && !this.loop ? (this.gotoAndStop(this._textures.length - 1), this.onComplete && this.onComplete()) : f !== this.currentFrame && (this.loop && this.onLoop && (this.animationSpeed > 0 && this.currentFrame < f ? this.onLoop() : this.animationSpeed < 0 && this.currentFrame > f && this.onLoop()), this.updateTexture());
    }
    updateTexture() {
      this._texture = this._textures[this.currentFrame], this._textureID = -1, this.cachedTint = 16777215, this.updateAnchor && this._anchor.copy(this._texture.defaultAnchor), this.onFrameChange && this.onFrameChange(this.currentFrame);
    }
    destroy(c) {
      this.stop(), super.destroy(c);
    }
    static fromFrames(c) {
      for (var d = [], f = 0; f < c.length; ++f)
        d.push(r.default.fromFrame(c[f]));
      return new Rm(d);
    }
    static fromImages(c) {
      for (var d = [], f = 0; f < c.length; ++f)
        d.push(r.default.fromImage(c[f]));
      return new Rm(d);
    }
    get totalFrames() {
      return this._textures.length;
    }
    get textures() {
      return this._textures;
    }
    set textures(c) {
      if (c[0] instanceof r.default)
        this._textures = c, this._durations = null;
      else {
        this._textures = [], this._durations = [];
        for (var d = 0; d < c.length; d++)
          this._textures.push(c[d].texture), this._durations.push(c[d].time);
      }
      this.gotoAndStop(0), this.updateTexture();
    }
    get currentFrame() {
      var c = Math.floor(this._currentTime) % this._textures.length;
      return c < 0 && (c += this._textures.length), c;
    }
  };
  return AnimatedSprite.default = u, AnimatedSprite;
}
var CanvasSpriteRenderer = {}, CanvasTinter = {}, hasRequiredCanvasTinter;
function requireCanvasTinter() {
  if (hasRequiredCanvasTinter) return CanvasTinter;
  hasRequiredCanvasTinter = 1, Object.defineProperty(CanvasTinter, "__esModule", {
    value: true
  }), CanvasTinter.default = void 0;
  var i2 = r(requireImage$2()), e = requireUtils$3(), t = r(requireCanUseNewCanvasBlendModes());
  function r(u) {
    return u && u.__esModule ? u : { default: u };
  }
  var a = {
    getTintedTexture: (u, l) => {
      var c = u._texture;
      l = a.roundColor(l);
      var d = "#" + ("00000" + (l | 0).toString(16)).substr(-6);
      c.tintCache = c.tintCache || {};
      var f = c.tintCache[d], p;
      if (f) {
        if (f.tintId === c._updateID)
          return c.tintCache[d];
        p = c.tintCache[d];
      } else
        p = a.canvas;
      if (a.tintMethod(c, l, p), p.tintId = c._updateID, a.convertTintToImage) {
        var m = new i2.default();
        m.src = p.toDataURL(), c.tintCache[d] = m;
      } else
        c.tintCache[d] = p, a.canvas = null;
      return p;
    },
    tintWithMultiply: (u, l, c) => {
      var d = c.getContext("2d"), f = u._frame.clone(), p = u.baseTexture.resolution;
      f.x *= p, f.y *= p, f.width *= p, f.height *= p, c.width = Math.ceil(f.width), c.height = Math.ceil(f.height), d.save(), d.fillStyle = "#" + ("00000" + (l | 0).toString(16)).substr(-6), d.fillRect(0, 0, f.width, f.height), d.globalCompositeOperation = "multiply", d.drawImage(u.baseTexture.source, f.x, f.y, f.width, f.height, 0, 0, f.width, f.height), d.globalCompositeOperation = "destination-atop", d.drawImage(u.baseTexture.source, f.x, f.y, f.width, f.height, 0, 0, f.width, f.height), d.restore();
    },
    tintWithOverlay(u, l, c) {
      var d = c.getContext("2d"), f = u._frame.clone(), p = u.baseTexture.resolution;
      f.x *= p, f.y *= p, f.width *= p, f.height *= p, c.width = Math.ceil(f.width), c.height = Math.ceil(f.height), d.save(), d.globalCompositeOperation = "copy", d.fillStyle = "#" + ("00000" + (l | 0).toString(16)).substr(-6), d.fillRect(0, 0, f.width, f.height), d.globalCompositeOperation = "destination-atop", d.drawImage(u.baseTexture.source, f.x, f.y, f.width, f.height, 0, 0, f.width, f.height), d.restore();
    },
    tintWithPerPixel: (u, l, c) => {
      var d = c.getContext("2d"), f = u._frame.clone(), p = u.baseTexture.resolution;
      f.x *= p, f.y *= p, f.width *= p, f.height *= p, c.width = Math.ceil(f.width), c.height = Math.ceil(f.height), d.save(), d.globalCompositeOperation = "copy", d.drawImage(u.baseTexture.source, f.x, f.y, f.width, f.height, 0, 0, f.width, f.height), d.restore();
      for (var m = (0, e.hex2rgb)(l), y = m[0], x = m[1], g = m[2], _ = d.getImageData(0, 0, f.width, f.height), T = _.data, E = 0; E < T.length; E += 4)
        T[E + 0] *= y, T[E + 1] *= x, T[E + 2] *= g;
      d.putImageData(_, 0, 0);
    },
    roundColor: (u) => {
      var l = a.cacheStepsPerColorChannel, c = (0, e.hex2rgb)(u);
      return c[0] = Math.min(255, c[0] / l * l), c[1] = Math.min(255, c[1] / l * l), c[2] = Math.min(255, c[2] / l * l), (0, e.rgb2hex)(c);
    },
    cacheStepsPerColorChannel: 8,
    convertTintToImage: false,
    canUseMultiply: (0, t.default)(),
    tintMethod: 0
  };
  a.tintMethod = a.canUseMultiply ? a.tintWithMultiply : a.tintWithPerPixel;
  var s = a;
  return CanvasTinter.default = s, CanvasTinter;
}
var hasRequiredCanvasSpriteRenderer;
function requireCanvasSpriteRenderer() {
  if (hasRequiredCanvasSpriteRenderer) return CanvasSpriteRenderer;
  hasRequiredCanvasSpriteRenderer = 1, Object.defineProperty(CanvasSpriteRenderer, "__esModule", {
    value: true
  }), CanvasSpriteRenderer.default = void 0;
  var i2 = a(requireCanvasRenderer()), e = require_const(), t = requireMath$1(), r = a(requireImage$2());
  a(requireCanvasTinter());
  function a(l) {
    return l && l.__esModule ? l : { default: l };
  }
  var s = new t.Matrix();
  let u = class {
    constructor(l) {
      this.renderer = l;
    }
    render(l) {
      var c = l._texture, d = this.renderer, f = c._frame.width, p = c._frame.height, m = l.transform.worldTransform, y = 0, x = 0;
      if (!(c.orig.width <= 0 || c.orig.height <= 0 || !c.baseTexture.source) && (d.setBlendMode(l.blendMode), c.valid)) {
        d.context.globalAlpha = l.worldAlpha;
        var g = c.baseTexture.scaleMode === e.SCALE_MODES.LINEAR;
        d.smoothProperty && d.context[d.smoothProperty] !== g && (d.context[d.smoothProperty] = g), y = (0.5 - l.anchor.x) * c.orig.width, x = (0.5 - l.anchor.y) * c.orig.height, c.rotate && (m.copy(s), m = s, t.GroupD8.matrixAppendRotationInv(m, c.rotate, y, x), y = 0, x = 0), y -= f / 2, x -= p / 2, d.roundPixels ? (d.context.setTransform(m.a, m.b, m.c, m.d, m.tx * d.resolution | 0, m.ty * d.resolution | 0), y = y | 0, x = x | 0) : d.context.setTransform(m.a, m.b, m.c, m.d, m.tx * d.resolution, m.ty * d.resolution);
        var _ = c.baseTexture.resolution;
        this.adaptedNodeCanvas(c.baseTexture);
        var T, E, b, C;
        T = c._frame.x, E = c._frame.y, c.trim ? (b = c.trim.width, C = c.trim.height) : (b = f, C = p), d.context.drawImage(c.baseTexture.source, T * _, E * _, f * _, p * _, y * d.resolution, x * d.resolution, b * d.resolution, C * d.resolution);
      }
    }
    adaptedNodeCanvas(l) {
      if (l.source && !l.source.isPSCanvas && this.isImageData(l.source)) {
        var {
          source: c,
          width: d,
          height: f
        } = l;
        l.source = r.default.convertToCanvas(c, d, f);
      }
    }
    isImageData(l) {
      return l ? !!(l.width && l.height && l.data && l.data.length) : false;
    }
    destroy() {
      this.renderer = null;
    }
  };
  return CanvasSpriteRenderer.default = u, i2.default.registerPlugin("sprite", u), CanvasSpriteRenderer;
}
var SpriteRenderer = {}, generateMultiTextureShader = {}, hasRequiredGenerateMultiTextureShader;
function requireGenerateMultiTextureShader() {
  if (hasRequiredGenerateMultiTextureShader) return generateMultiTextureShader;
  hasRequiredGenerateMultiTextureShader = 1, Object.defineProperty(generateMultiTextureShader, "__esModule", {
    value: true
  }), generateMultiTextureShader.default = r;
  var i2 = e(requireShader$1());
  function e(s) {
    return s && s.__esModule ? s : { default: s };
  }
  var t = ["varying vec2 vTextureCoord;", "varying vec4 vColor;", "varying float vTextureId;", "uniform sampler2D uSamplers[%count%];", "void main(void){", "vec4 color;", "%forloop%", "gl_FragColor = color * vColor;", "}"].join(`
`);
  function r(s, u) {
    var l = `precision highp float;
attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;
attribute vec4 aColor;
attribute float aTextureId;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;
varying vec4 vColor;
varying float vTextureId;

void main(void){
    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = aTextureCoord;
    vTextureId = aTextureId;
    vColor = aColor;
}
`, c = t;
    c = c.replace(/%count%/gi, u), c = c.replace(/%forloop%/gi, a(u));
    for (var d = new i2.default(s, l, c), f = [], p = 0; p < u; p++)
      f[p] = p;
    return d.bind(), d.uniforms.uSamplers = f, d;
  }
  function a(s) {
    var u = "";
    u += `
`, u += `
`;
    for (var l = 0; l < s; l++)
      l > 0 && (u += `
else `), l < s - 1 && (u += "if(vTextureId < " + l + ".5)"), u += `
{`, u += `
	color = texture2D(uSamplers[` + l + "], vTextureCoord);", u += `
}`;
    return u += `
`, u += `
`, u;
  }
  return generateMultiTextureShader;
}
var checkMaxIfStatmentsInShader = {}, hasRequiredCheckMaxIfStatmentsInShader;
function requireCheckMaxIfStatmentsInShader() {
  if (hasRequiredCheckMaxIfStatmentsInShader) return checkMaxIfStatmentsInShader;
  hasRequiredCheckMaxIfStatmentsInShader = 1, Object.defineProperty(checkMaxIfStatmentsInShader, "__esModule", {
    value: true
  }), checkMaxIfStatmentsInShader.default = e;
  var i2 = ["precision mediump float;", "void main(void){", "float test = 0.1;", "%forloop%", "gl_FragColor = vec4(0.0);", "}"].join(`
`);
  function e(r, a) {
    for (var s = a.createShader(a.FRAGMENT_SHADER); ; ) {
      var u = i2.replace(/%forloop%/gi, t(r));
      if (a.shaderSource(s, u), a.compileShader(s), !a.getShaderParameter(s, a.COMPILE_STATUS))
        r = r / 2 | 0;
      else
        break;
    }
    return r;
  }
  function t(r) {
    for (var a = "", s = 0; s < r; ++s)
      s > 0 && (a += `
else `), s < r - 1 && (a += "if(test == " + s + ".0){}");
    return a;
  }
  return checkMaxIfStatmentsInShader;
}
var BatchBuffer = {}, hasRequiredBatchBuffer;
function requireBatchBuffer() {
  if (hasRequiredBatchBuffer) return BatchBuffer;
  hasRequiredBatchBuffer = 1, Object.defineProperty(BatchBuffer, "__esModule", {
    value: true
  }), BatchBuffer.default = void 0;
  class i2 {
    constructor(t) {
      this.vertices = new ArrayBuffer(t), this.float32View = new Float32Array(this.vertices), this.uint32View = new Uint32Array(this.vertices);
    }
    destroy() {
      this.vertices = null, this.positions = null, this.uvs = null, this.colors = null;
    }
  }
  return BatchBuffer.default = i2, BatchBuffer;
}
var hasRequiredSpriteRenderer;
function requireSpriteRenderer() {
  if (hasRequiredSpriteRenderer) return SpriteRenderer;
  hasRequiredSpriteRenderer = 1, Object.defineProperty(SpriteRenderer, "__esModule", {
    value: true
  }), SpriteRenderer.default = void 0;
  var i2 = f(requireObjectRenderer()), e = f(requireWebGLRenderer()), t = f(requireCreateIndicesForQuads()), r = f(requireGenerateMultiTextureShader()), a = f(requireCheckMaxIfStatmentsInShader()), s = f(requireBatchBuffer()), u = f(requireSettings()), l = requireUtils$3(), c = f(requireSrc$1()), d = f(requireTwiddle$1());
  function f(x) {
    return x && x.__esModule ? x : { default: x };
  }
  var p = 0, m = 0;
  let y = class extends i2.default {
    constructor(x) {
      super(x), this.vertSize = 5, this.vertByteSize = this.vertSize * 4, this.size = u.default.SPRITE_BATCH_SIZE, this.buffers = [];
      for (var g = 1; g <= d.default.nextPow2(this.size); g *= 2)
        this.buffers.push(new s.default(g * 4 * this.vertByteSize));
      this.indices = (0, t.default)(this.size), this.shader = null, this.currentIndex = 0, this.groups = [];
      for (var _ = 0; _ < this.size; _++)
        this.groups[_] = {
          textures: [],
          textureCount: 0,
          ids: [],
          size: 0,
          start: 0,
          blend: 0
        };
      this.sprites = [], this.vertexBuffers = [], this.vaos = [], this.vaoMax = 2, this.vertexCount = 0, this.renderer.on("prerender", this.onPrerender, this);
    }
    /**
     * Sets up the renderer context and necessary buffers.
     *
     * @private
     */
    onContextChange() {
      var x = this.renderer.gl;
      this.renderer.legacy ? this.MAX_TEXTURES = 1 : (this.MAX_TEXTURES = Math.min(x.getParameter(x.MAX_TEXTURE_IMAGE_UNITS), u.default.SPRITE_MAX_TEXTURES), this.MAX_TEXTURES = (0, a.default)(this.MAX_TEXTURES, x)), this.shader = (0, r.default)(x, this.MAX_TEXTURES), this.indexBuffer = c.default.GLBuffer.createIndexBuffer(x, this.indices, x.STATIC_DRAW), this.renderer.bindVao(null);
      for (var g = this.shader.attributes, _ = 0; _ < this.vaoMax; _++) {
        var T = this.vertexBuffers[_] = c.default.GLBuffer.createVertexBuffer(x, null, x.STREAM_DRAW), E = this.renderer.createVao().addIndex(this.indexBuffer).addAttribute(T, g.aVertexPosition, x.FLOAT, false, this.vertByteSize, 0).addAttribute(T, g.aTextureCoord, x.UNSIGNED_SHORT, true, this.vertByteSize, 2 * 4).addAttribute(T, g.aColor, x.UNSIGNED_BYTE, true, this.vertByteSize, 3 * 4);
        g.aTextureId && E.addAttribute(T, g.aTextureId, x.FLOAT, false, this.vertByteSize, 4 * 4), this.vaos[_] = E;
      }
      this.vao = this.vaos[0], this.currentBlendMode = 99999, this.boundTextures = new Array(this.MAX_TEXTURES);
    }
    /**
     * Called before the renderer starts rendering.
     *
     */
    onPrerender() {
      this.vertexCount = 0;
    }
    /**
     * Renders the sprite object.
     *
     * @param {InkPaint.Sprite} sprite - the sprite to render when using this spritebatch
     */
    render(x) {
      this.currentIndex >= this.size && this.flush(), x._texture._uvs && (this.sprites[this.currentIndex++] = x);
    }
    /**
     * Renders the content and empties the current batch.
     *
     */
    flush() {
      if (this.currentIndex !== 0) {
        var x = this.renderer.gl, g = this.MAX_TEXTURES, _ = d.default.nextPow2(this.currentIndex), T = d.default.log2(_), E = this.buffers[T], b = this.sprites, C = this.groups, w = E.float32View, A = E.uint32View, S = this.boundTextures, F = this.renderer.boundTextures, M = this.renderer.textureGC.count, U = 0, B, q, z = 1, D = 0, X = C[0], k, I, P = l.premultiplyBlendMode[b[0]._texture.baseTexture.premultipliedAlpha ? 1 : 0][b[0].blendMode];
        X.textureCount = 0, X.start = 0, X.blend = P, p++;
        var G;
        for (G = 0; G < g; ++G) {
          var W = F[G];
          if (W._enabled === p) {
            S[G] = this.renderer.emptyTextures[G];
            continue;
          }
          S[G] = W, W._virtalBoundId = G, W._enabled = p;
        }
        for (p++, G = 0; G < this.currentIndex; ++G) {
          var V = b[G];
          b[G] = null, B = V._texture.baseTexture;
          var K = l.premultiplyBlendMode[Number(B.premultipliedAlpha)][V.blendMode];
          if (P !== K && (P = K, q = null, D = g, p++), q !== B && (q = B, B._enabled !== p)) {
            if (D === g && (p++, X.size = G - X.start, D = 0, X = C[z++], X.blend = P, X.textureCount = 0, X.start = G), B.touched = M, B._virtalBoundId === -1)
              for (var J = 0; J < g; ++J) {
                var ae = (J + m) % g, re = S[ae];
                if (re._enabled !== p) {
                  m++, re._virtalBoundId = -1, B._virtalBoundId = ae, S[ae] = B;
                  break;
                }
              }
            B._enabled = p, X.textureCount++, X.ids[D] = B._virtalBoundId, X.textures[D++] = B;
          }
          if (k = V.vertexData, I = V._texture._uvs.uvsUint32, this.renderer.roundPixels) {
            var he = this.renderer.resolution;
            w[U] = (k[0] * he | 0) / he, w[U + 1] = (k[1] * he | 0) / he, w[U + 5] = (k[2] * he | 0) / he, w[U + 6] = (k[3] * he | 0) / he, w[U + 10] = (k[4] * he | 0) / he, w[U + 11] = (k[5] * he | 0) / he, w[U + 15] = (k[6] * he | 0) / he, w[U + 16] = (k[7] * he | 0) / he;
          } else
            w[U] = k[0], w[U + 1] = k[1], w[U + 5] = k[2], w[U + 6] = k[3], w[U + 10] = k[4], w[U + 11] = k[5], w[U + 15] = k[6], w[U + 16] = k[7];
          A[U + 2] = I[0], A[U + 7] = I[1], A[U + 12] = I[2], A[U + 17] = I[3];
          var ge = Math.min(V.worldAlpha, 1), me = ge < 1 && B.premultipliedAlpha ? (0, l.premultiplyTint)(V._tintRGB, ge) : V._tintRGB + (ge * 255 << 24);
          A[U + 3] = A[U + 8] = A[U + 13] = A[U + 18] = me, w[U + 4] = w[U + 9] = w[U + 14] = w[U + 19] = B._virtalBoundId, U += 20;
        }
        if (X.size = G - X.start, u.default.CAN_UPLOAD_SAME_BUFFER)
          this.vertexBuffers[this.vertexCount].upload(E.vertices, 0, true);
        else {
          if (this.vaoMax <= this.vertexCount) {
            this.vaoMax++;
            var Te = this.shader.attributes, _e = this.vertexBuffers[this.vertexCount] = c.default.GLBuffer.createVertexBuffer(x, null, x.STREAM_DRAW), ye = this.renderer.createVao().addIndex(this.indexBuffer).addAttribute(_e, Te.aVertexPosition, x.FLOAT, false, this.vertByteSize, 0).addAttribute(_e, Te.aTextureCoord, x.UNSIGNED_SHORT, true, this.vertByteSize, 2 * 4).addAttribute(_e, Te.aColor, x.UNSIGNED_BYTE, true, this.vertByteSize, 3 * 4);
            Te.aTextureId && ye.addAttribute(_e, Te.aTextureId, x.FLOAT, false, this.vertByteSize, 4 * 4), this.vaos[this.vertexCount] = ye;
          }
          this.renderer.bindVao(this.vaos[this.vertexCount]), this.vertexBuffers[this.vertexCount].upload(E.vertices, 0, false), this.vertexCount++;
        }
        for (G = 0; G < g; ++G)
          F[G]._virtalBoundId = -1;
        for (G = 0; G < z; ++G) {
          for (var Ae = C[G], ke = Ae.textureCount, Pe = 0; Pe < ke; Pe++)
            q = Ae.textures[Pe], F[Ae.ids[Pe]] !== q && this.renderer.bindTexture(q, Ae.ids[Pe], true), q._virtalBoundId = -1;
          this.renderer.state.setBlendMode(Ae.blend), x.drawElements(x.TRIANGLES, Ae.size * 6, x.UNSIGNED_SHORT, Ae.start * 6 * 2);
        }
        this.currentIndex = 0;
      }
    }
    /**
     * Starts a new sprite batch.
     */
    start() {
      this.renderer.bindShader(this.shader), u.default.CAN_UPLOAD_SAME_BUFFER && (this.renderer.bindVao(this.vaos[this.vertexCount]), this.vertexBuffers[this.vertexCount].bind());
    }
    /**
     * Stops and flushes the current batch.
     *
     */
    stop() {
      this.flush();
    }
    /**
     * Destroys the SpriteRenderer.
     *
     */
    destroy() {
      for (var x = 0; x < this.vaoMax; x++)
        this.vertexBuffers[x] && this.vertexBuffers[x].destroy(), this.vaos[x] && this.vaos[x].destroy();
      this.indexBuffer && this.indexBuffer.destroy(), this.renderer.off("prerender", this.onPrerender, this), super.destroy(), this.shader && (this.shader.destroy(), this.shader = null), this.vertexBuffers = null, this.vaos = null, this.indexBuffer = null, this.indices = null, this.sprites = null;
      for (var g = 0; g < this.buffers.length; ++g)
        this.buffers[g].destroy();
    }
  };
  return SpriteRenderer.default = y, e.default.registerPlugin("sprite", y), SpriteRenderer;
}
var Text = {}, TextStyle = {}, hasRequiredTextStyle;
function requireTextStyle() {
  if (hasRequiredTextStyle) return TextStyle;
  hasRequiredTextStyle = 1, Object.defineProperty(TextStyle, "__esModule", {
    value: true
  }), TextStyle.default = void 0;
  var i2 = require_const(), e = requireUtils$3(), t = {
    align: "left",
    breakWords: false,
    dropShadow: false,
    dropShadowAlpha: 1,
    dropShadowAngle: Math.PI / 6,
    dropShadowBlur: 0,
    dropShadowColor: "black",
    dropShadowDistance: 5,
    fill: "black",
    fillGradientType: i2.TEXT_GRADIENT.LINEAR_VERTICAL,
    fillGradientStops: [],
    fontFamily: ["Helvetica", "Arial", "sans-serif"],
    //
    fontSize: 26,
    fontStyle: "normal",
    fontVariant: "normal",
    fontWeight: "normal",
    letterSpacing: 0,
    lineHeight: 0,
    lineJoin: "miter",
    miterLimit: 10,
    padding: 0,
    stroke: "black",
    strokeThickness: 0,
    textBaseline: "alphabetic",
    trim: false,
    whiteSpace: "pre",
    wordWrap: false,
    wordWrapWidth: 100,
    leading: 0
  }, r = ["serif", "sans-serif", "monospace", "cursive", "fantasy", "system-ui"];
  let a = class Dm {
    constructor(f) {
      this.styleID = 0, this.reset(), c(this, f, f);
    }
    clone() {
      var f = {};
      return c(f, this, t), new Dm(f);
    }
    reset() {
      c(this, t, t);
    }
    get align() {
      return this._align;
    }
    set align(f) {
      this._align !== f && (this._align = f, this.styleID++);
    }
    get breakWords() {
      return this._breakWords;
    }
    set breakWords(f) {
      this._breakWords !== f && (this._breakWords = f, this.styleID++);
    }
    get dropShadow() {
      return this._dropShadow;
    }
    set dropShadow(f) {
      this._dropShadow !== f && (this._dropShadow = f, this.styleID++);
    }
    get dropShadowAlpha() {
      return this._dropShadowAlpha;
    }
    set dropShadowAlpha(f) {
      this._dropShadowAlpha !== f && (this._dropShadowAlpha = f, this.styleID++);
    }
    get dropShadowAngle() {
      return this._dropShadowAngle;
    }
    set dropShadowAngle(f) {
      this._dropShadowAngle !== f && (this._dropShadowAngle = f, this.styleID++);
    }
    get dropShadowBlur() {
      return this._dropShadowBlur;
    }
    set dropShadowBlur(f) {
      this._dropShadowBlur !== f && (this._dropShadowBlur = f, this.styleID++);
    }
    get dropShadowColor() {
      return this._dropShadowColor;
    }
    set dropShadowColor(f) {
      var p = u(f);
      this._dropShadowColor !== p && (this._dropShadowColor = p, this.styleID++);
    }
    get dropShadowDistance() {
      return this._dropShadowDistance;
    }
    set dropShadowDistance(f) {
      this._dropShadowDistance !== f && (this._dropShadowDistance = f, this.styleID++);
    }
    get fill() {
      return this._fill;
    }
    set fill(f) {
      var p = u(f);
      this._fill !== p && (this._fill = p, this.styleID++);
    }
    get fillGradientType() {
      return this._fillGradientType;
    }
    set fillGradientType(f) {
      this._fillGradientType !== f && (this._fillGradientType = f, this.styleID++);
    }
    get fillGradientStops() {
      return this._fillGradientStops;
    }
    set fillGradientStops(f) {
      l(this._fillGradientStops, f) || (this._fillGradientStops = f, this.styleID++);
    }
    get fontFamily() {
      return this._fontFamily;
    }
    set fontFamily(f) {
      this.fontFamily !== f && (this._fontFamily = f, this.styleID++);
    }
    get fontSize() {
      return this._fontSize;
    }
    set fontSize(f) {
      this._fontSize !== f && (this._fontSize = f, this.styleID++);
    }
    get fontStyle() {
      return this._fontStyle;
    }
    set fontStyle(f) {
      this._fontStyle !== f && (this._fontStyle = f, this.styleID++);
    }
    get fontVariant() {
      return this._fontVariant;
    }
    set fontVariant(f) {
      this._fontVariant !== f && (this._fontVariant = f, this.styleID++);
    }
    get fontWeight() {
      return this._fontWeight;
    }
    set fontWeight(f) {
      this._fontWeight !== f && (this._fontWeight = f, this.styleID++);
    }
    get letterSpacing() {
      return this._letterSpacing;
    }
    set letterSpacing(f) {
      this._letterSpacing !== f && (this._letterSpacing = f, this.styleID++);
    }
    get lineHeight() {
      return this._lineHeight;
    }
    set lineHeight(f) {
      this._lineHeight !== f && (this._lineHeight = f, this.styleID++);
    }
    get leading() {
      return this._leading;
    }
    set leading(f) {
      this._leading !== f && (this._leading = f, this.styleID++);
    }
    get lineJoin() {
      return this._lineJoin;
    }
    set lineJoin(f) {
      this._lineJoin !== f && (this._lineJoin = f, this.styleID++);
    }
    get miterLimit() {
      return this._miterLimit;
    }
    set miterLimit(f) {
      this._miterLimit !== f && (this._miterLimit = f, this.styleID++);
    }
    get padding() {
      return this._padding;
    }
    set padding(f) {
      this._padding !== f && (this._padding = f, this.styleID++);
    }
    get stroke() {
      return this._stroke;
    }
    set stroke(f) {
      var p = u(f);
      this._stroke !== p && (this._stroke = p, this.styleID++);
    }
    get strokeThickness() {
      return this._strokeThickness;
    }
    set strokeThickness(f) {
      this._strokeThickness !== f && (this._strokeThickness = f, this.styleID++);
    }
    get textBaseline() {
      return this._textBaseline;
    }
    set textBaseline(f) {
      this._textBaseline !== f && (this._textBaseline = f, this.styleID++);
    }
    get trim() {
      return this._trim;
    }
    set trim(f) {
      this._trim !== f && (this._trim = f, this.styleID++);
    }
    get whiteSpace() {
      return this._whiteSpace;
    }
    set whiteSpace(f) {
      this._whiteSpace !== f && (this._whiteSpace = f, this.styleID++);
    }
    get wordWrap() {
      return this._wordWrap;
    }
    set wordWrap(f) {
      this._wordWrap !== f && (this._wordWrap = f, this.styleID++);
    }
    get wordWrapWidth() {
      return this._wordWrapWidth;
    }
    set wordWrapWidth(f) {
      this._wordWrapWidth !== f && (this._wordWrapWidth = f, this.styleID++);
    }
    toFontString() {
      var f = typeof this.fontSize == "number" ? this.fontSize + "px" : this.fontSize, p = this.fontFamily;
      Array.isArray(this.fontFamily) || (p = this.fontFamily.split(","));
      for (var m = p.length - 1; m >= 0; m--) {
        var y = p[m].trim();
        !/([\"\'])[^\'\"]+\1/.test(y) && r.indexOf(y) < 0 && (y = '"' + y + '"'), p[m] = y;
      }
      return this.fontStyle + " " + this.fontVariant + " " + this.fontWeight + " " + f + " " + p.join(",");
    }
  };
  TextStyle.default = a;
  function s(d) {
    return typeof d == "number" ? (0, e.hex2string)(d) : (typeof d == "string" && d.indexOf("0x") === 0 && (d = d.replace("0x", "#")), d);
  }
  function u(d) {
    if (!Array.isArray(d)) return s(d);
    for (var f = 0; f < d.length; ++f)
      d[f] = s(d[f]);
    return d;
  }
  function l(d, f) {
    if (!Array.isArray(d) || !Array.isArray(f) || d.length !== f.length)
      return false;
    for (var p = 0; p < d.length; ++p)
      if (d[p] !== f[p])
        return false;
    return true;
  }
  function c(d, f, p) {
    for (var m in p)
      Array.isArray(f[m]) ? d[m] = f[m].slice() : d[m] = f[m];
  }
  return TextStyle;
}
var TextMetrics = {}, hasRequiredTextMetrics;
function requireTextMetrics() {
  if (hasRequiredTextMetrics) return TextMetrics;
  hasRequiredTextMetrics = 1, Object.defineProperty(TextMetrics, "__esModule", {
    value: true
  }), TextMetrics.default = void 0;
  var i2 = e(requireDoc());
  function e(a) {
    return a && a.__esModule ? a : { default: a };
  }
  let t = class qt {
    constructor(s, u, l, c, d, f, p, m, y) {
      this.text = s, this.style = u, this.width = l, this.height = c, this.lines = d, this.lineWidths = f, this.lineHeight = p, this.maxLineWidth = m, this.fontProperties = y;
    }
    static measureText(s, u, l, c) {
      c === void 0 && (c = qt._canvas), l = l ?? u.wordWrap;
      var d = u.toFontString(), f = qt.measureFont(d), p = c.getContext("2d");
      p.font = d;
      var m;
      l ? m = qt.wordWrap(s, u, c) : m = s.split(/(?:\r\n|\r|\n)/).map((F) => F + `
`);
      var y = 0, x = m[m.length - 1];
      x.endsWith(`
`) && (y = -1);
      var g = Array.from(s).length;
      m.map((F) => y += Array.from(F).length), g !== y && console.error("text parse err!!!", {
        before: g,
        after: y
      }, m);
      for (var _ = new Array(m.length), T = 0, E = 0; E < m.length; E++) {
        var b = m[E];
        b.endsWith(`
`) && (b = b.substring(0, b.length - 1));
        var C = p.measureText(b).width + (Array.from(b).length - 1) * u.letterSpacing;
        _[E] = C, T = Math.max(T, C);
      }
      var w = T + u.strokeThickness;
      u.dropShadow && (w += u.dropShadowDistance);
      var A = u.lineHeight || f.fontSize + u.strokeThickness, S = Math.max(A, f.fontSize + u.strokeThickness) + (m.length - 1) * (A + u.leading);
      return u.dropShadow && (S += u.dropShadowDistance), new qt(s, u, w, S, m, _, A + u.leading, T, f);
    }
    static wordWrap(s, u, l) {
      l === void 0 && (l = qt._canvas);
      for (var c = l.getContext("2d"), d = 0, f = "", p = [], m = {}, {
        letterSpacing: y,
        whiteSpace: x
      } = u, g = qt.collapseSpaces(x), _ = qt.collapseNewlines(x), T = !g, E = u.wordWrapWidth + y, b = qt.tokenize(s), C = 0; C < b.length; C++) {
        var w = b[C];
        if (qt.isNewline(w)) {
          if (!_) {
            p.push(qt.addLine(f, "T0")), T = !g, f = "", d = 0;
            continue;
          }
          w = " ";
        }
        if (g) {
          var A = qt.isBreakingSpace(w), S = qt.isBreakingSpace(f[f.length - 1]);
          if (A && S)
            continue;
        }
        var F = qt.getFromCache(w, y, m, c);
        if (F > E)
          if (f !== "" && (p.push(qt.addLine(f, "T1", false)), f = "", d = 0), qt.canBreakWords(w, u.breakWords))
            for (var M = Array.from(w), U = 0; U < M.length; U++) {
              for (var B = M[U], q = 1; M[U + q]; ) {
                var z = M[U + q], D = B[B.length - 1];
                if (!qt.canBreakChars(D, z, w, U, u.breakWords))
                  B += z;
                else
                  break;
                q++, U++;
              }
              var X = qt.getFromCache(B, y, m, c);
              X + d > E && (p.push(qt.addLine(f, "T2", false)), T = false, f = "", d = 0), f += B, d += X;
            }
          else {
            f.length > 0 && (p.push(qt.addLine(f, "T3", false)), f = "", d = 0);
            var k = C === b.length - 1;
            p.push(qt.addLine(w, "T4", k)), T = false, f = "", d = 0;
          }
        else {
          if (F + d > E) {
            for (T = false; qt.isBreakingSpace(w); )
              if (f += w, w = b[++C], w === void 0) {
                w = "";
                break;
              }
            p.push(qt.addLine(f, "T5", false)), f = "", d = 0;
          }
          (f.length > 0 || !qt.isBreakingSpace(w) || T) && (f += w, d += F);
        }
      }
      p.push(qt.addLine(f, "T6"));
      for (var I = 0; I < p.length - 1; I++)
        p[I].endsWith(`
`) || p[I + 1] !== `
` || (p[I] += p[I + 1], p[I + 1] = "");
      return p.filter((P) => P.length > 0);
    }
    static addLine(s, u, l) {
      return l === void 0 && (l = true), s = l ? s + `
` : s, s;
    }
    static getFromCache(s, u, l, c) {
      var d = l[s];
      if (d === void 0) {
        var f = s.length * u;
        d = c.measureText(s).width + f, l[s] = d;
      }
      return d;
    }
    static collapseSpaces(s) {
      return s === "normal" || s === "pre-line";
    }
    static collapseNewlines(s) {
      return s === "normal";
    }
    static trimRight(s) {
      if (typeof s != "string")
        return "";
      for (var u = s.length - 1; u >= 0; u--) {
        var l = s[u];
        if (!qt.isBreakingSpace(l))
          break;
        s = s.slice(0, -1);
      }
      return s;
    }
    static isNewline(s) {
      return typeof s != "string" ? false : qt._newlines.indexOf(s.charCodeAt(0)) >= 0;
    }
    static isBreakingSpace(s) {
      return typeof s != "string" ? false : qt._breakingSpaces.indexOf(s.charCodeAt(0)) >= 0;
    }
    static tokenize(s) {
      var u = [], l = "";
      if (typeof s != "string")
        return u;
      for (var c = 0; c < s.length; c++) {
        var d = s[c];
        if (qt.isBreakingSpace(d) || qt.isNewline(d)) {
          l !== "" && (u.push(l), l = ""), u.push(d);
          continue;
        }
        l += d;
      }
      return l !== "" && u.push(l), u;
    }
    static canBreakWords(s, u) {
      return u;
    }
    static canBreakChars(s, u, l, c, d) {
      return true;
    }
    static measureFont(s) {
      if (qt._fonts[s])
        return qt._fonts[s];
      var u = {}, l = qt._canvas, c = qt._context;
      c.font = s;
      var d = qt.METRICS_STRING + qt.BASELINE_SYMBOL, f = Math.ceil(c.measureText(d).width), p = Math.ceil(c.measureText(qt.BASELINE_SYMBOL).width), m = 2 * p;
      p = p * qt.BASELINE_MULTIPLIER | 0, l.width = f, l.height = m, c.fillStyle = "#f00", c.fillRect(0, 0, f, m), c.font = s, c.textBaseline = "alphabetic", c.fillStyle = "#000", c.fillText(d, 0, p);
      var y = c.getImageData(0, 0, f, m).data, x = y.length, g = f * 4, _ = 0, T = 0, E = false;
      for (_ = 0; _ < p; ++_) {
        for (var b = 0; b < g; b += 4)
          if (y[T + b] !== 255) {
            E = true;
            break;
          }
        if (!E)
          T += g;
        else
          break;
      }
      for (u.ascent = p - _, T = x - g, E = false, _ = m; _ > p; --_) {
        for (var C = 0; C < g; C += 4)
          if (y[T + C] !== 255) {
            E = true;
            break;
          }
        if (!E)
          T -= g;
        else
          break;
      }
      return u.descent = _ - p, u.fontSize = u.ascent + u.descent, qt._fonts[s] = u, u;
    }
    static clearMetrics(s) {
      s === void 0 && (s = ""), s ? delete qt._fonts[s] : qt._fonts = {};
    }
  };
  TextMetrics.default = t;
  var r = i2.default.createElement("canvas");
  return r.width = r.height = 10, t._canvas = r, t._context = r.getContext("2d"), t._fonts = {}, t.METRICS_STRING = "|Éq", t.BASELINE_SYMBOL = "M", t.BASELINE_MULTIPLIER = 1.4, t._newlines = [
    10,
    // line feed
    13
    // carriage return
  ], t._breakingSpaces = [
    9,
    // character tabulation
    32,
    // space
    8192,
    // en quad
    8193,
    // em quad
    8194,
    // en space
    8195,
    // em space
    8196,
    // three-per-em space
    8197,
    // four-per-em space
    8198,
    // six-per-em space
    8200,
    // punctuation space
    8201,
    // thin space
    8202,
    // hair space
    8287,
    // medium mathematical space
    12288
    // ideographic space
  ], TextMetrics;
}
var trimCanvas = {}, hasRequiredTrimCanvas;
function requireTrimCanvas() {
  if (hasRequiredTrimCanvas) return trimCanvas;
  hasRequiredTrimCanvas = 1, Object.defineProperty(trimCanvas, "__esModule", {
    value: true
  }), trimCanvas.default = i2;
  function i2(e) {
    var t = e.width, r = e.height, a = e.getContext("2d"), s = a.getImageData(0, 0, t, r), u = s.data, l = u.length, c = {
      top: null,
      left: null,
      right: null,
      bottom: null
    }, d = null, f, p, m;
    for (f = 0; f < l; f += 4)
      u[f + 3] !== 0 && (p = f / 4 % t, m = ~~(f / 4 / t), c.top === null && (c.top = m), (c.left === null || p < c.left) && (c.left = p), (c.right === null || c.right < p) && (c.right = p + 1), (c.bottom === null || c.bottom < m) && (c.bottom = m));
    return c.top !== null && (t = c.right - c.left, r = c.bottom - c.top + 1, d = a.getImageData(c.left, c.top, t, r)), {
      height: r,
      width: t,
      data: d
    };
  }
  return trimCanvas;
}
var lodash$3 = { exports: {} };
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
var lodash$2 = lodash$3.exports, hasRequiredLodash$1;
function requireLodash$1() {
  return hasRequiredLodash$1 || (hasRequiredLodash$1 = 1, function(i2, e) {
    (function() {
      var t, r = "4.17.21", a = 200, s = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", u = "Expected a function", l = "Invalid `variable` option passed into `_.template`", c = "__lodash_hash_undefined__", d = 500, f = "__lodash_placeholder__", p = 1, m = 2, y = 4, x = 1, g = 2, _ = 1, T = 2, E = 4, b = 8, C = 16, w = 32, A = 64, S = 128, F = 256, M = 512, U = 30, B = "...", q = 800, z = 16, D = 1, X = 2, k = 3, I = 1 / 0, P = 9007199254740991, G = 17976931348623157e292, W = NaN, V = 4294967295, K = V - 1, J = V >>> 1, ae = [
        ["ary", S],
        ["bind", _],
        ["bindKey", T],
        ["curry", b],
        ["curryRight", C],
        ["flip", M],
        ["partial", w],
        ["partialRight", A],
        ["rearg", F]
      ], re = "[object Arguments]", he = "[object Array]", ge = "[object AsyncFunction]", me = "[object Boolean]", Te = "[object Date]", _e = "[object DOMException]", ye = "[object Error]", Ae = "[object Function]", ke = "[object GeneratorFunction]", Pe = "[object Map]", Ee = "[object Number]", Oe = "[object Null]", $e = "[object Object]", gt = "[object Promise]", xt = "[object Proxy]", vt = "[object RegExp]", Xe = "[object Set]", at = "[object String]", ct = "[object Symbol]", Rt = "[object Undefined]", It = "[object WeakMap]", er = "[object WeakSet]", $ = "[object ArrayBuffer]", Y = "[object DataView]", ee = "[object Float32Array]", be = "[object Float64Array]", Se = "[object Int8Array]", Ne = "[object Int16Array]", je = "[object Int32Array]", pt = "[object Uint8Array]", oe = "[object Uint8ClampedArray]", le = "[object Uint16Array]", Ue = "[object Uint32Array]", et = /\b__p \+= '';/g, lt = /\b(__p \+=) '' \+/g, We = /(__e\(.*?\)|\b__t\)) \+\n'';/g, te = /&(?:amp|lt|gt|quot|#39);/g, ne = /[&<>"']/g, fe = RegExp(te.source), qe = RegExp(ne.source), Je = /<%-([\s\S]+?)%>/g, ht = /<%([\s\S]+?)%>/g, bt = /<%=([\s\S]+?)%>/g, kt = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, Ar = /^\w*$/, Sr = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, Vt = /[\\^$.*+?()[\]{}|]/g, jr = RegExp(Vt.source), tr = /^\s+/, _r = /\s/, wr = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, xr = /\{\n\/\* \[wrapped with (.+)\] \*/, Mr = /,? & /, Or = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g, hi = /[()=,{}\[\]\/\s]/, Rr = /\\(\\)?/g, ci = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g, Ri = /\w*$/, fi = /^[-+]0x[0-9a-f]+$/i, Ir = /^0b[01]+$/i, Zr = /^\[object .+?Constructor\]$/, Xi = /^0o[0-7]+$/i, Ai = /^(?:0|[1-9]\d*)$/, rs = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, Mi = /($^)/, Ja = /['\n\r\u2028\u2029\\]/g, Qr = "\\ud800-\\udfff", Za = "\\u0300-\\u036f", Vi = "\\ufe20-\\ufe2f", is = "\\u20d0-\\u20ff", Hi = Za + Vi + is, Yi = "\\u2700-\\u27bf", Bn = "a-z\\xdf-\\xf6\\xf8-\\xff", ns = "\\xac\\xb1\\xd7\\xf7", $n = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", as = "\\u2000-\\u206f", ss = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", ue = "A-Z\\xc0-\\xd6\\xd8-\\xde", de = "\\ufe0e\\ufe0f", pe = ns + $n + as + ss, Me = "['’]", Re = "[" + Qr + "]", Ie = "[" + pe + "]", Fe = "[" + Hi + "]", ze = "\\d+", Ze = "[" + Yi + "]", Ke = "[" + Bn + "]", Ye = "[^" + Qr + pe + ze + Yi + Bn + ue + "]", dt = "\\ud83c[\\udffb-\\udfff]", Pt = "(?:" + Fe + "|" + dt + ")", Ut = "[^" + Qr + "]", Dt = "(?:\\ud83c[\\udde6-\\uddff]){2}", Qt = "[\\ud800-\\udbff][\\udc00-\\udfff]", Ft = "[" + ue + "]", Ur = "\\u200d", Ki = "(?:" + Ke + "|" + Ye + ")", jn = "(?:" + Ft + "|" + Ye + ")", Un = "(?:" + Me + "(?:d|ll|m|re|s|t|ve))?", Gn = "(?:" + Me + "(?:D|LL|M|RE|S|T|VE))?", Dn = Pt + "?", os = "[" + de + "]?", Ru = "(?:" + Ur + "(?:" + [Ut, Dt, Qt].join("|") + ")" + os + Dn + ")*", Au = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", Mu = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", us = os + Dn + Ru, Ou = "(?:" + [Ze, Dt, Qt].join("|") + ")" + us, Iu = "(?:" + [Ut + Fe + "?", Fe, Dt, Qt, Re].join("|") + ")", Pu = RegExp(Me, "g"), qu = RegExp(Fe, "g"), zn = RegExp(dt + "(?=" + dt + ")|" + Iu + us, "g"), ku = RegExp([
        Ft + "?" + Ke + "+" + Un + "(?=" + [Ie, Ft, "$"].join("|") + ")",
        jn + "+" + Gn + "(?=" + [Ie, Ft + Ki, "$"].join("|") + ")",
        Ft + "?" + Ki + "+" + Un,
        Ft + "+" + Gn,
        Mu,
        Au,
        ze,
        Ou
      ].join("|"), "g"), Lu = RegExp("[" + Ur + Qr + Hi + de + "]"), Nu = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/, Du = [
        "Array",
        "Buffer",
        "DataView",
        "Date",
        "Error",
        "Float32Array",
        "Float64Array",
        "Function",
        "Int8Array",
        "Int16Array",
        "Int32Array",
        "Map",
        "Math",
        "Object",
        "Promise",
        "RegExp",
        "Set",
        "String",
        "Symbol",
        "TypeError",
        "Uint8Array",
        "Uint8ClampedArray",
        "Uint16Array",
        "Uint32Array",
        "WeakMap",
        "_",
        "clearTimeout",
        "isFinite",
        "parseInt",
        "setTimeout"
      ], Fu = -1, Et = {};
      Et[ee] = Et[be] = Et[Se] = Et[Ne] = Et[je] = Et[pt] = Et[oe] = Et[le] = Et[Ue] = true, Et[re] = Et[he] = Et[$] = Et[me] = Et[Y] = Et[Te] = Et[ye] = Et[Ae] = Et[Pe] = Et[Ee] = Et[$e] = Et[vt] = Et[Xe] = Et[at] = Et[It] = false;
      var wt = {};
      wt[re] = wt[he] = wt[$] = wt[Y] = wt[me] = wt[Te] = wt[ee] = wt[be] = wt[Se] = wt[Ne] = wt[je] = wt[Pe] = wt[Ee] = wt[$e] = wt[vt] = wt[Xe] = wt[at] = wt[ct] = wt[pt] = wt[oe] = wt[le] = wt[Ue] = true, wt[ye] = wt[Ae] = wt[It] = false;
      var Bu = {
        // Latin-1 Supplement block.
        À: "A",
        Á: "A",
        Â: "A",
        Ã: "A",
        Ä: "A",
        Å: "A",
        à: "a",
        á: "a",
        â: "a",
        ã: "a",
        ä: "a",
        å: "a",
        Ç: "C",
        ç: "c",
        Ð: "D",
        ð: "d",
        È: "E",
        É: "E",
        Ê: "E",
        Ë: "E",
        è: "e",
        é: "e",
        ê: "e",
        ë: "e",
        Ì: "I",
        Í: "I",
        Î: "I",
        Ï: "I",
        ì: "i",
        í: "i",
        î: "i",
        ï: "i",
        Ñ: "N",
        ñ: "n",
        Ò: "O",
        Ó: "O",
        Ô: "O",
        Õ: "O",
        Ö: "O",
        Ø: "O",
        ò: "o",
        ó: "o",
        ô: "o",
        õ: "o",
        ö: "o",
        ø: "o",
        Ù: "U",
        Ú: "U",
        Û: "U",
        Ü: "U",
        ù: "u",
        ú: "u",
        û: "u",
        ü: "u",
        Ý: "Y",
        ý: "y",
        ÿ: "y",
        Æ: "Ae",
        æ: "ae",
        Þ: "Th",
        þ: "th",
        ß: "ss",
        // Latin Extended-A block.
        Ā: "A",
        Ă: "A",
        Ą: "A",
        ā: "a",
        ă: "a",
        ą: "a",
        Ć: "C",
        Ĉ: "C",
        Ċ: "C",
        Č: "C",
        ć: "c",
        ĉ: "c",
        ċ: "c",
        č: "c",
        Ď: "D",
        Đ: "D",
        ď: "d",
        đ: "d",
        Ē: "E",
        Ĕ: "E",
        Ė: "E",
        Ę: "E",
        Ě: "E",
        ē: "e",
        ĕ: "e",
        ė: "e",
        ę: "e",
        ě: "e",
        Ĝ: "G",
        Ğ: "G",
        Ġ: "G",
        Ģ: "G",
        ĝ: "g",
        ğ: "g",
        ġ: "g",
        ģ: "g",
        Ĥ: "H",
        Ħ: "H",
        ĥ: "h",
        ħ: "h",
        Ĩ: "I",
        Ī: "I",
        Ĭ: "I",
        Į: "I",
        İ: "I",
        ĩ: "i",
        ī: "i",
        ĭ: "i",
        į: "i",
        ı: "i",
        Ĵ: "J",
        ĵ: "j",
        Ķ: "K",
        ķ: "k",
        ĸ: "k",
        Ĺ: "L",
        Ļ: "L",
        Ľ: "L",
        Ŀ: "L",
        Ł: "L",
        ĺ: "l",
        ļ: "l",
        ľ: "l",
        ŀ: "l",
        ł: "l",
        Ń: "N",
        Ņ: "N",
        Ň: "N",
        Ŋ: "N",
        ń: "n",
        ņ: "n",
        ň: "n",
        ŋ: "n",
        Ō: "O",
        Ŏ: "O",
        Ő: "O",
        ō: "o",
        ŏ: "o",
        ő: "o",
        Ŕ: "R",
        Ŗ: "R",
        Ř: "R",
        ŕ: "r",
        ŗ: "r",
        ř: "r",
        Ś: "S",
        Ŝ: "S",
        Ş: "S",
        Š: "S",
        ś: "s",
        ŝ: "s",
        ş: "s",
        š: "s",
        Ţ: "T",
        Ť: "T",
        Ŧ: "T",
        ţ: "t",
        ť: "t",
        ŧ: "t",
        Ũ: "U",
        Ū: "U",
        Ŭ: "U",
        Ů: "U",
        Ű: "U",
        Ų: "U",
        ũ: "u",
        ū: "u",
        ŭ: "u",
        ů: "u",
        ű: "u",
        ų: "u",
        Ŵ: "W",
        ŵ: "w",
        Ŷ: "Y",
        ŷ: "y",
        Ÿ: "Y",
        Ź: "Z",
        Ż: "Z",
        Ž: "Z",
        ź: "z",
        ż: "z",
        ž: "z",
        Ĳ: "IJ",
        ĳ: "ij",
        Œ: "Oe",
        œ: "oe",
        ŉ: "'n",
        ſ: "s"
      }, $u = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;"
      }, ju = {
        "&amp;": "&",
        "&lt;": "<",
        "&gt;": ">",
        "&quot;": '"',
        "&#39;": "'"
      }, Uu = {
        "\\": "\\",
        "'": "'",
        "\n": "n",
        "\r": "r",
        "\u2028": "u2028",
        "\u2029": "u2029"
      }, Gu = parseFloat, zu = parseInt, ls = typeof window == "object" && window && window.Object === Object && window, Vu = typeof self == "object" && self && self.Object === Object && self, $t = ls || Vu || Function("return this")(), Vn = e && !e.nodeType && e, ei = Vn && true && i2 && !i2.nodeType && i2, hs = ei && ei.exports === Vn, Hn = hs && ls.process, ur = function() {
        try {
          var ie = ei && ei.require && ei.require("util").types;
          return ie || Hn && Hn.binding && Hn.binding("util");
        } catch {
        }
      }(), cs = ur && ur.isArrayBuffer, fs = ur && ur.isDate, ds = ur && ur.isMap, ps = ur && ur.isRegExp, ms = ur && ur.isSet, vs = ur && ur.isTypedArray;
      function rr(ie, ve, ce) {
        switch (ce.length) {
          case 0:
            return ie.call(ve);
          case 1:
            return ie.call(ve, ce[0]);
          case 2:
            return ie.call(ve, ce[0], ce[1]);
          case 3:
            return ie.call(ve, ce[0], ce[1], ce[2]);
        }
        return ie.apply(ve, ce);
      }
      function Hu(ie, ve, ce, De) {
        for (var Qe = -1, ft = ie == null ? 0 : ie.length; ++Qe < ft; ) {
          var Lt = ie[Qe];
          ve(De, Lt, ce(Lt), ie);
        }
        return De;
      }
      function lr(ie, ve) {
        for (var ce = -1, De = ie == null ? 0 : ie.length; ++ce < De && ve(ie[ce], ce, ie) !== false; )
          ;
        return ie;
      }
      function Wu(ie, ve) {
        for (var ce = ie == null ? 0 : ie.length; ce-- && ve(ie[ce], ce, ie) !== false; )
          ;
        return ie;
      }
      function gs(ie, ve) {
        for (var ce = -1, De = ie == null ? 0 : ie.length; ++ce < De; )
          if (!ve(ie[ce], ce, ie))
            return false;
        return true;
      }
      function Gr(ie, ve) {
        for (var ce = -1, De = ie == null ? 0 : ie.length, Qe = 0, ft = []; ++ce < De; ) {
          var Lt = ie[ce];
          ve(Lt, ce, ie) && (ft[Qe++] = Lt);
        }
        return ft;
      }
      function Ji(ie, ve) {
        var ce = ie == null ? 0 : ie.length;
        return !!ce && di(ie, ve, 0) > -1;
      }
      function Wn(ie, ve, ce) {
        for (var De = -1, Qe = ie == null ? 0 : ie.length; ++De < Qe; )
          if (ce(ve, ie[De]))
            return true;
        return false;
      }
      function Tt(ie, ve) {
        for (var ce = -1, De = ie == null ? 0 : ie.length, Qe = Array(De); ++ce < De; )
          Qe[ce] = ve(ie[ce], ce, ie);
        return Qe;
      }
      function zr(ie, ve) {
        for (var ce = -1, De = ve.length, Qe = ie.length; ++ce < De; )
          ie[Qe + ce] = ve[ce];
        return ie;
      }
      function Xn(ie, ve, ce, De) {
        var Qe = -1, ft = ie == null ? 0 : ie.length;
        for (De && ft && (ce = ie[++Qe]); ++Qe < ft; )
          ce = ve(ce, ie[Qe], Qe, ie);
        return ce;
      }
      function Xu(ie, ve, ce, De) {
        var Qe = ie == null ? 0 : ie.length;
        for (De && Qe && (ce = ie[--Qe]); Qe--; )
          ce = ve(ce, ie[Qe], Qe, ie);
        return ce;
      }
      function Yn(ie, ve) {
        for (var ce = -1, De = ie == null ? 0 : ie.length; ++ce < De; )
          if (ve(ie[ce], ce, ie))
            return true;
        return false;
      }
      var Yu = Kn("length");
      function Ku(ie) {
        return ie.split("");
      }
      function Ju(ie) {
        return ie.match(Or) || [];
      }
      function ys(ie, ve, ce) {
        var De;
        return ce(ie, function(Qe, ft, Lt) {
          if (ve(Qe, ft, Lt))
            return De = ft, false;
        }), De;
      }
      function Zi(ie, ve, ce, De) {
        for (var Qe = ie.length, ft = ce + (De ? 1 : -1); De ? ft-- : ++ft < Qe; )
          if (ve(ie[ft], ft, ie))
            return ft;
        return -1;
      }
      function di(ie, ve, ce) {
        return ve === ve ? ll(ie, ve, ce) : Zi(ie, bs, ce);
      }
      function Zu(ie, ve, ce, De) {
        for (var Qe = ce - 1, ft = ie.length; ++Qe < ft; )
          if (De(ie[Qe], ve))
            return Qe;
        return -1;
      }
      function bs(ie) {
        return ie !== ie;
      }
      function _s(ie, ve) {
        var ce = ie == null ? 0 : ie.length;
        return ce ? Zn(ie, ve) / ce : W;
      }
      function Kn(ie) {
        return function(ve) {
          return ve == null ? t : ve[ie];
        };
      }
      function Jn(ie) {
        return function(ve) {
          return ie == null ? t : ie[ve];
        };
      }
      function xs(ie, ve, ce, De, Qe) {
        return Qe(ie, function(ft, Lt, _t) {
          ce = De ? (De = false, ft) : ve(ce, ft, Lt, _t);
        }), ce;
      }
      function Qu(ie, ve) {
        var ce = ie.length;
        for (ie.sort(ve); ce--; )
          ie[ce] = ie[ce].value;
        return ie;
      }
      function Zn(ie, ve) {
        for (var ce, De = -1, Qe = ie.length; ++De < Qe; ) {
          var ft = ve(ie[De]);
          ft !== t && (ce = ce === t ? ft : ce + ft);
        }
        return ce;
      }
      function Qn(ie, ve) {
        for (var ce = -1, De = Array(ie); ++ce < ie; )
          De[ce] = ve(ce);
        return De;
      }
      function el(ie, ve) {
        return Tt(ve, function(ce) {
          return [ce, ie[ce]];
        });
      }
      function ws(ie) {
        return ie && ie.slice(0, Ss(ie) + 1).replace(tr, "");
      }
      function ir(ie) {
        return function(ve) {
          return ie(ve);
        };
      }
      function ea(ie, ve) {
        return Tt(ve, function(ce) {
          return ie[ce];
        });
      }
      function Oi(ie, ve) {
        return ie.has(ve);
      }
      function Es(ie, ve) {
        for (var ce = -1, De = ie.length; ++ce < De && di(ve, ie[ce], 0) > -1; )
          ;
        return ce;
      }
      function Ts(ie, ve) {
        for (var ce = ie.length; ce-- && di(ve, ie[ce], 0) > -1; )
          ;
        return ce;
      }
      function tl(ie, ve) {
        for (var ce = ie.length, De = 0; ce--; )
          ie[ce] === ve && ++De;
        return De;
      }
      var rl = Jn(Bu), il = Jn($u);
      function nl(ie) {
        return "\\" + Uu[ie];
      }
      function al(ie, ve) {
        return ie == null ? t : ie[ve];
      }
      function pi(ie) {
        return Lu.test(ie);
      }
      function sl(ie) {
        return Nu.test(ie);
      }
      function ol(ie) {
        for (var ve, ce = []; !(ve = ie.next()).done; )
          ce.push(ve.value);
        return ce;
      }
      function ta(ie) {
        var ve = -1, ce = Array(ie.size);
        return ie.forEach(function(De, Qe) {
          ce[++ve] = [Qe, De];
        }), ce;
      }
      function Cs(ie, ve) {
        return function(ce) {
          return ie(ve(ce));
        };
      }
      function Vr(ie, ve) {
        for (var ce = -1, De = ie.length, Qe = 0, ft = []; ++ce < De; ) {
          var Lt = ie[ce];
          (Lt === ve || Lt === f) && (ie[ce] = f, ft[Qe++] = ce);
        }
        return ft;
      }
      function Qi(ie) {
        var ve = -1, ce = Array(ie.size);
        return ie.forEach(function(De) {
          ce[++ve] = De;
        }), ce;
      }
      function ul(ie) {
        var ve = -1, ce = Array(ie.size);
        return ie.forEach(function(De) {
          ce[++ve] = [De, De];
        }), ce;
      }
      function ll(ie, ve, ce) {
        for (var De = ce - 1, Qe = ie.length; ++De < Qe; )
          if (ie[De] === ve)
            return De;
        return -1;
      }
      function hl(ie, ve, ce) {
        for (var De = ce + 1; De--; )
          if (ie[De] === ve)
            return De;
        return De;
      }
      function mi(ie) {
        return pi(ie) ? fl(ie) : Yu(ie);
      }
      function vr(ie) {
        return pi(ie) ? dl(ie) : Ku(ie);
      }
      function Ss(ie) {
        for (var ve = ie.length; ve-- && _r.test(ie.charAt(ve)); )
          ;
        return ve;
      }
      var cl = Jn(ju);
      function fl(ie) {
        for (var ve = zn.lastIndex = 0; zn.test(ie); )
          ++ve;
        return ve;
      }
      function dl(ie) {
        return ie.match(zn) || [];
      }
      function pl(ie) {
        return ie.match(ku) || [];
      }
      var ml = function ie(ve) {
        ve = ve == null ? $t : vi.defaults($t.Object(), ve, vi.pick($t, Du));
        var ce = ve.Array, De = ve.Date, Qe = ve.Error, ft = ve.Function, Lt = ve.Math, _t = ve.Object, ra = ve.RegExp, vl = ve.String, hr = ve.TypeError, en = ce.prototype, yl = ft.prototype, gi = _t.prototype, tn = ve["__core-js_shared__"], rn = yl.toString, yt = gi.hasOwnProperty, bl = 0, Rs = function() {
          var o = /[^.]+$/.exec(tn && tn.keys && tn.keys.IE_PROTO || "");
          return o ? "Symbol(src)_1." + o : "";
        }(), nn = gi.toString, _l = rn.call(_t), xl = $t._, wl = ra(
          "^" + rn.call(yt).replace(Vt, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
        ), an = hs ? ve.Buffer : t, Hr = ve.Symbol, sn = ve.Uint8Array, As = an ? an.allocUnsafe : t, on = Cs(_t.getPrototypeOf, _t), Ms = _t.create, Os = gi.propertyIsEnumerable, un = en.splice, Is = Hr ? Hr.isConcatSpreadable : t, Ii = Hr ? Hr.iterator : t, ti = Hr ? Hr.toStringTag : t, ln = function() {
          try {
            var o = si(_t, "defineProperty");
            return o({}, "", {}), o;
          } catch {
          }
        }(), El = ve.clearTimeout !== $t.clearTimeout && ve.clearTimeout, Tl = De && De.now !== $t.Date.now && De.now, Cl = ve.setTimeout !== $t.setTimeout && ve.setTimeout, hn = Lt.ceil, cn = Lt.floor, ia = _t.getOwnPropertySymbols, Sl = an ? an.isBuffer : t, Ps = ve.isFinite, Rl = en.join, Al = Cs(_t.keys, _t), Nt = Lt.max, Gt = Lt.min, Ml = De.now, Ol = ve.parseInt, qs = Lt.random, Il = en.reverse, na = si(ve, "DataView"), Pi = si(ve, "Map"), aa = si(ve, "Promise"), yi = si(ve, "Set"), qi = si(ve, "WeakMap"), ki = si(_t, "create"), fn = qi && new qi(), bi = {}, Pl = oi(na), ql = oi(Pi), kl = oi(aa), Ll = oi(yi), Nl = oi(qi), dn = Hr ? Hr.prototype : t, Li = dn ? dn.valueOf : t, ks = dn ? dn.toString : t;
        function j(o) {
          if (At(o) && !tt(o) && !(o instanceof ot)) {
            if (o instanceof cr)
              return o;
            if (yt.call(o, "__wrapped__"))
              return Do(o);
          }
          return new cr(o);
        }
        var _i = /* @__PURE__ */ function() {
          function o() {
          }
          return function(h) {
            if (!St(h))
              return {};
            if (Ms)
              return Ms(h);
            o.prototype = h;
            var v = new o();
            return o.prototype = t, v;
          };
        }();
        function pn() {
        }
        function cr(o, h) {
          this.__wrapped__ = o, this.__actions__ = [], this.__chain__ = !!h, this.__index__ = 0, this.__values__ = t;
        }
        j.templateSettings = {
          /**
           * Used to detect `data` property values to be HTML-escaped.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          escape: Je,
          /**
           * Used to detect code to be evaluated.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          evaluate: ht,
          /**
           * Used to detect `data` property values to inject.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          interpolate: bt,
          /**
           * Used to reference the data object in the template text.
           *
           * @memberOf _.templateSettings
           * @type {string}
           */
          variable: "",
          /**
           * Used to import variables into the compiled template.
           *
           * @memberOf _.templateSettings
           * @type {Object}
           */
          imports: {
            /**
             * A reference to the `lodash` function.
             *
             * @memberOf _.templateSettings.imports
             * @type {Function}
             */
            _: j
          }
        }, j.prototype = pn.prototype, j.prototype.constructor = j, cr.prototype = _i(pn.prototype), cr.prototype.constructor = cr;
        function ot(o) {
          this.__wrapped__ = o, this.__actions__ = [], this.__dir__ = 1, this.__filtered__ = false, this.__iteratees__ = [], this.__takeCount__ = V, this.__views__ = [];
        }
        function Dl() {
          var o = new ot(this.__wrapped__);
          return o.__actions__ = Yt(this.__actions__), o.__dir__ = this.__dir__, o.__filtered__ = this.__filtered__, o.__iteratees__ = Yt(this.__iteratees__), o.__takeCount__ = this.__takeCount__, o.__views__ = Yt(this.__views__), o;
        }
        function Fl() {
          if (this.__filtered__) {
            var o = new ot(this);
            o.__dir__ = -1, o.__filtered__ = true;
          } else
            o = this.clone(), o.__dir__ *= -1;
          return o;
        }
        function Bl() {
          var o = this.__wrapped__.value(), h = this.__dir__, v = tt(o), R = h < 0, N = v ? o.length : 0, H = Jh(0, N, this.__views__), Z = H.start, Q = H.end, se = Q - Z, xe = R ? Q : Z - 1, we = this.__iteratees__, Ce = we.length, Le = 0, Be = Gt(se, this.__takeCount__);
          if (!v || !R && N == se && Be == se)
            return ao(o, this.__actions__);
          var Ve = [];
          e:
            for (; se-- && Le < Be; ) {
              xe += h;
              for (var it = -1, He = o[xe]; ++it < Ce; ) {
                var st = we[it], ut = st.iteratee, sr = st.type, Xt = ut(He);
                if (sr == X)
                  He = Xt;
                else if (!Xt) {
                  if (sr == D)
                    continue e;
                  break e;
                }
              }
              Ve[Le++] = He;
            }
          return Ve;
        }
        ot.prototype = _i(pn.prototype), ot.prototype.constructor = ot;
        function ri(o) {
          var h = -1, v = o == null ? 0 : o.length;
          for (this.clear(); ++h < v; ) {
            var R = o[h];
            this.set(R[0], R[1]);
          }
        }
        function $l() {
          this.__data__ = ki ? ki(null) : {}, this.size = 0;
        }
        function jl(o) {
          var h = this.has(o) && delete this.__data__[o];
          return this.size -= h ? 1 : 0, h;
        }
        function Ul(o) {
          var h = this.__data__;
          if (ki) {
            var v = h[o];
            return v === c ? t : v;
          }
          return yt.call(h, o) ? h[o] : t;
        }
        function Gl(o) {
          var h = this.__data__;
          return ki ? h[o] !== t : yt.call(h, o);
        }
        function zl(o, h) {
          var v = this.__data__;
          return this.size += this.has(o) ? 0 : 1, v[o] = ki && h === t ? c : h, this;
        }
        ri.prototype.clear = $l, ri.prototype.delete = jl, ri.prototype.get = Ul, ri.prototype.has = Gl, ri.prototype.set = zl;
        function Pr(o) {
          var h = -1, v = o == null ? 0 : o.length;
          for (this.clear(); ++h < v; ) {
            var R = o[h];
            this.set(R[0], R[1]);
          }
        }
        function Vl() {
          this.__data__ = [], this.size = 0;
        }
        function Hl(o) {
          var h = this.__data__, v = mn(h, o);
          if (v < 0)
            return false;
          var R = h.length - 1;
          return v == R ? h.pop() : un.call(h, v, 1), --this.size, true;
        }
        function Wl(o) {
          var h = this.__data__, v = mn(h, o);
          return v < 0 ? t : h[v][1];
        }
        function Xl(o) {
          return mn(this.__data__, o) > -1;
        }
        function Yl(o, h) {
          var v = this.__data__, R = mn(v, o);
          return R < 0 ? (++this.size, v.push([o, h])) : v[R][1] = h, this;
        }
        Pr.prototype.clear = Vl, Pr.prototype.delete = Hl, Pr.prototype.get = Wl, Pr.prototype.has = Xl, Pr.prototype.set = Yl;
        function qr(o) {
          var h = -1, v = o == null ? 0 : o.length;
          for (this.clear(); ++h < v; ) {
            var R = o[h];
            this.set(R[0], R[1]);
          }
        }
        function Kl() {
          this.size = 0, this.__data__ = {
            hash: new ri(),
            map: new (Pi || Pr)(),
            string: new ri()
          };
        }
        function Jl(o) {
          var h = Rn(this, o).delete(o);
          return this.size -= h ? 1 : 0, h;
        }
        function Zl(o) {
          return Rn(this, o).get(o);
        }
        function Ql(o) {
          return Rn(this, o).has(o);
        }
        function eh(o, h) {
          var v = Rn(this, o), R = v.size;
          return v.set(o, h), this.size += v.size == R ? 0 : 1, this;
        }
        qr.prototype.clear = Kl, qr.prototype.delete = Jl, qr.prototype.get = Zl, qr.prototype.has = Ql, qr.prototype.set = eh;
        function ii(o) {
          var h = -1, v = o == null ? 0 : o.length;
          for (this.__data__ = new qr(); ++h < v; )
            this.add(o[h]);
        }
        function th(o) {
          return this.__data__.set(o, c), this;
        }
        function rh(o) {
          return this.__data__.has(o);
        }
        ii.prototype.add = ii.prototype.push = th, ii.prototype.has = rh;
        function gr(o) {
          var h = this.__data__ = new Pr(o);
          this.size = h.size;
        }
        function ih() {
          this.__data__ = new Pr(), this.size = 0;
        }
        function nh(o) {
          var h = this.__data__, v = h.delete(o);
          return this.size = h.size, v;
        }
        function ah(o) {
          return this.__data__.get(o);
        }
        function sh(o) {
          return this.__data__.has(o);
        }
        function oh(o, h) {
          var v = this.__data__;
          if (v instanceof Pr) {
            var R = v.__data__;
            if (!Pi || R.length < a - 1)
              return R.push([o, h]), this.size = ++v.size, this;
            v = this.__data__ = new qr(R);
          }
          return v.set(o, h), this.size = v.size, this;
        }
        gr.prototype.clear = ih, gr.prototype.delete = nh, gr.prototype.get = ah, gr.prototype.has = sh, gr.prototype.set = oh;
        function Ls(o, h) {
          var v = tt(o), R = !v && ui(o), N = !v && !R && Jr(o), H = !v && !R && !N && Ti(o), Z = v || R || N || H, Q = Z ? Qn(o.length, vl) : [], se = Q.length;
          for (var xe in o)
            (h || yt.call(o, xe)) && !(Z && // Safari 9 has enumerable `arguments.length` in strict mode.
            (xe == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
            N && (xe == "offset" || xe == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
            H && (xe == "buffer" || xe == "byteLength" || xe == "byteOffset") || // Skip index properties.
            Dr(xe, se))) && Q.push(xe);
          return Q;
        }
        function Ns(o) {
          var h = o.length;
          return h ? o[va(0, h - 1)] : t;
        }
        function uh(o, h) {
          return An(Yt(o), ni(h, 0, o.length));
        }
        function lh(o) {
          return An(Yt(o));
        }
        function sa(o, h, v) {
          (v !== t && !yr(o[h], v) || v === t && !(h in o)) && kr(o, h, v);
        }
        function Ni(o, h, v) {
          var R = o[h];
          (!(yt.call(o, h) && yr(R, v)) || v === t && !(h in o)) && kr(o, h, v);
        }
        function mn(o, h) {
          for (var v = o.length; v--; )
            if (yr(o[v][0], h))
              return v;
          return -1;
        }
        function hh(o, h, v, R) {
          return Wr(o, function(N, H, Z) {
            h(R, N, v(N), Z);
          }), R;
        }
        function Ds(o, h) {
          return o && Tr(h, Bt(h), o);
        }
        function ch(o, h) {
          return o && Tr(h, Jt(h), o);
        }
        function kr(o, h, v) {
          h == "__proto__" && ln ? ln(o, h, {
            configurable: true,
            enumerable: true,
            value: v,
            writable: true
          }) : o[h] = v;
        }
        function oa(o, h) {
          for (var v = -1, R = h.length, N = ce(R), H = o == null; ++v < R; )
            N[v] = H ? t : ja(o, h[v]);
          return N;
        }
        function ni(o, h, v) {
          return o === o && (v !== t && (o = o <= v ? o : v), h !== t && (o = o >= h ? o : h)), o;
        }
        function fr(o, h, v, R, N, H) {
          var Z, Q = h & p, se = h & m, xe = h & y;
          if (v && (Z = N ? v(o, R, N, H) : v(o)), Z !== t)
            return Z;
          if (!St(o))
            return o;
          var we = tt(o);
          if (we) {
            if (Z = Qh(o), !Q)
              return Yt(o, Z);
          } else {
            var Ce = zt(o), Le = Ce == Ae || Ce == ke;
            if (Jr(o))
              return uo(o, Q);
            if (Ce == $e || Ce == re || Le && !N) {
              if (Z = se || Le ? {} : Ao(o), !Q)
                return se ? Uh(o, ch(Z, o)) : jh(o, Ds(Z, o));
            } else {
              if (!wt[Ce])
                return N ? o : {};
              Z = ec(o, Ce, Q);
            }
          }
          H || (H = new gr());
          var Be = H.get(o);
          if (Be)
            return Be;
          H.set(o, Z), iu(o) ? o.forEach(function(He) {
            Z.add(fr(He, h, v, He, o, H));
          }) : tu(o) && o.forEach(function(He, st) {
            Z.set(st, fr(He, h, v, st, o, H));
          });
          var Ve = xe ? se ? Ra : Sa : se ? Jt : Bt, it = we ? t : Ve(o);
          return lr(it || o, function(He, st) {
            it && (st = He, He = o[st]), Ni(Z, st, fr(He, h, v, st, o, H));
          }), Z;
        }
        function fh(o) {
          var h = Bt(o);
          return function(v) {
            return Fs(v, o, h);
          };
        }
        function Fs(o, h, v) {
          var R = v.length;
          if (o == null)
            return !R;
          for (o = _t(o); R--; ) {
            var N = v[R], H = h[N], Z = o[N];
            if (Z === t && !(N in o) || !H(Z))
              return false;
          }
          return true;
        }
        function Bs(o, h, v) {
          if (typeof o != "function")
            throw new hr(u);
          return Gi(function() {
            o.apply(t, v);
          }, h);
        }
        function Di(o, h, v, R) {
          var N = -1, H = Ji, Z = true, Q = o.length, se = [], xe = h.length;
          if (!Q)
            return se;
          v && (h = Tt(h, ir(v))), R ? (H = Wn, Z = false) : h.length >= a && (H = Oi, Z = false, h = new ii(h));
          e:
            for (; ++N < Q; ) {
              var we = o[N], Ce = v == null ? we : v(we);
              if (we = R || we !== 0 ? we : 0, Z && Ce === Ce) {
                for (var Le = xe; Le--; )
                  if (h[Le] === Ce)
                    continue e;
                se.push(we);
              } else H(h, Ce, R) || se.push(we);
            }
          return se;
        }
        var Wr = po(Er), $s = po(la, true);
        function dh(o, h) {
          var v = true;
          return Wr(o, function(R, N, H) {
            return v = !!h(R, N, H), v;
          }), v;
        }
        function vn(o, h, v) {
          for (var R = -1, N = o.length; ++R < N; ) {
            var H = o[R], Z = h(H);
            if (Z != null && (Q === t ? Z === Z && !ar(Z) : v(Z, Q)))
              var Q = Z, se = H;
          }
          return se;
        }
        function ph(o, h, v, R) {
          var N = o.length;
          for (v = rt(v), v < 0 && (v = -v > N ? 0 : N + v), R = R === t || R > N ? N : rt(R), R < 0 && (R += N), R = v > R ? 0 : au(R); v < R; )
            o[v++] = h;
          return o;
        }
        function js(o, h) {
          var v = [];
          return Wr(o, function(R, N, H) {
            h(R, N, H) && v.push(R);
          }), v;
        }
        function jt(o, h, v, R, N) {
          var H = -1, Z = o.length;
          for (v || (v = rc), N || (N = []); ++H < Z; ) {
            var Q = o[H];
            h > 0 && v(Q) ? h > 1 ? jt(Q, h - 1, v, R, N) : zr(N, Q) : R || (N[N.length] = Q);
          }
          return N;
        }
        var ua = mo(), Us = mo(true);
        function Er(o, h) {
          return o && ua(o, h, Bt);
        }
        function la(o, h) {
          return o && Us(o, h, Bt);
        }
        function gn(o, h) {
          return Gr(h, function(v) {
            return Fr(o[v]);
          });
        }
        function ai(o, h) {
          h = Yr(h, o);
          for (var v = 0, R = h.length; o != null && v < R; )
            o = o[Cr(h[v++])];
          return v && v == R ? o : t;
        }
        function Gs(o, h, v) {
          var R = h(o);
          return tt(o) ? R : zr(R, v(o));
        }
        function Ht(o) {
          return o == null ? o === t ? Rt : Oe : ti && ti in _t(o) ? Kh(o) : lc(o);
        }
        function ha(o, h) {
          return o > h;
        }
        function mh(o, h) {
          return o != null && yt.call(o, h);
        }
        function vh(o, h) {
          return o != null && h in _t(o);
        }
        function gh(o, h, v) {
          return o >= Gt(h, v) && o < Nt(h, v);
        }
        function ca(o, h, v) {
          for (var R = v ? Wn : Ji, N = o[0].length, H = o.length, Z = H, Q = ce(H), se = 1 / 0, xe = []; Z--; ) {
            var we = o[Z];
            Z && h && (we = Tt(we, ir(h))), se = Gt(we.length, se), Q[Z] = !v && (h || N >= 120 && we.length >= 120) ? new ii(Z && we) : t;
          }
          we = o[0];
          var Ce = -1, Le = Q[0];
          e:
            for (; ++Ce < N && xe.length < se; ) {
              var Be = we[Ce], Ve = h ? h(Be) : Be;
              if (Be = v || Be !== 0 ? Be : 0, !(Le ? Oi(Le, Ve) : R(xe, Ve, v))) {
                for (Z = H; --Z; ) {
                  var it = Q[Z];
                  if (!(it ? Oi(it, Ve) : R(o[Z], Ve, v)))
                    continue e;
                }
                Le && Le.push(Ve), xe.push(Be);
              }
            }
          return xe;
        }
        function yh(o, h, v, R) {
          return Er(o, function(N, H, Z) {
            h(R, v(N), H, Z);
          }), R;
        }
        function Fi(o, h, v) {
          h = Yr(h, o), o = Po(o, h);
          var R = o == null ? o : o[Cr(pr(h))];
          return R == null ? t : rr(R, o, v);
        }
        function zs(o) {
          return At(o) && Ht(o) == re;
        }
        function bh(o) {
          return At(o) && Ht(o) == $;
        }
        function _h(o) {
          return At(o) && Ht(o) == Te;
        }
        function Bi(o, h, v, R, N) {
          return o === h ? true : o == null || h == null || !At(o) && !At(h) ? o !== o && h !== h : xh(o, h, v, R, Bi, N);
        }
        function xh(o, h, v, R, N, H) {
          var Z = tt(o), Q = tt(h), se = Z ? he : zt(o), xe = Q ? he : zt(h);
          se = se == re ? $e : se, xe = xe == re ? $e : xe;
          var we = se == $e, Ce = xe == $e, Le = se == xe;
          if (Le && Jr(o)) {
            if (!Jr(h))
              return false;
            Z = true, we = false;
          }
          if (Le && !we)
            return H || (H = new gr()), Z || Ti(o) ? Co(o, h, v, R, N, H) : Xh(o, h, se, v, R, N, H);
          if (!(v & x)) {
            var Be = we && yt.call(o, "__wrapped__"), Ve = Ce && yt.call(h, "__wrapped__");
            if (Be || Ve) {
              var it = Be ? o.value() : o, He = Ve ? h.value() : h;
              return H || (H = new gr()), N(it, He, v, R, H);
            }
          }
          return Le ? (H || (H = new gr()), Yh(o, h, v, R, N, H)) : false;
        }
        function wh(o) {
          return At(o) && zt(o) == Pe;
        }
        function fa(o, h, v, R) {
          var N = v.length, H = N, Z = !R;
          if (o == null)
            return !H;
          for (o = _t(o); N--; ) {
            var Q = v[N];
            if (Z && Q[2] ? Q[1] !== o[Q[0]] : !(Q[0] in o))
              return false;
          }
          for (; ++N < H; ) {
            Q = v[N];
            var se = Q[0], xe = o[se], we = Q[1];
            if (Z && Q[2]) {
              if (xe === t && !(se in o))
                return false;
            } else {
              var Ce = new gr();
              if (R)
                var Le = R(xe, we, se, o, h, Ce);
              if (!(Le === t ? Bi(we, xe, x | g, R, Ce) : Le))
                return false;
            }
          }
          return true;
        }
        function Vs(o) {
          if (!St(o) || nc(o))
            return false;
          var h = Fr(o) ? wl : Zr;
          return h.test(oi(o));
        }
        function Eh(o) {
          return At(o) && Ht(o) == vt;
        }
        function Th(o) {
          return At(o) && zt(o) == Xe;
        }
        function Ch(o) {
          return At(o) && kn(o.length) && !!Et[Ht(o)];
        }
        function Hs(o) {
          return typeof o == "function" ? o : o == null ? Zt : typeof o == "object" ? tt(o) ? Ys(o[0], o[1]) : Xs(o) : vu(o);
        }
        function da(o) {
          if (!Ui(o))
            return Al(o);
          var h = [];
          for (var v in _t(o))
            yt.call(o, v) && v != "constructor" && h.push(v);
          return h;
        }
        function Sh(o) {
          if (!St(o))
            return uc(o);
          var h = Ui(o), v = [];
          for (var R in o)
            R == "constructor" && (h || !yt.call(o, R)) || v.push(R);
          return v;
        }
        function pa(o, h) {
          return o < h;
        }
        function Ws(o, h) {
          var v = -1, R = Kt(o) ? ce(o.length) : [];
          return Wr(o, function(N, H, Z) {
            R[++v] = h(N, H, Z);
          }), R;
        }
        function Xs(o) {
          var h = Ma(o);
          return h.length == 1 && h[0][2] ? Oo(h[0][0], h[0][1]) : function(v) {
            return v === o || fa(v, o, h);
          };
        }
        function Ys(o, h) {
          return Ia(o) && Mo(h) ? Oo(Cr(o), h) : function(v) {
            var R = ja(v, o);
            return R === t && R === h ? Ua(v, o) : Bi(h, R, x | g);
          };
        }
        function yn(o, h, v, R, N) {
          o !== h && ua(h, function(H, Z) {
            if (N || (N = new gr()), St(H))
              Rh(o, h, Z, v, yn, R, N);
            else {
              var Q = R ? R(qa(o, Z), H, Z + "", o, h, N) : t;
              Q === t && (Q = H), sa(o, Z, Q);
            }
          }, Jt);
        }
        function Rh(o, h, v, R, N, H, Z) {
          var Q = qa(o, v), se = qa(h, v), xe = Z.get(se);
          if (xe) {
            sa(o, v, xe);
            return;
          }
          var we = H ? H(Q, se, v + "", o, h, Z) : t, Ce = we === t;
          if (Ce) {
            var Le = tt(se), Be = !Le && Jr(se), Ve = !Le && !Be && Ti(se);
            we = se, Le || Be || Ve ? tt(Q) ? we = Q : Mt(Q) ? we = Yt(Q) : Be ? (Ce = false, we = uo(se, true)) : Ve ? (Ce = false, we = lo(se, true)) : we = [] : zi(se) || ui(se) ? (we = Q, ui(Q) ? we = su(Q) : (!St(Q) || Fr(Q)) && (we = Ao(se))) : Ce = false;
          }
          Ce && (Z.set(se, we), N(we, se, R, H, Z), Z.delete(se)), sa(o, v, we);
        }
        function Ks(o, h) {
          var v = o.length;
          if (v)
            return h += h < 0 ? v : 0, Dr(h, v) ? o[h] : t;
        }
        function Js(o, h, v) {
          h.length ? h = Tt(h, function(H) {
            return tt(H) ? function(Z) {
              return ai(Z, H.length === 1 ? H[0] : H);
            } : H;
          }) : h = [Zt];
          var R = -1;
          h = Tt(h, ir(Ge()));
          var N = Ws(o, function(H, Z, Q) {
            var se = Tt(h, function(xe) {
              return xe(H);
            });
            return { criteria: se, index: ++R, value: H };
          });
          return Qu(N, function(H, Z) {
            return $h(H, Z, v);
          });
        }
        function Ah(o, h) {
          return Zs(o, h, function(v, R) {
            return Ua(o, R);
          });
        }
        function Zs(o, h, v) {
          for (var R = -1, N = h.length, H = {}; ++R < N; ) {
            var Z = h[R], Q = ai(o, Z);
            v(Q, Z) && $i(H, Yr(Z, o), Q);
          }
          return H;
        }
        function Mh(o) {
          return function(h) {
            return ai(h, o);
          };
        }
        function ma(o, h, v, R) {
          var N = R ? Zu : di, H = -1, Z = h.length, Q = o;
          for (o === h && (h = Yt(h)), v && (Q = Tt(o, ir(v))); ++H < Z; )
            for (var se = 0, xe = h[H], we = v ? v(xe) : xe; (se = N(Q, we, se, R)) > -1; )
              Q !== o && un.call(Q, se, 1), un.call(o, se, 1);
          return o;
        }
        function Qs(o, h) {
          for (var v = o ? h.length : 0, R = v - 1; v--; ) {
            var N = h[v];
            if (v == R || N !== H) {
              var H = N;
              Dr(N) ? un.call(o, N, 1) : ba(o, N);
            }
          }
          return o;
        }
        function va(o, h) {
          return o + cn(qs() * (h - o + 1));
        }
        function Oh(o, h, v, R) {
          for (var N = -1, H = Nt(hn((h - o) / (v || 1)), 0), Z = ce(H); H--; )
            Z[R ? H : ++N] = o, o += v;
          return Z;
        }
        function ga(o, h) {
          var v = "";
          if (!o || h < 1 || h > P)
            return v;
          do
            h % 2 && (v += o), h = cn(h / 2), h && (o += o);
          while (h);
          return v;
        }
        function nt(o, h) {
          return ka(Io(o, h, Zt), o + "");
        }
        function Ih(o) {
          return Ns(Ci(o));
        }
        function Ph(o, h) {
          var v = Ci(o);
          return An(v, ni(h, 0, v.length));
        }
        function $i(o, h, v, R) {
          if (!St(o))
            return o;
          h = Yr(h, o);
          for (var N = -1, H = h.length, Z = H - 1, Q = o; Q != null && ++N < H; ) {
            var se = Cr(h[N]), xe = v;
            if (se === "__proto__" || se === "constructor" || se === "prototype")
              return o;
            if (N != Z) {
              var we = Q[se];
              xe = R ? R(we, se, Q) : t, xe === t && (xe = St(we) ? we : Dr(h[N + 1]) ? [] : {});
            }
            Ni(Q, se, xe), Q = Q[se];
          }
          return o;
        }
        var eo = fn ? function(o, h) {
          return fn.set(o, h), o;
        } : Zt, qh = ln ? function(o, h) {
          return ln(o, "toString", {
            configurable: true,
            enumerable: false,
            value: za(h),
            writable: true
          });
        } : Zt;
        function kh(o) {
          return An(Ci(o));
        }
        function dr(o, h, v) {
          var R = -1, N = o.length;
          h < 0 && (h = -h > N ? 0 : N + h), v = v > N ? N : v, v < 0 && (v += N), N = h > v ? 0 : v - h >>> 0, h >>>= 0;
          for (var H = ce(N); ++R < N; )
            H[R] = o[R + h];
          return H;
        }
        function Lh(o, h) {
          var v;
          return Wr(o, function(R, N, H) {
            return v = h(R, N, H), !v;
          }), !!v;
        }
        function bn(o, h, v) {
          var R = 0, N = o == null ? R : o.length;
          if (typeof h == "number" && h === h && N <= J) {
            for (; R < N; ) {
              var H = R + N >>> 1, Z = o[H];
              Z !== null && !ar(Z) && (v ? Z <= h : Z < h) ? R = H + 1 : N = H;
            }
            return N;
          }
          return ya(o, h, Zt, v);
        }
        function ya(o, h, v, R) {
          var N = 0, H = o == null ? 0 : o.length;
          if (H === 0)
            return 0;
          h = v(h);
          for (var Z = h !== h, Q = h === null, se = ar(h), xe = h === t; N < H; ) {
            var we = cn((N + H) / 2), Ce = v(o[we]), Le = Ce !== t, Be = Ce === null, Ve = Ce === Ce, it = ar(Ce);
            if (Z)
              var He = R || Ve;
            else xe ? He = Ve && (R || Le) : Q ? He = Ve && Le && (R || !Be) : se ? He = Ve && Le && !Be && (R || !it) : Be || it ? He = false : He = R ? Ce <= h : Ce < h;
            He ? N = we + 1 : H = we;
          }
          return Gt(H, K);
        }
        function to(o, h) {
          for (var v = -1, R = o.length, N = 0, H = []; ++v < R; ) {
            var Z = o[v], Q = h ? h(Z) : Z;
            if (!v || !yr(Q, se)) {
              var se = Q;
              H[N++] = Z === 0 ? 0 : Z;
            }
          }
          return H;
        }
        function ro(o) {
          return typeof o == "number" ? o : ar(o) ? W : +o;
        }
        function nr(o) {
          if (typeof o == "string")
            return o;
          if (tt(o))
            return Tt(o, nr) + "";
          if (ar(o))
            return ks ? ks.call(o) : "";
          var h = o + "";
          return h == "0" && 1 / o == -1 / 0 ? "-0" : h;
        }
        function Xr(o, h, v) {
          var R = -1, N = Ji, H = o.length, Z = true, Q = [], se = Q;
          if (v)
            Z = false, N = Wn;
          else if (H >= a) {
            var xe = h ? null : Hh(o);
            if (xe)
              return Qi(xe);
            Z = false, N = Oi, se = new ii();
          } else
            se = h ? [] : Q;
          e:
            for (; ++R < H; ) {
              var we = o[R], Ce = h ? h(we) : we;
              if (we = v || we !== 0 ? we : 0, Z && Ce === Ce) {
                for (var Le = se.length; Le--; )
                  if (se[Le] === Ce)
                    continue e;
                h && se.push(Ce), Q.push(we);
              } else N(se, Ce, v) || (se !== Q && se.push(Ce), Q.push(we));
            }
          return Q;
        }
        function ba(o, h) {
          return h = Yr(h, o), o = Po(o, h), o == null || delete o[Cr(pr(h))];
        }
        function io(o, h, v, R) {
          return $i(o, h, v(ai(o, h)), R);
        }
        function _n(o, h, v, R) {
          for (var N = o.length, H = R ? N : -1; (R ? H-- : ++H < N) && h(o[H], H, o); )
            ;
          return v ? dr(o, R ? 0 : H, R ? H + 1 : N) : dr(o, R ? H + 1 : 0, R ? N : H);
        }
        function ao(o, h) {
          var v = o;
          return v instanceof ot && (v = v.value()), Xn(h, function(R, N) {
            return N.func.apply(N.thisArg, zr([R], N.args));
          }, v);
        }
        function _a(o, h, v) {
          var R = o.length;
          if (R < 2)
            return R ? Xr(o[0]) : [];
          for (var N = -1, H = ce(R); ++N < R; )
            for (var Z = o[N], Q = -1; ++Q < R; )
              Q != N && (H[N] = Di(H[N] || Z, o[Q], h, v));
          return Xr(jt(H, 1), h, v);
        }
        function so(o, h, v) {
          for (var R = -1, N = o.length, H = h.length, Z = {}; ++R < N; ) {
            var Q = R < H ? h[R] : t;
            v(Z, o[R], Q);
          }
          return Z;
        }
        function xa(o) {
          return Mt(o) ? o : [];
        }
        function wa(o) {
          return typeof o == "function" ? o : Zt;
        }
        function Yr(o, h) {
          return tt(o) ? o : Ia(o, h) ? [o] : No(mt(o));
        }
        var Nh = nt;
        function Kr(o, h, v) {
          var R = o.length;
          return v = v === t ? R : v, !h && v >= R ? o : dr(o, h, v);
        }
        var oo = El || function(o) {
          return $t.clearTimeout(o);
        };
        function uo(o, h) {
          if (h)
            return o.slice();
          var v = o.length, R = As ? As(v) : new o.constructor(v);
          return o.copy(R), R;
        }
        function Ea(o) {
          var h = new o.constructor(o.byteLength);
          return new sn(h).set(new sn(o)), h;
        }
        function Dh(o, h) {
          var v = h ? Ea(o.buffer) : o.buffer;
          return new o.constructor(v, o.byteOffset, o.byteLength);
        }
        function Fh(o) {
          var h = new o.constructor(o.source, Ri.exec(o));
          return h.lastIndex = o.lastIndex, h;
        }
        function Bh(o) {
          return Li ? _t(Li.call(o)) : {};
        }
        function lo(o, h) {
          var v = h ? Ea(o.buffer) : o.buffer;
          return new o.constructor(v, o.byteOffset, o.length);
        }
        function ho(o, h) {
          if (o !== h) {
            var v = o !== t, R = o === null, N = o === o, H = ar(o), Z = h !== t, Q = h === null, se = h === h, xe = ar(h);
            if (!Q && !xe && !H && o > h || H && Z && se && !Q && !xe || R && Z && se || !v && se || !N)
              return 1;
            if (!R && !H && !xe && o < h || xe && v && N && !R && !H || Q && v && N || !Z && N || !se)
              return -1;
          }
          return 0;
        }
        function $h(o, h, v) {
          for (var R = -1, N = o.criteria, H = h.criteria, Z = N.length, Q = v.length; ++R < Z; ) {
            var se = ho(N[R], H[R]);
            if (se) {
              if (R >= Q)
                return se;
              var xe = v[R];
              return se * (xe == "desc" ? -1 : 1);
            }
          }
          return o.index - h.index;
        }
        function co(o, h, v, R) {
          for (var N = -1, H = o.length, Z = v.length, Q = -1, se = h.length, xe = Nt(H - Z, 0), we = ce(se + xe), Ce = !R; ++Q < se; )
            we[Q] = h[Q];
          for (; ++N < Z; )
            (Ce || N < H) && (we[v[N]] = o[N]);
          for (; xe--; )
            we[Q++] = o[N++];
          return we;
        }
        function fo(o, h, v, R) {
          for (var N = -1, H = o.length, Z = -1, Q = v.length, se = -1, xe = h.length, we = Nt(H - Q, 0), Ce = ce(we + xe), Le = !R; ++N < we; )
            Ce[N] = o[N];
          for (var Be = N; ++se < xe; )
            Ce[Be + se] = h[se];
          for (; ++Z < Q; )
            (Le || N < H) && (Ce[Be + v[Z]] = o[N++]);
          return Ce;
        }
        function Yt(o, h) {
          var v = -1, R = o.length;
          for (h || (h = ce(R)); ++v < R; )
            h[v] = o[v];
          return h;
        }
        function Tr(o, h, v, R) {
          var N = !v;
          v || (v = {});
          for (var H = -1, Z = h.length; ++H < Z; ) {
            var Q = h[H], se = R ? R(v[Q], o[Q], Q, v, o) : t;
            se === t && (se = o[Q]), N ? kr(v, Q, se) : Ni(v, Q, se);
          }
          return v;
        }
        function jh(o, h) {
          return Tr(o, Oa(o), h);
        }
        function Uh(o, h) {
          return Tr(o, So(o), h);
        }
        function xn(o, h) {
          return function(v, R) {
            var N = tt(v) ? Hu : hh, H = h ? h() : {};
            return N(v, o, Ge(R, 2), H);
          };
        }
        function xi(o) {
          return nt(function(h, v) {
            var R = -1, N = v.length, H = N > 1 ? v[N - 1] : t, Z = N > 2 ? v[2] : t;
            for (H = o.length > 3 && typeof H == "function" ? (N--, H) : t, Z && Wt(v[0], v[1], Z) && (H = N < 3 ? t : H, N = 1), h = _t(h); ++R < N; ) {
              var Q = v[R];
              Q && o(h, Q, R, H);
            }
            return h;
          });
        }
        function po(o, h) {
          return function(v, R) {
            if (v == null)
              return v;
            if (!Kt(v))
              return o(v, R);
            for (var N = v.length, H = h ? N : -1, Z = _t(v); (h ? H-- : ++H < N) && R(Z[H], H, Z) !== false; )
              ;
            return v;
          };
        }
        function mo(o) {
          return function(h, v, R) {
            for (var N = -1, H = _t(h), Z = R(h), Q = Z.length; Q--; ) {
              var se = Z[o ? Q : ++N];
              if (v(H[se], se, H) === false)
                break;
            }
            return h;
          };
        }
        function Gh(o, h, v) {
          var R = h & _, N = ji(o);
          function H() {
            var Z = this && this !== $t && this instanceof H ? N : o;
            return Z.apply(R ? v : this, arguments);
          }
          return H;
        }
        function vo(o) {
          return function(h) {
            h = mt(h);
            var v = pi(h) ? vr(h) : t, R = v ? v[0] : h.charAt(0), N = v ? Kr(v, 1).join("") : h.slice(1);
            return R[o]() + N;
          };
        }
        function wi(o) {
          return function(h) {
            return Xn(pu(du(h).replace(Pu, "")), o, "");
          };
        }
        function ji(o) {
          return function() {
            var h = arguments;
            switch (h.length) {
              case 0:
                return new o();
              case 1:
                return new o(h[0]);
              case 2:
                return new o(h[0], h[1]);
              case 3:
                return new o(h[0], h[1], h[2]);
              case 4:
                return new o(h[0], h[1], h[2], h[3]);
              case 5:
                return new o(h[0], h[1], h[2], h[3], h[4]);
              case 6:
                return new o(h[0], h[1], h[2], h[3], h[4], h[5]);
              case 7:
                return new o(h[0], h[1], h[2], h[3], h[4], h[5], h[6]);
            }
            var v = _i(o.prototype), R = o.apply(v, h);
            return St(R) ? R : v;
          };
        }
        function zh(o, h, v) {
          var R = ji(o);
          function N() {
            for (var H = arguments.length, Z = ce(H), Q = H, se = Ei(N); Q--; )
              Z[Q] = arguments[Q];
            var xe = H < 3 && Z[0] !== se && Z[H - 1] !== se ? [] : Vr(Z, se);
            if (H -= xe.length, H < v)
              return xo(
                o,
                h,
                wn,
                N.placeholder,
                t,
                Z,
                xe,
                t,
                t,
                v - H
              );
            var we = this && this !== $t && this instanceof N ? R : o;
            return rr(we, this, Z);
          }
          return N;
        }
        function go(o) {
          return function(h, v, R) {
            var N = _t(h);
            if (!Kt(h)) {
              var H = Ge(v, 3);
              h = Bt(h), v = function(Q) {
                return H(N[Q], Q, N);
              };
            }
            var Z = o(h, v, R);
            return Z > -1 ? N[H ? h[Z] : Z] : t;
          };
        }
        function yo(o) {
          return Nr(function(h) {
            var v = h.length, R = v, N = cr.prototype.thru;
            for (o && h.reverse(); R--; ) {
              var H = h[R];
              if (typeof H != "function")
                throw new hr(u);
              if (N && !Z && Sn(H) == "wrapper")
                var Z = new cr([], true);
            }
            for (R = Z ? R : v; ++R < v; ) {
              H = h[R];
              var Q = Sn(H), se = Q == "wrapper" ? Aa(H) : t;
              se && Pa(se[0]) && se[1] == (S | b | w | F) && !se[4].length && se[9] == 1 ? Z = Z[Sn(se[0])].apply(Z, se[3]) : Z = H.length == 1 && Pa(H) ? Z[Q]() : Z.thru(H);
            }
            return function() {
              var xe = arguments, we = xe[0];
              if (Z && xe.length == 1 && tt(we))
                return Z.plant(we).value();
              for (var Ce = 0, Le = v ? h[Ce].apply(this, xe) : we; ++Ce < v; )
                Le = h[Ce].call(this, Le);
              return Le;
            };
          });
        }
        function wn(o, h, v, R, N, H, Z, Q, se, xe) {
          var we = h & S, Ce = h & _, Le = h & T, Be = h & (b | C), Ve = h & M, it = Le ? t : ji(o);
          function He() {
            for (var st = arguments.length, ut = ce(st), sr = st; sr--; )
              ut[sr] = arguments[sr];
            if (Be)
              var Xt = Ei(He), or = tl(ut, Xt);
            if (R && (ut = co(ut, R, N, Be)), H && (ut = fo(ut, H, Z, Be)), st -= or, Be && st < xe) {
              var Ot = Vr(ut, Xt);
              return xo(
                o,
                h,
                wn,
                He.placeholder,
                v,
                ut,
                Ot,
                Q,
                se,
                xe - st
              );
            }
            var br = Ce ? v : this, $r = Le ? br[o] : o;
            return st = ut.length, Q ? ut = hc(ut, Q) : Ve && st > 1 && ut.reverse(), we && se < st && (ut.length = se), this && this !== $t && this instanceof He && ($r = it || ji($r)), $r.apply(br, ut);
          }
          return He;
        }
        function bo(o, h) {
          return function(v, R) {
            return yh(v, o, h(R), {});
          };
        }
        function En(o, h) {
          return function(v, R) {
            var N;
            if (v === t && R === t)
              return h;
            if (v !== t && (N = v), R !== t) {
              if (N === t)
                return R;
              typeof v == "string" || typeof R == "string" ? (v = nr(v), R = nr(R)) : (v = ro(v), R = ro(R)), N = o(v, R);
            }
            return N;
          };
        }
        function Ta(o) {
          return Nr(function(h) {
            return h = Tt(h, ir(Ge())), nt(function(v) {
              var R = this;
              return o(h, function(N) {
                return rr(N, R, v);
              });
            });
          });
        }
        function Tn(o, h) {
          h = h === t ? " " : nr(h);
          var v = h.length;
          if (v < 2)
            return v ? ga(h, o) : h;
          var R = ga(h, hn(o / mi(h)));
          return pi(h) ? Kr(vr(R), 0, o).join("") : R.slice(0, o);
        }
        function Vh(o, h, v, R) {
          var N = h & _, H = ji(o);
          function Z() {
            for (var Q = -1, se = arguments.length, xe = -1, we = R.length, Ce = ce(we + se), Le = this && this !== $t && this instanceof Z ? H : o; ++xe < we; )
              Ce[xe] = R[xe];
            for (; se--; )
              Ce[xe++] = arguments[++Q];
            return rr(Le, N ? v : this, Ce);
          }
          return Z;
        }
        function _o(o) {
          return function(h, v, R) {
            return R && typeof R != "number" && Wt(h, v, R) && (v = R = t), h = Br(h), v === t ? (v = h, h = 0) : v = Br(v), R = R === t ? h < v ? 1 : -1 : Br(R), Oh(h, v, R, o);
          };
        }
        function Cn(o) {
          return function(h, v) {
            return typeof h == "string" && typeof v == "string" || (h = mr(h), v = mr(v)), o(h, v);
          };
        }
        function xo(o, h, v, R, N, H, Z, Q, se, xe) {
          var we = h & b, Ce = we ? Z : t, Le = we ? t : Z, Be = we ? H : t, Ve = we ? t : H;
          h |= we ? w : A, h &= ~(we ? A : w), h & E || (h &= -4);
          var it = [
            o,
            h,
            N,
            Be,
            Ce,
            Ve,
            Le,
            Q,
            se,
            xe
          ], He = v.apply(t, it);
          return Pa(o) && qo(He, it), He.placeholder = R, ko(He, o, h);
        }
        function Ca(o) {
          var h = Lt[o];
          return function(v, R) {
            if (v = mr(v), R = R == null ? 0 : Gt(rt(R), 292), R && Ps(v)) {
              var N = (mt(v) + "e").split("e"), H = h(N[0] + "e" + (+N[1] + R));
              return N = (mt(H) + "e").split("e"), +(N[0] + "e" + (+N[1] - R));
            }
            return h(v);
          };
        }
        var Hh = yi && 1 / Qi(new yi([, -0]))[1] == I ? function(o) {
          return new yi(o);
        } : Wa;
        function wo(o) {
          return function(h) {
            var v = zt(h);
            return v == Pe ? ta(h) : v == Xe ? ul(h) : el(h, o(h));
          };
        }
        function Lr(o, h, v, R, N, H, Z, Q) {
          var se = h & T;
          if (!se && typeof o != "function")
            throw new hr(u);
          var xe = R ? R.length : 0;
          if (xe || (h &= -97, R = N = t), Z = Z === t ? Z : Nt(rt(Z), 0), Q = Q === t ? Q : rt(Q), xe -= N ? N.length : 0, h & A) {
            var we = R, Ce = N;
            R = N = t;
          }
          var Le = se ? t : Aa(o), Be = [
            o,
            h,
            v,
            R,
            N,
            we,
            Ce,
            H,
            Z,
            Q
          ];
          if (Le && oc(Be, Le), o = Be[0], h = Be[1], v = Be[2], R = Be[3], N = Be[4], Q = Be[9] = Be[9] === t ? se ? 0 : o.length : Nt(Be[9] - xe, 0), !Q && h & (b | C) && (h &= -25), !h || h == _)
            var Ve = Gh(o, h, v);
          else h == b || h == C ? Ve = zh(o, h, Q) : (h == w || h == (_ | w)) && !N.length ? Ve = Vh(o, h, v, R) : Ve = wn.apply(t, Be);
          var it = Le ? eo : qo;
          return ko(it(Ve, Be), o, h);
        }
        function Eo(o, h, v, R) {
          return o === t || yr(o, gi[v]) && !yt.call(R, v) ? h : o;
        }
        function To(o, h, v, R, N, H) {
          return St(o) && St(h) && (H.set(h, o), yn(o, h, t, To, H), H.delete(h)), o;
        }
        function Wh(o) {
          return zi(o) ? t : o;
        }
        function Co(o, h, v, R, N, H) {
          var Z = v & x, Q = o.length, se = h.length;
          if (Q != se && !(Z && se > Q))
            return false;
          var xe = H.get(o), we = H.get(h);
          if (xe && we)
            return xe == h && we == o;
          var Ce = -1, Le = true, Be = v & g ? new ii() : t;
          for (H.set(o, h), H.set(h, o); ++Ce < Q; ) {
            var Ve = o[Ce], it = h[Ce];
            if (R)
              var He = Z ? R(it, Ve, Ce, h, o, H) : R(Ve, it, Ce, o, h, H);
            if (He !== t) {
              if (He)
                continue;
              Le = false;
              break;
            }
            if (Be) {
              if (!Yn(h, function(st, ut) {
                if (!Oi(Be, ut) && (Ve === st || N(Ve, st, v, R, H)))
                  return Be.push(ut);
              })) {
                Le = false;
                break;
              }
            } else if (!(Ve === it || N(Ve, it, v, R, H))) {
              Le = false;
              break;
            }
          }
          return H.delete(o), H.delete(h), Le;
        }
        function Xh(o, h, v, R, N, H, Z) {
          switch (v) {
            case Y:
              if (o.byteLength != h.byteLength || o.byteOffset != h.byteOffset)
                return false;
              o = o.buffer, h = h.buffer;
            case $:
              return !(o.byteLength != h.byteLength || !H(new sn(o), new sn(h)));
            case me:
            case Te:
            case Ee:
              return yr(+o, +h);
            case ye:
              return o.name == h.name && o.message == h.message;
            case vt:
            case at:
              return o == h + "";
            case Pe:
              var Q = ta;
            case Xe:
              var se = R & x;
              if (Q || (Q = Qi), o.size != h.size && !se)
                return false;
              var xe = Z.get(o);
              if (xe)
                return xe == h;
              R |= g, Z.set(o, h);
              var we = Co(Q(o), Q(h), R, N, H, Z);
              return Z.delete(o), we;
            case ct:
              if (Li)
                return Li.call(o) == Li.call(h);
          }
          return false;
        }
        function Yh(o, h, v, R, N, H) {
          var Z = v & x, Q = Sa(o), se = Q.length, xe = Sa(h), we = xe.length;
          if (se != we && !Z)
            return false;
          for (var Ce = se; Ce--; ) {
            var Le = Q[Ce];
            if (!(Z ? Le in h : yt.call(h, Le)))
              return false;
          }
          var Be = H.get(o), Ve = H.get(h);
          if (Be && Ve)
            return Be == h && Ve == o;
          var it = true;
          H.set(o, h), H.set(h, o);
          for (var He = Z; ++Ce < se; ) {
            Le = Q[Ce];
            var st = o[Le], ut = h[Le];
            if (R)
              var sr = Z ? R(ut, st, Le, h, o, H) : R(st, ut, Le, o, h, H);
            if (!(sr === t ? st === ut || N(st, ut, v, R, H) : sr)) {
              it = false;
              break;
            }
            He || (He = Le == "constructor");
          }
          if (it && !He) {
            var Xt = o.constructor, or = h.constructor;
            Xt != or && "constructor" in o && "constructor" in h && !(typeof Xt == "function" && Xt instanceof Xt && typeof or == "function" && or instanceof or) && (it = false);
          }
          return H.delete(o), H.delete(h), it;
        }
        function Nr(o) {
          return ka(Io(o, t, $o), o + "");
        }
        function Sa(o) {
          return Gs(o, Bt, Oa);
        }
        function Ra(o) {
          return Gs(o, Jt, So);
        }
        var Aa = fn ? function(o) {
          return fn.get(o);
        } : Wa;
        function Sn(o) {
          for (var h = o.name + "", v = bi[h], R = yt.call(bi, h) ? v.length : 0; R--; ) {
            var N = v[R], H = N.func;
            if (H == null || H == o)
              return N.name;
          }
          return h;
        }
        function Ei(o) {
          var h = yt.call(j, "placeholder") ? j : o;
          return h.placeholder;
        }
        function Ge() {
          var o = j.iteratee || Va;
          return o = o === Va ? Hs : o, arguments.length ? o(arguments[0], arguments[1]) : o;
        }
        function Rn(o, h) {
          var v = o.__data__;
          return ic(h) ? v[typeof h == "string" ? "string" : "hash"] : v.map;
        }
        function Ma(o) {
          for (var h = Bt(o), v = h.length; v--; ) {
            var R = h[v], N = o[R];
            h[v] = [R, N, Mo(N)];
          }
          return h;
        }
        function si(o, h) {
          var v = al(o, h);
          return Vs(v) ? v : t;
        }
        function Kh(o) {
          var h = yt.call(o, ti), v = o[ti];
          try {
            o[ti] = t;
            var R = true;
          } catch {
          }
          var N = nn.call(o);
          return R && (h ? o[ti] = v : delete o[ti]), N;
        }
        var Oa = ia ? function(o) {
          return o == null ? [] : (o = _t(o), Gr(ia(o), function(h) {
            return Os.call(o, h);
          }));
        } : Xa, So = ia ? function(o) {
          for (var h = []; o; )
            zr(h, Oa(o)), o = on(o);
          return h;
        } : Xa, zt = Ht;
        (na && zt(new na(new ArrayBuffer(1))) != Y || Pi && zt(new Pi()) != Pe || aa && zt(aa.resolve()) != gt || yi && zt(new yi()) != Xe || qi && zt(new qi()) != It) && (zt = function(o) {
          var h = Ht(o), v = h == $e ? o.constructor : t, R = v ? oi(v) : "";
          if (R)
            switch (R) {
              case Pl:
                return Y;
              case ql:
                return Pe;
              case kl:
                return gt;
              case Ll:
                return Xe;
              case Nl:
                return It;
            }
          return h;
        });
        function Jh(o, h, v) {
          for (var R = -1, N = v.length; ++R < N; ) {
            var H = v[R], Z = H.size;
            switch (H.type) {
              case "drop":
                o += Z;
                break;
              case "dropRight":
                h -= Z;
                break;
              case "take":
                h = Gt(h, o + Z);
                break;
              case "takeRight":
                o = Nt(o, h - Z);
                break;
            }
          }
          return { start: o, end: h };
        }
        function Zh(o) {
          var h = o.match(xr);
          return h ? h[1].split(Mr) : [];
        }
        function Ro(o, h, v) {
          h = Yr(h, o);
          for (var R = -1, N = h.length, H = false; ++R < N; ) {
            var Z = Cr(h[R]);
            if (!(H = o != null && v(o, Z)))
              break;
            o = o[Z];
          }
          return H || ++R != N ? H : (N = o == null ? 0 : o.length, !!N && kn(N) && Dr(Z, N) && (tt(o) || ui(o)));
        }
        function Qh(o) {
          var h = o.length, v = new o.constructor(h);
          return h && typeof o[0] == "string" && yt.call(o, "index") && (v.index = o.index, v.input = o.input), v;
        }
        function Ao(o) {
          return typeof o.constructor == "function" && !Ui(o) ? _i(on(o)) : {};
        }
        function ec(o, h, v) {
          var R = o.constructor;
          switch (h) {
            case $:
              return Ea(o);
            case me:
            case Te:
              return new R(+o);
            case Y:
              return Dh(o, v);
            case ee:
            case be:
            case Se:
            case Ne:
            case je:
            case pt:
            case oe:
            case le:
            case Ue:
              return lo(o, v);
            case Pe:
              return new R();
            case Ee:
            case at:
              return new R(o);
            case vt:
              return Fh(o);
            case Xe:
              return new R();
            case ct:
              return Bh(o);
          }
        }
        function tc(o, h) {
          var v = h.length;
          if (!v)
            return o;
          var R = v - 1;
          return h[R] = (v > 1 ? "& " : "") + h[R], h = h.join(v > 2 ? ", " : " "), o.replace(wr, `{
/* [wrapped with ` + h + `] */
`);
        }
        function rc(o) {
          return tt(o) || ui(o) || !!(Is && o && o[Is]);
        }
        function Dr(o, h) {
          var v = typeof o;
          return h = h ?? P, !!h && (v == "number" || v != "symbol" && Ai.test(o)) && o > -1 && o % 1 == 0 && o < h;
        }
        function Wt(o, h, v) {
          if (!St(v))
            return false;
          var R = typeof h;
          return (R == "number" ? Kt(v) && Dr(h, v.length) : R == "string" && h in v) ? yr(v[h], o) : false;
        }
        function Ia(o, h) {
          if (tt(o))
            return false;
          var v = typeof o;
          return v == "number" || v == "symbol" || v == "boolean" || o == null || ar(o) ? true : Ar.test(o) || !kt.test(o) || h != null && o in _t(h);
        }
        function ic(o) {
          var h = typeof o;
          return h == "string" || h == "number" || h == "symbol" || h == "boolean" ? o !== "__proto__" : o === null;
        }
        function Pa(o) {
          var h = Sn(o), v = j[h];
          if (typeof v != "function" || !(h in ot.prototype))
            return false;
          if (o === v)
            return true;
          var R = Aa(v);
          return !!R && o === R[0];
        }
        function nc(o) {
          return !!Rs && Rs in o;
        }
        var ac = tn ? Fr : Ya;
        function Ui(o) {
          var h = o && o.constructor, v = typeof h == "function" && h.prototype || gi;
          return o === v;
        }
        function Mo(o) {
          return o === o && !St(o);
        }
        function Oo(o, h) {
          return function(v) {
            return v == null ? false : v[o] === h && (h !== t || o in _t(v));
          };
        }
        function sc(o) {
          var h = Pn(o, function(R) {
            return v.size === d && v.clear(), R;
          }), v = h.cache;
          return h;
        }
        function oc(o, h) {
          var v = o[1], R = h[1], N = v | R, H = N < (_ | T | S), Z = R == S && v == b || R == S && v == F && o[7].length <= h[8] || R == (S | F) && h[7].length <= h[8] && v == b;
          if (!(H || Z))
            return o;
          R & _ && (o[2] = h[2], N |= v & _ ? 0 : E);
          var Q = h[3];
          if (Q) {
            var se = o[3];
            o[3] = se ? co(se, Q, h[4]) : Q, o[4] = se ? Vr(o[3], f) : h[4];
          }
          return Q = h[5], Q && (se = o[5], o[5] = se ? fo(se, Q, h[6]) : Q, o[6] = se ? Vr(o[5], f) : h[6]), Q = h[7], Q && (o[7] = Q), R & S && (o[8] = o[8] == null ? h[8] : Gt(o[8], h[8])), o[9] == null && (o[9] = h[9]), o[0] = h[0], o[1] = N, o;
        }
        function uc(o) {
          var h = [];
          if (o != null)
            for (var v in _t(o))
              h.push(v);
          return h;
        }
        function lc(o) {
          return nn.call(o);
        }
        function Io(o, h, v) {
          return h = Nt(h === t ? o.length - 1 : h, 0), function() {
            for (var R = arguments, N = -1, H = Nt(R.length - h, 0), Z = ce(H); ++N < H; )
              Z[N] = R[h + N];
            N = -1;
            for (var Q = ce(h + 1); ++N < h; )
              Q[N] = R[N];
            return Q[h] = v(Z), rr(o, this, Q);
          };
        }
        function Po(o, h) {
          return h.length < 2 ? o : ai(o, dr(h, 0, -1));
        }
        function hc(o, h) {
          for (var v = o.length, R = Gt(h.length, v), N = Yt(o); R--; ) {
            var H = h[R];
            o[R] = Dr(H, v) ? N[H] : t;
          }
          return o;
        }
        function qa(o, h) {
          if (!(h === "constructor" && typeof o[h] == "function") && h != "__proto__")
            return o[h];
        }
        var qo = Lo(eo), Gi = Cl || function(o, h) {
          return $t.setTimeout(o, h);
        }, ka = Lo(qh);
        function ko(o, h, v) {
          var R = h + "";
          return ka(o, tc(R, cc(Zh(R), v)));
        }
        function Lo(o) {
          var h = 0, v = 0;
          return function() {
            var R = Ml(), N = z - (R - v);
            if (v = R, N > 0) {
              if (++h >= q)
                return arguments[0];
            } else
              h = 0;
            return o.apply(t, arguments);
          };
        }
        function An(o, h) {
          var v = -1, R = o.length, N = R - 1;
          for (h = h === t ? R : h; ++v < h; ) {
            var H = va(v, N), Z = o[H];
            o[H] = o[v], o[v] = Z;
          }
          return o.length = h, o;
        }
        var No = sc(function(o) {
          var h = [];
          return o.charCodeAt(0) === 46 && h.push(""), o.replace(Sr, function(v, R, N, H) {
            h.push(N ? H.replace(Rr, "$1") : R || v);
          }), h;
        });
        function Cr(o) {
          if (typeof o == "string" || ar(o))
            return o;
          var h = o + "";
          return h == "0" && 1 / o == -1 / 0 ? "-0" : h;
        }
        function oi(o) {
          if (o != null) {
            try {
              return rn.call(o);
            } catch {
            }
            try {
              return o + "";
            } catch {
            }
          }
          return "";
        }
        function cc(o, h) {
          return lr(ae, function(v) {
            var R = "_." + v[0];
            h & v[1] && !Ji(o, R) && o.push(R);
          }), o.sort();
        }
        function Do(o) {
          if (o instanceof ot)
            return o.clone();
          var h = new cr(o.__wrapped__, o.__chain__);
          return h.__actions__ = Yt(o.__actions__), h.__index__ = o.__index__, h.__values__ = o.__values__, h;
        }
        function fc(o, h, v) {
          (v ? Wt(o, h, v) : h === t) ? h = 1 : h = Nt(rt(h), 0);
          var R = o == null ? 0 : o.length;
          if (!R || h < 1)
            return [];
          for (var N = 0, H = 0, Z = ce(hn(R / h)); N < R; )
            Z[H++] = dr(o, N, N += h);
          return Z;
        }
        function dc(o) {
          for (var h = -1, v = o == null ? 0 : o.length, R = 0, N = []; ++h < v; ) {
            var H = o[h];
            H && (N[R++] = H);
          }
          return N;
        }
        function pc() {
          var o = arguments.length;
          if (!o)
            return [];
          for (var h = ce(o - 1), v = arguments[0], R = o; R--; )
            h[R - 1] = arguments[R];
          return zr(tt(v) ? Yt(v) : [v], jt(h, 1));
        }
        var mc = nt(function(o, h) {
          return Mt(o) ? Di(o, jt(h, 1, Mt, true)) : [];
        }), vc = nt(function(o, h) {
          var v = pr(h);
          return Mt(v) && (v = t), Mt(o) ? Di(o, jt(h, 1, Mt, true), Ge(v, 2)) : [];
        }), gc = nt(function(o, h) {
          var v = pr(h);
          return Mt(v) && (v = t), Mt(o) ? Di(o, jt(h, 1, Mt, true), t, v) : [];
        });
        function yc(o, h, v) {
          var R = o == null ? 0 : o.length;
          return R ? (h = v || h === t ? 1 : rt(h), dr(o, h < 0 ? 0 : h, R)) : [];
        }
        function bc(o, h, v) {
          var R = o == null ? 0 : o.length;
          return R ? (h = v || h === t ? 1 : rt(h), h = R - h, dr(o, 0, h < 0 ? 0 : h)) : [];
        }
        function _c(o, h) {
          return o && o.length ? _n(o, Ge(h, 3), true, true) : [];
        }
        function xc(o, h) {
          return o && o.length ? _n(o, Ge(h, 3), true) : [];
        }
        function wc(o, h, v, R) {
          var N = o == null ? 0 : o.length;
          return N ? (v && typeof v != "number" && Wt(o, h, v) && (v = 0, R = N), ph(o, h, v, R)) : [];
        }
        function Fo(o, h, v) {
          var R = o == null ? 0 : o.length;
          if (!R)
            return -1;
          var N = v == null ? 0 : rt(v);
          return N < 0 && (N = Nt(R + N, 0)), Zi(o, Ge(h, 3), N);
        }
        function Bo(o, h, v) {
          var R = o == null ? 0 : o.length;
          if (!R)
            return -1;
          var N = R - 1;
          return v !== t && (N = rt(v), N = v < 0 ? Nt(R + N, 0) : Gt(N, R - 1)), Zi(o, Ge(h, 3), N, true);
        }
        function $o(o) {
          var h = o == null ? 0 : o.length;
          return h ? jt(o, 1) : [];
        }
        function Ec(o) {
          var h = o == null ? 0 : o.length;
          return h ? jt(o, I) : [];
        }
        function Tc(o, h) {
          var v = o == null ? 0 : o.length;
          return v ? (h = h === t ? 1 : rt(h), jt(o, h)) : [];
        }
        function Cc(o) {
          for (var h = -1, v = o == null ? 0 : o.length, R = {}; ++h < v; ) {
            var N = o[h];
            R[N[0]] = N[1];
          }
          return R;
        }
        function jo(o) {
          return o && o.length ? o[0] : t;
        }
        function Sc(o, h, v) {
          var R = o == null ? 0 : o.length;
          if (!R)
            return -1;
          var N = v == null ? 0 : rt(v);
          return N < 0 && (N = Nt(R + N, 0)), di(o, h, N);
        }
        function Rc(o) {
          var h = o == null ? 0 : o.length;
          return h ? dr(o, 0, -1) : [];
        }
        var Ac = nt(function(o) {
          var h = Tt(o, xa);
          return h.length && h[0] === o[0] ? ca(h) : [];
        }), Mc = nt(function(o) {
          var h = pr(o), v = Tt(o, xa);
          return h === pr(v) ? h = t : v.pop(), v.length && v[0] === o[0] ? ca(v, Ge(h, 2)) : [];
        }), Oc = nt(function(o) {
          var h = pr(o), v = Tt(o, xa);
          return h = typeof h == "function" ? h : t, h && v.pop(), v.length && v[0] === o[0] ? ca(v, t, h) : [];
        });
        function Ic(o, h) {
          return o == null ? "" : Rl.call(o, h);
        }
        function pr(o) {
          var h = o == null ? 0 : o.length;
          return h ? o[h - 1] : t;
        }
        function Pc(o, h, v) {
          var R = o == null ? 0 : o.length;
          if (!R)
            return -1;
          var N = R;
          return v !== t && (N = rt(v), N = N < 0 ? Nt(R + N, 0) : Gt(N, R - 1)), h === h ? hl(o, h, N) : Zi(o, bs, N, true);
        }
        function qc(o, h) {
          return o && o.length ? Ks(o, rt(h)) : t;
        }
        var kc = nt(Uo);
        function Uo(o, h) {
          return o && o.length && h && h.length ? ma(o, h) : o;
        }
        function Lc(o, h, v) {
          return o && o.length && h && h.length ? ma(o, h, Ge(v, 2)) : o;
        }
        function Nc(o, h, v) {
          return o && o.length && h && h.length ? ma(o, h, t, v) : o;
        }
        var Dc = Nr(function(o, h) {
          var v = o == null ? 0 : o.length, R = oa(o, h);
          return Qs(o, Tt(h, function(N) {
            return Dr(N, v) ? +N : N;
          }).sort(ho)), R;
        });
        function Fc(o, h) {
          var v = [];
          if (!(o && o.length))
            return v;
          var R = -1, N = [], H = o.length;
          for (h = Ge(h, 3); ++R < H; ) {
            var Z = o[R];
            h(Z, R, o) && (v.push(Z), N.push(R));
          }
          return Qs(o, N), v;
        }
        function La(o) {
          return o == null ? o : Il.call(o);
        }
        function Bc(o, h, v) {
          var R = o == null ? 0 : o.length;
          return R ? (v && typeof v != "number" && Wt(o, h, v) ? (h = 0, v = R) : (h = h == null ? 0 : rt(h), v = v === t ? R : rt(v)), dr(o, h, v)) : [];
        }
        function $c(o, h) {
          return bn(o, h);
        }
        function jc(o, h, v) {
          return ya(o, h, Ge(v, 2));
        }
        function Uc(o, h) {
          var v = o == null ? 0 : o.length;
          if (v) {
            var R = bn(o, h);
            if (R < v && yr(o[R], h))
              return R;
          }
          return -1;
        }
        function Gc(o, h) {
          return bn(o, h, true);
        }
        function zc(o, h, v) {
          return ya(o, h, Ge(v, 2), true);
        }
        function Vc(o, h) {
          var v = o == null ? 0 : o.length;
          if (v) {
            var R = bn(o, h, true) - 1;
            if (yr(o[R], h))
              return R;
          }
          return -1;
        }
        function Hc(o) {
          return o && o.length ? to(o) : [];
        }
        function Wc(o, h) {
          return o && o.length ? to(o, Ge(h, 2)) : [];
        }
        function Xc(o) {
          var h = o == null ? 0 : o.length;
          return h ? dr(o, 1, h) : [];
        }
        function Yc(o, h, v) {
          return o && o.length ? (h = v || h === t ? 1 : rt(h), dr(o, 0, h < 0 ? 0 : h)) : [];
        }
        function Kc(o, h, v) {
          var R = o == null ? 0 : o.length;
          return R ? (h = v || h === t ? 1 : rt(h), h = R - h, dr(o, h < 0 ? 0 : h, R)) : [];
        }
        function Jc(o, h) {
          return o && o.length ? _n(o, Ge(h, 3), false, true) : [];
        }
        function Zc(o, h) {
          return o && o.length ? _n(o, Ge(h, 3)) : [];
        }
        var Qc = nt(function(o) {
          return Xr(jt(o, 1, Mt, true));
        }), ef = nt(function(o) {
          var h = pr(o);
          return Mt(h) && (h = t), Xr(jt(o, 1, Mt, true), Ge(h, 2));
        }), tf = nt(function(o) {
          var h = pr(o);
          return h = typeof h == "function" ? h : t, Xr(jt(o, 1, Mt, true), t, h);
        });
        function rf(o) {
          return o && o.length ? Xr(o) : [];
        }
        function nf(o, h) {
          return o && o.length ? Xr(o, Ge(h, 2)) : [];
        }
        function af(o, h) {
          return h = typeof h == "function" ? h : t, o && o.length ? Xr(o, t, h) : [];
        }
        function Na(o) {
          if (!(o && o.length))
            return [];
          var h = 0;
          return o = Gr(o, function(v) {
            if (Mt(v))
              return h = Nt(v.length, h), true;
          }), Qn(h, function(v) {
            return Tt(o, Kn(v));
          });
        }
        function Go(o, h) {
          if (!(o && o.length))
            return [];
          var v = Na(o);
          return h == null ? v : Tt(v, function(R) {
            return rr(h, t, R);
          });
        }
        var sf = nt(function(o, h) {
          return Mt(o) ? Di(o, h) : [];
        }), of = nt(function(o) {
          return _a(Gr(o, Mt));
        }), uf = nt(function(o) {
          var h = pr(o);
          return Mt(h) && (h = t), _a(Gr(o, Mt), Ge(h, 2));
        }), lf = nt(function(o) {
          var h = pr(o);
          return h = typeof h == "function" ? h : t, _a(Gr(o, Mt), t, h);
        }), hf = nt(Na);
        function cf(o, h) {
          return so(o || [], h || [], Ni);
        }
        function ff(o, h) {
          return so(o || [], h || [], $i);
        }
        var df = nt(function(o) {
          var h = o.length, v = h > 1 ? o[h - 1] : t;
          return v = typeof v == "function" ? (o.pop(), v) : t, Go(o, v);
        });
        function zo(o) {
          var h = j(o);
          return h.__chain__ = true, h;
        }
        function pf(o, h) {
          return h(o), o;
        }
        function Mn(o, h) {
          return h(o);
        }
        var mf = Nr(function(o) {
          var h = o.length, v = h ? o[0] : 0, R = this.__wrapped__, N = function(H) {
            return oa(H, o);
          };
          return h > 1 || this.__actions__.length || !(R instanceof ot) || !Dr(v) ? this.thru(N) : (R = R.slice(v, +v + (h ? 1 : 0)), R.__actions__.push({
            func: Mn,
            args: [N],
            thisArg: t
          }), new cr(R, this.__chain__).thru(function(H) {
            return h && !H.length && H.push(t), H;
          }));
        });
        function vf() {
          return zo(this);
        }
        function gf() {
          return new cr(this.value(), this.__chain__);
        }
        function yf() {
          this.__values__ === t && (this.__values__ = nu(this.value()));
          var o = this.__index__ >= this.__values__.length, h = o ? t : this.__values__[this.__index__++];
          return { done: o, value: h };
        }
        function bf() {
          return this;
        }
        function _f(o) {
          for (var h, v = this; v instanceof pn; ) {
            var R = Do(v);
            R.__index__ = 0, R.__values__ = t, h ? N.__wrapped__ = R : h = R;
            var N = R;
            v = v.__wrapped__;
          }
          return N.__wrapped__ = o, h;
        }
        function xf() {
          var o = this.__wrapped__;
          if (o instanceof ot) {
            var h = o;
            return this.__actions__.length && (h = new ot(this)), h = h.reverse(), h.__actions__.push({
              func: Mn,
              args: [La],
              thisArg: t
            }), new cr(h, this.__chain__);
          }
          return this.thru(La);
        }
        function wf() {
          return ao(this.__wrapped__, this.__actions__);
        }
        var Ef = xn(function(o, h, v) {
          yt.call(o, v) ? ++o[v] : kr(o, v, 1);
        });
        function Tf(o, h, v) {
          var R = tt(o) ? gs : dh;
          return v && Wt(o, h, v) && (h = t), R(o, Ge(h, 3));
        }
        function Cf(o, h) {
          var v = tt(o) ? Gr : js;
          return v(o, Ge(h, 3));
        }
        var Sf = go(Fo), Rf = go(Bo);
        function Af(o, h) {
          return jt(On(o, h), 1);
        }
        function Mf(o, h) {
          return jt(On(o, h), I);
        }
        function Of(o, h, v) {
          return v = v === t ? 1 : rt(v), jt(On(o, h), v);
        }
        function Vo(o, h) {
          var v = tt(o) ? lr : Wr;
          return v(o, Ge(h, 3));
        }
        function Ho(o, h) {
          var v = tt(o) ? Wu : $s;
          return v(o, Ge(h, 3));
        }
        var If = xn(function(o, h, v) {
          yt.call(o, v) ? o[v].push(h) : kr(o, v, [h]);
        });
        function Pf(o, h, v, R) {
          o = Kt(o) ? o : Ci(o), v = v && !R ? rt(v) : 0;
          var N = o.length;
          return v < 0 && (v = Nt(N + v, 0)), Ln(o) ? v <= N && o.indexOf(h, v) > -1 : !!N && di(o, h, v) > -1;
        }
        var qf = nt(function(o, h, v) {
          var R = -1, N = typeof h == "function", H = Kt(o) ? ce(o.length) : [];
          return Wr(o, function(Z) {
            H[++R] = N ? rr(h, Z, v) : Fi(Z, h, v);
          }), H;
        }), kf = xn(function(o, h, v) {
          kr(o, v, h);
        });
        function On(o, h) {
          var v = tt(o) ? Tt : Ws;
          return v(o, Ge(h, 3));
        }
        function Lf(o, h, v, R) {
          return o == null ? [] : (tt(h) || (h = h == null ? [] : [h]), v = R ? t : v, tt(v) || (v = v == null ? [] : [v]), Js(o, h, v));
        }
        var Nf = xn(function(o, h, v) {
          o[v ? 0 : 1].push(h);
        }, function() {
          return [[], []];
        });
        function Df(o, h, v) {
          var R = tt(o) ? Xn : xs, N = arguments.length < 3;
          return R(o, Ge(h, 4), v, N, Wr);
        }
        function Ff(o, h, v) {
          var R = tt(o) ? Xu : xs, N = arguments.length < 3;
          return R(o, Ge(h, 4), v, N, $s);
        }
        function Bf(o, h) {
          var v = tt(o) ? Gr : js;
          return v(o, qn(Ge(h, 3)));
        }
        function $f(o) {
          var h = tt(o) ? Ns : Ih;
          return h(o);
        }
        function jf(o, h, v) {
          (v ? Wt(o, h, v) : h === t) ? h = 1 : h = rt(h);
          var R = tt(o) ? uh : Ph;
          return R(o, h);
        }
        function Uf(o) {
          var h = tt(o) ? lh : kh;
          return h(o);
        }
        function Gf(o) {
          if (o == null)
            return 0;
          if (Kt(o))
            return Ln(o) ? mi(o) : o.length;
          var h = zt(o);
          return h == Pe || h == Xe ? o.size : da(o).length;
        }
        function zf(o, h, v) {
          var R = tt(o) ? Yn : Lh;
          return v && Wt(o, h, v) && (h = t), R(o, Ge(h, 3));
        }
        var Vf = nt(function(o, h) {
          if (o == null)
            return [];
          var v = h.length;
          return v > 1 && Wt(o, h[0], h[1]) ? h = [] : v > 2 && Wt(h[0], h[1], h[2]) && (h = [h[0]]), Js(o, jt(h, 1), []);
        }), In = Tl || function() {
          return $t.Date.now();
        };
        function Hf(o, h) {
          if (typeof h != "function")
            throw new hr(u);
          return o = rt(o), function() {
            if (--o < 1)
              return h.apply(this, arguments);
          };
        }
        function Wo(o, h, v) {
          return h = v ? t : h, h = o && h == null ? o.length : h, Lr(o, S, t, t, t, t, h);
        }
        function Xo(o, h) {
          var v;
          if (typeof h != "function")
            throw new hr(u);
          return o = rt(o), function() {
            return --o > 0 && (v = h.apply(this, arguments)), o <= 1 && (h = t), v;
          };
        }
        var Da = nt(function(o, h, v) {
          var R = _;
          if (v.length) {
            var N = Vr(v, Ei(Da));
            R |= w;
          }
          return Lr(o, R, h, v, N);
        }), Yo = nt(function(o, h, v) {
          var R = _ | T;
          if (v.length) {
            var N = Vr(v, Ei(Yo));
            R |= w;
          }
          return Lr(h, R, o, v, N);
        });
        function Ko(o, h, v) {
          h = v ? t : h;
          var R = Lr(o, b, t, t, t, t, t, h);
          return R.placeholder = Ko.placeholder, R;
        }
        function Jo(o, h, v) {
          h = v ? t : h;
          var R = Lr(o, C, t, t, t, t, t, h);
          return R.placeholder = Jo.placeholder, R;
        }
        function Zo(o, h, v) {
          var R, N, H, Z, Q, se, xe = 0, we = false, Ce = false, Le = true;
          if (typeof o != "function")
            throw new hr(u);
          h = mr(h) || 0, St(v) && (we = !!v.leading, Ce = "maxWait" in v, H = Ce ? Nt(mr(v.maxWait) || 0, h) : H, Le = "trailing" in v ? !!v.trailing : Le);
          function Be(Ot) {
            var br = R, $r = N;
            return R = N = t, xe = Ot, Z = o.apply($r, br), Z;
          }
          function Ve(Ot) {
            return xe = Ot, Q = Gi(st, h), we ? Be(Ot) : Z;
          }
          function it(Ot) {
            var br = Ot - se, $r = Ot - xe, gu = h - br;
            return Ce ? Gt(gu, H - $r) : gu;
          }
          function He(Ot) {
            var br = Ot - se, $r = Ot - xe;
            return se === t || br >= h || br < 0 || Ce && $r >= H;
          }
          function st() {
            var Ot = In();
            if (He(Ot))
              return ut(Ot);
            Q = Gi(st, it(Ot));
          }
          function ut(Ot) {
            return Q = t, Le && R ? Be(Ot) : (R = N = t, Z);
          }
          function sr() {
            Q !== t && oo(Q), xe = 0, R = se = N = Q = t;
          }
          function Xt() {
            return Q === t ? Z : ut(In());
          }
          function or() {
            var Ot = In(), br = He(Ot);
            if (R = arguments, N = this, se = Ot, br) {
              if (Q === t)
                return Ve(se);
              if (Ce)
                return oo(Q), Q = Gi(st, h), Be(se);
            }
            return Q === t && (Q = Gi(st, h)), Z;
          }
          return or.cancel = sr, or.flush = Xt, or;
        }
        var Wf = nt(function(o, h) {
          return Bs(o, 1, h);
        }), Xf = nt(function(o, h, v) {
          return Bs(o, mr(h) || 0, v);
        });
        function Yf(o) {
          return Lr(o, M);
        }
        function Pn(o, h) {
          if (typeof o != "function" || h != null && typeof h != "function")
            throw new hr(u);
          var v = function() {
            var R = arguments, N = h ? h.apply(this, R) : R[0], H = v.cache;
            if (H.has(N))
              return H.get(N);
            var Z = o.apply(this, R);
            return v.cache = H.set(N, Z) || H, Z;
          };
          return v.cache = new (Pn.Cache || qr)(), v;
        }
        Pn.Cache = qr;
        function qn(o) {
          if (typeof o != "function")
            throw new hr(u);
          return function() {
            var h = arguments;
            switch (h.length) {
              case 0:
                return !o.call(this);
              case 1:
                return !o.call(this, h[0]);
              case 2:
                return !o.call(this, h[0], h[1]);
              case 3:
                return !o.call(this, h[0], h[1], h[2]);
            }
            return !o.apply(this, h);
          };
        }
        function Kf(o) {
          return Xo(2, o);
        }
        var Jf = Nh(function(o, h) {
          h = h.length == 1 && tt(h[0]) ? Tt(h[0], ir(Ge())) : Tt(jt(h, 1), ir(Ge()));
          var v = h.length;
          return nt(function(R) {
            for (var N = -1, H = Gt(R.length, v); ++N < H; )
              R[N] = h[N].call(this, R[N]);
            return rr(o, this, R);
          });
        }), Fa = nt(function(o, h) {
          var v = Vr(h, Ei(Fa));
          return Lr(o, w, t, h, v);
        }), Qo = nt(function(o, h) {
          var v = Vr(h, Ei(Qo));
          return Lr(o, A, t, h, v);
        }), Zf = Nr(function(o, h) {
          return Lr(o, F, t, t, t, h);
        });
        function Qf(o, h) {
          if (typeof o != "function")
            throw new hr(u);
          return h = h === t ? h : rt(h), nt(o, h);
        }
        function ed(o, h) {
          if (typeof o != "function")
            throw new hr(u);
          return h = h == null ? 0 : Nt(rt(h), 0), nt(function(v) {
            var R = v[h], N = Kr(v, 0, h);
            return R && zr(N, R), rr(o, this, N);
          });
        }
        function td(o, h, v) {
          var R = true, N = true;
          if (typeof o != "function")
            throw new hr(u);
          return St(v) && (R = "leading" in v ? !!v.leading : R, N = "trailing" in v ? !!v.trailing : N), Zo(o, h, {
            leading: R,
            maxWait: h,
            trailing: N
          });
        }
        function rd(o) {
          return Wo(o, 1);
        }
        function id(o, h) {
          return Fa(wa(h), o);
        }
        function nd() {
          if (!arguments.length)
            return [];
          var o = arguments[0];
          return tt(o) ? o : [o];
        }
        function ad(o) {
          return fr(o, y);
        }
        function sd(o, h) {
          return h = typeof h == "function" ? h : t, fr(o, y, h);
        }
        function od(o) {
          return fr(o, p | y);
        }
        function ud(o, h) {
          return h = typeof h == "function" ? h : t, fr(o, p | y, h);
        }
        function ld(o, h) {
          return h == null || Fs(o, h, Bt(h));
        }
        function yr(o, h) {
          return o === h || o !== o && h !== h;
        }
        var hd = Cn(ha), cd = Cn(function(o, h) {
          return o >= h;
        }), ui = zs(/* @__PURE__ */ function() {
          return arguments;
        }()) ? zs : function(o) {
          return At(o) && yt.call(o, "callee") && !Os.call(o, "callee");
        }, tt = ce.isArray, fd = cs ? ir(cs) : bh;
        function Kt(o) {
          return o != null && kn(o.length) && !Fr(o);
        }
        function Mt(o) {
          return At(o) && Kt(o);
        }
        function dd(o) {
          return o === true || o === false || At(o) && Ht(o) == me;
        }
        var Jr = Sl || Ya, pd = fs ? ir(fs) : _h;
        function md(o) {
          return At(o) && o.nodeType === 1 && !zi(o);
        }
        function vd(o) {
          if (o == null)
            return true;
          if (Kt(o) && (tt(o) || typeof o == "string" || typeof o.splice == "function" || Jr(o) || Ti(o) || ui(o)))
            return !o.length;
          var h = zt(o);
          if (h == Pe || h == Xe)
            return !o.size;
          if (Ui(o))
            return !da(o).length;
          for (var v in o)
            if (yt.call(o, v))
              return false;
          return true;
        }
        function gd(o, h) {
          return Bi(o, h);
        }
        function yd(o, h, v) {
          v = typeof v == "function" ? v : t;
          var R = v ? v(o, h) : t;
          return R === t ? Bi(o, h, t, v) : !!R;
        }
        function Ba(o) {
          if (!At(o))
            return false;
          var h = Ht(o);
          return h == ye || h == _e || typeof o.message == "string" && typeof o.name == "string" && !zi(o);
        }
        function bd(o) {
          return typeof o == "number" && Ps(o);
        }
        function Fr(o) {
          if (!St(o))
            return false;
          var h = Ht(o);
          return h == Ae || h == ke || h == ge || h == xt;
        }
        function eu(o) {
          return typeof o == "number" && o == rt(o);
        }
        function kn(o) {
          return typeof o == "number" && o > -1 && o % 1 == 0 && o <= P;
        }
        function St(o) {
          var h = typeof o;
          return o != null && (h == "object" || h == "function");
        }
        function At(o) {
          return o != null && typeof o == "object";
        }
        var tu = ds ? ir(ds) : wh;
        function _d(o, h) {
          return o === h || fa(o, h, Ma(h));
        }
        function xd(o, h, v) {
          return v = typeof v == "function" ? v : t, fa(o, h, Ma(h), v);
        }
        function wd(o) {
          return ru(o) && o != +o;
        }
        function Ed(o) {
          if (ac(o))
            throw new Qe(s);
          return Vs(o);
        }
        function Td(o) {
          return o === null;
        }
        function Cd(o) {
          return o == null;
        }
        function ru(o) {
          return typeof o == "number" || At(o) && Ht(o) == Ee;
        }
        function zi(o) {
          if (!At(o) || Ht(o) != $e)
            return false;
          var h = on(o);
          if (h === null)
            return true;
          var v = yt.call(h, "constructor") && h.constructor;
          return typeof v == "function" && v instanceof v && rn.call(v) == _l;
        }
        var $a = ps ? ir(ps) : Eh;
        function Sd(o) {
          return eu(o) && o >= -9007199254740991 && o <= P;
        }
        var iu = ms ? ir(ms) : Th;
        function Ln(o) {
          return typeof o == "string" || !tt(o) && At(o) && Ht(o) == at;
        }
        function ar(o) {
          return typeof o == "symbol" || At(o) && Ht(o) == ct;
        }
        var Ti = vs ? ir(vs) : Ch;
        function Rd(o) {
          return o === t;
        }
        function Ad(o) {
          return At(o) && zt(o) == It;
        }
        function Md(o) {
          return At(o) && Ht(o) == er;
        }
        var Od = Cn(pa), Id = Cn(function(o, h) {
          return o <= h;
        });
        function nu(o) {
          if (!o)
            return [];
          if (Kt(o))
            return Ln(o) ? vr(o) : Yt(o);
          if (Ii && o[Ii])
            return ol(o[Ii]());
          var h = zt(o), v = h == Pe ? ta : h == Xe ? Qi : Ci;
          return v(o);
        }
        function Br(o) {
          if (!o)
            return o === 0 ? o : 0;
          if (o = mr(o), o === I || o === -1 / 0) {
            var h = o < 0 ? -1 : 1;
            return h * G;
          }
          return o === o ? o : 0;
        }
        function rt(o) {
          var h = Br(o), v = h % 1;
          return h === h ? v ? h - v : h : 0;
        }
        function au(o) {
          return o ? ni(rt(o), 0, V) : 0;
        }
        function mr(o) {
          if (typeof o == "number")
            return o;
          if (ar(o))
            return W;
          if (St(o)) {
            var h = typeof o.valueOf == "function" ? o.valueOf() : o;
            o = St(h) ? h + "" : h;
          }
          if (typeof o != "string")
            return o === 0 ? o : +o;
          o = ws(o);
          var v = Ir.test(o);
          return v || Xi.test(o) ? zu(o.slice(2), v ? 2 : 8) : fi.test(o) ? W : +o;
        }
        function su(o) {
          return Tr(o, Jt(o));
        }
        function Pd(o) {
          return o ? ni(rt(o), -9007199254740991, P) : o === 0 ? o : 0;
        }
        function mt(o) {
          return o == null ? "" : nr(o);
        }
        var qd = xi(function(o, h) {
          if (Ui(h) || Kt(h)) {
            Tr(h, Bt(h), o);
            return;
          }
          for (var v in h)
            yt.call(h, v) && Ni(o, v, h[v]);
        }), ou = xi(function(o, h) {
          Tr(h, Jt(h), o);
        }), Nn = xi(function(o, h, v, R) {
          Tr(h, Jt(h), o, R);
        }), kd = xi(function(o, h, v, R) {
          Tr(h, Bt(h), o, R);
        }), Ld = Nr(oa);
        function Nd(o, h) {
          var v = _i(o);
          return h == null ? v : Ds(v, h);
        }
        var Dd = nt(function(o, h) {
          o = _t(o);
          var v = -1, R = h.length, N = R > 2 ? h[2] : t;
          for (N && Wt(h[0], h[1], N) && (R = 1); ++v < R; )
            for (var H = h[v], Z = Jt(H), Q = -1, se = Z.length; ++Q < se; ) {
              var xe = Z[Q], we = o[xe];
              (we === t || yr(we, gi[xe]) && !yt.call(o, xe)) && (o[xe] = H[xe]);
            }
          return o;
        }), Fd = nt(function(o) {
          return o.push(t, To), rr(uu, t, o);
        });
        function Bd(o, h) {
          return ys(o, Ge(h, 3), Er);
        }
        function $d(o, h) {
          return ys(o, Ge(h, 3), la);
        }
        function jd(o, h) {
          return o == null ? o : ua(o, Ge(h, 3), Jt);
        }
        function Ud(o, h) {
          return o == null ? o : Us(o, Ge(h, 3), Jt);
        }
        function Gd(o, h) {
          return o && Er(o, Ge(h, 3));
        }
        function zd(o, h) {
          return o && la(o, Ge(h, 3));
        }
        function Vd(o) {
          return o == null ? [] : gn(o, Bt(o));
        }
        function Hd(o) {
          return o == null ? [] : gn(o, Jt(o));
        }
        function ja(o, h, v) {
          var R = o == null ? t : ai(o, h);
          return R === t ? v : R;
        }
        function Wd(o, h) {
          return o != null && Ro(o, h, mh);
        }
        function Ua(o, h) {
          return o != null && Ro(o, h, vh);
        }
        var Xd = bo(function(o, h, v) {
          h != null && typeof h.toString != "function" && (h = nn.call(h)), o[h] = v;
        }, za(Zt)), Yd = bo(function(o, h, v) {
          h != null && typeof h.toString != "function" && (h = nn.call(h)), yt.call(o, h) ? o[h].push(v) : o[h] = [v];
        }, Ge), Kd = nt(Fi);
        function Bt(o) {
          return Kt(o) ? Ls(o) : da(o);
        }
        function Jt(o) {
          return Kt(o) ? Ls(o, true) : Sh(o);
        }
        function Jd(o, h) {
          var v = {};
          return h = Ge(h, 3), Er(o, function(R, N, H) {
            kr(v, h(R, N, H), R);
          }), v;
        }
        function Zd(o, h) {
          var v = {};
          return h = Ge(h, 3), Er(o, function(R, N, H) {
            kr(v, N, h(R, N, H));
          }), v;
        }
        var Qd = xi(function(o, h, v) {
          yn(o, h, v);
        }), uu = xi(function(o, h, v, R) {
          yn(o, h, v, R);
        }), ep = Nr(function(o, h) {
          var v = {};
          if (o == null)
            return v;
          var R = false;
          h = Tt(h, function(H) {
            return H = Yr(H, o), R || (R = H.length > 1), H;
          }), Tr(o, Ra(o), v), R && (v = fr(v, p | m | y, Wh));
          for (var N = h.length; N--; )
            ba(v, h[N]);
          return v;
        });
        function tp(o, h) {
          return lu(o, qn(Ge(h)));
        }
        var rp = Nr(function(o, h) {
          return o == null ? {} : Ah(o, h);
        });
        function lu(o, h) {
          if (o == null)
            return {};
          var v = Tt(Ra(o), function(R) {
            return [R];
          });
          return h = Ge(h), Zs(o, v, function(R, N) {
            return h(R, N[0]);
          });
        }
        function ip(o, h, v) {
          h = Yr(h, o);
          var R = -1, N = h.length;
          for (N || (N = 1, o = t); ++R < N; ) {
            var H = o == null ? t : o[Cr(h[R])];
            H === t && (R = N, H = v), o = Fr(H) ? H.call(o) : H;
          }
          return o;
        }
        function np(o, h, v) {
          return o == null ? o : $i(o, h, v);
        }
        function ap(o, h, v, R) {
          return R = typeof R == "function" ? R : t, o == null ? o : $i(o, h, v, R);
        }
        var hu = wo(Bt), cu = wo(Jt);
        function sp(o, h, v) {
          var R = tt(o), N = R || Jr(o) || Ti(o);
          if (h = Ge(h, 4), v == null) {
            var H = o && o.constructor;
            N ? v = R ? new H() : [] : St(o) ? v = Fr(H) ? _i(on(o)) : {} : v = {};
          }
          return (N ? lr : Er)(o, function(Z, Q, se) {
            return h(v, Z, Q, se);
          }), v;
        }
        function op(o, h) {
          return o == null ? true : ba(o, h);
        }
        function up(o, h, v) {
          return o == null ? o : io(o, h, wa(v));
        }
        function lp(o, h, v, R) {
          return R = typeof R == "function" ? R : t, o == null ? o : io(o, h, wa(v), R);
        }
        function Ci(o) {
          return o == null ? [] : ea(o, Bt(o));
        }
        function hp(o) {
          return o == null ? [] : ea(o, Jt(o));
        }
        function cp(o, h, v) {
          return v === t && (v = h, h = t), v !== t && (v = mr(v), v = v === v ? v : 0), h !== t && (h = mr(h), h = h === h ? h : 0), ni(mr(o), h, v);
        }
        function fp(o, h, v) {
          return h = Br(h), v === t ? (v = h, h = 0) : v = Br(v), o = mr(o), gh(o, h, v);
        }
        function dp(o, h, v) {
          if (v && typeof v != "boolean" && Wt(o, h, v) && (h = v = t), v === t && (typeof h == "boolean" ? (v = h, h = t) : typeof o == "boolean" && (v = o, o = t)), o === t && h === t ? (o = 0, h = 1) : (o = Br(o), h === t ? (h = o, o = 0) : h = Br(h)), o > h) {
            var R = o;
            o = h, h = R;
          }
          if (v || o % 1 || h % 1) {
            var N = qs();
            return Gt(o + N * (h - o + Gu("1e-" + ((N + "").length - 1))), h);
          }
          return va(o, h);
        }
        var pp = wi(function(o, h, v) {
          return h = h.toLowerCase(), o + (v ? fu(h) : h);
        });
        function fu(o) {
          return Ga(mt(o).toLowerCase());
        }
        function du(o) {
          return o = mt(o), o && o.replace(rs, rl).replace(qu, "");
        }
        function mp(o, h, v) {
          o = mt(o), h = nr(h);
          var R = o.length;
          v = v === t ? R : ni(rt(v), 0, R);
          var N = v;
          return v -= h.length, v >= 0 && o.slice(v, N) == h;
        }
        function vp(o) {
          return o = mt(o), o && qe.test(o) ? o.replace(ne, il) : o;
        }
        function gp(o) {
          return o = mt(o), o && jr.test(o) ? o.replace(Vt, "\\$&") : o;
        }
        var yp = wi(function(o, h, v) {
          return o + (v ? "-" : "") + h.toLowerCase();
        }), bp = wi(function(o, h, v) {
          return o + (v ? " " : "") + h.toLowerCase();
        }), _p = vo("toLowerCase");
        function xp(o, h, v) {
          o = mt(o), h = rt(h);
          var R = h ? mi(o) : 0;
          if (!h || R >= h)
            return o;
          var N = (h - R) / 2;
          return Tn(cn(N), v) + o + Tn(hn(N), v);
        }
        function wp(o, h, v) {
          o = mt(o), h = rt(h);
          var R = h ? mi(o) : 0;
          return h && R < h ? o + Tn(h - R, v) : o;
        }
        function Ep(o, h, v) {
          o = mt(o), h = rt(h);
          var R = h ? mi(o) : 0;
          return h && R < h ? Tn(h - R, v) + o : o;
        }
        function Tp(o, h, v) {
          return v || h == null ? h = 0 : h && (h = +h), Ol(mt(o).replace(tr, ""), h || 0);
        }
        function Cp(o, h, v) {
          return (v ? Wt(o, h, v) : h === t) ? h = 1 : h = rt(h), ga(mt(o), h);
        }
        function Sp() {
          var o = arguments, h = mt(o[0]);
          return o.length < 3 ? h : h.replace(o[1], o[2]);
        }
        var Rp = wi(function(o, h, v) {
          return o + (v ? "_" : "") + h.toLowerCase();
        });
        function Ap(o, h, v) {
          return v && typeof v != "number" && Wt(o, h, v) && (h = v = t), v = v === t ? V : v >>> 0, v ? (o = mt(o), o && (typeof h == "string" || h != null && !$a(h)) && (h = nr(h), !h && pi(o)) ? Kr(vr(o), 0, v) : o.split(h, v)) : [];
        }
        var Mp = wi(function(o, h, v) {
          return o + (v ? " " : "") + Ga(h);
        });
        function Op(o, h, v) {
          return o = mt(o), v = v == null ? 0 : ni(rt(v), 0, o.length), h = nr(h), o.slice(v, v + h.length) == h;
        }
        function Ip(o, h, v) {
          var R = j.templateSettings;
          v && Wt(o, h, v) && (h = t), o = mt(o), h = Nn({}, h, R, Eo);
          var N = Nn({}, h.imports, R.imports, Eo), H = Bt(N), Z = ea(N, H), Q, se, xe = 0, we = h.interpolate || Mi, Ce = "__p += '", Le = ra(
            (h.escape || Mi).source + "|" + we.source + "|" + (we === bt ? ci : Mi).source + "|" + (h.evaluate || Mi).source + "|$",
            "g"
          ), Be = "//# sourceURL=" + (yt.call(h, "sourceURL") ? (h.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++Fu + "]") + `
`;
          o.replace(Le, function(He, st, ut, sr, Xt, or) {
            return ut || (ut = sr), Ce += o.slice(xe, or).replace(Ja, nl), st && (Q = true, Ce += `' +
__e(` + st + `) +
'`), Xt && (se = true, Ce += `';
` + Xt + `;
__p += '`), ut && (Ce += `' +
((__t = (` + ut + `)) == null ? '' : __t) +
'`), xe = or + He.length, He;
          }), Ce += `';
`;
          var Ve = yt.call(h, "variable") && h.variable;
          if (!Ve)
            Ce = `with (obj) {
` + Ce + `
}
`;
          else if (hi.test(Ve))
            throw new Qe(l);
          Ce = (se ? Ce.replace(et, "") : Ce).replace(lt, "$1").replace(We, "$1;"), Ce = "function(" + (Ve || "obj") + `) {
` + (Ve ? "" : `obj || (obj = {});
`) + "var __t, __p = ''" + (Q ? ", __e = _.escape" : "") + (se ? `, __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }
` : `;
`) + Ce + `return __p
}`;
          var it = mu(function() {
            return ft(H, Be + "return " + Ce).apply(t, Z);
          });
          if (it.source = Ce, Ba(it))
            throw it;
          return it;
        }
        function Pp(o) {
          return mt(o).toLowerCase();
        }
        function qp(o) {
          return mt(o).toUpperCase();
        }
        function kp(o, h, v) {
          if (o = mt(o), o && (v || h === t))
            return ws(o);
          if (!o || !(h = nr(h)))
            return o;
          var R = vr(o), N = vr(h), H = Es(R, N), Z = Ts(R, N) + 1;
          return Kr(R, H, Z).join("");
        }
        function Lp(o, h, v) {
          if (o = mt(o), o && (v || h === t))
            return o.slice(0, Ss(o) + 1);
          if (!o || !(h = nr(h)))
            return o;
          var R = vr(o), N = Ts(R, vr(h)) + 1;
          return Kr(R, 0, N).join("");
        }
        function Np(o, h, v) {
          if (o = mt(o), o && (v || h === t))
            return o.replace(tr, "");
          if (!o || !(h = nr(h)))
            return o;
          var R = vr(o), N = Es(R, vr(h));
          return Kr(R, N).join("");
        }
        function Dp(o, h) {
          var v = U, R = B;
          if (St(h)) {
            var N = "separator" in h ? h.separator : N;
            v = "length" in h ? rt(h.length) : v, R = "omission" in h ? nr(h.omission) : R;
          }
          o = mt(o);
          var H = o.length;
          if (pi(o)) {
            var Z = vr(o);
            H = Z.length;
          }
          if (v >= H)
            return o;
          var Q = v - mi(R);
          if (Q < 1)
            return R;
          var se = Z ? Kr(Z, 0, Q).join("") : o.slice(0, Q);
          if (N === t)
            return se + R;
          if (Z && (Q += se.length - Q), $a(N)) {
            if (o.slice(Q).search(N)) {
              var xe, we = se;
              for (N.global || (N = ra(N.source, mt(Ri.exec(N)) + "g")), N.lastIndex = 0; xe = N.exec(we); )
                var Ce = xe.index;
              se = se.slice(0, Ce === t ? Q : Ce);
            }
          } else if (o.indexOf(nr(N), Q) != Q) {
            var Le = se.lastIndexOf(N);
            Le > -1 && (se = se.slice(0, Le));
          }
          return se + R;
        }
        function Fp(o) {
          return o = mt(o), o && fe.test(o) ? o.replace(te, cl) : o;
        }
        var Bp = wi(function(o, h, v) {
          return o + (v ? " " : "") + h.toUpperCase();
        }), Ga = vo("toUpperCase");
        function pu(o, h, v) {
          return o = mt(o), h = v ? t : h, h === t ? sl(o) ? pl(o) : Ju(o) : o.match(h) || [];
        }
        var mu = nt(function(o, h) {
          try {
            return rr(o, t, h);
          } catch (v) {
            return Ba(v) ? v : new Qe(v);
          }
        }), $p = Nr(function(o, h) {
          return lr(h, function(v) {
            v = Cr(v), kr(o, v, Da(o[v], o));
          }), o;
        });
        function jp(o) {
          var h = o == null ? 0 : o.length, v = Ge();
          return o = h ? Tt(o, function(R) {
            if (typeof R[1] != "function")
              throw new hr(u);
            return [v(R[0]), R[1]];
          }) : [], nt(function(R) {
            for (var N = -1; ++N < h; ) {
              var H = o[N];
              if (rr(H[0], this, R))
                return rr(H[1], this, R);
            }
          });
        }
        function Up(o) {
          return fh(fr(o, p));
        }
        function za(o) {
          return function() {
            return o;
          };
        }
        function Gp(o, h) {
          return o == null || o !== o ? h : o;
        }
        var zp = yo(), Vp = yo(true);
        function Zt(o) {
          return o;
        }
        function Va(o) {
          return Hs(typeof o == "function" ? o : fr(o, p));
        }
        function Hp(o) {
          return Xs(fr(o, p));
        }
        function Wp(o, h) {
          return Ys(o, fr(h, p));
        }
        var Xp = nt(function(o, h) {
          return function(v) {
            return Fi(v, o, h);
          };
        }), Yp = nt(function(o, h) {
          return function(v) {
            return Fi(o, v, h);
          };
        });
        function Ha(o, h, v) {
          var R = Bt(h), N = gn(h, R);
          v == null && !(St(h) && (N.length || !R.length)) && (v = h, h = o, o = this, N = gn(h, Bt(h)));
          var H = !(St(v) && "chain" in v) || !!v.chain, Z = Fr(o);
          return lr(N, function(Q) {
            var se = h[Q];
            o[Q] = se, Z && (o.prototype[Q] = function() {
              var xe = this.__chain__;
              if (H || xe) {
                var we = o(this.__wrapped__), Ce = we.__actions__ = Yt(this.__actions__);
                return Ce.push({ func: se, args: arguments, thisArg: o }), we.__chain__ = xe, we;
              }
              return se.apply(o, zr([this.value()], arguments));
            });
          }), o;
        }
        function Kp() {
          return $t._ === this && ($t._ = xl), this;
        }
        function Wa() {
        }
        function Jp(o) {
          return o = rt(o), nt(function(h) {
            return Ks(h, o);
          });
        }
        var Zp = Ta(Tt), Qp = Ta(gs), em = Ta(Yn);
        function vu(o) {
          return Ia(o) ? Kn(Cr(o)) : Mh(o);
        }
        function tm(o) {
          return function(h) {
            return o == null ? t : ai(o, h);
          };
        }
        var rm = _o(), im = _o(true);
        function Xa() {
          return [];
        }
        function Ya() {
          return false;
        }
        function nm() {
          return {};
        }
        function am() {
          return "";
        }
        function sm() {
          return true;
        }
        function om(o, h) {
          if (o = rt(o), o < 1 || o > P)
            return [];
          var v = V, R = Gt(o, V);
          h = Ge(h), o -= V;
          for (var N = Qn(R, h); ++v < o; )
            h(v);
          return N;
        }
        function um(o) {
          return tt(o) ? Tt(o, Cr) : ar(o) ? [o] : Yt(No(mt(o)));
        }
        function lm(o) {
          var h = ++bl;
          return mt(o) + h;
        }
        var hm = En(function(o, h) {
          return o + h;
        }, 0), cm = Ca("ceil"), fm = En(function(o, h) {
          return o / h;
        }, 1), dm = Ca("floor");
        function pm(o) {
          return o && o.length ? vn(o, Zt, ha) : t;
        }
        function mm(o, h) {
          return o && o.length ? vn(o, Ge(h, 2), ha) : t;
        }
        function vm(o) {
          return _s(o, Zt);
        }
        function gm(o, h) {
          return _s(o, Ge(h, 2));
        }
        function ym(o) {
          return o && o.length ? vn(o, Zt, pa) : t;
        }
        function bm(o, h) {
          return o && o.length ? vn(o, Ge(h, 2), pa) : t;
        }
        var _m = En(function(o, h) {
          return o * h;
        }, 1), xm = Ca("round"), wm = En(function(o, h) {
          return o - h;
        }, 0);
        function Em(o) {
          return o && o.length ? Zn(o, Zt) : 0;
        }
        function Tm(o, h) {
          return o && o.length ? Zn(o, Ge(h, 2)) : 0;
        }
        return j.after = Hf, j.ary = Wo, j.assign = qd, j.assignIn = ou, j.assignInWith = Nn, j.assignWith = kd, j.at = Ld, j.before = Xo, j.bind = Da, j.bindAll = $p, j.bindKey = Yo, j.castArray = nd, j.chain = zo, j.chunk = fc, j.compact = dc, j.concat = pc, j.cond = jp, j.conforms = Up, j.constant = za, j.countBy = Ef, j.create = Nd, j.curry = Ko, j.curryRight = Jo, j.debounce = Zo, j.defaults = Dd, j.defaultsDeep = Fd, j.defer = Wf, j.delay = Xf, j.difference = mc, j.differenceBy = vc, j.differenceWith = gc, j.drop = yc, j.dropRight = bc, j.dropRightWhile = _c, j.dropWhile = xc, j.fill = wc, j.filter = Cf, j.flatMap = Af, j.flatMapDeep = Mf, j.flatMapDepth = Of, j.flatten = $o, j.flattenDeep = Ec, j.flattenDepth = Tc, j.flip = Yf, j.flow = zp, j.flowRight = Vp, j.fromPairs = Cc, j.functions = Vd, j.functionsIn = Hd, j.groupBy = If, j.initial = Rc, j.intersection = Ac, j.intersectionBy = Mc, j.intersectionWith = Oc, j.invert = Xd, j.invertBy = Yd, j.invokeMap = qf, j.iteratee = Va, j.keyBy = kf, j.keys = Bt, j.keysIn = Jt, j.map = On, j.mapKeys = Jd, j.mapValues = Zd, j.matches = Hp, j.matchesProperty = Wp, j.memoize = Pn, j.merge = Qd, j.mergeWith = uu, j.method = Xp, j.methodOf = Yp, j.mixin = Ha, j.negate = qn, j.nthArg = Jp, j.omit = ep, j.omitBy = tp, j.once = Kf, j.orderBy = Lf, j.over = Zp, j.overArgs = Jf, j.overEvery = Qp, j.overSome = em, j.partial = Fa, j.partialRight = Qo, j.partition = Nf, j.pick = rp, j.pickBy = lu, j.property = vu, j.propertyOf = tm, j.pull = kc, j.pullAll = Uo, j.pullAllBy = Lc, j.pullAllWith = Nc, j.pullAt = Dc, j.range = rm, j.rangeRight = im, j.rearg = Zf, j.reject = Bf, j.remove = Fc, j.rest = Qf, j.reverse = La, j.sampleSize = jf, j.set = np, j.setWith = ap, j.shuffle = Uf, j.slice = Bc, j.sortBy = Vf, j.sortedUniq = Hc, j.sortedUniqBy = Wc, j.split = Ap, j.spread = ed, j.tail = Xc, j.take = Yc, j.takeRight = Kc, j.takeRightWhile = Jc, j.takeWhile = Zc, j.tap = pf, j.throttle = td, j.thru = Mn, j.toArray = nu, j.toPairs = hu, j.toPairsIn = cu, j.toPath = um, j.toPlainObject = su, j.transform = sp, j.unary = rd, j.union = Qc, j.unionBy = ef, j.unionWith = tf, j.uniq = rf, j.uniqBy = nf, j.uniqWith = af, j.unset = op, j.unzip = Na, j.unzipWith = Go, j.update = up, j.updateWith = lp, j.values = Ci, j.valuesIn = hp, j.without = sf, j.words = pu, j.wrap = id, j.xor = of, j.xorBy = uf, j.xorWith = lf, j.zip = hf, j.zipObject = cf, j.zipObjectDeep = ff, j.zipWith = df, j.entries = hu, j.entriesIn = cu, j.extend = ou, j.extendWith = Nn, Ha(j, j), j.add = hm, j.attempt = mu, j.camelCase = pp, j.capitalize = fu, j.ceil = cm, j.clamp = cp, j.clone = ad, j.cloneDeep = od, j.cloneDeepWith = ud, j.cloneWith = sd, j.conformsTo = ld, j.deburr = du, j.defaultTo = Gp, j.divide = fm, j.endsWith = mp, j.eq = yr, j.escape = vp, j.escapeRegExp = gp, j.every = Tf, j.find = Sf, j.findIndex = Fo, j.findKey = Bd, j.findLast = Rf, j.findLastIndex = Bo, j.findLastKey = $d, j.floor = dm, j.forEach = Vo, j.forEachRight = Ho, j.forIn = jd, j.forInRight = Ud, j.forOwn = Gd, j.forOwnRight = zd, j.get = ja, j.gt = hd, j.gte = cd, j.has = Wd, j.hasIn = Ua, j.head = jo, j.identity = Zt, j.includes = Pf, j.indexOf = Sc, j.inRange = fp, j.invoke = Kd, j.isArguments = ui, j.isArray = tt, j.isArrayBuffer = fd, j.isArrayLike = Kt, j.isArrayLikeObject = Mt, j.isBoolean = dd, j.isBuffer = Jr, j.isDate = pd, j.isElement = md, j.isEmpty = vd, j.isEqual = gd, j.isEqualWith = yd, j.isError = Ba, j.isFinite = bd, j.isFunction = Fr, j.isInteger = eu, j.isLength = kn, j.isMap = tu, j.isMatch = _d, j.isMatchWith = xd, j.isNaN = wd, j.isNative = Ed, j.isNil = Cd, j.isNull = Td, j.isNumber = ru, j.isObject = St, j.isObjectLike = At, j.isPlainObject = zi, j.isRegExp = $a, j.isSafeInteger = Sd, j.isSet = iu, j.isString = Ln, j.isSymbol = ar, j.isTypedArray = Ti, j.isUndefined = Rd, j.isWeakMap = Ad, j.isWeakSet = Md, j.join = Ic, j.kebabCase = yp, j.last = pr, j.lastIndexOf = Pc, j.lowerCase = bp, j.lowerFirst = _p, j.lt = Od, j.lte = Id, j.max = pm, j.maxBy = mm, j.mean = vm, j.meanBy = gm, j.min = ym, j.minBy = bm, j.stubArray = Xa, j.stubFalse = Ya, j.stubObject = nm, j.stubString = am, j.stubTrue = sm, j.multiply = _m, j.nth = qc, j.noConflict = Kp, j.noop = Wa, j.now = In, j.pad = xp, j.padEnd = wp, j.padStart = Ep, j.parseInt = Tp, j.random = dp, j.reduce = Df, j.reduceRight = Ff, j.repeat = Cp, j.replace = Sp, j.result = ip, j.round = xm, j.runInContext = ie, j.sample = $f, j.size = Gf, j.snakeCase = Rp, j.some = zf, j.sortedIndex = $c, j.sortedIndexBy = jc, j.sortedIndexOf = Uc, j.sortedLastIndex = Gc, j.sortedLastIndexBy = zc, j.sortedLastIndexOf = Vc, j.startCase = Mp, j.startsWith = Op, j.subtract = wm, j.sum = Em, j.sumBy = Tm, j.template = Ip, j.times = om, j.toFinite = Br, j.toInteger = rt, j.toLength = au, j.toLower = Pp, j.toNumber = mr, j.toSafeInteger = Pd, j.toString = mt, j.toUpper = qp, j.trim = kp, j.trimEnd = Lp, j.trimStart = Np, j.truncate = Dp, j.unescape = Fp, j.uniqueId = lm, j.upperCase = Bp, j.upperFirst = Ga, j.each = Vo, j.eachRight = Ho, j.first = jo, Ha(j, function() {
          var o = {};
          return Er(j, function(h, v) {
            yt.call(j.prototype, v) || (o[v] = h);
          }), o;
        }(), { chain: false }), j.VERSION = r, lr(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(o) {
          j[o].placeholder = j;
        }), lr(["drop", "take"], function(o, h) {
          ot.prototype[o] = function(v) {
            v = v === t ? 1 : Nt(rt(v), 0);
            var R = this.__filtered__ && !h ? new ot(this) : this.clone();
            return R.__filtered__ ? R.__takeCount__ = Gt(v, R.__takeCount__) : R.__views__.push({
              size: Gt(v, V),
              type: o + (R.__dir__ < 0 ? "Right" : "")
            }), R;
          }, ot.prototype[o + "Right"] = function(v) {
            return this.reverse()[o](v).reverse();
          };
        }), lr(["filter", "map", "takeWhile"], function(o, h) {
          var v = h + 1, R = v == D || v == k;
          ot.prototype[o] = function(N) {
            var H = this.clone();
            return H.__iteratees__.push({
              iteratee: Ge(N, 3),
              type: v
            }), H.__filtered__ = H.__filtered__ || R, H;
          };
        }), lr(["head", "last"], function(o, h) {
          var v = "take" + (h ? "Right" : "");
          ot.prototype[o] = function() {
            return this[v](1).value()[0];
          };
        }), lr(["initial", "tail"], function(o, h) {
          var v = "drop" + (h ? "" : "Right");
          ot.prototype[o] = function() {
            return this.__filtered__ ? new ot(this) : this[v](1);
          };
        }), ot.prototype.compact = function() {
          return this.filter(Zt);
        }, ot.prototype.find = function(o) {
          return this.filter(o).head();
        }, ot.prototype.findLast = function(o) {
          return this.reverse().find(o);
        }, ot.prototype.invokeMap = nt(function(o, h) {
          return typeof o == "function" ? new ot(this) : this.map(function(v) {
            return Fi(v, o, h);
          });
        }), ot.prototype.reject = function(o) {
          return this.filter(qn(Ge(o)));
        }, ot.prototype.slice = function(o, h) {
          o = rt(o);
          var v = this;
          return v.__filtered__ && (o > 0 || h < 0) ? new ot(v) : (o < 0 ? v = v.takeRight(-o) : o && (v = v.drop(o)), h !== t && (h = rt(h), v = h < 0 ? v.dropRight(-h) : v.take(h - o)), v);
        }, ot.prototype.takeRightWhile = function(o) {
          return this.reverse().takeWhile(o).reverse();
        }, ot.prototype.toArray = function() {
          return this.take(V);
        }, Er(ot.prototype, function(o, h) {
          var v = /^(?:filter|find|map|reject)|While$/.test(h), R = /^(?:head|last)$/.test(h), N = j[R ? "take" + (h == "last" ? "Right" : "") : h], H = R || /^find/.test(h);
          N && (j.prototype[h] = function() {
            var Z = this.__wrapped__, Q = R ? [1] : arguments, se = Z instanceof ot, xe = Q[0], we = se || tt(Z), Ce = function(st) {
              var ut = N.apply(j, zr([st], Q));
              return R && Le ? ut[0] : ut;
            };
            we && v && typeof xe == "function" && xe.length != 1 && (se = we = false);
            var Le = this.__chain__, Be = !!this.__actions__.length, Ve = H && !Le, it = se && !Be;
            if (!H && we) {
              Z = it ? Z : new ot(this);
              var He = o.apply(Z, Q);
              return He.__actions__.push({ func: Mn, args: [Ce], thisArg: t }), new cr(He, Le);
            }
            return Ve && it ? o.apply(this, Q) : (He = this.thru(Ce), Ve ? R ? He.value()[0] : He.value() : He);
          });
        }), lr(["pop", "push", "shift", "sort", "splice", "unshift"], function(o) {
          var h = en[o], v = /^(?:push|sort|unshift)$/.test(o) ? "tap" : "thru", R = /^(?:pop|shift)$/.test(o);
          j.prototype[o] = function() {
            var N = arguments;
            if (R && !this.__chain__) {
              var H = this.value();
              return h.apply(tt(H) ? H : [], N);
            }
            return this[v](function(Z) {
              return h.apply(tt(Z) ? Z : [], N);
            });
          };
        }), Er(ot.prototype, function(o, h) {
          var v = j[h];
          if (v) {
            var R = v.name + "";
            yt.call(bi, R) || (bi[R] = []), bi[R].push({ name: h, func: v });
          }
        }), bi[wn(t, T).name] = [{
          name: "wrapper",
          func: t
        }], ot.prototype.clone = Dl, ot.prototype.reverse = Fl, ot.prototype.value = Bl, j.prototype.at = mf, j.prototype.chain = vf, j.prototype.commit = gf, j.prototype.next = yf, j.prototype.plant = _f, j.prototype.reverse = xf, j.prototype.toJSON = j.prototype.valueOf = j.prototype.value = wf, j.prototype.first = j.prototype.head, Ii && (j.prototype[Ii] = bf), j;
      }, vi = ml();
      ei ? ((ei.exports = vi)._ = vi, Vn._ = vi) : $t._ = vi;
    }).call(lodash$2);
  }(lodash$3, lodash$3.exports)), lodash$3.exports;
}
var hasRequiredText$1;
function requireText$1() {
  if (hasRequiredText$1) return Text;
  hasRequiredText$1 = 1, Object.defineProperty(Text, "__esModule", {
    value: true
  }), Text.default = void 0;
  var i2 = p(requireSprite()), e = p(requireTexture$1()), t = requireUtils$3(), r = requireMath$1(), a = require_const(), s = p(requireSettings()), u = p(requireTextStyle()), l = p(requireTextMetrics()), c = p(requireTrimCanvas()), d = p(requireDoc()), f = requireCache();
  p(requireLodash$1());
  function p(x) {
    return x && x.__esModule ? x : { default: x };
  }
  var m = {
    texture: true,
    children: false,
    baseTexture: true
  };
  let y = class extends i2.default {
    constructor(x, g, _) {
      _ = _ || d.default.createElement("canvas"), _.width = 3, _.height = 3;
      var T = e.default.fromCanvas(_, s.default.SCALE_MODE, "text");
      T.orig = new r.Rectangle(), T.trim = new r.Rectangle(), super(T), (0, f.addToTextureCache)(this._texture, this._texture.baseTexture.textureCacheIds[0]), this.canvas = _, this.context = this.canvas.getContext("2d"), this.resolution = s.default.RESOLUTION, this._text = null, this._style = null, this._styleListener = null, this._font = "", this.text = x, this.style = g, this.localStyleID = -1;
    }
    updateText(x) {
      var g = this._style;
      if (this.localStyleID !== g.styleID && (this.dirty = true, this.localStyleID = g.styleID), !(!this.dirty && x)) {
        this._font = this._style.toFontString();
        var _ = this.context, T = l.default.measureText(this._text, this._style, this._style.wordWrap, this.canvas), E = T.width, b = T.height, C = T.lines, w = T.lineHeight, A = T.lineWidths, S = T.maxLineWidth, F = T.fontProperties;
        this.lineHeight = T.lineHeight, this.charWidth = F.fontSize + this._style.letterSpacing, this.canvas.width = Math.ceil((Math.max(1, E) + g.padding * 2) * this.resolution), this.canvas.height = Math.ceil((Math.max(1, b) + g.padding * 2) * this.resolution), _.scale(this.resolution, this.resolution), _.clearRect(0, 0, this.canvas.width, this.canvas.height), this.drawBackground(g), this.drawSelection(), _.font = this._font, _.strokeStyle = g.stroke, _.lineWidth = g.strokeThickness, _.textBaseline = g.textBaseline, _.lineJoin = g.lineJoin, _.miterLimit = g.miterLimit;
        var M, U, B = (w - F.fontSize) / 2;
        if (g.dropShadow) {
          _.fillStyle = g.dropShadowColor, _.globalAlpha = g.dropShadowAlpha, _.shadowBlur = g.dropShadowBlur, g.dropShadowBlur > 0 && (_.shadowColor = g.dropShadowColor);
          for (var q = Math.cos(g.dropShadowAngle) * g.dropShadowDistance, z = Math.sin(g.dropShadowAngle) * g.dropShadowDistance, D = 0; D < C.length; D++)
            M = g.strokeThickness / 2, U = B + g.strokeThickness / 2 + D * w + F.ascent, g.align === "right" ? M += S - A[D] : g.align === "center" && (M += (S - A[D]) / 2), g.fill && (this.drawLetterSpacing(C[D], M + q + g.padding, U + z + g.padding), g.stroke && g.strokeThickness && (_.strokeStyle = g.dropShadowColor, this.drawLetterSpacing(C[D], M + q + g.padding, U + z + g.padding, true), _.strokeStyle = g.stroke));
        }
        _.shadowBlur = 0, _.globalAlpha = 1, _.fillStyle = this._generateFillStyle(g, C);
        for (var X = [], k = 0; k < C.length; k++)
          if (M = g.strokeThickness / 2, U = B + g.strokeThickness / 2 + k * w + F.ascent, g.align === "right" ? M += S - A[k] : g.align === "center" && (M += (S - A[k]) / 2), g.stroke && g.strokeThickness && this.drawLetterSpacing(C[k], M + g.padding, U + g.padding, true), g.fill) {
            var I = X[X.length - 1], P = I ? I[I.length - 1].ci : -1;
            X.push(this.drawLetterSpacing(C[k], M + g.padding, U + g.padding, false, P + 1));
          }
        this.chars = X, this.updateTexture();
      }
    }
    drawBackground(x) {
      var g = x.background || x.backgroundColor;
      if (g) {
        var {
          context: _,
          canvas: T,
          text: E
        } = this, b = String(E).trim();
        b ? (_.fillStyle = g, _.fillRect(0, 0, T.width, T.height)) : _.clearRect(0, 0, T.width, T.height);
      }
    }
    drawSelection() {
      if (!this.selectionStart || !this.selectionEnd) {
        this.selection = null;
        return;
      }
      var x = this.lineHeight, [g, _] = this.selectionStart.lineIdx < this.selectionEnd.lineIdx || this.selectionStart.lineIdx == this.selectionEnd.lineIdx && this.selectionStart.charIdx <= this.selectionEnd.charIdx ? [this.selectionStart, this.selectionEnd] : [this.selectionEnd, this.selectionStart];
      this.selection = {
        start: g,
        end: _
      };
      for (var T = g.lineIdx; T <= _.lineIdx; T++) {
        var E, b, C = T === g.lineIdx ? g.x : ((E = this.chars[T][0]) == null ? void 0 : E.left) || 0, w = T === _.lineIdx ? _.x : ((b = this.chars[T][this.chars[T].length - 1]) == null ? void 0 : b.right) || 0;
        this.context.fillStyle = this._style.selectionBgColor, this.context.fillRect(C, T * x, w - C, x);
      }
    }
    drawLetterSpacing(x, g, _, T, E) {
      T === void 0 && (T = false), E === void 0 && (E = 0);
      for (var b = this._style, C = b.letterSpacing, w = Array.from(x), A = g, S = 0, F = "", M = this.context.measureText(x).width, U = 0, B = []; S < w.length; ) {
        F = w[S++], g = A, T ? this.context.strokeText(F, g, _) : this.context.fillText(F, g, _), U = this.context.measureText(w.slice(S).join("")).width, A += M - U + C, M = U;
        var q = A - C * 0.5;
        B.push({
          char: F,
          ci: E,
          top: _,
          left: g,
          right: q,
          cx: 0.5 * (g + q)
        }), E++;
      }
      return B;
    }
    updateStyle(x) {
      for (var g in x) {
        var _ = this.camelCase(g);
        _ === "color" && (_ = "fill"), this.style[_] = x[g];
      }
    }
    selectStart(x) {
      this.selectionStart = this.indexOf(x), this.selectionEnd = null;
    }
    selectEnd(x) {
      this.selectionEnd = this.indexOf(x), this.cursorPoint = {
        x: this.selectionEnd.x,
        y: this.selectionEnd.y + 1
      }, this.updateText(false);
    }
    selectMove(x, g, _, T) {
      if (this.selectionEnd) {
        if (x !== 0) {
          var E;
          if (!_ && this.selection && this.selection.start.ci < this.selection.end.ci) {
            var b = this.selection[x > 0 ? "end" : "start"];
            E = {
              x: b.x,
              y: b.y + 1
            };
          } else if (!T && x < 0 && this.selectionEnd.charIdx <= 0) {
            if (this.selectionEnd.lineIdx > 0) {
              var C = this.chars[this.selectionEnd.lineIdx - 1], w = C[C.length - 1];
              E = {
                x: w.left,
                y: w.top + 1
              };
            }
          } else if (!T && x > 0 && this.selectionEnd.charIdx >= this.textLine(this.selectionEnd.lineIdx).length) {
            if (this.selectionEnd.lineIdx + 1 < this.chars.length) {
              var A = this.chars[this.selectionEnd.lineIdx], S = A[A.length - 1].char !== `
` ? "right" : "left", F = this.chars[this.selectionEnd.lineIdx + 1], M = F[0];
              E = {
                x: M[S],
                y: M.top + 1
              };
            }
          } else {
            var U = this.selectionEnd.charIdx + (x > 0 ? 1 : -1), B = this.textLine(this.selectionEnd.lineIdx);
            T && (U = x > 0 ? B.length : 0);
            var q = U >= B.length ? "right" : "left", z = B[Math.min(U, B.length - 1)];
            E = {
              x: z[q],
              y: z.top + 1
            };
          }
          E && (this.cursorPoint = E, this.selectionEnd = this.indexOf(E));
        } else {
          var D = this.selectionEnd.lineIdx + (g > 0 ? 1 : -1), X = this.cursorPoint.x;
          T && (D = g > 0 ? this.chars.length : 0, X = g > 0 ? this.width : 0), this.selectionEnd = this.indexOf({
            x: X,
            y: this.lineHeight * D + 1
          });
        }
        _ || (this.selectionStart = this.selectionEnd), this.updateText(false);
      }
    }
    textLine(x) {
      return this.chars[x].filter((g) => g.char != `
`);
    }
    indexOf(x) {
      var g = Math.max(0, Math.min(this.chars.length - 1, Math.floor(x.y / this.lineHeight))), _ = 0, T = this.chars[g][0] ? this.chars[g][0].ci : 0, E = this.chars[g][0] ? this.chars[g][0].left : 0;
      for (var b of this.chars[g])
        if (b.char !== `
`) {
          if (x.x < b.cx) break;
          _++, E = b.right, T = b.ci + 1;
        }
      var C = this.lineHeight;
      return {
        lineIdx: g,
        charIdx: _,
        ci: T,
        x: E,
        y: g * C,
        height: C
      };
    }
    cursor(x) {
      var g = x;
      x === void 0 && (g = this.selectionEnd.ci);
      var _ = this.charOf(g), T = "left";
      if (!_) {
        var E = this.chars[this.chars.length - 1];
        _ = E[E.length - 1], T = "right";
      }
      if (this.selectionEnd = this.indexOf({
        x: _[T],
        y: _.top + 1
      }), x === void 0) return this.selectionEnd;
      this.selectionStart = this.selectionEnd;
    }
    input(x) {
      var {
        text: g,
        cursorIndex: _
      } = this.delete(false), T = Array.from(g);
      return T.splice(_, 0, x), {
        text: T.join(""),
        cursorIndex: _ + Array.from(x).length
      };
    }
    delete(x) {
      x === void 0 && (x = true);
      var g = Array.from(this.text), _ = this.selection.start.ci - 1, T = 1, E = this.selectionEnd;
      if (this.selection && this.selection.start.ci < this.selection.end.ci)
        _ = this.selection.start.ci, T = this.selection.end.ci - this.selection.start.ci, E = this.selection.end, this.selectionStart = this.selectionEnd = E;
      else if (!x || !E || E.ci < 1)
        return {
          text: this.text,
          cursorIndex: E ? E.ci : g.length + 1
        };
      g.splice(_, T);
      var b = this.chars[E.lineIdx], C = E.charIdx < b.length ? "left" : "right", w = b[Math.min(E.charIdx, b.length - 1)];
      C === "right" && this.chars[E.lineIdx + 1] && this.chars[E.lineIdx + 1][0] && (w = this.chars[E.lineIdx + 1][0], C = "left");
      var A = w.ci + (C === "right" ? 1 : 0) - T;
      return {
        text: g.join(""),
        cursorIndex: A
      };
    }
    charOf(x) {
      for (var g of this.chars)
        for (var _ of g)
          if (_.ci === x) return _;
    }
    selectionText() {
      if (this.selection && this.selection.start.ci < this.selection.end.ci) {
        var x = Array.from(this.text);
        return x.slice(this.selection.start.ci, this.selection.end.ci).join("");
      }
      return "";
    }
    camelCase(x) {
      var g = /([\:\-\_]+(.))/g, _ = /^moz([A-Z])/;
      return x.replace(g, function(T, E, b, C) {
        return C ? b.toUpperCase() : b;
      }).replace(_, "Moz$1");
    }
    updateTexture() {
      var x = this.canvas;
      if (this._style.trim) {
        var g = (0, c.default)(x);
        g.data && (x.width = g.width, x.height = g.height, this.context.putImageData(g.data, 0, 0));
      }
      var _ = this._texture, T = this._style, E = T.trim ? 0 : T.padding, b = _.baseTexture;
      b.hasLoaded = true, b.resolution = this.resolution, b.realWidth = x.width, b.realHeight = x.height, b.width = x.width / this.resolution, b.height = x.height / this.resolution, _.trim.width = _._frame.width = x.width / this.resolution, _.trim.height = _._frame.height = x.height / this.resolution, _.trim.x = -E, _.trim.y = -E, _.orig.width = _._frame.width - E * 2, _.orig.height = _._frame.height - E * 2, this._onTextureUpdate(), b.emit("update", b), b.adaptedNodeCanvas(), this.dirty = false;
    }
    renderWebGL(x) {
      this.resolution !== x.resolution && (this.resolution = x.resolution, this.dirty = true), this.updateText(true), super.renderWebGL(x);
    }
    _renderCanvas(x) {
      this.resolution !== x.resolution && (this.resolution = x.resolution, this.dirty = true), this.updateText(true), super._renderCanvas(x);
    }
    getLocalBounds(x) {
      return this.updateText(true), super.getLocalBounds.call(this, x);
    }
    _calculateBounds() {
      this.updateText(true), this.calculateVertices(), this._bounds.addQuad(this.vertexData);
    }
    _onStyleChange() {
      this.dirty = true;
    }
    _generateFillStyle(x, g) {
      if (x.fillImage)
        return this.context.createPattern(x.fillImage, "repeat");
      if (!Array.isArray(x.fill))
        return x.fill;
      var _, T, E, b, C = this.canvas.width / this.resolution, w = this.canvas.height / this.resolution, A = x.fill.slice(), S = x.fillGradientStops.slice();
      if (!S.length)
        for (var F = A.length + 1, M = 1; M < F; ++M)
          S.push(M / F);
      if (A.unshift(x.fill[0]), S.unshift(0), A.push(x.fill[x.fill.length - 1]), S.push(1), x.fillGradientType === a.TEXT_GRADIENT.LINEAR_VERTICAL) {
        _ = this.context.createLinearGradient(C / 2, 0, C / 2, w), T = (A.length + 1) * g.length, E = 0;
        for (var U = 0; U < g.length; U++) {
          E += 1;
          for (var B = 0; B < A.length; B++)
            typeof S[B] == "number" ? b = S[B] / g.length + U / g.length : b = E / T, _.addColorStop(b, A[B]), E++;
        }
      } else {
        _ = this.context.createLinearGradient(0, w / 2, C, w / 2), T = A.length + 1, E = 1;
        for (var q = 0; q < A.length; q++)
          typeof S[q] == "number" ? b = S[q] : b = E / T, _.addColorStop(b, A[q]), E++;
      }
      return _;
    }
    destroy(x) {
      this.destroyed || (typeof x == "boolean" && (x = {
        children: x
      }), x = Object.assign({}, m, x), super.destroy(x), this.context = null, this.canvas = null, this._style = null);
    }
    get width() {
      return this.updateText(true), Math.abs(this.scale.x) * this._texture.orig.width;
    }
    set width(x) {
      this.updateText(true);
      var g = (0, t.sign)(this.scale.x) || 1;
      this.scale.x = g * x / this._texture.orig.width, this._width = x;
    }
    get height() {
      return this.updateText(true), Math.abs(this.scale.y) * this._texture.orig.height;
    }
    set height(x) {
      this.updateText(true);
      var g = (0, t.sign)(this.scale.y) || 1;
      this.scale.y = g * x / this._texture.orig.height, this._height = x;
    }
    get font() {
      return this._font;
    }
    get style() {
      return this._style;
    }
    set style(x) {
      x = x || {}, x instanceof u.default ? this._style = x : this._style = new u.default(x), this.localStyleID = -1, this.dirty = true;
    }
    get text() {
      return this._text;
    }
    set text(x) {
      x = String(x === "" || x === null || x === void 0 ? " " : x), this._text !== x && (this._text = x, this.dirty = true);
    }
  };
  return Text.default = y, Text;
}
var Graphics = {}, GraphicsData = {}, hasRequiredGraphicsData;
function requireGraphicsData() {
  if (hasRequiredGraphicsData) return GraphicsData;
  hasRequiredGraphicsData = 1, Object.defineProperty(GraphicsData, "__esModule", {
    value: true
  }), GraphicsData.default = void 0;
  let i2 = class Fm {
    constructor(t, r, a, s, u, l, c, d, f) {
      this.lineWidth = t, this.lineAlignment = f, this.nativeLines = c, this.lineColor = r, this.lineAlpha = a, this._lineTint = r, this.fillColor = s, this.fillAlpha = u, this._fillTint = s, this.fill = l, this.holes = [], this.shape = d, this.type = d.type;
    }
    /**
     * Creates a new GraphicsData object with the same values as this one.
     *
     * @return {InkPaint.GraphicsData} Cloned GraphicsData object
     */
    clone() {
      return new Fm(this.lineWidth, this.lineColor, this.lineAlpha, this.fillColor, this.fillAlpha, this.fill, this.nativeLines, this.shape, this.lineAlignment);
    }
    /**
     * Adds a hole to the shape.
     *
     * @param {InkPaint.Rectangle|InkPaint.Circle} shape - The shape of the hole.
     */
    addHole(t) {
      this.holes.push(t);
    }
    /**
     * Destroys the Graphics data.
     */
    destroy() {
      this.shape = null, this.holes = null;
    }
  };
  return GraphicsData.default = i2, GraphicsData;
}
var bezierCurveTo = {}, hasRequiredBezierCurveTo;
function requireBezierCurveTo() {
  if (hasRequiredBezierCurveTo) return bezierCurveTo;
  hasRequiredBezierCurveTo = 1, Object.defineProperty(bezierCurveTo, "__esModule", {
    value: true
  }), bezierCurveTo.default = i2;
  function i2(e, t, r, a, s, u, l, c, d, f) {
    f === void 0 && (f = []);
    var p = 0, m = 0, y = 0, x = 0, g = 0;
    f.push(e, t);
    for (var _ = 1, T = 0; _ <= d; ++_)
      T = _ / d, p = 1 - T, m = p * p, y = m * p, x = T * T, g = x * T, f.push(y * e + 3 * m * T * r + 3 * p * x * s + g * l, y * t + 3 * m * T * a + 3 * p * x * u + g * c);
    return f;
  }
  return bezierCurveTo;
}
var hasRequiredGraphics;
function requireGraphics() {
  if (hasRequiredGraphics) return Graphics;
  hasRequiredGraphics = 1, Object.defineProperty(Graphics, "__esModule", {
    value: true
  }), Graphics.default = void 0;
  var i2 = p(requireContainer()), e = p(requireRenderTexture()), t = p(requireTexture$1()), r = p(requireGraphicsData()), a = p(requireSprite()), s = requireMath$1(), u = requireUtils$3(), l = require_const(), c = p(requireBounds()), d = p(requireBezierCurveTo()), f = p(requireCanvasRenderer());
  function p(E) {
    return E && E.__esModule ? E : { default: E };
  }
  var m, y = new s.Matrix(), x = new s.Point(), g = new Float32Array(4), _ = new Float32Array(4);
  let T = class Wi extends i2.default {
    constructor(b) {
      b === void 0 && (b = false), super(), this.fillAlpha = 1, this.lineWidth = 0, this.nativeLines = b, this.lineColor = 0, this.lineAlignment = 0.5, this.graphicsData = [], this.tint = 16777215, this._prevTint = 16777215, this.blendMode = l.BLEND_MODES.NORMAL, this.currentPath = null, this._webGL = {}, this.isMask = false, this.boundsPadding = 0, this._localBounds = new c.default(), this.dirty = 0, this.fastRectDirty = -1, this.clearDirty = 0, this.boundsDirty = -1, this.cachedSpriteDirty = false, this._spriteRect = null, this._fastRect = false, this._prevRectTint = null, this._prevRectFillColor = null;
    }
    clone() {
      var b = new Wi();
      b.renderable = this.renderable, b.fillAlpha = this.fillAlpha, b.lineWidth = this.lineWidth, b.lineColor = this.lineColor, b.lineAlignment = this.lineAlignment, b.tint = this.tint, b.blendMode = this.blendMode, b.isMask = this.isMask, b.boundsPadding = this.boundsPadding, b.dirty = 0, b.cachedSpriteDirty = this.cachedSpriteDirty;
      for (var C = 0; C < this.graphicsData.length; ++C)
        b.graphicsData.push(this.graphicsData[C].clone());
      return b.currentPath = b.graphicsData[b.graphicsData.length - 1], b.updateLocalBounds(), b;
    }
    /**
     * Calculate length of quadratic curve
     * @see {@link http://www.malczak.linuxpl.com/blog/quadratic-bezier-curve-length/}
     * for the detailed explanation of math behind this.
     *
     * @private
     * @param {number} fromX - x-coordinate of curve start point
     * @param {number} fromY - y-coordinate of curve start point
     * @param {number} cpX - x-coordinate of curve control point
     * @param {number} cpY - y-coordinate of curve control point
     * @param {number} toX - x-coordinate of curve end point
     * @param {number} toY - y-coordinate of curve end point
     * @return {number} Length of quadratic curve
     */
    _quadraticCurveLength(b, C, w, A, S, F) {
      var M = b - 2 * w + S, U = C - 2 * A + F, B = 2 * w - 2 * b, q = 2 * A - 2 * C, z = 4 * (M * M + U * U), D = 4 * (M * B + U * q), X = B * B + q * q, k = 2 * Math.sqrt(z + D + X), I = Math.sqrt(z), P = 2 * z * I, G = 2 * Math.sqrt(X), W = D / I;
      return (P * k + I * D * (k - G) + (4 * X * z - D * D) * Math.log((2 * I + W + k) / (W + G))) / (4 * P);
    }
    /**
     * Calculate length of bezier curve.
     * Analytical solution is impossible, since it involves an integral that does not integrate in general.
     * Therefore numerical solution is used.
     *
     * @private
     * @param {number} fromX - Starting point x
     * @param {number} fromY - Starting point y
     * @param {number} cpX - Control point x
     * @param {number} cpY - Control point y
     * @param {number} cpX2 - Second Control point x
     * @param {number} cpY2 - Second Control point y
     * @param {number} toX - Destination point x
     * @param {number} toY - Destination point y
     * @return {number} Length of bezier curve
     */
    _bezierCurveLength(b, C, w, A, S, F, M, U) {
      for (var B = 10, q = 0, z = 0, D = 0, X = 0, k = 0, I = 0, P = 0, G = 0, W = 0, V = 0, K = 0, J = b, ae = C, re = 1; re <= B; ++re)
        z = re / B, D = z * z, X = D * z, k = 1 - z, I = k * k, P = I * k, G = P * b + 3 * I * z * w + 3 * k * D * S + X * M, W = P * C + 3 * I * z * A + 3 * k * D * F + X * U, V = J - G, K = ae - W, J = G, ae = W, q += Math.sqrt(V * V + K * K);
      return q;
    }
    /**
     * Calculate number of segments for the curve based on its length to ensure its smoothness.
     *
     * @private
     * @param {number} length - length of curve
     * @return {number} Number of segments
     */
    _segmentsCount(b) {
      var C = Math.ceil(b / Wi.CURVES.maxLength);
      return C < Wi.CURVES.minSegments ? C = Wi.CURVES.minSegments : C > Wi.CURVES.maxSegments && (C = Wi.CURVES.maxSegments), C;
    }
    /**
     * Specifies the line style used for subsequent calls to Graphics methods such as the lineTo()
     * method or the drawCircle() method.
     *
     * @param {number} [lineWidth=0] - width of the line to draw, will update the objects stored style
     * @param {number} [color=0] - color of the line to draw, will update the objects stored style
     * @param {number} [alpha=1] - alpha of the line to draw, will update the objects stored style
     * @param {number} [alignment=0.5] - alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)
     * @return {InkPaint.Graphics} This Graphics object. Good for chaining method calls
     */
    lineStyle(b, C, w, A) {
      if (b === void 0 && (b = 0), C === void 0 && (C = 0), w === void 0 && (w = 1), A === void 0 && (A = 0.5), this.lineWidth = b, this.lineColor = C, this.lineAlpha = w, this.lineAlignment = A, this.currentPath)
        if (this.currentPath.shape.points.length) {
          var S = new s.Polygon(this.currentPath.shape.points.slice(-2));
          S.closed = false, this.drawShape(S);
        } else
          this.currentPath.lineWidth = this.lineWidth, this.currentPath.lineColor = this.lineColor, this.currentPath.lineAlpha = this.lineAlpha, this.currentPath.lineAlignment = this.lineAlignment;
      return this;
    }
    /**
     * Moves the current drawing position to x, y.
     *
     * @param {number} x - the X coordinate to move to
     * @param {number} y - the Y coordinate to move to
     * @return {InkPaint.Graphics} This Graphics object. Good for chaining method calls
     */
    moveTo(b, C) {
      var w = new s.Polygon([b, C]);
      return w.closed = false, this.drawShape(w), this;
    }
    /**
     * Draws a line using the current line style from the current drawing position to (x, y);
     * The current drawing position is then set to (x, y).
     *
     * @param {number} x - the X coordinate to draw to
     * @param {number} y - the Y coordinate to draw to
     * @return {InkPaint.Graphics} This Graphics object. Good for chaining method calls
     */
    lineTo(b, C) {
      var w = this.currentPath.shape.points, A = w[w.length - 2], S = w[w.length - 1];
      return (A !== b || S !== C) && (w.push(b, C), this.dirty++), this;
    }
    /**
     * Calculate the points for a quadratic bezier curve and then draws it.
     * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c
     *
     * @param {number} cpX - Control point x
     * @param {number} cpY - Control point y
     * @param {number} toX - Destination point x
     * @param {number} toY - Destination point y
     * @return {InkPaint.Graphics} This Graphics object. Good for chaining method calls
     */
    quadraticCurveTo(b, C, w, A) {
      this.currentPath ? this.currentPath.shape.points.length === 0 && (this.currentPath.shape.points = [0, 0]) : this.moveTo(0, 0);
      var S = this.currentPath.shape.points, F = 0, M = 0;
      S.length === 0 && this.moveTo(0, 0);
      for (var U = S[S.length - 2], B = S[S.length - 1], q = Wi.CURVES.adaptive ? this._segmentsCount(this._quadraticCurveLength(U, B, b, C, w, A)) : 20, z = 1; z <= q; ++z) {
        var D = z / q;
        F = U + (b - U) * D, M = B + (C - B) * D, S.push(F + (b + (w - b) * D - F) * D, M + (C + (A - C) * D - M) * D);
      }
      return this.dirty++, this;
    }
    /**
     * Calculate the points for a bezier curve and then draws it.
     *
     * @param {number} cpX - Control point x
     * @param {number} cpY - Control point y
     * @param {number} cpX2 - Second Control point x
     * @param {number} cpY2 - Second Control point y
     * @param {number} toX - Destination point x
     * @param {number} toY - Destination point y
     * @return {InkPaint.Graphics} This Graphics object. Good for chaining method calls
     */
    bezierCurveTo(b, C, w, A, S, F) {
      this.currentPath ? this.currentPath.shape.points.length === 0 && (this.currentPath.shape.points = [0, 0]) : this.moveTo(0, 0);
      var M = this.currentPath.shape.points, U = M[M.length - 2], B = M[M.length - 1];
      M.length -= 2;
      var q = Wi.CURVES.adaptive ? this._segmentsCount(this._bezierCurveLength(U, B, b, C, w, A, S, F)) : 20;
      return (0, d.default)(U, B, b, C, w, A, S, F, q, M), this.dirty++, this;
    }
    /**
     * The arcTo() method creates an arc/curve between two tangents on the canvas.
     *
     * "borrowed" from https://code.google.com/p/fxcanvas/ - thanks google!
     *
     * @param {number} x1 - The x-coordinate of the beginning of the arc
     * @param {number} y1 - The y-coordinate of the beginning of the arc
     * @param {number} x2 - The x-coordinate of the end of the arc
     * @param {number} y2 - The y-coordinate of the end of the arc
     * @param {number} radius - The radius of the arc
     * @return {InkPaint.Graphics} This Graphics object. Good for chaining method calls
     */
    arcTo(b, C, w, A, S) {
      this.currentPath ? this.currentPath.shape.points.length === 0 && this.currentPath.shape.points.push(b, C) : this.moveTo(b, C);
      var F = this.currentPath.shape.points, M = F[F.length - 2], U = F[F.length - 1], B = U - C, q = M - b, z = A - C, D = w - b, X = Math.abs(B * D - q * z);
      if (X < 1e-8 || S === 0)
        (F[F.length - 2] !== b || F[F.length - 1] !== C) && F.push(b, C);
      else {
        var k = B * B + q * q, I = z * z + D * D, P = B * z + q * D, G = S * Math.sqrt(k) / X, W = S * Math.sqrt(I) / X, V = G * P / k, K = W * P / I, J = G * D + W * q, ae = G * z + W * B, re = q * (W + V), he = B * (W + V), ge = D * (G + K), me = z * (G + K), Te = Math.atan2(he - ae, re - J), _e = Math.atan2(me - ae, ge - J);
        this.arc(J + b, ae + C, S, Te, _e, q * z > D * B);
      }
      return this.dirty++, this;
    }
    /**
     * The arc method creates an arc/curve (used to create circles, or parts of circles).
     *
     * @param {number} cx - The x-coordinate of the center of the circle
     * @param {number} cy - The y-coordinate of the center of the circle
     * @param {number} radius - The radius of the circle
     * @param {number} startAngle - The starting angle, in radians (0 is at the 3 o'clock position
     *  of the arc's circle)
     * @param {number} endAngle - The ending angle, in radians
     * @param {boolean} [anticlockwise=false] - Specifies whether the drawing should be
     *  counter-clockwise or clockwise. False is default, and indicates clockwise, while true
     *  indicates counter-clockwise.
     * @return {InkPaint.Graphics} This Graphics object. Good for chaining method calls
     */
    arc(b, C, w, A, S, F) {
      if (F === void 0 && (F = false), A === S)
        return this;
      !F && S <= A ? S += l.PI_2 : F && A <= S && (A += l.PI_2);
      var M = S - A, U = Wi.CURVES.adaptive ? this._segmentsCount(Math.abs(M) * w) : Math.ceil(Math.abs(M) / l.PI_2) * 40;
      if (M === 0)
        return this;
      var B = b + Math.cos(A) * w, q = C + Math.sin(A) * w, z = this.currentPath ? this.currentPath.shape.points : null;
      if (z) {
        var D = Math.abs(z[z.length - 2] - B), X = Math.abs(z[z.length - 1] - q);
        D < 1e-3 && X < 1e-3 || z.push(B, q);
      } else
        this.moveTo(B, q), z = this.currentPath.shape.points;
      for (var k = M / (U * 2), I = k * 2, P = Math.cos(k), G = Math.sin(k), W = U - 1, V = W % 1 / W, K = 0; K <= W; ++K) {
        var J = K + V * K, ae = k + A + I * J, re = Math.cos(ae), he = -Math.sin(ae);
        z.push((P * re + G * he) * w + b, (P * -he + G * re) * w + C);
      }
      return this.dirty++, this;
    }
    /**
     * Specifies a simple one-color fill that subsequent calls to other Graphics methods
     * (such as lineTo() or drawCircle()) use when drawing.
     *
     * @param {number} [color=0] - the color of the fill
     * @param {number} [alpha=1] - the alpha of the fill
     * @return {InkPaint.Graphics} This Graphics object. Good for chaining method calls
     */
    beginFill(b, C) {
      return b === void 0 && (b = 0), C === void 0 && (C = 1), this.filling = true, this.fillColor = b, this.fillAlpha = C, this.currentPath && this.currentPath.shape.points.length <= 2 && (this.currentPath.fill = this.filling, this.currentPath.fillColor = this.fillColor, this.currentPath.fillAlpha = this.fillAlpha), this;
    }
    /**
     * Applies a fill to the lines and shapes that were added since the last call to the beginFill() method.
     *
     * @return {InkPaint.Graphics} This Graphics object. Good for chaining method calls
     */
    endFill() {
      return this.filling = false, this.fillColor = null, this.fillAlpha = 1, this;
    }
    /**
     *
     * @param {number} x - The X coord of the top-left of the rectangle
     * @param {number} y - The Y coord of the top-left of the rectangle
     * @param {number} width - The width of the rectangle
     * @param {number} height - The height of the rectangle
     * @return {InkPaint.Graphics} This Graphics object. Good for chaining method calls
     */
    drawRect(b, C, w, A) {
      return this.drawShape(new s.Rectangle(b, C, w, A)), this;
    }
    /**
     *
     * @param {number} x - The X coord of the top-left of the rectangle
     * @param {number} y - The Y coord of the top-left of the rectangle
     * @param {number} width - The width of the rectangle
     * @param {number} height - The height of the rectangle
     * @param {number} radius - Radius of the rectangle corners
     * @return {InkPaint.Graphics} This Graphics object. Good for chaining method calls
     */
    drawRoundedRect(b, C, w, A, S) {
      return this.drawShape(new s.RoundedRectangle(b, C, w, A, S)), this;
    }
    /**
     * Draws a circle.
     *
     * @param {number} x - The X coordinate of the center of the circle
     * @param {number} y - The Y coordinate of the center of the circle
     * @param {number} radius - The radius of the circle
     * @return {InkPaint.Graphics} This Graphics object. Good for chaining method calls
     */
    drawCircle(b, C, w) {
      return this.drawShape(new s.Circle(b, C, w)), this;
    }
    /**
     * Draws an ellipse.
     *
     * @param {number} x - The X coordinate of the center of the ellipse
     * @param {number} y - The Y coordinate of the center of the ellipse
     * @param {number} width - The half width of the ellipse
     * @param {number} height - The half height of the ellipse
     * @return {InkPaint.Graphics} This Graphics object. Good for chaining method calls
     */
    drawEllipse(b, C, w, A) {
      return this.drawShape(new s.Ellipse(b, C, w, A)), this;
    }
    /**
     * Draws a polygon using the given path.
     *
     * @param {number[]|InkPaint.Point[]|InkPaint.Polygon} path - The path data used to construct the polygon.
     * @return {InkPaint.Graphics} This Graphics object. Good for chaining method calls
     */
    drawPolygon(b) {
      var C = b, w = true;
      if (C instanceof s.Polygon && (w = C.closed, C = C.points), !Array.isArray(C)) {
        C = new Array(arguments.length);
        for (var A = 0; A < C.length; ++A)
          C[A] = arguments[A];
      }
      var S = new s.Polygon(C);
      return S.closed = w, this.drawShape(S), this;
    }
    /**
     * Draw a star shape with an abitrary number of points.
     *
     * @param {number} x - Center X position of the star
     * @param {number} y - Center Y position of the star
     * @param {number} points - The number of points of the star, must be > 1
     * @param {number} radius - The outer radius of the star
     * @param {number} [innerRadius] - The inner radius between points, default half `radius`
     * @param {number} [rotation=0] - The rotation of the star in radians, where 0 is vertical
     * @return {InkPaint.Graphics} This Graphics object. Good for chaining method calls
     */
    drawStar(b, C, w, A, S, F) {
      F === void 0 && (F = 0), S = S || A / 2;
      for (var M = -1 * Math.PI / 2 + F, U = w * 2, B = l.PI_2 / U, q = [], z = 0; z < U; z++) {
        var D = z % 2 ? S : A, X = z * B + M;
        q.push(b + D * Math.cos(X), C + D * Math.sin(X));
      }
      return this.drawPolygon(q);
    }
    /**
     * Clears the graphics that were drawn to this Graphics object, and resets fill and line style settings.
     *
     * @return {InkPaint.Graphics} This Graphics object. Good for chaining method calls
     */
    clear() {
      return (this.lineWidth || this.filling || this.graphicsData.length > 0) && (this.lineWidth = 0, this.lineAlignment = 0.5, this.filling = false, this.boundsDirty = -1, this.canvasTintDirty = -1, this.dirty++, this.clearDirty++, this.graphicsData.length = 0), this.currentPath = null, this._spriteRect = null, this;
    }
    /**
     * True if graphics consists of one rectangle, and thus, can be drawn like a Sprite and
     * masked with gl.scissor.
     *
     * @returns {boolean} True if only 1 rect.
     */
    isFastRect() {
      return this.graphicsData.length === 1 && this.graphicsData[0].shape.type === l.SHAPES.RECT && !this.graphicsData[0].lineWidth;
    }
    /**
     * Renders the object using the WebGL renderer
     *
     * @private
     * @param {InkPaint.WebGLRenderer} renderer - The renderer
     */
    _renderWebGL(b) {
      this.dirty !== this.fastRectDirty && (this.fastRectDirty = this.dirty, this._fastRect = this.isFastRect()), this._fastRect ? this._renderSpriteRect(b) : (b.setObjectRenderer(b.plugins.graphics), b.plugins.graphics.render(this));
    }
    /**
     * Renders a sprite rectangle.
     *
     * @private
     * @param {InkPaint.WebGLRenderer} renderer - The renderer
     */
    _renderSpriteRect(b) {
      var C = this.graphicsData[0].shape;
      this._spriteRect || (this._spriteRect = new a.default(new t.default(t.default.EMPTY)));
      var w = this._spriteRect, A = this.graphicsData[0].fillColor;
      if (this.tint === 16777215)
        w.tint = A;
      else if (this.tint !== this._prevRectTint || A !== this._prevRectFillColor) {
        var S = g, F = _;
        (0, u.hex2rgb)(A, S), (0, u.hex2rgb)(this.tint, F), S[0] *= F[0], S[1] *= F[1], S[2] *= F[2], w.tint = (0, u.rgb2hex)(S), this._prevRectTint = this.tint, this._prevRectFillColor = A;
      }
      w.alpha = this.graphicsData[0].fillAlpha, w.worldAlpha = this.worldAlpha * w.alpha, w.blendMode = this.blendMode, w._texture._frame.width = C.width, w._texture._frame.height = C.height, w.transform.worldTransform = this.transform.worldTransform, w.anchor.set(-C.x / C.width, -C.y / C.height), w._onAnchorUpdate(), w._renderWebGL(b);
    }
    _renderCanvas(b) {
      this.isMask !== true && b.plugins.graphics.render(this);
    }
    /**
     * Retrieves the bounds of the graphic shape as a rectangle object
     *
     * @private
     */
    _calculateBounds() {
      this.boundsDirty !== this.dirty && (this.boundsDirty = this.dirty, this.updateLocalBounds(), this.cachedSpriteDirty = true);
      var b = this._localBounds;
      this._bounds.addFrame(this.transform, b.minX, b.minY, b.maxX, b.maxY);
    }
    /**
     * Tests if a point is inside this graphics object
     *
     * @param {InkPaint.Point} point - the point to test
     * @return {boolean} the result of the test
     */
    containsPoint(b) {
      this.worldTransform.applyInverse(b, x);
      for (var C = this.graphicsData, w = 0; w < C.length; ++w) {
        var A = C[w];
        if (A.fill && A.shape && A.shape.contains(x.x, x.y)) {
          var S = false;
          if (A.holes)
            for (var F = 0; F < A.holes.length; F++) {
              var M = A.holes[F];
              if (M.contains(x.x, x.y)) {
                S = true;
                break;
              }
            }
          if (!S)
            return true;
        }
      }
      return false;
    }
    /**
     * Update the bounds of the object
     *
     */
    updateLocalBounds() {
      var b = 1 / 0, C = -1 / 0, w = 1 / 0, A = -1 / 0;
      if (this.graphicsData.length)
        for (var S = 0, F = 0, M = 0, U = 0, B = 0, q = 0; q < this.graphicsData.length; q++) {
          var z = this.graphicsData[q], D = z.type, X = z.lineWidth, k = z.lineAlignment, I = X * k;
          if (S = z.shape, D === l.SHAPES.RECT || D === l.SHAPES.RREC)
            F = S.x - I, M = S.y - I, U = S.width + I * 2, B = S.height + I * 2, b = F < b ? F : b, C = F + U > C ? F + U : C, w = M < w ? M : w, A = M + B > A ? M + B : A;
          else if (D === l.SHAPES.CIRC)
            F = S.x, M = S.y, U = S.radius + I, B = S.radius + I, b = F - U < b ? F - U : b, C = F + U > C ? F + U : C, w = M - B < w ? M - B : w, A = M + B > A ? M + B : A;
          else if (D === l.SHAPES.ELIP)
            F = S.x, M = S.y, U = S.width + I, B = S.height + I, b = F - U < b ? F - U : b, C = F + U > C ? F + U : C, w = M - B < w ? M - B : w, A = M + B > A ? M + B : A;
          else
            for (var P = S.points, G = 0, W = 0, V = 0, K = 0, J = 0, ae = 0, re = 0, he = 0, ge = 0; ge + 2 < P.length; ge += 2)
              F = P[ge], M = P[ge + 1], G = P[ge + 2], W = P[ge + 3], V = Math.abs(G - F), K = Math.abs(W - M), B = I * 2, U = Math.sqrt(V * V + K * K), !(U < 1e-9) && (J = (B / U * K + V) / 2, ae = (B / U * V + K) / 2, re = (G + F) / 2, he = (W + M) / 2, b = re - J < b ? re - J : b, C = re + J > C ? re + J : C, w = he - ae < w ? he - ae : w, A = he + ae > A ? he + ae : A);
        }
      else
        b = 0, C = 0, w = 0, A = 0;
      var me = this.boundsPadding;
      this._localBounds.minX = b - me, this._localBounds.maxX = C + me, this._localBounds.minY = w - me, this._localBounds.maxY = A + me;
    }
    /**
     * Draws the given shape to this Graphics object. Can be any of Circle, Rectangle, Ellipse, Line or Polygon.
     *
     * @param {InkPaint.Circle|InkPaint.Ellipse|InkPaint.Polygon|InkPaint.Rectangle|InkPaint.RoundedRectangle} shape - The shape object to draw.
     * @return {InkPaint.GraphicsData} The generated GraphicsData object.
     */
    drawShape(b) {
      this.currentPath && this.currentPath.shape.points.length <= 2 && this.graphicsData.pop(), this.currentPath = null;
      var C = new r.default(this.lineWidth, this.lineColor, this.lineAlpha, this.fillColor, this.fillAlpha, this.filling, this.nativeLines, b, this.lineAlignment);
      return this.graphicsData.push(C), C.type === l.SHAPES.POLY && (C.shape.closed = C.shape.closed, this.currentPath = C), this.dirty++, C;
    }
    generateTexture(b, C, w) {
      w === void 0 && (w = 1);
      var A = this.getLocalBounds(), S = e.default.create(A.width, A.height, C, w);
      return this.transform.updateLocalTransform(), this.transform.localTransform.copy(y), y.invert(), y.tx -= A.x, y.ty -= A.y, b.render(this, S, true, y), S;
    }
    generateCanvasTexture(b, C) {
      C === void 0 && (C = 1);
      var w = this.getLocalBounds(), A = e.default.create(w.width, w.height, b, C);
      m || (m = new f.default()), this.transform.updateLocalTransform(), this.transform.localTransform.copy(y), y.invert(), y.tx -= w.x, y.ty -= w.y, m.render(this, A, true, y);
      var S = t.default.fromCanvas(A.baseTexture._canvasRenderTarget.canvas, b, "graphics");
      return S.baseTexture.resolution = C, S.baseTexture.update(), S;
    }
    /**
     * Closes the current path.
     *
     * @return {InkPaint.Graphics} Returns itself.
     */
    closePath() {
      var b = this.currentPath;
      return b && b.shape && b.shape.close(), this;
    }
    /**
     * Adds a hole in the current path.
     *
     * @return {InkPaint.Graphics} Returns itself.
     */
    addHole() {
      var b = this.graphicsData.pop();
      return this.currentPath = this.graphicsData[this.graphicsData.length - 1], this.currentPath.addHole(b.shape), this.currentPath = null, this;
    }
    /**
     * Destroys the Graphics object.
     *
     * @param {object|boolean} [options] - Options parameter. A boolean will act as if all
     *  options have been set to that value
     * @param {boolean} [options.children=false] - if set to true, all the children will have
     *  their destroy method called as well. 'options' will be passed on to those calls.
     * @param {boolean} [options.texture=false] - Only used for child Sprites if options.children is set to true
     *  Should it destroy the texture of the child sprite
     * @param {boolean} [options.baseTexture=false] - Only used for child Sprites if options.children is set to true
     *  Should it destroy the base texture of the child sprite
     */
    destroy(b) {
      super.destroy(b);
      for (var C = 0; C < this.graphicsData.length; ++C)
        this.graphicsData[C].destroy();
      for (var w in this._webGL)
        for (var A = 0; A < this._webGL[w].data.length; ++A)
          this._webGL[w].data[A].destroy();
      this._spriteRect && this._spriteRect.destroy(), this.graphicsData = null, this.currentPath = null, this._webGL = null, this._localBounds = null;
    }
  };
  return Graphics.default = T, T._SPRITE_TEXTURE = null, T.CURVES = {
    adaptive: false,
    maxLength: 10,
    minSegments: 8,
    maxSegments: 2048
  }, Graphics;
}
var GraphicsRenderer = {}, WebGLGraphicsData = {}, hasRequiredWebGLGraphicsData;
function requireWebGLGraphicsData() {
  if (hasRequiredWebGLGraphicsData) return WebGLGraphicsData;
  hasRequiredWebGLGraphicsData = 1, Object.defineProperty(WebGLGraphicsData, "__esModule", {
    value: true
  }), WebGLGraphicsData.default = void 0;
  var i2 = e(requireSrc$1());
  function e(r) {
    return r && r.__esModule ? r : { default: r };
  }
  let t = class {
    /**
     * @param {WebGLRenderingContext} gl - The current WebGL drawing context
     * @param {InkPaint.Shader} shader - The shader
     * @param {object} attribsState - The state for the VAO
     */
    constructor(r, a, s) {
      this.gl = r, this.color = [0, 0, 0], this.points = [], this.indices = [], this.buffer = i2.default.GLBuffer.createVertexBuffer(r), this.indexBuffer = i2.default.GLBuffer.createIndexBuffer(r), this.dirty = true, this.nativeLines = false, this.glPoints = null, this.glIndices = null, this.shader = a, this.vao = new i2.default.VertexArrayObject(r, s).addIndex(this.indexBuffer).addAttribute(this.buffer, a.attributes.aVertexPosition, r.FLOAT, false, 4 * 6, 0).addAttribute(this.buffer, a.attributes.aColor, r.FLOAT, false, 4 * 6, 2 * 4);
    }
    /**
     * Resets the vertices and the indices
     */
    reset() {
      this.points.length = 0, this.indices.length = 0;
    }
    /**
     * Binds the buffers and uploads the data
     */
    upload() {
      this.glPoints = new Float32Array(this.points), this.buffer.upload(this.glPoints), this.glIndices = new Uint16Array(this.indices), this.indexBuffer.upload(this.glIndices), this.dirty = false;
    }
    /**
     * Empties all the data
     */
    destroy() {
      this.color = null, this.points = null, this.indices = null, this.vao.destroy(), this.buffer.destroy(), this.indexBuffer.destroy(), this.gl = null, this.buffer = null, this.indexBuffer = null, this.glPoints = null, this.glIndices = null;
    }
  };
  return WebGLGraphicsData.default = t, WebGLGraphicsData;
}
var PrimitiveShader = {}, hasRequiredPrimitiveShader;
function requirePrimitiveShader() {
  if (hasRequiredPrimitiveShader) return PrimitiveShader;
  hasRequiredPrimitiveShader = 1, Object.defineProperty(PrimitiveShader, "__esModule", {
    value: true
  }), PrimitiveShader.default = void 0;
  var i2 = e(requireShader$1());
  function e(r) {
    return r && r.__esModule ? r : { default: r };
  }
  let t = class extends i2.default {
    constructor(r) {
      super(
        r,
        // vertex shader
        ["attribute vec2 aVertexPosition;", "attribute vec4 aColor;", "uniform mat3 translationMatrix;", "uniform mat3 projectionMatrix;", "uniform float alpha;", "uniform vec3 tint;", "varying vec4 vColor;", "void main(void){", "   gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);", "   vColor = aColor * vec4(tint * alpha, alpha);", "}"].join(`
`),
        // fragment shader
        ["varying vec4 vColor;", "void main(void){", "   gl_FragColor = vColor;", "}"].join(`
`)
      );
    }
  };
  return PrimitiveShader.default = t, PrimitiveShader;
}
var buildPoly = {}, buildLine = {}, hasRequiredBuildLine;
function requireBuildLine() {
  if (hasRequiredBuildLine) return buildLine;
  hasRequiredBuildLine = 1, Object.defineProperty(buildLine, "__esModule", {
    value: true
  }), buildLine.default = t;
  var i2 = requireMath$1(), e = requireUtils$3();
  function t(s, u, l) {
    s.nativeLines ? a(s, l) : r(s, u);
  }
  function r(s, u) {
    var l = s.points;
    if (l.length !== 0) {
      var c = new i2.Point(l[0], l[1]), d = new i2.Point(l[l.length - 2], l[l.length - 1]);
      if (c.x === d.x && c.y === d.y) {
        l = l.slice(), l.pop(), l.pop(), d = new i2.Point(l[l.length - 2], l[l.length - 1]);
        var f = d.x + (c.x - d.x) * 0.5, p = d.y + (c.y - d.y) * 0.5;
        l.unshift(f, p), l.push(f, p);
      }
      var m = u.points, y = u.indices, x = l.length / 2, g = l.length, _ = m.length / 6, T = s.lineWidth / 2, E = (0, e.hex2rgb)(s.lineColor), b = s.lineAlpha, C = E[0] * b, w = E[1] * b, A = E[2] * b, S = l[0], F = l[1], M = l[2], U = l[3], B = 0, q = 0, z = -(F - U), D = S - M, X = 0, k = 0, I = 0, P = 0, G = Math.sqrt(z * z + D * D);
      z /= G, D /= G, z *= T, D *= T;
      var W = s.lineAlignment, V = (1 - W) * 2, K = W * 2;
      m.push(S - z * V, F - D * V, C, w, A, b), m.push(S + z * K, F + D * K, C, w, A, b);
      for (var J = 1; J < x - 1; ++J) {
        S = l[(J - 1) * 2], F = l[(J - 1) * 2 + 1], M = l[J * 2], U = l[J * 2 + 1], B = l[(J + 1) * 2], q = l[(J + 1) * 2 + 1], z = -(F - U), D = S - M, G = Math.sqrt(z * z + D * D), z /= G, D /= G, z *= T, D *= T, X = -(U - q), k = M - B, G = Math.sqrt(X * X + k * k), X /= G, k /= G, X *= T, k *= T;
        var ae = -D + F - (-D + U), re = -z + M - (-z + S), he = (-z + S) * (-D + U) - (-z + M) * (-D + F), ge = -k + q - (-k + U), me = -X + M - (-X + B), Te = (-X + B) * (-k + U) - (-X + M) * (-k + q), _e = ae * me - ge * re;
        if (Math.abs(_e) < 0.1) {
          _e += 10.1, m.push(M - z * V, U - D * V, C, w, A, b), m.push(M + z * K, U + D * K, C, w, A, b);
          continue;
        }
        var ye = (re * Te - me * he) / _e, Ae = (ge * he - ae * Te) / _e, ke = (ye - M) * (ye - M) + (Ae - U) * (Ae - U);
        ke > 196 * T * T ? (I = z - X, P = D - k, G = Math.sqrt(I * I + P * P), I /= G, P /= G, I *= T, P *= T, m.push(M - I * V, U - P * V), m.push(C, w, A, b), m.push(M + I * K, U + P * K), m.push(C, w, A, b), m.push(M - I * K * V, U - P * V), m.push(C, w, A, b), g++) : (m.push(M + (ye - M) * V, U + (Ae - U) * V), m.push(C, w, A, b), m.push(M - (ye - M) * K, U - (Ae - U) * K), m.push(C, w, A, b));
      }
      S = l[(x - 2) * 2], F = l[(x - 2) * 2 + 1], M = l[(x - 1) * 2], U = l[(x - 1) * 2 + 1], z = -(F - U), D = S - M, G = Math.sqrt(z * z + D * D), z /= G, D /= G, z *= T, D *= T, m.push(M - z * V, U - D * V), m.push(C, w, A, b), m.push(M + z * K, U + D * K), m.push(C, w, A, b), y.push(_);
      for (var Pe = 0; Pe < g; ++Pe)
        y.push(_++);
      y.push(_ - 1);
    }
  }
  function a(s, u) {
    var l = 0, c = s.points;
    if (c.length !== 0) {
      var d = u.points, f = c.length / 2, p = (0, e.hex2rgb)(s.lineColor), m = s.lineAlpha, y = p[0] * m, x = p[1] * m, g = p[2] * m;
      for (l = 1; l < f; l++) {
        var _ = c[(l - 1) * 2], T = c[(l - 1) * 2 + 1], E = c[l * 2], b = c[l * 2 + 1];
        d.push(_, T), d.push(y, x, g, m), d.push(E, b), d.push(y, x, g, m);
      }
    }
  }
  return buildLine;
}
var hasRequiredBuildPoly;
function requireBuildPoly() {
  if (hasRequiredBuildPoly) return buildPoly;
  hasRequiredBuildPoly = 1, Object.defineProperty(buildPoly, "__esModule", {
    value: true
  }), buildPoly.default = a;
  var i2 = r(requireBuildLine()), e = requireUtils$3(), t = r(requireEarcut());
  function r(s) {
    return s && s.__esModule ? s : { default: s };
  }
  function a(s, u, l) {
    s.points = s.shape.points.slice();
    var c = s.points;
    if (s.fill && c.length >= 6) {
      for (var d = [], f = s.holes, p = 0; p < f.length; p++) {
        var m = f[p];
        d.push(c.length / 2), c = c.concat(m.points);
      }
      var y = u.points, x = u.indices, g = c.length / 2, _ = (0, e.hex2rgb)(s.fillColor), T = s.fillAlpha, E = _[0] * T, b = _[1] * T, C = _[2] * T, w = (0, t.default)(c, d, 2);
      if (!w)
        return;
      for (var A = y.length / 6, S = 0; S < w.length; S += 3)
        x.push(w[S] + A), x.push(w[S] + A), x.push(w[S + 1] + A), x.push(w[S + 2] + A), x.push(w[S + 2] + A);
      for (var F = 0; F < g; F++)
        y.push(c[F * 2], c[F * 2 + 1], E, b, C, T);
    }
    s.lineWidth > 0 && (0, i2.default)(s, u, l);
  }
  return buildPoly;
}
var buildRectangle = {}, hasRequiredBuildRectangle;
function requireBuildRectangle() {
  if (hasRequiredBuildRectangle) return buildRectangle;
  hasRequiredBuildRectangle = 1, Object.defineProperty(buildRectangle, "__esModule", {
    value: true
  }), buildRectangle.default = r;
  var i2 = t(requireBuildLine()), e = requireUtils$3();
  function t(a) {
    return a && a.__esModule ? a : { default: a };
  }
  function r(a, s, u) {
    var l = a.shape, c = l.x, d = l.y, f = l.width, p = l.height;
    if (a.fill) {
      var m = (0, e.hex2rgb)(a.fillColor), y = a.fillAlpha, x = m[0] * y, g = m[1] * y, _ = m[2] * y, T = s.points, E = s.indices, b = T.length / 6;
      T.push(c, d), T.push(x, g, _, y), T.push(c + f, d), T.push(x, g, _, y), T.push(c, d + p), T.push(x, g, _, y), T.push(c + f, d + p), T.push(x, g, _, y), E.push(b, b, b + 1, b + 2, b + 3, b + 3);
    }
    if (a.lineWidth) {
      var C = a.points;
      a.points = [c, d, c + f, d, c + f, d + p, c, d + p, c, d], (0, i2.default)(a, s, u), a.points = C;
    }
  }
  return buildRectangle;
}
var buildRoundedRectangle = {}, hasRequiredBuildRoundedRectangle;
function requireBuildRoundedRectangle() {
  if (hasRequiredBuildRoundedRectangle) return buildRoundedRectangle;
  hasRequiredBuildRoundedRectangle = 1, Object.defineProperty(buildRoundedRectangle, "__esModule", {
    value: true
  }), buildRoundedRectangle.default = a;
  var i2 = r(requireEarcut()), e = r(requireBuildLine()), t = requireUtils$3();
  function r(l) {
    return l && l.__esModule ? l : { default: l };
  }
  function a(l, c, d) {
    var f = l.shape, p = f.x, m = f.y, y = f.width, x = f.height, g = f.radius, _ = [];
    if (_.push(p + g, m), u(p + y - g, m, p + y, m, p + y, m + g, _), u(p + y, m + x - g, p + y, m + x, p + y - g, m + x, _), u(p + g, m + x, p, m + x, p, m + x - g, _), u(p, m + g, p, m, p + g + 1e-10, m, _), l.fill) {
      for (var T = (0, t.hex2rgb)(l.fillColor), E = l.fillAlpha, b = T[0] * E, C = T[1] * E, w = T[2] * E, A = c.points, S = c.indices, F = A.length / 6, M = (0, i2.default)(_, null, 2), U = 0, B = M.length; U < B; U += 3)
        S.push(M[U] + F), S.push(M[U] + F), S.push(M[U + 1] + F), S.push(M[U + 2] + F), S.push(M[U + 2] + F);
      for (var q = 0, z = _.length; q < z; q++)
        A.push(_[q], _[++q], b, C, w, E);
    }
    if (l.lineWidth) {
      var D = l.points;
      l.points = _, (0, e.default)(l, c, d), l.points = D;
    }
  }
  function s(l, c, d) {
    var f = c - l;
    return l + f * d;
  }
  function u(l, c, d, f, p, m, y) {
    y === void 0 && (y = []);
    for (var x = 20, g = y, _ = 0, T = 0, E = 0, b = 0, C = 0, w = 0, A = 0, S = 0; A <= x; ++A)
      S = A / x, _ = s(l, d, S), T = s(c, f, S), E = s(d, p, S), b = s(f, m, S), C = s(_, E, S), w = s(T, b, S), g.push(C, w);
    return g;
  }
  return buildRoundedRectangle;
}
var buildCircle = {}, hasRequiredBuildCircle;
function requireBuildCircle() {
  if (hasRequiredBuildCircle) return buildCircle;
  hasRequiredBuildCircle = 1, Object.defineProperty(buildCircle, "__esModule", {
    value: true
  }), buildCircle.default = a;
  var i2 = r(requireBuildLine()), e = require_const(), t = requireUtils$3();
  function r(s) {
    return s && s.__esModule ? s : { default: s };
  }
  function a(s, u, l) {
    var c = s.shape, d = c.x, f = c.y, p, m;
    if (s.type === e.SHAPES.CIRC ? (p = c.radius, m = c.radius) : (p = c.width, m = c.height), !(p === 0 || m === 0)) {
      var y = Math.floor(30 * Math.sqrt(c.radius)) || Math.floor(15 * Math.sqrt(c.width + c.height)), x = Math.PI * 2 / y;
      if (s.fill) {
        var g = (0, t.hex2rgb)(s.fillColor), _ = s.fillAlpha, T = g[0] * _, E = g[1] * _, b = g[2] * _, C = u.points, w = u.indices, A = C.length / 6;
        w.push(A);
        for (var S = 0; S < y + 1; S++)
          C.push(d, f, T, E, b, _), C.push(d + Math.sin(x * S) * p, f + Math.cos(x * S) * m, T, E, b, _), w.push(A++, A++);
        w.push(A - 1);
      }
      if (s.lineWidth) {
        var F = s.points;
        s.points = [];
        for (var M = 0; M < y; M++)
          s.points.push(d + Math.sin(x * -M) * p, f + Math.cos(x * -M) * m);
        s.points.push(s.points[0], s.points[1]), (0, i2.default)(s, u, l), s.points = F;
      }
    }
  }
  return buildCircle;
}
var hasRequiredGraphicsRenderer;
function requireGraphicsRenderer() {
  if (hasRequiredGraphicsRenderer) return GraphicsRenderer;
  hasRequiredGraphicsRenderer = 1, Object.defineProperty(GraphicsRenderer, "__esModule", {
    value: true
  }), GraphicsRenderer.default = void 0;
  var i2 = requireUtils$3(), e = require_const(), t = f(requireObjectRenderer()), r = f(requireWebGLRenderer()), a = f(requireWebGLGraphicsData()), s = f(requirePrimitiveShader()), u = f(requireBuildPoly()), l = f(requireBuildRectangle()), c = f(requireBuildRoundedRectangle()), d = f(requireBuildCircle());
  function f(m) {
    return m && m.__esModule ? m : { default: m };
  }
  let p = class extends t.default {
    /**
     * @param {InkPaint.WebGLRenderer} renderer - The renderer this object renderer works for.
     */
    constructor(m) {
      super(m), this.graphicsDataPool = [], this.primitiveShader = null, this.gl = m.gl, this.CONTEXT_UID = 0;
    }
    /**
     * Called when there is a WebGL context change
     *
     * @private
     *
     */
    onContextChange() {
      this.gl = this.renderer.gl, this.CONTEXT_UID = this.renderer.CONTEXT_UID, this.primitiveShader = new s.default(this.gl);
    }
    /**
     * Destroys this renderer.
     *
     */
    destroy() {
      t.default.prototype.destroy.call(this);
      for (var m = 0; m < this.graphicsDataPool.length; ++m)
        this.graphicsDataPool[m].destroy();
      this.graphicsDataPool = null;
    }
    /**
     * Renders a graphics object.
     *
     * @param {InkPaint.Graphics} graphics - The graphics object to render.
     */
    render(m) {
      var y = this.renderer, x = y.gl, g, _ = m._webGL[this.CONTEXT_UID];
      (!_ || m.dirty !== _.dirty) && (this.updateGraphics(m), _ = m._webGL[this.CONTEXT_UID]);
      var T = this.primitiveShader;
      y.bindShader(T), y.state.setBlendMode(m.blendMode);
      for (var E = 0, b = _.data.length; E < b; E++) {
        g = _.data[E];
        var C = g.shader;
        y.bindShader(C), C.uniforms.translationMatrix = m.transform.worldTransform.toArray(true), C.uniforms.tint = (0, i2.hex2rgb)(m.tint), C.uniforms.alpha = m.worldAlpha, y.bindVao(g.vao), g.nativeLines ? x.drawArrays(x.LINES, 0, g.points.length / 6) : g.vao.draw(x.TRIANGLE_STRIP, g.indices.length);
      }
    }
    /**
     * Updates the graphics object
     *
     * @private
     * @param {InkPaint.Graphics} graphics - The graphics object to update
     */
    updateGraphics(m) {
      var y = this.renderer.gl, x = m._webGL[this.CONTEXT_UID];
      if (x || (x = m._webGL[this.CONTEXT_UID] = {
        lastIndex: 0,
        data: [],
        gl: y,
        clearDirty: -1,
        dirty: -1
      }), x.dirty = m.dirty, m.clearDirty !== x.clearDirty) {
        x.clearDirty = m.clearDirty;
        for (var g = 0; g < x.data.length; g++)
          this.graphicsDataPool.push(x.data[g]);
        x.data.length = 0, x.lastIndex = 0;
      }
      for (var _, T, E = x.lastIndex; E < m.graphicsData.length; E++) {
        var b = m.graphicsData[E];
        _ = this.getWebGLData(x, 0), b.nativeLines && b.lineWidth && (T = this.getWebGLData(x, 0, true), x.lastIndex++), b.type === e.SHAPES.POLY && (0, u.default)(b, _, T), b.type === e.SHAPES.RECT ? (0, l.default)(b, _, T) : b.type === e.SHAPES.CIRC || b.type === e.SHAPES.ELIP ? (0, d.default)(b, _, T) : b.type === e.SHAPES.RREC && (0, c.default)(b, _, T), x.lastIndex++;
      }
      this.renderer.bindVao(null);
      for (var C = 0; C < x.data.length; C++)
        _ = x.data[C], _.dirty && _.upload();
    }
    /**
     *
     * @private
     * @param {WebGLRenderingContext} gl - the current WebGL drawing context
     * @param {number} type - TODO @Alvin
     * @param {number} nativeLines - indicate whether the webGLData use for nativeLines.
     * @return {*} TODO
     */
    getWebGLData(m, y, x) {
      var g = m.data[m.data.length - 1];
      return (!g || g.nativeLines !== x || g.points.length > 32e4) && (g = this.graphicsDataPool.pop() || new a.default(this.renderer.gl, this.primitiveShader, this.renderer.state.attribsState), g.nativeLines = x, g.reset(y), m.data.push(g)), g.dirty = true, g;
    }
  };
  return GraphicsRenderer.default = p, r.default.registerPlugin("graphics", p), GraphicsRenderer;
}
var CanvasGraphicsRenderer = {}, hasRequiredCanvasGraphicsRenderer;
function requireCanvasGraphicsRenderer() {
  if (hasRequiredCanvasGraphicsRenderer) return CanvasGraphicsRenderer;
  hasRequiredCanvasGraphicsRenderer = 1, Object.defineProperty(CanvasGraphicsRenderer, "__esModule", {
    value: true
  }), CanvasGraphicsRenderer.default = void 0;
  var i2 = t(requireCanvasRenderer()), e = require_const();
  function t(a) {
    return a && a.__esModule ? a : { default: a };
  }
  let r = class {
    constructor(a) {
      this.renderer = a;
    }
    render(a) {
      var s = this.renderer, u = s.context, l = a.worldAlpha, c = a.transform.worldTransform, d = s.resolution;
      u.setTransform(c.a * d, c.b * d, c.c * d, c.d * d, c.tx * d, c.ty * d), (a.canvasTintDirty !== a.dirty || a._prevTint !== a.tint) && this.updateGraphicsTint(a), s.setBlendMode(a.blendMode);
      for (var f = 0; f < a.graphicsData.length; f++) {
        var p = a.graphicsData[f], m = p.shape, y = p._fillTint, x = p._lineTint;
        if (u.lineWidth = p.lineWidth, p.type === e.SHAPES.POLY) {
          u.beginPath();
          var g = m.points, _ = p.holes, T = void 0, E = void 0, b = void 0, C = void 0;
          u.moveTo(g[0], g[1]);
          for (var w = 2; w < g.length; w += 2)
            u.lineTo(g[w], g[w + 1]);
          if (m.closed && u.closePath(), _.length > 0) {
            T = 0, b = g[0], C = g[1];
            for (var A = 2; A + 2 < g.length; A += 2)
              T += (g[A] - b) * (g[A + 3] - C) - (g[A + 2] - b) * (g[A + 1] - C);
            for (var S = 0; S < _.length; S++)
              if (g = _[S].points, !!g) {
                E = 0, b = g[0], C = g[1];
                for (var F = 2; F + 2 < g.length; F += 2)
                  E += (g[F] - b) * (g[F + 3] - C) - (g[F + 2] - b) * (g[F + 1] - C);
                if (E * T < 0) {
                  u.moveTo(g[0], g[1]);
                  for (var M = 2; M < g.length; M += 2)
                    u.lineTo(g[M], g[M + 1]);
                } else {
                  u.moveTo(g[g.length - 2], g[g.length - 1]);
                  for (var U = g.length - 4; U >= 0; U -= 2)
                    u.lineTo(g[U], g[U + 1]);
                }
                _[S].close && u.closePath();
              }
          }
          p.fill && (u.globalAlpha = p.fillAlpha * l, u.fillStyle = "#" + ("00000" + (y | 0).toString(16)).substr(-6), u.fill()), p.lineWidth && (u.globalAlpha = p.lineAlpha * l, u.strokeStyle = "#" + ("00000" + (x | 0).toString(16)).substr(-6), u.stroke());
        } else if (p.type === e.SHAPES.RECT)
          (p.fillColor || p.fillColor === 0) && (u.globalAlpha = p.fillAlpha * l, u.fillStyle = "#" + ("00000" + (y | 0).toString(16)).substr(-6), u.fillRect(m.x, m.y, m.width, m.height)), p.lineWidth && (u.globalAlpha = p.lineAlpha * l, u.strokeStyle = "#" + ("00000" + (x | 0).toString(16)).substr(-6), u.strokeRect(m.x, m.y, m.width, m.height));
        else if (p.type === e.SHAPES.CIRC)
          u.beginPath(), u.arc(m.x, m.y, m.radius, 0, 2 * Math.PI), u.closePath(), p.fill && (u.globalAlpha = p.fillAlpha * l, u.fillStyle = "#" + ("00000" + (y | 0).toString(16)).substr(-6), u.fill()), p.lineWidth && (u.globalAlpha = p.lineAlpha * l, u.strokeStyle = "#" + ("00000" + (x | 0).toString(16)).substr(-6), u.stroke());
        else if (p.type === e.SHAPES.ELIP) {
          var B = m.width * 2, q = m.height * 2, z = m.x - B / 2, D = m.y - q / 2;
          u.beginPath();
          var X = 0.5522848, k = B / 2 * X, I = q / 2 * X, P = z + B, G = D + q, W = z + B / 2, V = D + q / 2;
          u.moveTo(z, V), u.bezierCurveTo(z, V - I, W - k, D, W, D), u.bezierCurveTo(W + k, D, P, V - I, P, V), u.bezierCurveTo(P, V + I, W + k, G, W, G), u.bezierCurveTo(W - k, G, z, V + I, z, V), u.closePath(), p.fill && (u.globalAlpha = p.fillAlpha * l, u.fillStyle = "#" + ("00000" + (y | 0).toString(16)).substr(-6), u.fill()), p.lineWidth && (u.globalAlpha = p.lineAlpha * l, u.strokeStyle = "#" + ("00000" + (x | 0).toString(16)).substr(-6), u.stroke());
        } else if (p.type === e.SHAPES.RREC) {
          var K = m.x, J = m.y, ae = m.width, re = m.height, he = m.radius, ge = Math.min(ae, re) / 2 | 0;
          he = he > ge ? ge : he, u.beginPath(), u.moveTo(K, J + he), u.lineTo(K, J + re - he), u.quadraticCurveTo(K, J + re, K + he, J + re), u.lineTo(K + ae - he, J + re), u.quadraticCurveTo(K + ae, J + re, K + ae, J + re - he), u.lineTo(K + ae, J + he), u.quadraticCurveTo(K + ae, J, K + ae - he, J), u.lineTo(K + he, J), u.quadraticCurveTo(K, J, K, J + he), u.closePath(), (p.fillColor || p.fillColor === 0) && (u.globalAlpha = p.fillAlpha * l, u.fillStyle = "#" + ("00000" + (y | 0).toString(16)).substr(-6), u.fill()), p.lineWidth && (u.globalAlpha = p.lineAlpha * l, u.strokeStyle = "#" + ("00000" + (x | 0).toString(16)).substr(-6), u.stroke());
        }
      }
    }
    /**
     * Updates the tint of a graphics object
     *
     * @private
     * @param {InkPaint.Graphics} graphics - the graphics that will have its tint updated
     */
    updateGraphicsTint(a) {
      a._prevTint = a.tint, a.canvasTintDirty = a.dirty;
      for (var s = (a.tint >> 16 & 255) / 255, u = (a.tint >> 8 & 255) / 255, l = (a.tint & 255) / 255, c = 0; c < a.graphicsData.length; ++c) {
        var d = a.graphicsData[c], f = d.fillColor | 0, p = d.lineColor | 0;
        d._fillTint = ((f >> 16 & 255) / 255 * s * 255 << 16) + ((f >> 8 & 255) / 255 * u * 255 << 8) + (f & 255) / 255 * l * 255, d._lineTint = ((p >> 16 & 255) / 255 * s * 255 << 16) + ((p >> 8 & 255) / 255 * u * 255 << 8) + (p & 255) / 255 * l * 255;
      }
    }
    renderPolygon(a, s, u) {
      u.moveTo(a[0], a[1]);
      for (var l = 1; l < a.length / 2; ++l)
        u.lineTo(a[l * 2], a[l * 2 + 1]);
      s && u.closePath();
    }
    /**
     * destroy graphics object
     *
     */
    destroy() {
      this.renderer = null;
    }
  };
  return CanvasGraphicsRenderer.default = r, i2.default.registerPlugin("graphics", r), CanvasGraphicsRenderer;
}
var Spritesheet = {}, hasRequiredSpritesheet;
function requireSpritesheet() {
  if (hasRequiredSpritesheet) return Spritesheet;
  hasRequiredSpritesheet = 1, Object.defineProperty(Spritesheet, "__esModule", {
    value: true
  }), Spritesheet.default = void 0;
  var i2 = requireCore(), e = requireUtils$3(), t = requireCache();
  let r = class yu {
    static get BATCH_SIZE() {
      return 1e3;
    }
    constructor(s, u, l) {
      l === void 0 && (l = null), this.baseTexture = s, this.textures = {}, this.animations = {}, this.data = u, this.resolution = this._updateResolution(l || this.baseTexture.imageUrl), this._frames = this.data.frames, this._frameKeys = Object.keys(this._frames), this._batchIndex = 0, this._callback = null;
    }
    _updateResolution(s) {
      var u = this.data.meta.scale, l = (0, e.getResolutionOfUrl)(s, null);
      return l === null && (l = u !== void 0 ? parseFloat(u) : 1), l !== 1 && (this.baseTexture.resolution = l, this.baseTexture.update()), l;
    }
    parse(s) {
      this._batchIndex = 0, this._callback = s, this._frameKeys.length <= yu.BATCH_SIZE ? (this._processFrames(0), this._processAnimations(), this._parseComplete()) : this._nextBatch();
    }
    _processFrames(s) {
      for (var u = s, l = yu.BATCH_SIZE, c = this.baseTexture.sourceScale; u - s < l && u < this._frameKeys.length; ) {
        var d = this._frameKeys[u], f = this._frames[d], p = f.frame;
        if (p) {
          var m = null, y = null, x = f.trimmed !== false && f.sourceSize ? f.sourceSize : f.frame, g = new i2.Rectangle(0, 0, Math.floor(x.w * c) / this.resolution, Math.floor(x.h * c) / this.resolution);
          f.rotated ? m = new i2.Rectangle(Math.floor(p.x * c) / this.resolution, Math.floor(p.y * c) / this.resolution, Math.floor(p.h * c) / this.resolution, Math.floor(p.w * c) / this.resolution) : m = new i2.Rectangle(Math.floor(p.x * c) / this.resolution, Math.floor(p.y * c) / this.resolution, Math.floor(p.w * c) / this.resolution, Math.floor(p.h * c) / this.resolution), f.trimmed !== false && f.spriteSourceSize && (y = new i2.Rectangle(Math.floor(f.spriteSourceSize.x * c) / this.resolution, Math.floor(f.spriteSourceSize.y * c) / this.resolution, Math.floor(p.w * c) / this.resolution, Math.floor(p.h * c) / this.resolution)), this.textures[d] = new i2.Texture(this.baseTexture, m, g, y, f.rotated ? 2 : 0, f.anchor), (0, t.addToTextureCache)(this.textures[d], d);
        }
        u++;
      }
    }
    _processAnimations() {
      var s = this.data.animations || {};
      for (var u in s) {
        this.animations[u] = [];
        for (var l of s[u])
          this.animations[u].push(this.textures[l]);
      }
    }
    _parseComplete() {
      var s = this._callback;
      this._callback = null, this._batchIndex = 0, s.call(this, this.textures);
    }
    _nextBatch() {
      this._processFrames(this._batchIndex * yu.BATCH_SIZE), this._batchIndex++, setTimeout(() => {
        this._batchIndex * yu.BATCH_SIZE < this._frameKeys.length ? this._nextBatch() : (this._processAnimations(), this._parseComplete());
      }, 0);
    }
    destroy(s) {
      s === void 0 && (s = false);
      for (var u in this.textures)
        this.textures[u].destroy();
      this._frames = null, this._frameKeys = null, this.data = null, this.textures = null, s && this.baseTexture.destroy(), this.baseTexture = null;
    }
  };
  return Spritesheet.default = r, Spritesheet;
}
var Application = {}, autoRenderer = {}, hasRequiredAutoRenderer;
function requireAutoRenderer() {
  if (hasRequiredAutoRenderer) return autoRenderer;
  hasRequiredAutoRenderer = 1, Object.defineProperty(autoRenderer, "__esModule", {
    value: true
  }), autoRenderer.autoRenderer = r;
  var i2 = t(requireCanvasRenderer()), e = t(requireWebGLRenderer());
  function t(a) {
    return a && a.__esModule ? a : { default: a };
  }
  function r(a) {
    a === void 0 && (a = {});
    var s = a.useGL;
    return s ? new e.default(a) : new i2.default(a);
  }
  return autoRenderer;
}
var hasRequiredApplication;
function requireApplication() {
  if (hasRequiredApplication) return Application;
  hasRequiredApplication = 1, Object.defineProperty(Application, "__esModule", {
    value: true
  }), Application.default = void 0;
  var i2 = s(requireSettings()), e = s(requireContainer()), t = requireAutoRenderer(), r = requireTicker(), a = require_const();
  function s(l) {
    return l && l.__esModule ? l : { default: l };
  }
  let u = class {
    constructor(l, c, d, f, p) {
      typeof l == "number" && (l = Object.assign({
        width: l,
        height: c || i2.default.RENDER_OPTIONS.height,
        useGL: !!f,
        sharedTicker: !!p
      }, d)), this._options = l = Object.assign({
        autoStart: true,
        sharedTicker: false,
        useGL: false,
        sharedLoader: false,
        autoRender: false
      }, l), this.renderer = (0, t.autoRenderer)(l), this.stage = new e.default(), this.stage.isStage = true, this._ticker = null, l.autoRender && (this.ticker = l.sharedTicker ? r.shared : new r.Ticker()), l.autoStart && this.start();
    }
    set ticker(l) {
      this._ticker && this._ticker.remove(this.render, this), this._ticker = l, l && l.add(this.render, this, a.UPDATE_PRIORITY.LOW);
    }
    get ticker() {
      return this._ticker;
    }
    render() {
      this.renderer.render(this.stage);
    }
    stop() {
      this.ticker && this.ticker.stop();
    }
    start() {
      this.ticker && this.ticker.start();
    }
    get view() {
      return this.renderer.view;
    }
    get screen() {
      return this.renderer.screen;
    }
    destroyChildren(l) {
      this.stage.destroyChildren(l);
    }
    destroy(l, c) {
      if (this._ticker) {
        var d = this._ticker;
        this.ticker = null, d.destroy();
      }
      this.stage.destroy(c), this.renderer.destroy(l), this.renderer = null, this._options = null, this.stage = null;
    }
  };
  return Application.default = u, Application;
}
var hasRequiredCore;
function requireCore() {
  return hasRequiredCore || (hasRequiredCore = 1, function(i2) {
    Object.defineProperty(i2, "__esModule", {
      value: true
    });
    var e = {
      utils: true,
      settings: true,
      ticker: true,
      Ticker: true,
      CanvasRenderer: true,
      WebGLRenderer: true,
      glCore: true,
      Bounds: true,
      ProxyObj: true,
      DisplayObject: true,
      Container: true,
      Transform: true,
      TransformStatic: true,
      TransformBase: true,
      Sprite: true,
      AnimatedSprite: true,
      CanvasSpriteRenderer: true,
      CanvasTinter: true,
      SpriteRenderer: true,
      Text: true,
      TextStyle: true,
      TextMetrics: true,
      Graphics: true,
      GraphicsData: true,
      GraphicsRenderer: true,
      CanvasGraphicsRenderer: true,
      Texture: true,
      TextureMatrix: true,
      BaseTexture: true,
      RenderTexture: true,
      BaseRenderTexture: true,
      TextureUvs: true,
      Shader: true,
      Spritesheet: true,
      WebGLManager: true,
      ObjectRenderer: true,
      RenderTarget: true,
      Quad: true,
      SpriteMaskFilter: true,
      Filter: true,
      Application: true
    };
    Object.defineProperty(i2, "AnimatedSprite", {
      enumerable: true,
      get: function() {
        return E.default;
      }
    }), Object.defineProperty(i2, "Application", {
      enumerable: true,
      get: function() {
        return ge.default;
      }
    }), Object.defineProperty(i2, "BaseRenderTexture", {
      enumerable: true,
      get: function() {
        return I.default;
      }
    }), Object.defineProperty(i2, "BaseTexture", {
      enumerable: true,
      get: function() {
        return X.default;
      }
    }), Object.defineProperty(i2, "Bounds", {
      enumerable: true,
      get: function() {
        return f.default;
      }
    }), Object.defineProperty(i2, "CanvasGraphicsRenderer", {
      enumerable: true,
      get: function() {
        return q.default;
      }
    }), Object.defineProperty(i2, "CanvasRenderer", {
      enumerable: true,
      get: function() {
        return l.default;
      }
    }), Object.defineProperty(i2, "CanvasSpriteRenderer", {
      enumerable: true,
      get: function() {
        return b.default;
      }
    }), Object.defineProperty(i2, "CanvasTinter", {
      enumerable: true,
      get: function() {
        return C.default;
      }
    }), Object.defineProperty(i2, "Container", {
      enumerable: true,
      get: function() {
        return y.default;
      }
    }), Object.defineProperty(i2, "DisplayObject", {
      enumerable: true,
      get: function() {
        return m.default;
      }
    }), Object.defineProperty(i2, "Filter", {
      enumerable: true,
      get: function() {
        return he.default;
      }
    }), Object.defineProperty(i2, "Graphics", {
      enumerable: true,
      get: function() {
        return M.default;
      }
    }), Object.defineProperty(i2, "GraphicsData", {
      enumerable: true,
      get: function() {
        return U.default;
      }
    }), Object.defineProperty(i2, "GraphicsRenderer", {
      enumerable: true,
      get: function() {
        return B.default;
      }
    }), Object.defineProperty(i2, "ObjectRenderer", {
      enumerable: true,
      get: function() {
        return K.default;
      }
    }), Object.defineProperty(i2, "ProxyObj", {
      enumerable: true,
      get: function() {
        return p.default;
      }
    }), Object.defineProperty(i2, "Quad", {
      enumerable: true,
      get: function() {
        return ae.default;
      }
    }), Object.defineProperty(i2, "RenderTarget", {
      enumerable: true,
      get: function() {
        return J.default;
      }
    }), Object.defineProperty(i2, "RenderTexture", {
      enumerable: true,
      get: function() {
        return k.default;
      }
    }), Object.defineProperty(i2, "Shader", {
      enumerable: true,
      get: function() {
        return G.default;
      }
    }), Object.defineProperty(i2, "Sprite", {
      enumerable: true,
      get: function() {
        return T.default;
      }
    }), Object.defineProperty(i2, "SpriteMaskFilter", {
      enumerable: true,
      get: function() {
        return re.default;
      }
    }), Object.defineProperty(i2, "SpriteRenderer", {
      enumerable: true,
      get: function() {
        return w.default;
      }
    }), Object.defineProperty(i2, "Spritesheet", {
      enumerable: true,
      get: function() {
        return W.default;
      }
    }), Object.defineProperty(i2, "Text", {
      enumerable: true,
      get: function() {
        return A.default;
      }
    }), Object.defineProperty(i2, "TextMetrics", {
      enumerable: true,
      get: function() {
        return F.default;
      }
    }), Object.defineProperty(i2, "TextStyle", {
      enumerable: true,
      get: function() {
        return S.default;
      }
    }), Object.defineProperty(i2, "Texture", {
      enumerable: true,
      get: function() {
        return z.default;
      }
    }), Object.defineProperty(i2, "TextureMatrix", {
      enumerable: true,
      get: function() {
        return D.default;
      }
    }), Object.defineProperty(i2, "TextureUvs", {
      enumerable: true,
      get: function() {
        return P.default;
      }
    }), Object.defineProperty(i2, "Ticker", {
      enumerable: true,
      get: function() {
        return u.Ticker;
      }
    }), Object.defineProperty(i2, "Transform", {
      enumerable: true,
      get: function() {
        return x.default;
      }
    }), Object.defineProperty(i2, "TransformBase", {
      enumerable: true,
      get: function() {
        return _.default;
      }
    }), Object.defineProperty(i2, "TransformStatic", {
      enumerable: true,
      get: function() {
        return g.default;
      }
    }), Object.defineProperty(i2, "WebGLManager", {
      enumerable: true,
      get: function() {
        return V.default;
      }
    }), Object.defineProperty(i2, "WebGLRenderer", {
      enumerable: true,
      get: function() {
        return c.default;
      }
    }), Object.defineProperty(i2, "glCore", {
      enumerable: true,
      get: function() {
        return d.default;
      }
    }), Object.defineProperty(i2, "settings", {
      enumerable: true,
      get: function() {
        return s.default;
      }
    }), Object.defineProperty(i2, "ticker", {
      enumerable: true,
      get: function() {
        return u.shared;
      }
    }), i2.utils = void 0;
    var t = require_const();
    Object.keys(t).forEach(function(ye) {
      ye === "default" || ye === "__esModule" || Object.prototype.hasOwnProperty.call(e, ye) || ye in i2 && i2[ye] === t[ye] || Object.defineProperty(i2, ye, {
        enumerable: true,
        get: function() {
          return t[ye];
        }
      });
    });
    var r = requireMath$1();
    Object.keys(r).forEach(function(ye) {
      ye === "default" || ye === "__esModule" || Object.prototype.hasOwnProperty.call(e, ye) || ye in i2 && i2[ye] === r[ye] || Object.defineProperty(i2, ye, {
        enumerable: true,
        get: function() {
          return r[ye];
        }
      });
    });
    var a = _e(requireUtils$3());
    i2.utils = a;
    var s = me(requireSettings()), u = requireTicker(), l = me(requireCanvasRenderer()), c = me(requireWebGLRenderer()), d = me(requireSrc$1()), f = me(requireBounds()), p = me(requireProxyObj()), m = me(requireDisplayObject()), y = me(requireContainer()), x = me(requireTransform()), g = me(requireTransformStatic()), _ = me(requireTransformBase()), T = me(requireSprite()), E = me(requireAnimatedSprite()), b = me(requireCanvasSpriteRenderer()), C = me(requireCanvasTinter()), w = me(requireSpriteRenderer()), A = me(requireText$1()), S = me(requireTextStyle()), F = me(requireTextMetrics()), M = me(requireGraphics()), U = me(requireGraphicsData()), B = me(requireGraphicsRenderer()), q = me(requireCanvasGraphicsRenderer()), z = me(requireTexture$1()), D = me(requireTextureMatrix()), X = me(requireBaseTexture()), k = me(requireRenderTexture()), I = me(requireBaseRenderTexture()), P = me(requireTextureUvs()), G = me(requireShader$1()), W = me(requireSpritesheet()), V = me(requireWebGLManager()), K = me(requireObjectRenderer()), J = me(requireRenderTarget()), ae = me(requireQuad()), re = me(requireSpriteMaskFilter()), he = me(requireFilter$1()), ge = me(requireApplication());
    function me(ye) {
      return ye && ye.__esModule ? ye : { default: ye };
    }
    function Te(ye) {
      if (typeof WeakMap != "function") return null;
      var Ae = /* @__PURE__ */ new WeakMap(), ke = /* @__PURE__ */ new WeakMap();
      return (Te = function(Pe) {
        return Pe ? ke : Ae;
      })(ye);
    }
    function _e(ye, Ae) {
      if (ye.__esModule)
        return ye;
      if (ye === null || typeof ye != "object" && typeof ye != "function")
        return { default: ye };
      var ke = Te(Ae);
      if (ke && ke.has(ye))
        return ke.get(ye);
      var Pe = {}, Ee = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var Oe in ye)
        if (Oe !== "default" && Object.prototype.hasOwnProperty.call(ye, Oe)) {
          var $e = Ee ? Object.getOwnPropertyDescriptor(ye, Oe) : null;
          $e && ($e.get || $e.set) ? Object.defineProperty(Pe, Oe, $e) : Pe[Oe] = ye[Oe];
        }
      return Pe.default = ye, ke && ke.set(ye, Pe), Pe;
    }
  }(core)), core;
}
var filters = {}, NoiseFilter = {}, hasRequiredNoiseFilter;
function requireNoiseFilter() {
  if (hasRequiredNoiseFilter) return NoiseFilter;
  hasRequiredNoiseFilter = 1, Object.defineProperty(NoiseFilter, "__esModule", {
    value: true
  }), NoiseFilter.default = void 0, e(requireSettings());
  var i2 = e(requireFilter$1());
  function e(r) {
    return r && r.__esModule ? r : { default: r };
  }
  let t = class extends i2.default {
    constructor(r, a) {
      r === void 0 && (r = 0.5), a === void 0 && (a = Math.random()), super(
        // vertex shader
        `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);
    vTextureCoord = aTextureCoord;
}`,
        // fragment shader
        `precision highp float;

varying vec2 vTextureCoord;
varying vec4 vColor;

uniform float uNoise;
uniform float uSeed;
uniform sampler2D uSampler;

float rand(vec2 co)
{
    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);
}

void main()
{
    vec4 color = texture2D(uSampler, vTextureCoord);
    float randomValue = rand(gl_FragCoord.xy * uSeed);
    float diff = (randomValue - 0.5) * uNoise;

    // Un-premultiply alpha before applying the color matrix. See issue #3539.
    if (color.a > 0.0) {
        color.rgb /= color.a;
    }

    color.r += diff;
    color.g += diff;
    color.b += diff;

    // Premultiply alpha again.
    color.rgb *= color.a;

    gl_FragColor = color;
}
`
      ), this.noise = r, this.seed = a;
    }
    get noise() {
      return this.uniforms.uNoise;
    }
    set noise(r) {
      this.uniforms.uNoise = r;
    }
    get seed() {
      return this.uniforms.uSeed;
    }
    set seed(r) {
      this.uniforms.uSeed = r;
    }
  };
  return NoiseFilter.default = t, NoiseFilter;
}
var AlphaFilter = {}, hasRequiredAlphaFilter;
function requireAlphaFilter() {
  if (hasRequiredAlphaFilter) return AlphaFilter;
  hasRequiredAlphaFilter = 1, Object.defineProperty(AlphaFilter, "__esModule", {
    value: true
  }), AlphaFilter.default = void 0, e(requireSettings());
  var i2 = e(requireFilter$1());
  function e(r) {
    return r && r.__esModule ? r : { default: r };
  }
  let t = class extends i2.default {
    constructor(r) {
      r === void 0 && (r = 1), super(
        // vertex shader
        `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);
    vTextureCoord = aTextureCoord;
}`,
        // fragment shader
        `varying vec2 vTextureCoord;

uniform sampler2D uSampler;
uniform float uAlpha;

void main(void)
{
   gl_FragColor = texture2D(uSampler, vTextureCoord) * uAlpha;
}
`
      ), this.alpha = r, this.glShaderKey = "alpha";
    }
    /**
     * Coefficient for alpha multiplication
     *
     * @member {number}
     * @default 1
     */
    get alpha() {
      return this.uniforms.uAlpha;
    }
    set alpha(r) {
      this.uniforms.uAlpha = r;
    }
  };
  return AlphaFilter.default = t, AlphaFilter;
}
var hasRequiredFilters;
function requireFilters() {
  return hasRequiredFilters || (hasRequiredFilters = 1, function(i2) {
    Object.defineProperty(i2, "__esModule", {
      value: true
    }), Object.defineProperty(i2, "AlphaFilter", {
      enumerable: true,
      get: function() {
        return c.default;
      }
    }), Object.defineProperty(i2, "BlurFilter", {
      enumerable: true,
      get: function() {
        return a.default;
      }
    }), Object.defineProperty(i2, "BlurXFilter", {
      enumerable: true,
      get: function() {
        return s.default;
      }
    }), Object.defineProperty(i2, "BlurYFilter", {
      enumerable: true,
      get: function() {
        return u.default;
      }
    }), Object.defineProperty(i2, "ChromaFilter", {
      enumerable: true,
      get: function() {
        return d.default;
      }
    }), Object.defineProperty(i2, "ColorMatrixFilter", {
      enumerable: true,
      get: function() {
        return l.default;
      }
    }), Object.defineProperty(i2, "DisplacementFilter", {
      enumerable: true,
      get: function() {
        return r.default;
      }
    }), Object.defineProperty(i2, "FXAAFilter", {
      enumerable: true,
      get: function() {
        return e.default;
      }
    }), Object.defineProperty(i2, "NoiseFilter", {
      enumerable: true,
      get: function() {
        return t.default;
      }
    });
    var e = f(requireFXAAFilter()), t = f(requireNoiseFilter()), r = f(requireDisplacementFilter()), a = f(requireBlurFilter()), s = f(requireBlurXFilter()), u = f(requireBlurYFilter()), l = f(requireColorMatrixFilter()), c = f(requireAlphaFilter()), d = f(requireChromaFilter());
    function f(p) {
      return p && p.__esModule ? p : { default: p };
    }
  }(filters)), filters;
}
var loaders = {}, loader = {}, textureParser = {}, resource = {}, b64 = {}, hasRequiredB64;
function requireB64() {
  if (hasRequiredB64) return b64;
  hasRequiredB64 = 1, Object.defineProperty(b64, "__esModule", {
    value: true
  }), b64.encodeBinary = e;
  var i2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
  function e(t) {
    for (var r = "", a = 0; a < t.length; ) {
      for (var s = [0, 0, 0], u = [0, 0, 0, 0], l = 0; l < s.length; ++l)
        a < t.length ? s[l] = t.charCodeAt(a++) & 255 : s[l] = 0;
      u[0] = s[0] >> 2, u[1] = (s[0] & 3) << 4 | s[1] >> 4, u[2] = (s[1] & 15) << 2 | s[2] >> 6, u[3] = s[2] & 63;
      var c = a - (t.length - 1);
      switch (c) {
        case 2:
          u[3] = 64, u[2] = 64;
          break;
        case 1:
          u[3] = 64;
          break;
      }
      for (var d = 0; d < u.length; ++d)
        r += i2.charAt(u[d]);
    }
    return r;
  }
  return b64;
}
var async = {}, hasRequiredAsync;
function requireAsync() {
  if (hasRequiredAsync) return async;
  hasRequiredAsync = 1, Object.defineProperty(async, "__esModule", {
    value: true
  }), async.eachSeries = e, async.queue = r;
  function i2() {
  }
  function e(a, s, u, l) {
    var c = 0, d = a.length;
    (function f(p) {
      if (p || c === d) {
        u && u(p);
        return;
      }
      l ? setTimeout(() => {
        s(a[c++], f);
      }, 1) : s(a[c++], f);
    })();
  }
  function t(a) {
    return function() {
      if (a === null)
        throw new Error("Callback was already called.");
      var s = a;
      a = null, s.apply(this, arguments);
    };
  }
  function r(a, s) {
    if (s == null)
      s = 1;
    else if (s === 0)
      throw new Error("Concurrency must not be zero");
    var u = 0, l = {
      _tasks: [],
      concurrency: s,
      saturated: i2,
      unsaturated: i2,
      buffer: s / 4,
      empty: i2,
      drain: i2,
      error: i2,
      started: false,
      paused: false,
      push(f, p) {
        c(f, false, p);
      },
      kill() {
        u = 0, l.drain = i2, l.started = false, l._tasks = [];
      },
      unshift(f, p) {
        c(f, true, p);
      },
      process() {
        for (; !l.paused && u < l.concurrency && l._tasks.length; ) {
          var f = l._tasks.shift();
          l._tasks.length === 0 && l.empty(), u += 1, u === l.concurrency && l.saturated(), a(f.data, t(d(f)));
        }
      },
      length() {
        return l._tasks.length;
      },
      running() {
        return u;
      },
      idle() {
        return l._tasks.length + u === 0;
      },
      pause() {
        l.paused !== true && (l.paused = true);
      },
      resume() {
        if (l.paused !== false) {
          l.paused = false;
          for (var f = 1; f <= l.concurrency; f++)
            l.process();
        }
      }
    };
    function c(f, p, m) {
      if (m != null && typeof m != "function")
        throw new Error("task callback must be a function");
      if (l.started = true, f == null && l.idle()) {
        setTimeout(() => l.drain(), 1);
        return;
      }
      var y = {
        data: f,
        callback: typeof m == "function" ? m : i2
      };
      p ? l._tasks.unshift(y) : l._tasks.push(y), setTimeout(() => l.process(), 1);
    }
    function d(f) {
      return function() {
        u -= 1, f.callback.apply(f, arguments), arguments[0] != null && l.error(arguments[0], f.data), u <= l.concurrency - l.buffer && l.unsaturated(), l.idle() && l.drain(), l.process();
      };
    }
    return l;
  }
  return async;
}
var Loader = {};
class MiniSignalBinding {
  /**
  * MiniSignalBinding constructor.
  * @constructs MiniSignalBinding
  * @param {Function} fn Event handler to be called.
  * @param {Boolean} [once=false] Should this listener be removed after dispatch
  * @param {Mixed} [thisArg] The context of the callback function.
  * @api private
  */
  constructor(e, t = false, r) {
    this._fn = e, this._once = t, this._thisArg = r, this._next = this._prev = this._owner = null;
  }
  detach() {
    return this._owner === null ? false : (this._owner.detach(this), true);
  }
}
function _addMiniSignalBinding(i2, e) {
  return i2._head ? (i2._tail._next = e, e._prev = i2._tail, i2._tail = e) : (i2._head = e, i2._tail = e), e._owner = i2, e;
}
class MiniSignal {
  /**
  * MiniSignal constructor.
  * @constructs MiniSignal
  * @api public
  *
  * @example
  * let mySignal = new MiniSignal();
  * let binding = mySignal.add(onSignal);
  * mySignal.dispatch('foo', 'bar');
  * mySignal.detach(binding);
  */
  constructor() {
    this._head = this._tail = void 0;
  }
  /**
  * Return an array of attached MiniSignalBinding.
  *
  * @param {Boolean} [exists=false] We only need to know if there are handlers.
  * @returns {MiniSignalBinding[]|Boolean} Array of attached MiniSignalBinding or Boolean if called with exists = true
  * @api public
  */
  handlers(e = false) {
    let t = this._head;
    if (e) return !!t;
    const r = [];
    for (; t; )
      r.push(t), t = t._next;
    return r;
  }
  /**
  * Return true if node is a MiniSignalBinding attached to this MiniSignal
  *
  * @param {MiniSignalBinding} node Node to check.
  * @returns {Boolean} True if node is attache to mini-signal
  * @api public
  */
  has(e) {
    if (!(e instanceof MiniSignalBinding))
      throw new Error("MiniSignal#has(): First arg must be a MiniSignalBinding object.");
    return e._owner === this;
  }
  /**
  * Dispaches a signal to all registered listeners.
  *
  * @returns {Boolean} Indication if we've emitted an event.
  * @api public
  */
  dispatch() {
    let e = this._head;
    if (!e) return false;
    for (; e; )
      e._once && this.detach(e), e._fn.apply(e._thisArg, arguments), e = e._next;
    return true;
  }
  /**
  * Register a new listener.
  *
  * @param {Function} fn Callback function.
  * @param {Mixed} [thisArg] The context of the callback function.
  * @returns {MiniSignalBinding} The MiniSignalBinding node that was added.
  * @api public
  */
  add(e, t = null) {
    if (typeof e != "function")
      throw new Error("MiniSignal#add(): First arg must be a Function.");
    return _addMiniSignalBinding(this, new MiniSignalBinding(e, false, t));
  }
  /**
  * Register a new listener that will be executed only once.
  *
  * @param {Function} fn Callback function.
  * @param {Mixed} [thisArg] The context of the callback function.
  * @returns {MiniSignalBinding} The MiniSignalBinding node that was added.
  * @api public
  */
  once(e, t = null) {
    if (typeof e != "function")
      throw new Error("MiniSignal#once(): First arg must be a Function.");
    return _addMiniSignalBinding(this, new MiniSignalBinding(e, true, t));
  }
  /**
  * Remove binding object.
  *
  * @param {MiniSignalBinding} node The binding node that will be removed.
  * @returns {MiniSignal} The instance on which this method was called.
  * @api public */
  detach(e) {
    if (!(e instanceof MiniSignalBinding))
      throw new Error("MiniSignal#detach(): First arg must be a MiniSignalBinding object.");
    return e._owner !== this ? this : (e._prev && (e._prev._next = e._next), e._next && (e._next._prev = e._prev), e === this._head ? (this._head = e._next, e._next === null && (this._tail = null)) : e === this._tail && (this._tail = e._prev, this._tail._next = null), e._owner = null, this);
  }
  /**
  * Detach all listeners.
  *
  * @returns {MiniSignal} The instance on which this method was called.
  * @api public
  */
  detachAll() {
    let e = this._head;
    if (!e) return this;
    for (this._head = this._tail = null; e; )
      e._owner = null, e = e._next;
    return this;
  }
}
const miniSignals = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  MiniSignal,
  MiniSignalBinding,
  default: MiniSignal
}, Symbol.toStringTag, { value: "Module" })), require$$0 = /* @__PURE__ */ getAugmentedNamespace(miniSignals);
var src, hasRequiredSrc;
function requireSrc() {
  return hasRequiredSrc || (hasRequiredSrc = 1, src = (i2, e = {}) => {
    if (!i2) return;
    const t = {
      key: [
        "source",
        "protocol",
        "authority",
        "userInfo",
        "user",
        "password",
        "host",
        "port",
        "relative",
        "path",
        "directory",
        "file",
        "query",
        "anchor"
      ],
      q: {
        name: "queryKey",
        parser: /(?:^|&)([^&=]*)=?([^&]*)/g
      },
      parser: {
        strict: /^(?:([^:/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:/?#]*)(?::(\d*))?))?((((?:[^?#/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
        loose: /^(?:(?![^:@]+:[^:@/]*@)([^:/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#/]*\.[^?#/.]+(?:[?#]|$)))*\/?)?([^?#/]*))(?:\?([^#]*))?(?:#(.*))?)/
      }
    }, r = t.parser[e.strictMode ? "strict" : "loose"].exec(i2), a = {};
    let s = 14;
    for (; s--; ) a[t.key[s]] = r[s] || "";
    return a[t.q.name] = {}, a[t.key[12]].replace(t.q.parser, function(u, l, c) {
      l && (a[t.q.name][l] = c);
    }), a;
  }), src;
}
var Resource = {}, client = { exports: {} }, componentEmitter = { exports: {} }, hasRequiredComponentEmitter;
function requireComponentEmitter() {
  return hasRequiredComponentEmitter || (hasRequiredComponentEmitter = 1, function(i2) {
    i2.exports = e;
    function e(r) {
      if (r) return t(r);
    }
    function t(r) {
      for (var a in e.prototype)
        r[a] = e.prototype[a];
      return r;
    }
    e.prototype.on = e.prototype.addEventListener = function(r, a) {
      return this._callbacks = this._callbacks || {}, (this._callbacks["$" + r] = this._callbacks["$" + r] || []).push(a), this;
    }, e.prototype.once = function(r, a) {
      function s() {
        this.off(r, s), a.apply(this, arguments);
      }
      return s.fn = a, this.on(r, s), this;
    }, e.prototype.off = e.prototype.removeListener = e.prototype.removeAllListeners = e.prototype.removeEventListener = function(r, a) {
      if (this._callbacks = this._callbacks || {}, arguments.length == 0)
        return this._callbacks = {}, this;
      var s = this._callbacks["$" + r];
      if (!s) return this;
      if (arguments.length == 1)
        return delete this._callbacks["$" + r], this;
      for (var u, l = 0; l < s.length; l++)
        if (u = s[l], u === a || u.fn === a) {
          s.splice(l, 1);
          break;
        }
      return s.length === 0 && delete this._callbacks["$" + r], this;
    }, e.prototype.emit = function(r) {
      this._callbacks = this._callbacks || {};
      for (var a = new Array(arguments.length - 1), s = this._callbacks["$" + r], u = 1; u < arguments.length; u++)
        a[u - 1] = arguments[u];
      if (s) {
        s = s.slice(0);
        for (var u = 0, l = s.length; u < l; ++u)
          s[u].apply(this, a);
      }
      return this;
    }, e.prototype.listeners = function(r) {
      return this._callbacks = this._callbacks || {}, this._callbacks["$" + r] || [];
    }, e.prototype.hasListeners = function(r) {
      return !!this.listeners(r).length;
    };
  }(componentEmitter)), componentEmitter.exports;
}
var fastSafeStringify, hasRequiredFastSafeStringify;
function requireFastSafeStringify() {
  if (hasRequiredFastSafeStringify) return fastSafeStringify;
  hasRequiredFastSafeStringify = 1, fastSafeStringify = s, s.default = s, s.stable = d, s.stableStringify = d;
  var i2 = "[...]", e = "[Circular]", t = [], r = [];
  function a() {
    return {
      depthLimit: Number.MAX_SAFE_INTEGER,
      edgesLimit: Number.MAX_SAFE_INTEGER
    };
  }
  function s(m, y, x, g) {
    typeof g > "u" && (g = a()), l(m, "", 0, [], void 0, 0, g);
    var _;
    try {
      r.length === 0 ? _ = JSON.stringify(m, y, x) : _ = JSON.stringify(m, p(y), x);
    } catch {
      return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
    } finally {
      for (; t.length !== 0; ) {
        var T = t.pop();
        T.length === 4 ? Object.defineProperty(T[0], T[1], T[3]) : T[0][T[1]] = T[2];
      }
    }
    return _;
  }
  function u(m, y, x, g) {
    var _ = Object.getOwnPropertyDescriptor(g, x);
    _.get !== void 0 ? _.configurable ? (Object.defineProperty(g, x, { value: m }), t.push([g, x, y, _])) : r.push([y, x, m]) : (g[x] = m, t.push([g, x, y]));
  }
  function l(m, y, x, g, _, T, E) {
    T += 1;
    var b;
    if (typeof m == "object" && m !== null) {
      for (b = 0; b < g.length; b++)
        if (g[b] === m) {
          u(e, m, y, _);
          return;
        }
      if (typeof E.depthLimit < "u" && T > E.depthLimit) {
        u(i2, m, y, _);
        return;
      }
      if (typeof E.edgesLimit < "u" && x + 1 > E.edgesLimit) {
        u(i2, m, y, _);
        return;
      }
      if (g.push(m), Array.isArray(m))
        for (b = 0; b < m.length; b++)
          l(m[b], b, b, g, m, T, E);
      else {
        var C = Object.keys(m);
        for (b = 0; b < C.length; b++) {
          var w = C[b];
          l(m[w], w, b, g, m, T, E);
        }
      }
      g.pop();
    }
  }
  function c(m, y) {
    return m < y ? -1 : m > y ? 1 : 0;
  }
  function d(m, y, x, g) {
    typeof g > "u" && (g = a());
    var _ = f(m, "", 0, [], void 0, 0, g) || m, T;
    try {
      r.length === 0 ? T = JSON.stringify(_, y, x) : T = JSON.stringify(_, p(y), x);
    } catch {
      return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
    } finally {
      for (; t.length !== 0; ) {
        var E = t.pop();
        E.length === 4 ? Object.defineProperty(E[0], E[1], E[3]) : E[0][E[1]] = E[2];
      }
    }
    return T;
  }
  function f(m, y, x, g, _, T, E) {
    T += 1;
    var b;
    if (typeof m == "object" && m !== null) {
      for (b = 0; b < g.length; b++)
        if (g[b] === m) {
          u(e, m, y, _);
          return;
        }
      try {
        if (typeof m.toJSON == "function")
          return;
      } catch {
        return;
      }
      if (typeof E.depthLimit < "u" && T > E.depthLimit) {
        u(i2, m, y, _);
        return;
      }
      if (typeof E.edgesLimit < "u" && x + 1 > E.edgesLimit) {
        u(i2, m, y, _);
        return;
      }
      if (g.push(m), Array.isArray(m))
        for (b = 0; b < m.length; b++)
          f(m[b], b, b, g, m, T, E);
      else {
        var C = {}, w = Object.keys(m).sort(c);
        for (b = 0; b < w.length; b++) {
          var A = w[b];
          f(m[A], A, b, g, m, T, E), C[A] = m[A];
        }
        if (typeof _ < "u")
          t.push([_, y, m]), _[y] = C;
        else
          return C;
      }
      g.pop();
    }
  }
  function p(m) {
    return m = typeof m < "u" ? m : function(y, x) {
      return x;
    }, function(y, x) {
      if (r.length > 0)
        for (var g = 0; g < r.length; g++) {
          var _ = r[g];
          if (_[1] === y && _[0] === x) {
            x = _[2], r.splice(g, 1);
            break;
          }
        }
      return m.call(this, y, x);
    };
  }
  return fastSafeStringify;
}
var type, hasRequiredType;
function requireType() {
  return hasRequiredType || (hasRequiredType = 1, type = TypeError), type;
}
var objectInspect, hasRequiredObjectInspect;
function requireObjectInspect() {
  if (hasRequiredObjectInspect) return objectInspect;
  hasRequiredObjectInspect = 1;
  var i2 = typeof Map == "function" && Map.prototype, e = Object.getOwnPropertyDescriptor && i2 ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null, t = i2 && e && typeof e.get == "function" ? e.get : null, r = i2 && Map.prototype.forEach, a = typeof Set == "function" && Set.prototype, s = Object.getOwnPropertyDescriptor && a ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null, u = a && s && typeof s.get == "function" ? s.get : null, l = a && Set.prototype.forEach, c = typeof WeakMap == "function" && WeakMap.prototype, d = c ? WeakMap.prototype.has : null, f = typeof WeakSet == "function" && WeakSet.prototype, p = f ? WeakSet.prototype.has : null, m = typeof WeakRef == "function" && WeakRef.prototype, y = m ? WeakRef.prototype.deref : null, x = Boolean.prototype.valueOf, g = Object.prototype.toString, _ = Function.prototype.toString, T = String.prototype.match, E = String.prototype.slice, b = String.prototype.replace, C = String.prototype.toUpperCase, w = String.prototype.toLowerCase, A = RegExp.prototype.test, S = Array.prototype.concat, F = Array.prototype.join, M = Array.prototype.slice, U = Math.floor, B = typeof BigInt == "function" ? BigInt.prototype.valueOf : null, q = Object.getOwnPropertySymbols, z = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Symbol.prototype.toString : null, D = typeof Symbol == "function" && typeof Symbol.iterator == "object", X = typeof Symbol == "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === D || true) ? Symbol.toStringTag : null, k = Object.prototype.propertyIsEnumerable, I = (typeof Reflect == "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(oe) {
    return oe.__proto__;
  } : null);
  function P(oe, le) {
    if (oe === 1 / 0 || oe === -1 / 0 || oe !== oe || oe && oe > -1e3 && oe < 1e3 || A.call(/e/, le))
      return le;
    var Ue = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
    if (typeof oe == "number") {
      var et = oe < 0 ? -U(-oe) : U(oe);
      if (et !== oe) {
        var lt = String(et), We = E.call(le, lt.length + 1);
        return b.call(lt, Ue, "$&_") + "." + b.call(b.call(We, /([0-9]{3})/g, "$&_"), /_$/, "");
      }
    }
    return b.call(le, Ue, "$&_");
  }
  var G = require$$1$1, W = G.custom, V = ke(W) ? W : null, K = {
    __proto__: null,
    double: '"',
    single: "'"
  }, J = {
    __proto__: null,
    double: /(["\\])/g,
    single: /(['\\])/g
  };
  objectInspect = function oe(le, Ue, et, lt) {
    var We = Ue || {};
    if (Oe(We, "quoteStyle") && !Oe(K, We.quoteStyle))
      throw new TypeError('option "quoteStyle" must be "single" or "double"');
    if (Oe(We, "maxStringLength") && (typeof We.maxStringLength == "number" ? We.maxStringLength < 0 && We.maxStringLength !== 1 / 0 : We.maxStringLength !== null))
      throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
    var te = Oe(We, "customInspect") ? We.customInspect : true;
    if (typeof te != "boolean" && te !== "symbol")
      throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
    if (Oe(We, "indent") && We.indent !== null && We.indent !== "	" && !(parseInt(We.indent, 10) === We.indent && We.indent > 0))
      throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
    if (Oe(We, "numericSeparator") && typeof We.numericSeparator != "boolean")
      throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
    var ne = We.numericSeparator;
    if (typeof le > "u")
      return "undefined";
    if (le === null)
      return "null";
    if (typeof le == "boolean")
      return le ? "true" : "false";
    if (typeof le == "string")
      return er(le, We);
    if (typeof le == "number") {
      if (le === 0)
        return 1 / 0 / le > 0 ? "0" : "-0";
      var fe = String(le);
      return ne ? P(le, fe) : fe;
    }
    if (typeof le == "bigint") {
      var qe = String(le) + "n";
      return ne ? P(le, qe) : qe;
    }
    var Je = typeof We.depth > "u" ? 5 : We.depth;
    if (typeof et > "u" && (et = 0), et >= Je && Je > 0 && typeof le == "object")
      return he(le) ? "[Array]" : "[Object]";
    var ht = Ne(We, et);
    if (typeof lt > "u")
      lt = [];
    else if (xt(lt, le) >= 0)
      return "[Circular]";
    function bt(Ir, Zr, Xi) {
      if (Zr && (lt = M.call(lt), lt.push(Zr)), Xi) {
        var Ai = {
          depth: We.depth
        };
        return Oe(We, "quoteStyle") && (Ai.quoteStyle = We.quoteStyle), oe(Ir, Ai, et + 1, lt);
      }
      return oe(Ir, We, et + 1, lt);
    }
    if (typeof le == "function" && !me(le)) {
      var kt = gt(le), Ar = pt(le, bt);
      return "[Function" + (kt ? ": " + kt : " (anonymous)") + "]" + (Ar.length > 0 ? " { " + F.call(Ar, ", ") + " }" : "");
    }
    if (ke(le)) {
      var Sr = D ? b.call(String(le), /^(Symbol\(.*\))_[^)]*$/, "$1") : z.call(le);
      return typeof le == "object" && !D ? Y(Sr) : Sr;
    }
    if (It(le)) {
      for (var Vt = "<" + w.call(String(le.nodeName)), jr = le.attributes || [], tr = 0; tr < jr.length; tr++)
        Vt += " " + jr[tr].name + "=" + ae(re(jr[tr].value), "double", We);
      return Vt += ">", le.childNodes && le.childNodes.length && (Vt += "..."), Vt += "</" + w.call(String(le.nodeName)) + ">", Vt;
    }
    if (he(le)) {
      if (le.length === 0)
        return "[]";
      var _r = pt(le, bt);
      return ht && !Se(_r) ? "[" + je(_r, ht) + "]" : "[ " + F.call(_r, ", ") + " ]";
    }
    if (Te(le)) {
      var wr = pt(le, bt);
      return !("cause" in Error.prototype) && "cause" in le && !k.call(le, "cause") ? "{ [" + String(le) + "] " + F.call(S.call("[cause]: " + bt(le.cause), wr), ", ") + " }" : wr.length === 0 ? "[" + String(le) + "]" : "{ [" + String(le) + "] " + F.call(wr, ", ") + " }";
    }
    if (typeof le == "object" && te) {
      if (V && typeof le[V] == "function" && G)
        return G(le, { depth: Je - et });
      if (te !== "symbol" && typeof le.inspect == "function")
        return le.inspect();
    }
    if (vt(le)) {
      var xr = [];
      return r && r.call(le, function(Ir, Zr) {
        xr.push(bt(Zr, le, true) + " => " + bt(Ir, le));
      }), be("Map", t.call(le), xr, ht);
    }
    if (ct(le)) {
      var Mr = [];
      return l && l.call(le, function(Ir) {
        Mr.push(bt(Ir, le));
      }), be("Set", u.call(le), Mr, ht);
    }
    if (Xe(le))
      return ee("WeakMap");
    if (Rt(le))
      return ee("WeakSet");
    if (at(le))
      return ee("WeakRef");
    if (ye(le))
      return Y(bt(Number(le)));
    if (Pe(le))
      return Y(bt(B.call(le)));
    if (Ae(le))
      return Y(x.call(le));
    if (_e(le))
      return Y(bt(String(le)));
    if (typeof window < "u" && le === window)
      return "{ [object Window] }";
    if (typeof globalThis < "u" && le === globalThis || typeof window < "u" && le === window)
      return "{ [object globalThis] }";
    if (!ge(le) && !me(le)) {
      var Or = pt(le, bt), hi = I ? I(le) === Object.prototype : le instanceof Object || le.constructor === Object, Rr = le instanceof Object ? "" : "null prototype", ci = !hi && X && Object(le) === le && X in le ? E.call($e(le), 8, -1) : Rr ? "Object" : "", Ri = hi || typeof le.constructor != "function" ? "" : le.constructor.name ? le.constructor.name + " " : "", fi = Ri + (ci || Rr ? "[" + F.call(S.call([], ci || [], Rr || []), ": ") + "] " : "");
      return Or.length === 0 ? fi + "{}" : ht ? fi + "{" + je(Or, ht) + "}" : fi + "{ " + F.call(Or, ", ") + " }";
    }
    return String(le);
  };
  function ae(oe, le, Ue) {
    var et = Ue.quoteStyle || le, lt = K[et];
    return lt + oe + lt;
  }
  function re(oe) {
    return b.call(String(oe), /"/g, "&quot;");
  }
  function he(oe) {
    return $e(oe) === "[object Array]" && (!X || !(typeof oe == "object" && X in oe));
  }
  function ge(oe) {
    return $e(oe) === "[object Date]" && (!X || !(typeof oe == "object" && X in oe));
  }
  function me(oe) {
    return $e(oe) === "[object RegExp]" && (!X || !(typeof oe == "object" && X in oe));
  }
  function Te(oe) {
    return $e(oe) === "[object Error]" && (!X || !(typeof oe == "object" && X in oe));
  }
  function _e(oe) {
    return $e(oe) === "[object String]" && (!X || !(typeof oe == "object" && X in oe));
  }
  function ye(oe) {
    return $e(oe) === "[object Number]" && (!X || !(typeof oe == "object" && X in oe));
  }
  function Ae(oe) {
    return $e(oe) === "[object Boolean]" && (!X || !(typeof oe == "object" && X in oe));
  }
  function ke(oe) {
    if (D)
      return oe && typeof oe == "object" && oe instanceof Symbol;
    if (typeof oe == "symbol")
      return true;
    if (!oe || typeof oe != "object" || !z)
      return false;
    try {
      return z.call(oe), true;
    } catch {
    }
    return false;
  }
  function Pe(oe) {
    if (!oe || typeof oe != "object" || !B)
      return false;
    try {
      return B.call(oe), true;
    } catch {
    }
    return false;
  }
  var Ee = Object.prototype.hasOwnProperty || function(oe) {
    return oe in this;
  };
  function Oe(oe, le) {
    return Ee.call(oe, le);
  }
  function $e(oe) {
    return g.call(oe);
  }
  function gt(oe) {
    if (oe.name)
      return oe.name;
    var le = T.call(_.call(oe), /^function\s*([\w$]+)/);
    return le ? le[1] : null;
  }
  function xt(oe, le) {
    if (oe.indexOf)
      return oe.indexOf(le);
    for (var Ue = 0, et = oe.length; Ue < et; Ue++)
      if (oe[Ue] === le)
        return Ue;
    return -1;
  }
  function vt(oe) {
    if (!t || !oe || typeof oe != "object")
      return false;
    try {
      t.call(oe);
      try {
        u.call(oe);
      } catch {
        return true;
      }
      return oe instanceof Map;
    } catch {
    }
    return false;
  }
  function Xe(oe) {
    if (!d || !oe || typeof oe != "object")
      return false;
    try {
      d.call(oe, d);
      try {
        p.call(oe, p);
      } catch {
        return true;
      }
      return oe instanceof WeakMap;
    } catch {
    }
    return false;
  }
  function at(oe) {
    if (!y || !oe || typeof oe != "object")
      return false;
    try {
      return y.call(oe), true;
    } catch {
    }
    return false;
  }
  function ct(oe) {
    if (!u || !oe || typeof oe != "object")
      return false;
    try {
      u.call(oe);
      try {
        t.call(oe);
      } catch {
        return true;
      }
      return oe instanceof Set;
    } catch {
    }
    return false;
  }
  function Rt(oe) {
    if (!p || !oe || typeof oe != "object")
      return false;
    try {
      p.call(oe, p);
      try {
        d.call(oe, d);
      } catch {
        return true;
      }
      return oe instanceof WeakSet;
    } catch {
    }
    return false;
  }
  function It(oe) {
    return !oe || typeof oe != "object" ? false : typeof HTMLElement < "u" && oe instanceof HTMLElement ? true : typeof oe.nodeName == "string" && typeof oe.getAttribute == "function";
  }
  function er(oe, le) {
    if (oe.length > le.maxStringLength) {
      var Ue = oe.length - le.maxStringLength, et = "... " + Ue + " more character" + (Ue > 1 ? "s" : "");
      return er(E.call(oe, 0, le.maxStringLength), le) + et;
    }
    var lt = J[le.quoteStyle || "single"];
    lt.lastIndex = 0;
    var We = b.call(b.call(oe, lt, "\\$1"), /[\x00-\x1f]/g, $);
    return ae(We, "single", le);
  }
  function $(oe) {
    var le = oe.charCodeAt(0), Ue = {
      8: "b",
      9: "t",
      10: "n",
      12: "f",
      13: "r"
    }[le];
    return Ue ? "\\" + Ue : "\\x" + (le < 16 ? "0" : "") + C.call(le.toString(16));
  }
  function Y(oe) {
    return "Object(" + oe + ")";
  }
  function ee(oe) {
    return oe + " { ? }";
  }
  function be(oe, le, Ue, et) {
    var lt = et ? je(Ue, et) : F.call(Ue, ", ");
    return oe + " (" + le + ") {" + lt + "}";
  }
  function Se(oe) {
    for (var le = 0; le < oe.length; le++)
      if (xt(oe[le], `
`) >= 0)
        return false;
    return true;
  }
  function Ne(oe, le) {
    var Ue;
    if (oe.indent === "	")
      Ue = "	";
    else if (typeof oe.indent == "number" && oe.indent > 0)
      Ue = F.call(Array(oe.indent + 1), " ");
    else
      return null;
    return {
      base: Ue,
      prev: F.call(Array(le + 1), Ue)
    };
  }
  function je(oe, le) {
    if (oe.length === 0)
      return "";
    var Ue = `
` + le.prev + le.base;
    return Ue + F.call(oe, "," + Ue) + `
` + le.prev;
  }
  function pt(oe, le) {
    var Ue = he(oe), et = [];
    if (Ue) {
      et.length = oe.length;
      for (var lt = 0; lt < oe.length; lt++)
        et[lt] = Oe(oe, lt) ? le(oe[lt], oe) : "";
    }
    var We = typeof q == "function" ? q(oe) : [], te;
    if (D) {
      te = {};
      for (var ne = 0; ne < We.length; ne++)
        te["$" + We[ne]] = We[ne];
    }
    for (var fe in oe)
      Oe(oe, fe) && (Ue && String(Number(fe)) === fe && fe < oe.length || D && te["$" + fe] instanceof Symbol || (A.call(/[^\w$]/, fe) ? et.push(le(fe, oe) + ": " + le(oe[fe], oe)) : et.push(fe + ": " + le(oe[fe], oe))));
    if (typeof q == "function")
      for (var qe = 0; qe < We.length; qe++)
        k.call(oe, We[qe]) && et.push("[" + le(We[qe]) + "]: " + le(oe[We[qe]], oe));
    return et;
  }
  return objectInspect;
}
var sideChannelList, hasRequiredSideChannelList;
function requireSideChannelList() {
  if (hasRequiredSideChannelList) return sideChannelList;
  hasRequiredSideChannelList = 1;
  var i2 = /* @__PURE__ */ requireObjectInspect(), e = /* @__PURE__ */ requireType(), t = function(l, c, d) {
    for (var f = l, p; (p = f.next) != null; f = p)
      if (p.key === c)
        return f.next = p.next, d || (p.next = /** @type {NonNullable<typeof list.next>} */
        l.next, l.next = p), p;
  }, r = function(l, c) {
    if (l) {
      var d = t(l, c);
      return d && d.value;
    }
  }, a = function(l, c, d) {
    var f = t(l, c);
    f ? f.value = d : l.next = /** @type {import('./list.d.ts').ListNode<typeof value, typeof key>} */
    {
      // eslint-disable-line no-param-reassign, no-extra-parens
      key: c,
      next: l.next,
      value: d
    };
  }, s = function(l, c) {
    return l ? !!t(l, c) : false;
  }, u = function(l, c) {
    if (l)
      return t(l, c, true);
  };
  return sideChannelList = function() {
    var l, c = {
      assert: function(d) {
        if (!c.has(d))
          throw new e("Side channel does not contain " + i2(d));
      },
      delete: function(d) {
        var f = l && l.next, p = u(l, d);
        return p && f && f === p && (l = void 0), !!p;
      },
      get: function(d) {
        return r(l, d);
      },
      has: function(d) {
        return s(l, d);
      },
      set: function(d, f) {
        l || (l = {
          next: void 0
        }), a(
          /** @type {NonNullable<typeof $o>} */
          l,
          d,
          f
        );
      }
    };
    return c;
  }, sideChannelList;
}
var esObjectAtoms, hasRequiredEsObjectAtoms;
function requireEsObjectAtoms() {
  return hasRequiredEsObjectAtoms || (hasRequiredEsObjectAtoms = 1, esObjectAtoms = Object), esObjectAtoms;
}
var esErrors, hasRequiredEsErrors;
function requireEsErrors() {
  return hasRequiredEsErrors || (hasRequiredEsErrors = 1, esErrors = Error), esErrors;
}
var _eval, hasRequired_eval;
function require_eval() {
  return hasRequired_eval || (hasRequired_eval = 1, _eval = EvalError), _eval;
}
var range, hasRequiredRange;
function requireRange() {
  return hasRequiredRange || (hasRequiredRange = 1, range = RangeError), range;
}
var ref, hasRequiredRef;
function requireRef() {
  return hasRequiredRef || (hasRequiredRef = 1, ref = ReferenceError), ref;
}
var syntax, hasRequiredSyntax;
function requireSyntax() {
  return hasRequiredSyntax || (hasRequiredSyntax = 1, syntax = SyntaxError), syntax;
}
var uri, hasRequiredUri;
function requireUri() {
  return hasRequiredUri || (hasRequiredUri = 1, uri = URIError), uri;
}
var abs, hasRequiredAbs;
function requireAbs() {
  return hasRequiredAbs || (hasRequiredAbs = 1, abs = Math.abs), abs;
}
var floor, hasRequiredFloor;
function requireFloor() {
  return hasRequiredFloor || (hasRequiredFloor = 1, floor = Math.floor), floor;
}
var max$1, hasRequiredMax;
function requireMax() {
  return hasRequiredMax || (hasRequiredMax = 1, max$1 = Math.max), max$1;
}
var min, hasRequiredMin$1;
function requireMin$1() {
  return hasRequiredMin$1 || (hasRequiredMin$1 = 1, min = Math.min), min;
}
var pow, hasRequiredPow;
function requirePow() {
  return hasRequiredPow || (hasRequiredPow = 1, pow = Math.pow), pow;
}
var round, hasRequiredRound;
function requireRound() {
  return hasRequiredRound || (hasRequiredRound = 1, round = Math.round), round;
}
var _isNaN, hasRequired_isNaN;
function require_isNaN() {
  return hasRequired_isNaN || (hasRequired_isNaN = 1, _isNaN = Number.isNaN || function(i2) {
    return i2 !== i2;
  }), _isNaN;
}
var sign, hasRequiredSign;
function requireSign() {
  if (hasRequiredSign) return sign;
  hasRequiredSign = 1;
  var i2 = /* @__PURE__ */ require_isNaN();
  return sign = function(e) {
    return i2(e) || e === 0 ? e : e < 0 ? -1 : 1;
  }, sign;
}
var gOPD, hasRequiredGOPD;
function requireGOPD() {
  return hasRequiredGOPD || (hasRequiredGOPD = 1, gOPD = Object.getOwnPropertyDescriptor), gOPD;
}
var gopd, hasRequiredGopd;
function requireGopd() {
  if (hasRequiredGopd) return gopd;
  hasRequiredGopd = 1;
  var i2 = /* @__PURE__ */ requireGOPD();
  if (i2)
    try {
      i2([], "length");
    } catch {
      i2 = null;
    }
  return gopd = i2, gopd;
}
var esDefineProperty, hasRequiredEsDefineProperty;
function requireEsDefineProperty() {
  if (hasRequiredEsDefineProperty) return esDefineProperty;
  hasRequiredEsDefineProperty = 1;
  var i2 = Object.defineProperty || false;
  if (i2)
    try {
      i2({}, "a", { value: 1 });
    } catch {
      i2 = false;
    }
  return esDefineProperty = i2, esDefineProperty;
}
var shams, hasRequiredShams;
function requireShams() {
  return hasRequiredShams || (hasRequiredShams = 1, shams = function() {
    if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
      return false;
    if (typeof Symbol.iterator == "symbol")
      return true;
    var i2 = {}, e = Symbol("test"), t = Object(e);
    if (typeof e == "string" || Object.prototype.toString.call(e) !== "[object Symbol]" || Object.prototype.toString.call(t) !== "[object Symbol]")
      return false;
    var r = 42;
    i2[e] = r;
    for (var a in i2)
      return false;
    if (typeof Object.keys == "function" && Object.keys(i2).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(i2).length !== 0)
      return false;
    var s = Object.getOwnPropertySymbols(i2);
    if (s.length !== 1 || s[0] !== e || !Object.prototype.propertyIsEnumerable.call(i2, e))
      return false;
    if (typeof Object.getOwnPropertyDescriptor == "function") {
      var u = (
        /** @type {PropertyDescriptor} */
        Object.getOwnPropertyDescriptor(i2, e)
      );
      if (u.value !== r || u.enumerable !== true)
        return false;
    }
    return true;
  }), shams;
}
var hasSymbols, hasRequiredHasSymbols;
function requireHasSymbols() {
  if (hasRequiredHasSymbols) return hasSymbols;
  hasRequiredHasSymbols = 1;
  var i2 = typeof Symbol < "u" && Symbol, e = requireShams();
  return hasSymbols = function() {
    return typeof i2 != "function" || typeof Symbol != "function" || typeof i2("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? false : e();
  }, hasSymbols;
}
var Reflect_getPrototypeOf, hasRequiredReflect_getPrototypeOf;
function requireReflect_getPrototypeOf() {
  return hasRequiredReflect_getPrototypeOf || (hasRequiredReflect_getPrototypeOf = 1, Reflect_getPrototypeOf = typeof Reflect < "u" && Reflect.getPrototypeOf || null), Reflect_getPrototypeOf;
}
var Object_getPrototypeOf, hasRequiredObject_getPrototypeOf;
function requireObject_getPrototypeOf() {
  if (hasRequiredObject_getPrototypeOf) return Object_getPrototypeOf;
  hasRequiredObject_getPrototypeOf = 1;
  var i2 = /* @__PURE__ */ requireEsObjectAtoms();
  return Object_getPrototypeOf = i2.getPrototypeOf || null, Object_getPrototypeOf;
}
var implementation, hasRequiredImplementation;
function requireImplementation() {
  if (hasRequiredImplementation) return implementation;
  hasRequiredImplementation = 1;
  var i2 = "Function.prototype.bind called on incompatible ", e = Object.prototype.toString, t = Math.max, r = "[object Function]", a = function(l, c) {
    for (var d = [], f = 0; f < l.length; f += 1)
      d[f] = l[f];
    for (var p = 0; p < c.length; p += 1)
      d[p + l.length] = c[p];
    return d;
  }, s = function(l, c) {
    for (var d = [], f = c, p = 0; f < l.length; f += 1, p += 1)
      d[p] = l[f];
    return d;
  }, u = function(l, c) {
    for (var d = "", f = 0; f < l.length; f += 1)
      d += l[f], f + 1 < l.length && (d += c);
    return d;
  };
  return implementation = function(l) {
    var c = this;
    if (typeof c != "function" || e.apply(c) !== r)
      throw new TypeError(i2 + c);
    for (var d = s(arguments, 1), f, p = function() {
      if (this instanceof f) {
        var _ = c.apply(
          this,
          a(d, arguments)
        );
        return Object(_) === _ ? _ : this;
      }
      return c.apply(
        l,
        a(d, arguments)
      );
    }, m = t(0, c.length - d.length), y = [], x = 0; x < m; x++)
      y[x] = "$" + x;
    if (f = Function("binder", "return function (" + u(y, ",") + "){ return binder.apply(this,arguments); }")(p), c.prototype) {
      var g = function() {
      };
      g.prototype = c.prototype, f.prototype = new g(), g.prototype = null;
    }
    return f;
  }, implementation;
}
var functionBind, hasRequiredFunctionBind;
function requireFunctionBind() {
  if (hasRequiredFunctionBind) return functionBind;
  hasRequiredFunctionBind = 1;
  var i2 = requireImplementation();
  return functionBind = Function.prototype.bind || i2, functionBind;
}
var functionCall, hasRequiredFunctionCall;
function requireFunctionCall() {
  return hasRequiredFunctionCall || (hasRequiredFunctionCall = 1, functionCall = Function.prototype.call), functionCall;
}
var functionApply, hasRequiredFunctionApply;
function requireFunctionApply() {
  return hasRequiredFunctionApply || (hasRequiredFunctionApply = 1, functionApply = Function.prototype.apply), functionApply;
}
var reflectApply, hasRequiredReflectApply;
function requireReflectApply() {
  return hasRequiredReflectApply || (hasRequiredReflectApply = 1, reflectApply = typeof Reflect < "u" && Reflect && Reflect.apply), reflectApply;
}
var actualApply, hasRequiredActualApply;
function requireActualApply() {
  if (hasRequiredActualApply) return actualApply;
  hasRequiredActualApply = 1;
  var i2 = requireFunctionBind(), e = requireFunctionApply(), t = requireFunctionCall(), r = requireReflectApply();
  return actualApply = r || i2.call(t, e), actualApply;
}
var callBindApplyHelpers, hasRequiredCallBindApplyHelpers;
function requireCallBindApplyHelpers() {
  if (hasRequiredCallBindApplyHelpers) return callBindApplyHelpers;
  hasRequiredCallBindApplyHelpers = 1;
  var i2 = requireFunctionBind(), e = /* @__PURE__ */ requireType(), t = requireFunctionCall(), r = requireActualApply();
  return callBindApplyHelpers = function(a) {
    if (a.length < 1 || typeof a[0] != "function")
      throw new e("a function is required");
    return r(i2, t, a);
  }, callBindApplyHelpers;
}
var get, hasRequiredGet;
function requireGet() {
  if (hasRequiredGet) return get;
  hasRequiredGet = 1;
  var i2 = requireCallBindApplyHelpers(), e = /* @__PURE__ */ requireGopd(), t;
  try {
    t = /** @type {{ __proto__?: typeof Array.prototype }} */
    [].__proto__ === Array.prototype;
  } catch (u) {
    if (!u || typeof u != "object" || !("code" in u) || u.code !== "ERR_PROTO_ACCESS")
      throw u;
  }
  var r = !!t && e && e(
    Object.prototype,
    /** @type {keyof typeof Object.prototype} */
    "__proto__"
  ), a = Object, s = a.getPrototypeOf;
  return get = r && typeof r.get == "function" ? i2([r.get]) : typeof s == "function" ? (
    /** @type {import('./get')} */
    function(u) {
      return s(u == null ? u : a(u));
    }
  ) : false, get;
}
var getProto, hasRequiredGetProto;
function requireGetProto() {
  if (hasRequiredGetProto) return getProto;
  hasRequiredGetProto = 1;
  var i2 = requireReflect_getPrototypeOf(), e = requireObject_getPrototypeOf(), t = /* @__PURE__ */ requireGet();
  return getProto = i2 ? function(r) {
    return i2(r);
  } : e ? function(r) {
    if (!r || typeof r != "object" && typeof r != "function")
      throw new TypeError("getProto: not an object");
    return e(r);
  } : t ? function(r) {
    return t(r);
  } : null, getProto;
}
var hasown, hasRequiredHasown;
function requireHasown() {
  if (hasRequiredHasown) return hasown;
  hasRequiredHasown = 1;
  var i2 = Function.prototype.call, e = Object.prototype.hasOwnProperty, t = requireFunctionBind();
  return hasown = t.call(i2, e), hasown;
}
var getIntrinsic, hasRequiredGetIntrinsic;
function requireGetIntrinsic() {
  if (hasRequiredGetIntrinsic) return getIntrinsic;
  hasRequiredGetIntrinsic = 1;
  var i2, e = /* @__PURE__ */ requireEsObjectAtoms(), t = /* @__PURE__ */ requireEsErrors(), r = /* @__PURE__ */ require_eval(), a = /* @__PURE__ */ requireRange(), s = /* @__PURE__ */ requireRef(), u = /* @__PURE__ */ requireSyntax(), l = /* @__PURE__ */ requireType(), c = /* @__PURE__ */ requireUri(), d = /* @__PURE__ */ requireAbs(), f = /* @__PURE__ */ requireFloor(), p = /* @__PURE__ */ requireMax(), m = /* @__PURE__ */ requireMin$1(), y = /* @__PURE__ */ requirePow(), x = /* @__PURE__ */ requireRound(), g = /* @__PURE__ */ requireSign(), _ = Function, T = function(Te) {
    try {
      return _('"use strict"; return (' + Te + ").constructor;")();
    } catch {
    }
  }, E = /* @__PURE__ */ requireGopd(), b = /* @__PURE__ */ requireEsDefineProperty(), C = function() {
    throw new l();
  }, w = E ? function() {
    try {
      return arguments.callee, C;
    } catch {
      try {
        return E(arguments, "callee").get;
      } catch {
        return C;
      }
    }
  }() : C, A = requireHasSymbols()(), S = requireGetProto(), F = requireObject_getPrototypeOf(), M = requireReflect_getPrototypeOf(), U = requireFunctionApply(), B = requireFunctionCall(), q = {}, z = typeof Uint8Array > "u" || !S ? i2 : S(Uint8Array), D = {
    __proto__: null,
    "%AggregateError%": typeof AggregateError > "u" ? i2 : AggregateError,
    "%Array%": Array,
    "%ArrayBuffer%": typeof ArrayBuffer > "u" ? i2 : ArrayBuffer,
    "%ArrayIteratorPrototype%": A && S ? S([][Symbol.iterator]()) : i2,
    "%AsyncFromSyncIteratorPrototype%": i2,
    "%AsyncFunction%": q,
    "%AsyncGenerator%": q,
    "%AsyncGeneratorFunction%": q,
    "%AsyncIteratorPrototype%": q,
    "%Atomics%": typeof Atomics > "u" ? i2 : Atomics,
    "%BigInt%": typeof BigInt > "u" ? i2 : BigInt,
    "%BigInt64Array%": typeof BigInt64Array > "u" ? i2 : BigInt64Array,
    "%BigUint64Array%": typeof BigUint64Array > "u" ? i2 : BigUint64Array,
    "%Boolean%": Boolean,
    "%DataView%": typeof DataView > "u" ? i2 : DataView,
    "%Date%": Date,
    "%decodeURI%": decodeURI,
    "%decodeURIComponent%": decodeURIComponent,
    "%encodeURI%": encodeURI,
    "%encodeURIComponent%": encodeURIComponent,
    "%Error%": t,
    "%eval%": eval,
    // eslint-disable-line no-eval
    "%EvalError%": r,
    "%Float32Array%": typeof Float32Array > "u" ? i2 : Float32Array,
    "%Float64Array%": typeof Float64Array > "u" ? i2 : Float64Array,
    "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? i2 : FinalizationRegistry,
    "%Function%": _,
    "%GeneratorFunction%": q,
    "%Int8Array%": typeof Int8Array > "u" ? i2 : Int8Array,
    "%Int16Array%": typeof Int16Array > "u" ? i2 : Int16Array,
    "%Int32Array%": typeof Int32Array > "u" ? i2 : Int32Array,
    "%isFinite%": isFinite,
    "%isNaN%": isNaN,
    "%IteratorPrototype%": A && S ? S(S([][Symbol.iterator]())) : i2,
    "%JSON%": typeof JSON == "object" ? JSON : i2,
    "%Map%": typeof Map > "u" ? i2 : Map,
    "%MapIteratorPrototype%": typeof Map > "u" || !A || !S ? i2 : S((/* @__PURE__ */ new Map())[Symbol.iterator]()),
    "%Math%": Math,
    "%Number%": Number,
    "%Object%": e,
    "%Object.getOwnPropertyDescriptor%": E,
    "%parseFloat%": parseFloat,
    "%parseInt%": parseInt,
    "%Promise%": typeof Promise > "u" ? i2 : Promise,
    "%Proxy%": typeof Proxy > "u" ? i2 : Proxy,
    "%RangeError%": a,
    "%ReferenceError%": s,
    "%Reflect%": typeof Reflect > "u" ? i2 : Reflect,
    "%RegExp%": RegExp,
    "%Set%": typeof Set > "u" ? i2 : Set,
    "%SetIteratorPrototype%": typeof Set > "u" || !A || !S ? i2 : S((/* @__PURE__ */ new Set())[Symbol.iterator]()),
    "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? i2 : SharedArrayBuffer,
    "%String%": String,
    "%StringIteratorPrototype%": A && S ? S(""[Symbol.iterator]()) : i2,
    "%Symbol%": A ? Symbol : i2,
    "%SyntaxError%": u,
    "%ThrowTypeError%": w,
    "%TypedArray%": z,
    "%TypeError%": l,
    "%Uint8Array%": typeof Uint8Array > "u" ? i2 : Uint8Array,
    "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? i2 : Uint8ClampedArray,
    "%Uint16Array%": typeof Uint16Array > "u" ? i2 : Uint16Array,
    "%Uint32Array%": typeof Uint32Array > "u" ? i2 : Uint32Array,
    "%URIError%": c,
    "%WeakMap%": typeof WeakMap > "u" ? i2 : WeakMap,
    "%WeakRef%": typeof WeakRef > "u" ? i2 : WeakRef,
    "%WeakSet%": typeof WeakSet > "u" ? i2 : WeakSet,
    "%Function.prototype.call%": B,
    "%Function.prototype.apply%": U,
    "%Object.defineProperty%": b,
    "%Object.getPrototypeOf%": F,
    "%Math.abs%": d,
    "%Math.floor%": f,
    "%Math.max%": p,
    "%Math.min%": m,
    "%Math.pow%": y,
    "%Math.round%": x,
    "%Math.sign%": g,
    "%Reflect.getPrototypeOf%": M
  };
  if (S)
    try {
      null.error;
    } catch (Te) {
      var X = S(S(Te));
      D["%Error.prototype%"] = X;
    }
  var k = function Te(_e) {
    var ye;
    if (_e === "%AsyncFunction%")
      ye = T("async function () {}");
    else if (_e === "%GeneratorFunction%")
      ye = T("function* () {}");
    else if (_e === "%AsyncGeneratorFunction%")
      ye = T("async function* () {}");
    else if (_e === "%AsyncGenerator%") {
      var Ae = Te("%AsyncGeneratorFunction%");
      Ae && (ye = Ae.prototype);
    } else if (_e === "%AsyncIteratorPrototype%") {
      var ke = Te("%AsyncGenerator%");
      ke && S && (ye = S(ke.prototype));
    }
    return D[_e] = ye, ye;
  }, I = {
    __proto__: null,
    "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
    "%ArrayPrototype%": ["Array", "prototype"],
    "%ArrayProto_entries%": ["Array", "prototype", "entries"],
    "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
    "%ArrayProto_keys%": ["Array", "prototype", "keys"],
    "%ArrayProto_values%": ["Array", "prototype", "values"],
    "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
    "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
    "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
    "%BooleanPrototype%": ["Boolean", "prototype"],
    "%DataViewPrototype%": ["DataView", "prototype"],
    "%DatePrototype%": ["Date", "prototype"],
    "%ErrorPrototype%": ["Error", "prototype"],
    "%EvalErrorPrototype%": ["EvalError", "prototype"],
    "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
    "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
    "%FunctionPrototype%": ["Function", "prototype"],
    "%Generator%": ["GeneratorFunction", "prototype"],
    "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
    "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
    "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
    "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
    "%JSONParse%": ["JSON", "parse"],
    "%JSONStringify%": ["JSON", "stringify"],
    "%MapPrototype%": ["Map", "prototype"],
    "%NumberPrototype%": ["Number", "prototype"],
    "%ObjectPrototype%": ["Object", "prototype"],
    "%ObjProto_toString%": ["Object", "prototype", "toString"],
    "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
    "%PromisePrototype%": ["Promise", "prototype"],
    "%PromiseProto_then%": ["Promise", "prototype", "then"],
    "%Promise_all%": ["Promise", "all"],
    "%Promise_reject%": ["Promise", "reject"],
    "%Promise_resolve%": ["Promise", "resolve"],
    "%RangeErrorPrototype%": ["RangeError", "prototype"],
    "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
    "%RegExpPrototype%": ["RegExp", "prototype"],
    "%SetPrototype%": ["Set", "prototype"],
    "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
    "%StringPrototype%": ["String", "prototype"],
    "%SymbolPrototype%": ["Symbol", "prototype"],
    "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
    "%TypedArrayPrototype%": ["TypedArray", "prototype"],
    "%TypeErrorPrototype%": ["TypeError", "prototype"],
    "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
    "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
    "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
    "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
    "%URIErrorPrototype%": ["URIError", "prototype"],
    "%WeakMapPrototype%": ["WeakMap", "prototype"],
    "%WeakSetPrototype%": ["WeakSet", "prototype"]
  }, P = requireFunctionBind(), G = /* @__PURE__ */ requireHasown(), W = P.call(B, Array.prototype.concat), V = P.call(U, Array.prototype.splice), K = P.call(B, String.prototype.replace), J = P.call(B, String.prototype.slice), ae = P.call(B, RegExp.prototype.exec), re = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, he = /\\(\\)?/g, ge = function(Te) {
    var _e = J(Te, 0, 1), ye = J(Te, -1);
    if (_e === "%" && ye !== "%")
      throw new u("invalid intrinsic syntax, expected closing `%`");
    if (ye === "%" && _e !== "%")
      throw new u("invalid intrinsic syntax, expected opening `%`");
    var Ae = [];
    return K(Te, re, function(ke, Pe, Ee, Oe) {
      Ae[Ae.length] = Ee ? K(Oe, he, "$1") : Pe || ke;
    }), Ae;
  }, me = function(Te, _e) {
    var ye = Te, Ae;
    if (G(I, ye) && (Ae = I[ye], ye = "%" + Ae[0] + "%"), G(D, ye)) {
      var ke = D[ye];
      if (ke === q && (ke = k(ye)), typeof ke > "u" && !_e)
        throw new l("intrinsic " + Te + " exists, but is not available. Please file an issue!");
      return {
        alias: Ae,
        name: ye,
        value: ke
      };
    }
    throw new u("intrinsic " + Te + " does not exist!");
  };
  return getIntrinsic = function(Te, _e) {
    if (typeof Te != "string" || Te.length === 0)
      throw new l("intrinsic name must be a non-empty string");
    if (arguments.length > 1 && typeof _e != "boolean")
      throw new l('"allowMissing" argument must be a boolean');
    if (ae(/^%?[^%]*%?$/, Te) === null)
      throw new u("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
    var ye = ge(Te), Ae = ye.length > 0 ? ye[0] : "", ke = me("%" + Ae + "%", _e), Pe = ke.name, Ee = ke.value, Oe = false, $e = ke.alias;
    $e && (Ae = $e[0], V(ye, W([0, 1], $e)));
    for (var gt = 1, xt = true; gt < ye.length; gt += 1) {
      var vt = ye[gt], Xe = J(vt, 0, 1), at = J(vt, -1);
      if ((Xe === '"' || Xe === "'" || Xe === "`" || at === '"' || at === "'" || at === "`") && Xe !== at)
        throw new u("property names with quotes must have matching quotes");
      if ((vt === "constructor" || !xt) && (Oe = true), Ae += "." + vt, Pe = "%" + Ae + "%", G(D, Pe))
        Ee = D[Pe];
      else if (Ee != null) {
        if (!(vt in Ee)) {
          if (!_e)
            throw new l("base intrinsic for " + Te + " exists, but the property is not available.");
          return;
        }
        if (E && gt + 1 >= ye.length) {
          var ct = E(Ee, vt);
          xt = !!ct, xt && "get" in ct && !("originalValue" in ct.get) ? Ee = ct.get : Ee = Ee[vt];
        } else
          xt = G(Ee, vt), Ee = Ee[vt];
        xt && !Oe && (D[Pe] = Ee);
      }
    }
    return Ee;
  }, getIntrinsic;
}
var callBound, hasRequiredCallBound;
function requireCallBound() {
  if (hasRequiredCallBound) return callBound;
  hasRequiredCallBound = 1;
  var i2 = /* @__PURE__ */ requireGetIntrinsic(), e = requireCallBindApplyHelpers(), t = e([i2("%String.prototype.indexOf%")]);
  return callBound = function(r, a) {
    var s = (
      /** @type {Parameters<typeof callBindBasic>[0][0]} */
      i2(r, !!a)
    );
    return typeof s == "function" && t(r, ".prototype.") > -1 ? e([s]) : s;
  }, callBound;
}
var sideChannelMap, hasRequiredSideChannelMap;
function requireSideChannelMap() {
  if (hasRequiredSideChannelMap) return sideChannelMap;
  hasRequiredSideChannelMap = 1;
  var i2 = /* @__PURE__ */ requireGetIntrinsic(), e = /* @__PURE__ */ requireCallBound(), t = /* @__PURE__ */ requireObjectInspect(), r = /* @__PURE__ */ requireType(), a = i2("%Map%", true), s = e("Map.prototype.get", true), u = e("Map.prototype.set", true), l = e("Map.prototype.has", true), c = e("Map.prototype.delete", true), d = e("Map.prototype.size", true);
  return sideChannelMap = !!a && /** @type {Exclude<import('.'), false>} */
  function() {
    var f, p = {
      assert: function(m) {
        if (!p.has(m))
          throw new r("Side channel does not contain " + t(m));
      },
      delete: function(m) {
        if (f) {
          var y = c(f, m);
          return d(f) === 0 && (f = void 0), y;
        }
        return false;
      },
      get: function(m) {
        if (f)
          return s(f, m);
      },
      has: function(m) {
        return f ? l(f, m) : false;
      },
      set: function(m, y) {
        f || (f = new a()), u(f, m, y);
      }
    };
    return p;
  }, sideChannelMap;
}
var sideChannelWeakmap, hasRequiredSideChannelWeakmap;
function requireSideChannelWeakmap() {
  if (hasRequiredSideChannelWeakmap) return sideChannelWeakmap;
  hasRequiredSideChannelWeakmap = 1;
  var i2 = /* @__PURE__ */ requireGetIntrinsic(), e = /* @__PURE__ */ requireCallBound(), t = /* @__PURE__ */ requireObjectInspect(), r = requireSideChannelMap(), a = /* @__PURE__ */ requireType(), s = i2("%WeakMap%", true), u = e("WeakMap.prototype.get", true), l = e("WeakMap.prototype.set", true), c = e("WeakMap.prototype.has", true), d = e("WeakMap.prototype.delete", true);
  return sideChannelWeakmap = s ? (
    /** @type {Exclude<import('.'), false>} */
    function() {
      var f, p, m = {
        assert: function(y) {
          if (!m.has(y))
            throw new a("Side channel does not contain " + t(y));
        },
        delete: function(y) {
          if (s && y && (typeof y == "object" || typeof y == "function")) {
            if (f)
              return d(f, y);
          } else if (r && p)
            return p.delete(y);
          return false;
        },
        get: function(y) {
          return s && y && (typeof y == "object" || typeof y == "function") && f ? u(f, y) : p && p.get(y);
        },
        has: function(y) {
          return s && y && (typeof y == "object" || typeof y == "function") && f ? c(f, y) : !!p && p.has(y);
        },
        set: function(y, x) {
          s && y && (typeof y == "object" || typeof y == "function") ? (f || (f = new s()), l(f, y, x)) : r && (p || (p = r()), p.set(y, x));
        }
      };
      return m;
    }
  ) : r, sideChannelWeakmap;
}
var sideChannel, hasRequiredSideChannel;
function requireSideChannel() {
  if (hasRequiredSideChannel) return sideChannel;
  hasRequiredSideChannel = 1;
  var i2 = /* @__PURE__ */ requireType(), e = /* @__PURE__ */ requireObjectInspect(), t = requireSideChannelList(), r = requireSideChannelMap(), a = requireSideChannelWeakmap(), s = a || r || t;
  return sideChannel = function() {
    var u, l = {
      assert: function(c) {
        if (!l.has(c))
          throw new i2("Side channel does not contain " + e(c));
      },
      delete: function(c) {
        return !!u && u.delete(c);
      },
      get: function(c) {
        return u && u.get(c);
      },
      has: function(c) {
        return !!u && u.has(c);
      },
      set: function(c, d) {
        u || (u = s()), u.set(c, d);
      }
    };
    return l;
  }, sideChannel;
}
var formats, hasRequiredFormats;
function requireFormats() {
  if (hasRequiredFormats) return formats;
  hasRequiredFormats = 1;
  var i2 = String.prototype.replace, e = /%20/g, t = {
    RFC1738: "RFC1738",
    RFC3986: "RFC3986"
  };
  return formats = {
    default: t.RFC3986,
    formatters: {
      RFC1738: function(r) {
        return i2.call(r, e, "+");
      },
      RFC3986: function(r) {
        return String(r);
      }
    },
    RFC1738: t.RFC1738,
    RFC3986: t.RFC3986
  }, formats;
}
var utils$2, hasRequiredUtils$2;
function requireUtils$2() {
  if (hasRequiredUtils$2) return utils$2;
  hasRequiredUtils$2 = 1;
  var i2 = /* @__PURE__ */ requireFormats(), e = Object.prototype.hasOwnProperty, t = Array.isArray, r = function() {
    for (var _ = [], T = 0; T < 256; ++T)
      _.push("%" + ((T < 16 ? "0" : "") + T.toString(16)).toUpperCase());
    return _;
  }(), a = function(_) {
    for (; _.length > 1; ) {
      var T = _.pop(), E = T.obj[T.prop];
      if (t(E)) {
        for (var b = [], C = 0; C < E.length; ++C)
          typeof E[C] < "u" && b.push(E[C]);
        T.obj[T.prop] = b;
      }
    }
  }, s = function(_, T) {
    for (var E = T && T.plainObjects ? { __proto__: null } : {}, b = 0; b < _.length; ++b)
      typeof _[b] < "u" && (E[b] = _[b]);
    return E;
  }, u = function _(T, E, b) {
    if (!E)
      return T;
    if (typeof E != "object" && typeof E != "function") {
      if (t(T))
        T.push(E);
      else if (T && typeof T == "object")
        (b && (b.plainObjects || b.allowPrototypes) || !e.call(Object.prototype, E)) && (T[E] = true);
      else
        return [T, E];
      return T;
    }
    if (!T || typeof T != "object")
      return [T].concat(E);
    var C = T;
    return t(T) && !t(E) && (C = s(T, b)), t(T) && t(E) ? (E.forEach(function(w, A) {
      if (e.call(T, A)) {
        var S = T[A];
        S && typeof S == "object" && w && typeof w == "object" ? T[A] = _(S, w, b) : T.push(w);
      } else
        T[A] = w;
    }), T) : Object.keys(E).reduce(function(w, A) {
      var S = E[A];
      return e.call(w, A) ? w[A] = _(w[A], S, b) : w[A] = S, w;
    }, C);
  }, l = function(_, T) {
    return Object.keys(T).reduce(function(E, b) {
      return E[b] = T[b], E;
    }, _);
  }, c = function(_, T, E) {
    var b = _.replace(/\+/g, " ");
    if (E === "iso-8859-1")
      return b.replace(/%[0-9a-f]{2}/gi, unescape);
    try {
      return decodeURIComponent(b);
    } catch {
      return b;
    }
  }, d = 1024, f = function(_, T, E, b, C) {
    if (_.length === 0)
      return _;
    var w = _;
    if (typeof _ == "symbol" ? w = Symbol.prototype.toString.call(_) : typeof _ != "string" && (w = String(_)), E === "iso-8859-1")
      return escape(w).replace(/%u[0-9a-f]{4}/gi, function(q) {
        return "%26%23" + parseInt(q.slice(2), 16) + "%3B";
      });
    for (var A = "", S = 0; S < w.length; S += d) {
      for (var F = w.length >= d ? w.slice(S, S + d) : w, M = [], U = 0; U < F.length; ++U) {
        var B = F.charCodeAt(U);
        if (B === 45 || B === 46 || B === 95 || B === 126 || B >= 48 && B <= 57 || B >= 65 && B <= 90 || B >= 97 && B <= 122 || C === i2.RFC1738 && (B === 40 || B === 41)) {
          M[M.length] = F.charAt(U);
          continue;
        }
        if (B < 128) {
          M[M.length] = r[B];
          continue;
        }
        if (B < 2048) {
          M[M.length] = r[192 | B >> 6] + r[128 | B & 63];
          continue;
        }
        if (B < 55296 || B >= 57344) {
          M[M.length] = r[224 | B >> 12] + r[128 | B >> 6 & 63] + r[128 | B & 63];
          continue;
        }
        U += 1, B = 65536 + ((B & 1023) << 10 | F.charCodeAt(U) & 1023), M[M.length] = r[240 | B >> 18] + r[128 | B >> 12 & 63] + r[128 | B >> 6 & 63] + r[128 | B & 63];
      }
      A += M.join("");
    }
    return A;
  }, p = function(_) {
    for (var T = [{ obj: { o: _ }, prop: "o" }], E = [], b = 0; b < T.length; ++b)
      for (var C = T[b], w = C.obj[C.prop], A = Object.keys(w), S = 0; S < A.length; ++S) {
        var F = A[S], M = w[F];
        typeof M == "object" && M !== null && E.indexOf(M) === -1 && (T.push({ obj: w, prop: F }), E.push(M));
      }
    return a(T), _;
  }, m = function(_) {
    return Object.prototype.toString.call(_) === "[object RegExp]";
  }, y = function(_) {
    return !_ || typeof _ != "object" ? false : !!(_.constructor && _.constructor.isBuffer && _.constructor.isBuffer(_));
  }, x = function(_, T) {
    return [].concat(_, T);
  }, g = function(_, T) {
    if (t(_)) {
      for (var E = [], b = 0; b < _.length; b += 1)
        E.push(T(_[b]));
      return E;
    }
    return T(_);
  };
  return utils$2 = {
    arrayToObject: s,
    assign: l,
    combine: x,
    compact: p,
    decode: c,
    encode: f,
    isBuffer: y,
    isRegExp: m,
    maybeMap: g,
    merge: u
  }, utils$2;
}
var stringify_1, hasRequiredStringify;
function requireStringify() {
  if (hasRequiredStringify) return stringify_1;
  hasRequiredStringify = 1;
  var i2 = requireSideChannel(), e = /* @__PURE__ */ requireUtils$2(), t = /* @__PURE__ */ requireFormats(), r = Object.prototype.hasOwnProperty, a = {
    brackets: function(g) {
      return g + "[]";
    },
    comma: "comma",
    indices: function(g, _) {
      return g + "[" + _ + "]";
    },
    repeat: function(g) {
      return g;
    }
  }, s = Array.isArray, u = Array.prototype.push, l = function(g, _) {
    u.apply(g, s(_) ? _ : [_]);
  }, c = Date.prototype.toISOString, d = t.default, f = {
    addQueryPrefix: false,
    allowDots: false,
    allowEmptyArrays: false,
    arrayFormat: "indices",
    charset: "utf-8",
    charsetSentinel: false,
    commaRoundTrip: false,
    delimiter: "&",
    encode: true,
    encodeDotInKeys: false,
    encoder: e.encode,
    encodeValuesOnly: false,
    filter: void 0,
    format: d,
    formatter: t.formatters[d],
    // deprecated
    indices: false,
    serializeDate: function(g) {
      return c.call(g);
    },
    skipNulls: false,
    strictNullHandling: false
  }, p = function(g) {
    return typeof g == "string" || typeof g == "number" || typeof g == "boolean" || typeof g == "symbol" || typeof g == "bigint";
  }, m = {}, y = function g(_, T, E, b, C, w, A, S, F, M, U, B, q, z, D, X, k, I) {
    for (var P = _, G = I, W = 0, V = false; (G = G.get(m)) !== void 0 && !V; ) {
      var K = G.get(_);
      if (W += 1, typeof K < "u") {
        if (K === W)
          throw new RangeError("Cyclic object value");
        V = true;
      }
      typeof G.get(m) > "u" && (W = 0);
    }
    if (typeof M == "function" ? P = M(T, P) : P instanceof Date ? P = q(P) : E === "comma" && s(P) && (P = e.maybeMap(P, function(Ee) {
      return Ee instanceof Date ? q(Ee) : Ee;
    })), P === null) {
      if (w)
        return F && !X ? F(T, f.encoder, k, "key", z) : T;
      P = "";
    }
    if (p(P) || e.isBuffer(P)) {
      if (F) {
        var J = X ? T : F(T, f.encoder, k, "key", z);
        return [D(J) + "=" + D(F(P, f.encoder, k, "value", z))];
      }
      return [D(T) + "=" + D(String(P))];
    }
    var ae = [];
    if (typeof P > "u")
      return ae;
    var re;
    if (E === "comma" && s(P))
      X && F && (P = e.maybeMap(P, F)), re = [{ value: P.length > 0 ? P.join(",") || null : void 0 }];
    else if (s(M))
      re = M;
    else {
      var he = Object.keys(P);
      re = U ? he.sort(U) : he;
    }
    var ge = S ? String(T).replace(/\./g, "%2E") : String(T), me = b && s(P) && P.length === 1 ? ge + "[]" : ge;
    if (C && s(P) && P.length === 0)
      return me + "[]";
    for (var Te = 0; Te < re.length; ++Te) {
      var _e = re[Te], ye = typeof _e == "object" && _e && typeof _e.value < "u" ? _e.value : P[_e];
      if (!(A && ye === null)) {
        var Ae = B && S ? String(_e).replace(/\./g, "%2E") : String(_e), ke = s(P) ? typeof E == "function" ? E(me, Ae) : me : me + (B ? "." + Ae : "[" + Ae + "]");
        I.set(_, W);
        var Pe = i2();
        Pe.set(m, I), l(ae, g(
          ye,
          ke,
          E,
          b,
          C,
          w,
          A,
          S,
          E === "comma" && X && s(P) ? null : F,
          M,
          U,
          B,
          q,
          z,
          D,
          X,
          k,
          Pe
        ));
      }
    }
    return ae;
  }, x = function(g) {
    if (!g)
      return f;
    if (typeof g.allowEmptyArrays < "u" && typeof g.allowEmptyArrays != "boolean")
      throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
    if (typeof g.encodeDotInKeys < "u" && typeof g.encodeDotInKeys != "boolean")
      throw new TypeError("`encodeDotInKeys` option can only be `true` or `false`, when provided");
    if (g.encoder !== null && typeof g.encoder < "u" && typeof g.encoder != "function")
      throw new TypeError("Encoder has to be a function.");
    var _ = g.charset || f.charset;
    if (typeof g.charset < "u" && g.charset !== "utf-8" && g.charset !== "iso-8859-1")
      throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
    var T = t.default;
    if (typeof g.format < "u") {
      if (!r.call(t.formatters, g.format))
        throw new TypeError("Unknown format option provided.");
      T = g.format;
    }
    var E = t.formatters[T], b = f.filter;
    (typeof g.filter == "function" || s(g.filter)) && (b = g.filter);
    var C;
    if (g.arrayFormat in a ? C = g.arrayFormat : "indices" in g ? C = g.indices ? "indices" : "repeat" : C = f.arrayFormat, "commaRoundTrip" in g && typeof g.commaRoundTrip != "boolean")
      throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
    var w = typeof g.allowDots > "u" ? g.encodeDotInKeys === true ? true : f.allowDots : !!g.allowDots;
    return {
      addQueryPrefix: typeof g.addQueryPrefix == "boolean" ? g.addQueryPrefix : f.addQueryPrefix,
      allowDots: w,
      allowEmptyArrays: typeof g.allowEmptyArrays == "boolean" ? !!g.allowEmptyArrays : f.allowEmptyArrays,
      arrayFormat: C,
      charset: _,
      charsetSentinel: typeof g.charsetSentinel == "boolean" ? g.charsetSentinel : f.charsetSentinel,
      commaRoundTrip: !!g.commaRoundTrip,
      delimiter: typeof g.delimiter > "u" ? f.delimiter : g.delimiter,
      encode: typeof g.encode == "boolean" ? g.encode : f.encode,
      encodeDotInKeys: typeof g.encodeDotInKeys == "boolean" ? g.encodeDotInKeys : f.encodeDotInKeys,
      encoder: typeof g.encoder == "function" ? g.encoder : f.encoder,
      encodeValuesOnly: typeof g.encodeValuesOnly == "boolean" ? g.encodeValuesOnly : f.encodeValuesOnly,
      filter: b,
      format: T,
      formatter: E,
      serializeDate: typeof g.serializeDate == "function" ? g.serializeDate : f.serializeDate,
      skipNulls: typeof g.skipNulls == "boolean" ? g.skipNulls : f.skipNulls,
      sort: typeof g.sort == "function" ? g.sort : null,
      strictNullHandling: typeof g.strictNullHandling == "boolean" ? g.strictNullHandling : f.strictNullHandling
    };
  };
  return stringify_1 = function(g, _) {
    var T = g, E = x(_), b, C;
    typeof E.filter == "function" ? (C = E.filter, T = C("", T)) : s(E.filter) && (C = E.filter, b = C);
    var w = [];
    if (typeof T != "object" || T === null)
      return "";
    var A = a[E.arrayFormat], S = A === "comma" && E.commaRoundTrip;
    b || (b = Object.keys(T)), E.sort && b.sort(E.sort);
    for (var F = i2(), M = 0; M < b.length; ++M) {
      var U = b[M], B = T[U];
      E.skipNulls && B === null || l(w, y(
        B,
        U,
        A,
        S,
        E.allowEmptyArrays,
        E.strictNullHandling,
        E.skipNulls,
        E.encodeDotInKeys,
        E.encode ? E.encoder : null,
        E.filter,
        E.sort,
        E.allowDots,
        E.serializeDate,
        E.format,
        E.formatter,
        E.encodeValuesOnly,
        E.charset,
        F
      ));
    }
    var q = w.join(E.delimiter), z = E.addQueryPrefix === true ? "?" : "";
    return E.charsetSentinel && (E.charset === "iso-8859-1" ? z += "utf8=%26%2310003%3B&" : z += "utf8=%E2%9C%93&"), q.length > 0 ? z + q : "";
  }, stringify_1;
}
var parse, hasRequiredParse;
function requireParse() {
  if (hasRequiredParse) return parse;
  hasRequiredParse = 1;
  var i2 = /* @__PURE__ */ requireUtils$2(), e = Object.prototype.hasOwnProperty, t = Array.isArray, r = {
    allowDots: false,
    allowEmptyArrays: false,
    allowPrototypes: false,
    allowSparse: false,
    arrayLimit: 20,
    charset: "utf-8",
    charsetSentinel: false,
    comma: false,
    decodeDotInKeys: false,
    decoder: i2.decode,
    delimiter: "&",
    depth: 5,
    duplicates: "combine",
    ignoreQueryPrefix: false,
    interpretNumericEntities: false,
    parameterLimit: 1e3,
    parseArrays: true,
    plainObjects: false,
    strictDepth: false,
    strictNullHandling: false,
    throwOnLimitExceeded: false
  }, a = function(m) {
    return m.replace(/&#(\d+);/g, function(y, x) {
      return String.fromCharCode(parseInt(x, 10));
    });
  }, s = function(m, y, x) {
    if (m && typeof m == "string" && y.comma && m.indexOf(",") > -1)
      return m.split(",");
    if (y.throwOnLimitExceeded && x >= y.arrayLimit)
      throw new RangeError("Array limit exceeded. Only " + y.arrayLimit + " element" + (y.arrayLimit === 1 ? "" : "s") + " allowed in an array.");
    return m;
  }, u = "utf8=%26%2310003%3B", l = "utf8=%E2%9C%93", c = function(m, y) {
    var x = { __proto__: null }, g = y.ignoreQueryPrefix ? m.replace(/^\?/, "") : m;
    g = g.replace(/%5B/gi, "[").replace(/%5D/gi, "]");
    var _ = y.parameterLimit === 1 / 0 ? void 0 : y.parameterLimit, T = g.split(
      y.delimiter,
      y.throwOnLimitExceeded ? _ + 1 : _
    );
    if (y.throwOnLimitExceeded && T.length > _)
      throw new RangeError("Parameter limit exceeded. Only " + _ + " parameter" + (_ === 1 ? "" : "s") + " allowed.");
    var E = -1, b, C = y.charset;
    if (y.charsetSentinel)
      for (b = 0; b < T.length; ++b)
        T[b].indexOf("utf8=") === 0 && (T[b] === l ? C = "utf-8" : T[b] === u && (C = "iso-8859-1"), E = b, b = T.length);
    for (b = 0; b < T.length; ++b)
      if (b !== E) {
        var w = T[b], A = w.indexOf("]="), S = A === -1 ? w.indexOf("=") : A + 1, F, M;
        S === -1 ? (F = y.decoder(w, r.decoder, C, "key"), M = y.strictNullHandling ? null : "") : (F = y.decoder(w.slice(0, S), r.decoder, C, "key"), M = i2.maybeMap(
          s(
            w.slice(S + 1),
            y,
            t(x[F]) ? x[F].length : 0
          ),
          function(B) {
            return y.decoder(B, r.decoder, C, "value");
          }
        )), M && y.interpretNumericEntities && C === "iso-8859-1" && (M = a(String(M))), w.indexOf("[]=") > -1 && (M = t(M) ? [M] : M);
        var U = e.call(x, F);
        U && y.duplicates === "combine" ? x[F] = i2.combine(x[F], M) : (!U || y.duplicates === "last") && (x[F] = M);
      }
    return x;
  }, d = function(m, y, x, g) {
    var _ = 0;
    if (m.length > 0 && m[m.length - 1] === "[]") {
      var T = m.slice(0, -1).join("");
      _ = Array.isArray(y) && y[T] ? y[T].length : 0;
    }
    for (var E = g ? y : s(y, x, _), b = m.length - 1; b >= 0; --b) {
      var C, w = m[b];
      if (w === "[]" && x.parseArrays)
        C = x.allowEmptyArrays && (E === "" || x.strictNullHandling && E === null) ? [] : i2.combine([], E);
      else {
        C = x.plainObjects ? { __proto__: null } : {};
        var A = w.charAt(0) === "[" && w.charAt(w.length - 1) === "]" ? w.slice(1, -1) : w, S = x.decodeDotInKeys ? A.replace(/%2E/g, ".") : A, F = parseInt(S, 10);
        !x.parseArrays && S === "" ? C = { 0: E } : !isNaN(F) && w !== S && String(F) === S && F >= 0 && x.parseArrays && F <= x.arrayLimit ? (C = [], C[F] = E) : S !== "__proto__" && (C[S] = E);
      }
      E = C;
    }
    return E;
  }, f = function(m, y, x, g) {
    if (m) {
      var _ = x.allowDots ? m.replace(/\.([^.[]+)/g, "[$1]") : m, T = /(\[[^[\]]*])/, E = /(\[[^[\]]*])/g, b = x.depth > 0 && T.exec(_), C = b ? _.slice(0, b.index) : _, w = [];
      if (C) {
        if (!x.plainObjects && e.call(Object.prototype, C) && !x.allowPrototypes)
          return;
        w.push(C);
      }
      for (var A = 0; x.depth > 0 && (b = E.exec(_)) !== null && A < x.depth; ) {
        if (A += 1, !x.plainObjects && e.call(Object.prototype, b[1].slice(1, -1)) && !x.allowPrototypes)
          return;
        w.push(b[1]);
      }
      if (b) {
        if (x.strictDepth === true)
          throw new RangeError("Input depth exceeded depth option of " + x.depth + " and strictDepth is true");
        w.push("[" + _.slice(b.index) + "]");
      }
      return d(w, y, x, g);
    }
  }, p = function(m) {
    if (!m)
      return r;
    if (typeof m.allowEmptyArrays < "u" && typeof m.allowEmptyArrays != "boolean")
      throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
    if (typeof m.decodeDotInKeys < "u" && typeof m.decodeDotInKeys != "boolean")
      throw new TypeError("`decodeDotInKeys` option can only be `true` or `false`, when provided");
    if (m.decoder !== null && typeof m.decoder < "u" && typeof m.decoder != "function")
      throw new TypeError("Decoder has to be a function.");
    if (typeof m.charset < "u" && m.charset !== "utf-8" && m.charset !== "iso-8859-1")
      throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
    if (typeof m.throwOnLimitExceeded < "u" && typeof m.throwOnLimitExceeded != "boolean")
      throw new TypeError("`throwOnLimitExceeded` option must be a boolean");
    var y = typeof m.charset > "u" ? r.charset : m.charset, x = typeof m.duplicates > "u" ? r.duplicates : m.duplicates;
    if (x !== "combine" && x !== "first" && x !== "last")
      throw new TypeError("The duplicates option must be either combine, first, or last");
    var g = typeof m.allowDots > "u" ? m.decodeDotInKeys === true ? true : r.allowDots : !!m.allowDots;
    return {
      allowDots: g,
      allowEmptyArrays: typeof m.allowEmptyArrays == "boolean" ? !!m.allowEmptyArrays : r.allowEmptyArrays,
      allowPrototypes: typeof m.allowPrototypes == "boolean" ? m.allowPrototypes : r.allowPrototypes,
      allowSparse: typeof m.allowSparse == "boolean" ? m.allowSparse : r.allowSparse,
      arrayLimit: typeof m.arrayLimit == "number" ? m.arrayLimit : r.arrayLimit,
      charset: y,
      charsetSentinel: typeof m.charsetSentinel == "boolean" ? m.charsetSentinel : r.charsetSentinel,
      comma: typeof m.comma == "boolean" ? m.comma : r.comma,
      decodeDotInKeys: typeof m.decodeDotInKeys == "boolean" ? m.decodeDotInKeys : r.decodeDotInKeys,
      decoder: typeof m.decoder == "function" ? m.decoder : r.decoder,
      delimiter: typeof m.delimiter == "string" || i2.isRegExp(m.delimiter) ? m.delimiter : r.delimiter,
      // eslint-disable-next-line no-implicit-coercion, no-extra-parens
      depth: typeof m.depth == "number" || m.depth === false ? +m.depth : r.depth,
      duplicates: x,
      ignoreQueryPrefix: m.ignoreQueryPrefix === true,
      interpretNumericEntities: typeof m.interpretNumericEntities == "boolean" ? m.interpretNumericEntities : r.interpretNumericEntities,
      parameterLimit: typeof m.parameterLimit == "number" ? m.parameterLimit : r.parameterLimit,
      parseArrays: m.parseArrays !== false,
      plainObjects: typeof m.plainObjects == "boolean" ? m.plainObjects : r.plainObjects,
      strictDepth: typeof m.strictDepth == "boolean" ? !!m.strictDepth : r.strictDepth,
      strictNullHandling: typeof m.strictNullHandling == "boolean" ? m.strictNullHandling : r.strictNullHandling,
      throwOnLimitExceeded: typeof m.throwOnLimitExceeded == "boolean" ? m.throwOnLimitExceeded : false
    };
  };
  return parse = function(m, y) {
    var x = p(y);
    if (m === "" || m === null || typeof m > "u")
      return x.plainObjects ? { __proto__: null } : {};
    for (var g = typeof m == "string" ? c(m, x) : m, _ = x.plainObjects ? { __proto__: null } : {}, T = Object.keys(g), E = 0; E < T.length; ++E) {
      var b = T[E], C = f(b, g[b], x, typeof m == "string");
      _ = i2.merge(_, C, x);
    }
    return x.allowSparse === true ? _ : i2.compact(_);
  }, parse;
}
var lib$2, hasRequiredLib$3;
function requireLib$3() {
  if (hasRequiredLib$3) return lib$2;
  hasRequiredLib$3 = 1;
  var i2 = /* @__PURE__ */ requireStringify(), e = /* @__PURE__ */ requireParse(), t = /* @__PURE__ */ requireFormats();
  return lib$2 = {
    formats: t,
    parse: e,
    stringify: i2
  }, lib$2;
}
var isObject_1$1, hasRequiredIsObject$1;
function requireIsObject$1() {
  if (hasRequiredIsObject$1) return isObject_1$1;
  hasRequiredIsObject$1 = 1;
  function i2(t) {
    "@babel/helpers - typeof";
    return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? i2 = function(r) {
      return typeof r;
    } : i2 = function(r) {
      return r && typeof Symbol == "function" && r.constructor === Symbol && r !== Symbol.prototype ? "symbol" : typeof r;
    }, i2(t);
  }
  function e(t) {
    return t !== null && i2(t) === "object";
  }
  return isObject_1$1 = e, isObject_1$1;
}
var requestBase, hasRequiredRequestBase;
function requireRequestBase() {
  if (hasRequiredRequestBase) return requestBase;
  hasRequiredRequestBase = 1;
  function i2(u) {
    "@babel/helpers - typeof";
    return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? i2 = function(l) {
      return typeof l;
    } : i2 = function(l) {
      return l && typeof Symbol == "function" && l.constructor === Symbol && l !== Symbol.prototype ? "symbol" : typeof l;
    }, i2(u);
  }
  var e = requireIsObject$1();
  requestBase = t;
  function t(u) {
    if (u) return r(u);
  }
  function r(u) {
    for (var l in t.prototype)
      Object.prototype.hasOwnProperty.call(t.prototype, l) && (u[l] = t.prototype[l]);
    return u;
  }
  t.prototype.clearTimeout = function() {
    return clearTimeout(this._timer), clearTimeout(this._responseTimeoutTimer), clearTimeout(this._uploadTimeoutTimer), delete this._timer, delete this._responseTimeoutTimer, delete this._uploadTimeoutTimer, this;
  }, t.prototype.parse = function(u) {
    return this._parser = u, this;
  }, t.prototype.responseType = function(u) {
    return this._responseType = u, this;
  }, t.prototype.serialize = function(u) {
    return this._serializer = u, this;
  }, t.prototype.timeout = function(u) {
    if (!u || i2(u) !== "object")
      return this._timeout = u, this._responseTimeout = 0, this._uploadTimeout = 0, this;
    for (var l in u)
      if (Object.prototype.hasOwnProperty.call(u, l))
        switch (l) {
          case "deadline":
            this._timeout = u.deadline;
            break;
          case "response":
            this._responseTimeout = u.response;
            break;
          case "upload":
            this._uploadTimeout = u.upload;
            break;
          default:
            console.warn("Unknown timeout option", l);
        }
    return this;
  }, t.prototype.retry = function(u, l) {
    return (arguments.length === 0 || u === true) && (u = 1), u <= 0 && (u = 0), this._maxRetries = u, this._retries = 0, this._retryCallback = l, this;
  };
  var a = /* @__PURE__ */ new Set(["ETIMEDOUT", "ECONNRESET", "EADDRINUSE", "ECONNREFUSED", "EPIPE", "ENOTFOUND", "ENETUNREACH", "EAI_AGAIN"]), s = /* @__PURE__ */ new Set([408, 413, 429, 500, 502, 503, 504, 521, 522, 524]);
  return t.prototype._shouldRetry = function(u, l) {
    if (!this._maxRetries || this._retries++ >= this._maxRetries)
      return false;
    if (this._retryCallback)
      try {
        var c = this._retryCallback(u, l);
        if (c === true) return true;
        if (c === false) return false;
      } catch (d) {
        console.error(d);
      }
    return !!(l && l.status && s.has(l.status) || u && (u.code && a.has(u.code) || u.timeout && u.code === "ECONNABORTED" || u.crossDomain));
  }, t.prototype._retry = function() {
    return this.clearTimeout(), this.req && (this.req = null, this.req = this.request()), this._aborted = false, this.timedout = false, this.timedoutError = null, this._end();
  }, t.prototype.then = function(u, l) {
    var c = this;
    if (!this._fullfilledPromise) {
      var d = this;
      this._endCalled && console.warn("Warning: superagent request was sent twice, because both .end() and .then() were called. Never call .end() if you use promises"), this._fullfilledPromise = new Promise(function(f, p) {
        d.on("abort", function() {
          if (!(c._maxRetries && c._maxRetries > c._retries)) {
            if (c.timedout && c.timedoutError) {
              p(c.timedoutError);
              return;
            }
            var m = new Error("Aborted");
            m.code = "ABORTED", m.status = c.status, m.method = c.method, m.url = c.url, p(m);
          }
        }), d.end(function(m, y) {
          m ? p(m) : f(y);
        });
      });
    }
    return this._fullfilledPromise.then(u, l);
  }, t.prototype.catch = function(u) {
    return this.then(void 0, u);
  }, t.prototype.use = function(u) {
    return u(this), this;
  }, t.prototype.ok = function(u) {
    if (typeof u != "function") throw new Error("Callback required");
    return this._okCallback = u, this;
  }, t.prototype._isResponseOK = function(u) {
    return u ? this._okCallback ? this._okCallback(u) : u.status >= 200 && u.status < 300 : false;
  }, t.prototype.get = function(u) {
    return this._header[u.toLowerCase()];
  }, t.prototype.getHeader = t.prototype.get, t.prototype.set = function(u, l) {
    if (e(u)) {
      for (var c in u)
        Object.prototype.hasOwnProperty.call(u, c) && this.set(c, u[c]);
      return this;
    }
    return this._header[u.toLowerCase()] = l, this.header[u] = l, this;
  }, t.prototype.unset = function(u) {
    return delete this._header[u.toLowerCase()], delete this.header[u], this;
  }, t.prototype.field = function(u, l) {
    if (u == null)
      throw new Error(".field(name, val) name can not be empty");
    if (this._data)
      throw new Error(".field() can't be used if .send() is used. Please use only .send() or only .field() & .attach()");
    if (e(u)) {
      for (var c in u)
        Object.prototype.hasOwnProperty.call(u, c) && this.field(c, u[c]);
      return this;
    }
    if (Array.isArray(l)) {
      for (var d in l)
        Object.prototype.hasOwnProperty.call(l, d) && this.field(u, l[d]);
      return this;
    }
    if (l == null)
      throw new Error(".field(name, val) val can not be empty");
    return typeof l == "boolean" && (l = String(l)), this._getFormData().append(u, l), this;
  }, t.prototype.abort = function() {
    return this._aborted ? this : (this._aborted = true, this.xhr && this.xhr.abort(), this.req && this.req.abort(), this.clearTimeout(), this.emit("abort"), this);
  }, t.prototype._auth = function(u, l, c, d) {
    switch (c.type) {
      case "basic":
        this.set("Authorization", "Basic ".concat(d("".concat(u, ":").concat(l))));
        break;
      case "auto":
        this.username = u, this.password = l;
        break;
      case "bearer":
        this.set("Authorization", "Bearer ".concat(u));
        break;
    }
    return this;
  }, t.prototype.withCredentials = function(u) {
    return u === void 0 && (u = true), this._withCredentials = u, this;
  }, t.prototype.redirects = function(u) {
    return this._maxRedirects = u, this;
  }, t.prototype.maxResponseSize = function(u) {
    if (typeof u != "number")
      throw new TypeError("Invalid argument");
    return this._maxResponseSize = u, this;
  }, t.prototype.toJSON = function() {
    return {
      method: this.method,
      url: this.url,
      data: this._data,
      headers: this._header
    };
  }, t.prototype.send = function(u) {
    var l = e(u), c = this._header["content-type"];
    if (this._formData)
      throw new Error(".send() can't be used if .attach() or .field() is used. Please use only .send() or only .field() & .attach()");
    if (l && !this._data)
      Array.isArray(u) ? this._data = [] : this._isHost(u) || (this._data = {});
    else if (u && this._data && this._isHost(this._data))
      throw new Error("Can't merge these send calls");
    if (l && e(this._data))
      for (var d in u)
        Object.prototype.hasOwnProperty.call(u, d) && (this._data[d] = u[d]);
    else typeof u == "string" ? (c || this.type("form"), c = this._header["content-type"], c && (c = c.toLowerCase().trim()), c === "application/x-www-form-urlencoded" ? this._data = this._data ? "".concat(this._data, "&").concat(u) : u : this._data = (this._data || "") + u) : this._data = u;
    return !l || this._isHost(u) ? this : (c || this.type("json"), this);
  }, t.prototype.sortQuery = function(u) {
    return this._sort = typeof u > "u" ? true : u, this;
  }, t.prototype._finalizeQueryString = function() {
    var u = this._query.join("&");
    if (u && (this.url += (this.url.includes("?") ? "&" : "?") + u), this._query.length = 0, this._sort) {
      var l = this.url.indexOf("?");
      if (l >= 0) {
        var c = this.url.slice(l + 1).split("&");
        typeof this._sort == "function" ? c.sort(this._sort) : c.sort(), this.url = this.url.slice(0, l) + "?" + c.join("&");
      }
    }
  }, t.prototype._appendQueryString = function() {
    console.warn("Unsupported");
  }, t.prototype._timeoutError = function(u, l, c) {
    if (!this._aborted) {
      var d = new Error("".concat(u + l, "ms exceeded"));
      d.timeout = l, d.code = "ECONNABORTED", d.errno = c, this.timedout = true, this.timedoutError = d, this.abort(), this.callback(d);
    }
  }, t.prototype._setTimeouts = function() {
    var u = this;
    this._timeout && !this._timer && (this._timer = setTimeout(function() {
      u._timeoutError("Timeout of ", u._timeout, "ETIME");
    }, this._timeout)), this._responseTimeout && !this._responseTimeoutTimer && (this._responseTimeoutTimer = setTimeout(function() {
      u._timeoutError("Response timeout of ", u._responseTimeout, "ETIMEDOUT");
    }, this._responseTimeout));
  }, requestBase;
}
var utils$1 = {}, hasRequiredUtils$1;
function requireUtils$1() {
  if (hasRequiredUtils$1) return utils$1;
  hasRequiredUtils$1 = 1;
  function i2(r, a) {
    var s;
    if (typeof Symbol > "u" || r[Symbol.iterator] == null) {
      if (Array.isArray(r) || (s = e(r)) || a) {
        s && (r = s);
        var u = 0, l = function() {
        };
        return { s: l, n: function() {
          return u >= r.length ? { done: true } : { done: false, value: r[u++] };
        }, e: function(p) {
          throw p;
        }, f: l };
      }
      throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    var c = true, d = false, f;
    return { s: function() {
      s = r[Symbol.iterator]();
    }, n: function() {
      var p = s.next();
      return c = p.done, p;
    }, e: function(p) {
      d = true, f = p;
    }, f: function() {
      try {
        !c && s.return != null && s.return();
      } finally {
        if (d) throw f;
      }
    } };
  }
  function e(r, a) {
    if (r) {
      if (typeof r == "string") return t(r, a);
      var s = Object.prototype.toString.call(r).slice(8, -1);
      if (s === "Object" && r.constructor && (s = r.constructor.name), s === "Map" || s === "Set") return Array.from(r);
      if (s === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(s)) return t(r, a);
    }
  }
  function t(r, a) {
    (a == null || a > r.length) && (a = r.length);
    for (var s = 0, u = new Array(a); s < a; s++)
      u[s] = r[s];
    return u;
  }
  return utils$1.type = function(r) {
    return r.split(/ *; */).shift();
  }, utils$1.params = function(r) {
    var a = {}, s = i2(r.split(/ *; */)), u;
    try {
      for (s.s(); !(u = s.n()).done; ) {
        var l = u.value, c = l.split(/ *= */), d = c.shift(), f = c.shift();
        d && f && (a[d] = f);
      }
    } catch (p) {
      s.e(p);
    } finally {
      s.f();
    }
    return a;
  }, utils$1.parseLinks = function(r) {
    var a = {}, s = i2(r.split(/ *, */)), u;
    try {
      for (s.s(); !(u = s.n()).done; ) {
        var l = u.value, c = l.split(/ *; */), d = c[0].slice(1, -1), f = c[1].split(/ *= */)[1].slice(1, -1);
        a[f] = d;
      }
    } catch (p) {
      s.e(p);
    } finally {
      s.f();
    }
    return a;
  }, utils$1.cleanHeader = function(r, a) {
    return delete r["content-type"], delete r["content-length"], delete r["transfer-encoding"], delete r.host, a && (delete r.authorization, delete r.cookie), r;
  }, utils$1;
}
var responseBase, hasRequiredResponseBase;
function requireResponseBase() {
  if (hasRequiredResponseBase) return responseBase;
  hasRequiredResponseBase = 1;
  var i2 = requireUtils$1();
  responseBase = e;
  function e(r) {
    if (r) return t(r);
  }
  function t(r) {
    for (var a in e.prototype)
      Object.prototype.hasOwnProperty.call(e.prototype, a) && (r[a] = e.prototype[a]);
    return r;
  }
  return e.prototype.get = function(r) {
    return this.header[r.toLowerCase()];
  }, e.prototype._setHeaderProperties = function(r) {
    var a = r["content-type"] || "";
    this.type = i2.type(a);
    var s = i2.params(a);
    for (var u in s)
      Object.prototype.hasOwnProperty.call(s, u) && (this[u] = s[u]);
    this.links = {};
    try {
      r.link && (this.links = i2.parseLinks(r.link));
    } catch {
    }
  }, e.prototype._setStatusProperties = function(r) {
    var a = r / 100 | 0;
    this.statusCode = r, this.status = this.statusCode, this.statusType = a, this.info = a === 1, this.ok = a === 2, this.redirect = a === 3, this.clientError = a === 4, this.serverError = a === 5, this.error = a === 4 || a === 5 ? this.toError() : false, this.created = r === 201, this.accepted = r === 202, this.noContent = r === 204, this.badRequest = r === 400, this.unauthorized = r === 401, this.notAcceptable = r === 406, this.forbidden = r === 403, this.notFound = r === 404, this.unprocessableEntity = r === 422;
  }, responseBase;
}
var agentBase, hasRequiredAgentBase;
function requireAgentBase() {
  if (hasRequiredAgentBase) return agentBase;
  hasRequiredAgentBase = 1;
  function i2(l) {
    return a(l) || r(l) || t(l) || e();
  }
  function e() {
    throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  function t(l, c) {
    if (l) {
      if (typeof l == "string") return s(l, c);
      var d = Object.prototype.toString.call(l).slice(8, -1);
      if (d === "Object" && l.constructor && (d = l.constructor.name), d === "Map" || d === "Set") return Array.from(l);
      if (d === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(d)) return s(l, c);
    }
  }
  function r(l) {
    if (typeof Symbol < "u" && Symbol.iterator in Object(l)) return Array.from(l);
  }
  function a(l) {
    if (Array.isArray(l)) return s(l);
  }
  function s(l, c) {
    (c == null || c > l.length) && (c = l.length);
    for (var d = 0, f = new Array(c); d < c; d++)
      f[d] = l[d];
    return f;
  }
  function u() {
    this._defaults = [];
  }
  return ["use", "on", "once", "set", "query", "type", "accept", "auth", "withCredentials", "sortQuery", "retry", "ok", "redirects", "timeout", "buffer", "serialize", "parse", "ca", "key", "pfx", "cert", "disableTLSCerts"].forEach(function(l) {
    u.prototype[l] = function() {
      for (var c = arguments.length, d = new Array(c), f = 0; f < c; f++)
        d[f] = arguments[f];
      return this._defaults.push({
        fn: l,
        args: d
      }), this;
    };
  }), u.prototype._setDefaults = function(l) {
    this._defaults.forEach(function(c) {
      l[c.fn].apply(l, i2(c.args));
    });
  }, agentBase = u, agentBase;
}
var hasRequiredClient;
function requireClient() {
  return hasRequiredClient || (hasRequiredClient = 1, function(i2, e) {
    function t(A) {
      "@babel/helpers - typeof";
      return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? t = function(S) {
        return typeof S;
      } : t = function(S) {
        return S && typeof Symbol == "function" && S.constructor === Symbol && S !== Symbol.prototype ? "symbol" : typeof S;
      }, t(A);
    }
    var r;
    typeof window < "u" ? r = window : typeof self > "u" ? (console.warn("Using browser-only version of superagent in non-browser environment"), r = void 0) : r = self;
    var a = requireComponentEmitter(), s = requireFastSafeStringify(), u = /* @__PURE__ */ requireLib$3(), l = requireRequestBase(), c = requireIsObject$1(), d = requireResponseBase(), f = requireAgentBase();
    function p() {
    }
    i2.exports = function(A, S) {
      return typeof S == "function" ? new e.Request("GET", A).end(S) : arguments.length === 1 ? new e.Request("GET", A) : new e.Request(A, S);
    }, e = i2.exports;
    var m = e;
    e.Request = C, m.getXHR = function() {
      if (r.XMLHttpRequest && (!r.location || r.location.protocol !== "file:" || !r.ActiveXObject))
        return new XMLHttpRequest();
      try {
        return new ActiveXObject("Microsoft.XMLHTTP");
      } catch {
      }
      try {
        return new ActiveXObject("Msxml2.XMLHTTP.6.0");
      } catch {
      }
      try {
        return new ActiveXObject("Msxml2.XMLHTTP.3.0");
      } catch {
      }
      try {
        return new ActiveXObject("Msxml2.XMLHTTP");
      } catch {
      }
      throw new Error("Browser-only version of superagent could not find XHR");
    };
    var y = "".trim ? function(A) {
      return A.trim();
    } : function(A) {
      return A.replace(/(^\s*|\s*$)/g, "");
    };
    function x(A) {
      if (!c(A)) return A;
      var S = [];
      for (var F in A)
        Object.prototype.hasOwnProperty.call(A, F) && g(S, F, A[F]);
      return S.join("&");
    }
    function g(A, S, F) {
      if (F !== void 0) {
        if (F === null) {
          A.push(encodeURI(S));
          return;
        }
        if (Array.isArray(F))
          F.forEach(function(U) {
            g(A, S, U);
          });
        else if (c(F))
          for (var M in F)
            Object.prototype.hasOwnProperty.call(F, M) && g(A, "".concat(S, "[").concat(M, "]"), F[M]);
        else
          A.push(encodeURI(S) + "=" + encodeURIComponent(F));
      }
    }
    m.serializeObject = x;
    function _(A) {
      for (var S = {}, F = A.split("&"), M, U, B = 0, q = F.length; B < q; ++B)
        M = F[B], U = M.indexOf("="), U === -1 ? S[decodeURIComponent(M)] = "" : S[decodeURIComponent(M.slice(0, U))] = decodeURIComponent(M.slice(U + 1));
      return S;
    }
    m.parseString = _, m.types = {
      html: "text/html",
      json: "application/json",
      xml: "text/xml",
      urlencoded: "application/x-www-form-urlencoded",
      form: "application/x-www-form-urlencoded",
      "form-data": "application/x-www-form-urlencoded"
    }, m.serialize = {
      "application/x-www-form-urlencoded": u.stringify,
      "application/json": s
    }, m.parse = {
      "application/x-www-form-urlencoded": _,
      "application/json": JSON.parse
    };
    function T(A) {
      for (var S = A.split(/\r?\n/), F = {}, M, U, B, q, z = 0, D = S.length; z < D; ++z)
        U = S[z], M = U.indexOf(":"), M !== -1 && (B = U.slice(0, M).toLowerCase(), q = y(U.slice(M + 1)), F[B] = q);
      return F;
    }
    function E(A) {
      return /[/+]json($|[^-\w])/i.test(A);
    }
    function b(A) {
      this.req = A, this.xhr = this.req.xhr, this.text = this.req.method !== "HEAD" && (this.xhr.responseType === "" || this.xhr.responseType === "text") || typeof this.xhr.responseType > "u" ? this.xhr.responseText : null, this.statusText = this.req.xhr.statusText;
      var S = this.xhr.status;
      S === 1223 && (S = 204), this._setStatusProperties(S), this.headers = T(this.xhr.getAllResponseHeaders()), this.header = this.headers, this.header["content-type"] = this.xhr.getResponseHeader("content-type"), this._setHeaderProperties(this.header), this.text === null && A._responseType ? this.body = this.xhr.response : this.body = this.req.method === "HEAD" ? null : this._parseBody(this.text ? this.text : this.xhr.response);
    }
    d(b.prototype), b.prototype._parseBody = function(A) {
      var S = m.parse[this.type];
      return this.req._parser ? this.req._parser(this, A) : (!S && E(this.type) && (S = m.parse["application/json"]), S && A && (A.length > 0 || A instanceof Object) ? S(A) : null);
    }, b.prototype.toError = function() {
      var A = this.req, S = A.method, F = A.url, M = "cannot ".concat(S, " ").concat(F, " (").concat(this.status, ")"), U = new Error(M);
      return U.status = this.status, U.method = S, U.url = F, U;
    }, m.Response = b;
    function C(A, S) {
      var F = this;
      this._query = this._query || [], this.method = A, this.url = S, this.header = {}, this._header = {}, this.on("end", function() {
        var M = null, U = null;
        try {
          U = new b(F);
        } catch (q) {
          return M = new Error("Parser is unable to parse the response"), M.parse = true, M.original = q, F.xhr ? (M.rawResponse = typeof F.xhr.responseType > "u" ? F.xhr.responseText : F.xhr.response, M.status = F.xhr.status ? F.xhr.status : null, M.statusCode = M.status) : (M.rawResponse = null, M.status = null), F.callback(M);
        }
        F.emit("response", U);
        var B;
        try {
          F._isResponseOK(U) || (B = new Error(U.statusText || U.text || "Unsuccessful HTTP response"));
        } catch (q) {
          B = q;
        }
        B ? (B.original = M, B.response = U, B.status = U.status, F.callback(B, U)) : F.callback(null, U);
      });
    }
    a(C.prototype), l(C.prototype), C.prototype.type = function(A) {
      return this.set("Content-Type", m.types[A] || A), this;
    }, C.prototype.accept = function(A) {
      return this.set("Accept", m.types[A] || A), this;
    }, C.prototype.auth = function(A, S, F) {
      arguments.length === 1 && (S = ""), t(S) === "object" && S !== null && (F = S, S = ""), F || (F = {
        type: typeof btoa == "function" ? "basic" : "auto"
      });
      var M = function(U) {
        if (typeof btoa == "function")
          return btoa(U);
        throw new Error("Cannot use basic auth, btoa is not a function");
      };
      return this._auth(A, S, F, M);
    }, C.prototype.query = function(A) {
      return typeof A != "string" && (A = x(A)), A && this._query.push(A), this;
    }, C.prototype.attach = function(A, S, F) {
      if (S) {
        if (this._data)
          throw new Error("superagent can't mix .send() and .attach()");
        this._getFormData().append(A, S, F || S.name);
      }
      return this;
    }, C.prototype._getFormData = function() {
      return this._formData || (this._formData = new r.FormData()), this._formData;
    }, C.prototype.callback = function(A, S) {
      if (this._shouldRetry(A, S))
        return this._retry();
      var F = this._callback;
      this.clearTimeout(), A && (this._maxRetries && (A.retries = this._retries - 1), this.emit("error", A)), F(A, S);
    }, C.prototype.crossDomainError = function() {
      var A = new Error(`Request has been terminated
Possible causes: the network is offline, Origin is not allowed by Access-Control-Allow-Origin, the page is being unloaded, etc.`);
      A.crossDomain = true, A.status = this.status, A.method = this.method, A.url = this.url, this.callback(A);
    }, C.prototype.agent = function() {
      return console.warn("This is not supported in browser version of superagent"), this;
    }, C.prototype.ca = C.prototype.agent, C.prototype.buffer = C.prototype.ca, C.prototype.write = function() {
      throw new Error("Streaming is not supported in browser version of superagent");
    }, C.prototype.pipe = C.prototype.write, C.prototype._isHost = function(A) {
      return A && t(A) === "object" && !Array.isArray(A) && Object.prototype.toString.call(A) !== "[object Object]";
    }, C.prototype.end = function(A) {
      this._endCalled && console.warn("Warning: .end() was called twice. This is not supported in superagent"), this._endCalled = true, this._callback = A || p, this._finalizeQueryString(), this._end();
    }, C.prototype._setUploadTimeout = function() {
      var A = this;
      this._uploadTimeout && !this._uploadTimeoutTimer && (this._uploadTimeoutTimer = setTimeout(function() {
        A._timeoutError("Upload timeout of ", A._uploadTimeout, "ETIMEDOUT");
      }, this._uploadTimeout));
    }, C.prototype._end = function() {
      if (this._aborted) return this.callback(new Error("The request has been aborted even before .end() was called"));
      var A = this;
      this.xhr = m.getXHR();
      var S = this.xhr, F = this._formData || this._data;
      this._setTimeouts(), S.onreadystatechange = function() {
        var z = S.readyState;
        if (z >= 2 && A._responseTimeoutTimer && clearTimeout(A._responseTimeoutTimer), z === 4) {
          var D;
          try {
            D = S.status;
          } catch {
            D = 0;
          }
          if (!D)
            return A.timedout || A._aborted ? void 0 : A.crossDomainError();
          A.emit("end");
        }
      };
      var M = function(z, D) {
        D.total > 0 && (D.percent = D.loaded / D.total * 100, D.percent === 100 && clearTimeout(A._uploadTimeoutTimer)), D.direction = z, A.emit("progress", D);
      };
      if (this.hasListeners("progress"))
        try {
          S.addEventListener("progress", M.bind(null, "download")), S.upload && S.upload.addEventListener("progress", M.bind(null, "upload"));
        } catch {
        }
      S.upload && this._setUploadTimeout();
      try {
        this.username && this.password ? S.open(this.method, this.url, true, this.username, this.password) : S.open(this.method, this.url, true);
      } catch (z) {
        return this.callback(z);
      }
      if (this._withCredentials && (S.withCredentials = true), !this._formData && this.method !== "GET" && this.method !== "HEAD" && typeof F != "string" && !this._isHost(F)) {
        var U = this._header["content-type"], B = this._serializer || m.serialize[U ? U.split(";")[0] : ""];
        !B && E(U) && (B = m.serialize["application/json"]), B && (F = B(F));
      }
      for (var q in this.header)
        this.header[q] !== null && Object.prototype.hasOwnProperty.call(this.header, q) && S.setRequestHeader(q, this.header[q]);
      this._responseType && (S.responseType = this._responseType), this.emit("request", this), S.send(typeof F > "u" ? null : F);
    }, m.agent = function() {
      return new f();
    }, ["GET", "POST", "OPTIONS", "PATCH", "PUT", "DELETE"].forEach(function(A) {
      f.prototype[A.toLowerCase()] = function(S, F) {
        var M = new m.Request(A, S);
        return this._setDefaults(M), F && M.end(F), M;
      };
    }), f.prototype.del = f.prototype.delete, m.get = function(A, S, F) {
      var M = m("GET", A);
      return typeof S == "function" && (F = S, S = null), S && M.query(S), F && M.end(F), M;
    }, m.head = function(A, S, F) {
      var M = m("HEAD", A);
      return typeof S == "function" && (F = S, S = null), S && M.query(S), F && M.end(F), M;
    }, m.options = function(A, S, F) {
      var M = m("OPTIONS", A);
      return typeof S == "function" && (F = S, S = null), S && M.send(S), F && M.end(F), M;
    };
    function w(A, S, F) {
      var M = m("DELETE", A);
      return typeof S == "function" && (F = S, S = null), S && M.send(S), F && M.end(F), M;
    }
    m.del = w, m.delete = w, m.patch = function(A, S, F) {
      var M = m("PATCH", A);
      return typeof S == "function" && (F = S, S = null), S && M.send(S), F && M.end(F), M;
    }, m.post = function(A, S, F) {
      var M = m("POST", A);
      return typeof S == "function" && (F = S, S = null), S && M.send(S), F && M.end(F), M;
    }, m.put = function(A, S, F) {
      var M = m("PUT", A);
      return typeof S == "function" && (F = S, S = null), S && M.send(S), F && M.end(F), M;
    };
  }(client, client.exports)), client.exports;
}
var constant = {}, hasRequiredConstant;
function requireConstant() {
  if (hasRequiredConstant) return constant;
  hasRequiredConstant = 1, Object.defineProperty(constant, "__esModule", {
    value: true
  }), constant.XHR_TYPE_MAP = constant.XHR_RESPONSE_TYPE = constant.STATUS_FLAGS = constant.LOAD_TYPE_MAP = constant.LOAD_TYPE = void 0;
  var i2 = {
    NONE: 0,
    DATA_URL: 1,
    COMPLETE: 2,
    LOADING: 4
  };
  constant.STATUS_FLAGS = i2;
  var e = {
    XHR: 1,
    IMAGE: 2,
    AUDIO: 3,
    VIDEO: 4
  };
  constant.LOAD_TYPE = e;
  var t = {
    DEFAULT: "text",
    BUFFER: "arraybuffer",
    BLOB: "blob",
    DOCUMENT: "document",
    JSON: "json",
    TEXT: "text"
  };
  constant.XHR_RESPONSE_TYPE = t;
  var r = {
    // xml
    xhtml: t.DOCUMENT,
    html: t.DOCUMENT,
    htm: t.DOCUMENT,
    xml: t.DOCUMENT,
    tmx: t.DOCUMENT,
    svg: t.DOCUMENT,
    tsx: t.DOCUMENT,
    fnt: t.DOCUMENT,
    // images
    gif: t.BLOB,
    png: t.BLOB,
    bmp: t.BLOB,
    jpg: t.BLOB,
    jpeg: t.BLOB,
    tif: t.BLOB,
    tiff: t.BLOB,
    webp: t.BLOB,
    tga: t.BLOB,
    // json
    json: t.JSON,
    // text
    text: t.TEXT,
    txt: t.TEXT,
    // fonts
    ttf: t.BUFFER,
    otf: t.BUFFER
  };
  constant.XHR_TYPE_MAP = r;
  var a = {
    // images
    gif: e.IMAGE,
    png: e.IMAGE,
    bmp: e.IMAGE,
    jpg: e.IMAGE,
    jpeg: e.IMAGE,
    tif: e.IMAGE,
    tiff: e.IMAGE,
    webp: e.IMAGE,
    tga: e.IMAGE,
    svg: e.IMAGE,
    // audio
    mp3: e.AUDIO,
    ogg: e.AUDIO,
    wav: e.AUDIO,
    // videos
    mp4: e.VIDEO,
    webm: e.VIDEO
  };
  return constant.LOAD_TYPE_MAP = a, constant;
}
var hasRequiredResource$1;
function requireResource$1() {
  if (hasRequiredResource$1) return Resource;
  hasRequiredResource$1 = 1, Object.defineProperty(Resource, "__esModule", {
    value: true
  }), Resource.default = void 0;
  var i2 = s(require$$0), e = s(requireClient()), t = s(requireImage$2()), r = requireLib$4(), a = requireConstant();
  function s(f) {
    return f && f.__esModule ? f : { default: f };
  }
  function u() {
  }
  var l = "data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==";
  let c = class Tu {
    constructor(p, m, y) {
      if (y === void 0 && (y = {}), typeof p != "string" || typeof m != "string")
        throw new Error("Both name and url are required.");
      this._flags = 0, this.setflag(a.STATUS_FLAGS.DATA_URL, m.indexOf("data:") === 0), this.name = p, this.url = m, this.extension = this._getExt(), this.data = null, this.crossOrigin = y.crossOrigin === true ? "anonymous" : y.crossOrigin, this.timeout = y.timeout || 0, this.loadType = y.loadType || this._determineLoadType(), this.xhrType = y.xhrType, this.error = null, this.children = [], this.type = Tu.TYPE.UNKNOWN, this.progressChunk = 0, this._dequeue = u, this._onLoadBinding = null, this._elementTimer = 0, this.metadata = y.metadata || {}, this.onStart = new i2.default(), this.onProgress = new i2.default(), this.onComplete = new i2.default(), this.onAfterMiddleware = new i2.default(), this._onComplete = this._onComplete.bind(this), this._onError = this._onError.bind(this), this._onTimeout = this._onTimeout.bind(this), this._onXhrLoad = this._onXhrLoad.bind(this);
    }
    get isDataUrl() {
      return this.hasflag(a.STATUS_FLAGS.DATA_URL);
    }
    get isComplete() {
      return this.hasflag(a.STATUS_FLAGS.COMPLETE);
    }
    get isLoading() {
      return this.hasflag(a.STATUS_FLAGS.LOADING);
    }
    complete() {
      this._clearEvents(), this._finish();
    }
    load(p) {
      var {
        isLoading: m,
        loadType: y,
        isComplete: x
      } = this;
      if (!m) {
        if (x) {
          p && setTimeout(() => p(this), 1);
          return;
        } else p && this.onComplete.once(p);
        switch (this.setflag(a.STATUS_FLAGS.LOADING, true), this.onStart.dispatch(this), y) {
          case a.LOAD_TYPE.IMAGE:
            this.type = Tu.TYPE.IMAGE, this._loadImage();
            break;
          case a.LOAD_TYPE.XHR:
          default:
            this._loadOtherFile();
            break;
        }
      }
    }
    abort(p) {
      if (!this.error) {
        if (this.error = new Error(p), this._clearEvents(), this.data)
          if (this.data.src)
            this.data.src = l;
          else
            for (; this.data.firstChild; )
              this.data.removeChild(this.data.firstChild);
        this._finish();
      }
    }
    destroy() {
      this.removeHandler(), this.data = null, this.name = null, this.url = null, this.metadata = null, this.onStart = null, this.onProgress = null, this.onComplete = null, this.onAfterMiddleware = null, this.children = null, this._dequeue = null, this._onLoadBinding = null, this._flags = 0, this._onComplete = null, this._onError = null, this._onTimeout = null, this._onXhrLoad = null;
    }
    _loadOtherFile() {
      var p = this._isNetWork(this.url);
      p || r.isBrowser ? this._loadXhr() : this._loadLocalFile();
    }
    _loadLocalFile() {
      (0, _fs.readFile)(this.url, (p, m) => {
        if (p)
          this._onError(p);
        else {
          var y = JSON.parse(m);
          this._onXhrLoad(y);
        }
      });
    }
    _loadXhr() {
      e.default.get(this.url).end((p, m) => {
        p ? this._onError(p) : this._onXhrLoad(m.body);
      });
    }
    _isNetWork(p) {
      return !!/^\s*https?:\/\//.test(p);
    }
    _onXhrLoad(p) {
      this.data = p, this.type = Tu.TYPE.JSON, this.complete();
    }
    hasflag(p) {
      return (this._flags & p) !== 0;
    }
    setflag(p, m) {
      this._flags = m ? this._flags | p : this._flags & ~p;
    }
    removeHandler() {
      this.data && (this.data.onerror = null, this.data.onload = null);
    }
    _clearEvents() {
      clearTimeout(this._elementTimer), this.removeHandler();
    }
    _finish() {
      this.isComplete || (this.setflag(a.STATUS_FLAGS.COMPLETE, true), this.setflag(a.STATUS_FLAGS.LOADING, false), this.onComplete.dispatch(this));
    }
    _loadImage() {
      this.data = new t.default(), this.data.onerror = this._onError, this.data.onload = this._onComplete, this.crossOrigin && (this.data.crossOrigin = this.crossOrigin), this.data.src = this.url, this._isNetWork(this.url) ? this.data.network = true : this.data.network = false, this.timeout && (this._elementTimer = setTimeout(this._onTimeout, this.timeout));
    }
    _onError(p) {
      this.abort("Failed to load element using: " + p);
    }
    _onTimeout() {
      this.abort("Load timed out.");
    }
    _onComplete(p) {
      this.complete();
    }
    _determineLoadType() {
      return a.LOAD_TYPE_MAP[this.extension] || a.LOAD_TYPE.XHR;
    }
    _getExt() {
      var p = this.url, m = "";
      if (this.isDataUrl) {
        var y = p.indexOf("/");
        m = p.substring(y + 1, p.indexOf(";", y));
      } else {
        var x = p.indexOf("?"), g = p.indexOf("#"), _ = Math.min(x > -1 ? x : p.length, g > -1 ? g : p.length);
        p = p.substring(0, _), m = p.substring(p.lastIndexOf(".") + 1);
      }
      return m.toLowerCase();
    }
    static setExtensionLoadType(p, m) {
      d(a.LOAD_TYPE_MAP, p, m);
    }
    static setExtensionXhrType(p, m) {
      d(a.XHR_TYPE_MAP, p, m);
    }
  };
  Resource.default = c, c.TYPE = {
    UNKNOWN: 0,
    JSON: 1,
    XML: 2,
    IMAGE: 3,
    AUDIO: 4,
    VIDEO: 5,
    TEXT: 6
  };
  function d(f, p, m) {
    p && p.indexOf(".") === 0 && (p = p.substring(1)), p && (f[p] = m);
  }
  return Resource;
}
var hasRequiredLoader$1;
function requireLoader$1() {
  if (hasRequiredLoader$1) return Loader;
  hasRequiredLoader$1 = 1, Object.defineProperty(Loader, "__esModule", {
    value: true
  }), Loader.default = void 0;
  var i2 = u(require$$0), e = u(requireSrc()), t = s(requireAsync()), r = u(requireResource$1());
  function a(f) {
    if (typeof WeakMap != "function") return null;
    var p = /* @__PURE__ */ new WeakMap(), m = /* @__PURE__ */ new WeakMap();
    return (a = function(y) {
      return y ? m : p;
    })(f);
  }
  function s(f, p) {
    if (f && f.__esModule)
      return f;
    if (f === null || typeof f != "object" && typeof f != "function")
      return { default: f };
    var m = a(p);
    if (m && m.has(f))
      return m.get(f);
    var y = {}, x = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var g in f)
      if (g !== "default" && Object.prototype.hasOwnProperty.call(f, g)) {
        var _ = x ? Object.getOwnPropertyDescriptor(f, g) : null;
        _ && (_.get || _.set) ? Object.defineProperty(y, g, _) : y[g] = f[g];
      }
    return y.default = f, m && m.set(f, y), y;
  }
  function u(f) {
    return f && f.__esModule ? f : { default: f };
  }
  var l = 100, c = /(#[\w-]+)?$/;
  class d {
    constructor(p, m) {
      p === void 0 && (p = ""), m === void 0 && (m = 10), this.baseUrl = p, this.progress = 0, this.loading = false, this.defaultQueryString = "", this._beforeMiddleware = [], this._afterMiddleware = [], this._resourcesParsing = [], this._boundLoadResource = (g, _) => this._loadResource(g, _), this._queue = t.queue(this._boundLoadResource, m), this._queue.pause(), this.resources = {}, this.onProgress = new i2.default(), this.onError = new i2.default(), this.onLoad = new i2.default(), this.onStart = new i2.default(), this.onComplete = new i2.default();
      for (var y = 0; y < d._defaultBeforeMiddleware.length; ++y)
        this.pre(d._defaultBeforeMiddleware[y]);
      for (var x = 0; x < d._defaultAfterMiddleware.length; ++x)
        this.use(d._defaultAfterMiddleware[x]);
    }
    add(p, m, y, x) {
      if (Array.isArray(p)) {
        for (var g = 0; g < p.length; ++g)
          this.add(p[g]);
        return this;
      }
      if (typeof p == "object" && (x = m || p.callback || p.onComplete, y = p, m = p.url, p = p.name || p.key || p.url), !this.resources[p]) {
        if (typeof m != "string" && (x = y, y = m, m = p), typeof m != "string")
          throw new Error("No url passed to add resource to loader.");
        if (typeof y == "function" && (x = y, y = null), this.loading && (!y || !y.parentResource))
          throw new Error("Cannot add resources the loader is running.");
        if (m = this._prepareUrl(m), this.resources[p] = new r.default(p, m, y), typeof x == "function" && this.resources[p].onAfterMiddleware.once(x), this.loading) {
          for (var _ = y.parentResource, T = [], E = 0; E < _.children.length; ++E)
            _.children[E].isComplete || T.push(_.children[E]);
          var b = _.progressChunk * (T.length + 1), C = b / (T.length + 2);
          _.children.push(this.resources[p]), _.progressChunk = C;
          for (var w = 0; w < T.length; ++w)
            T[w].progressChunk = C;
          this.resources[p].progressChunk = C;
        }
        return this._queue.push(this.resources[p]), this;
      }
    }
    pre(p) {
      return this._beforeMiddleware.push(p), this;
    }
    use(p) {
      return this._afterMiddleware.push(p), this;
    }
    reset() {
      this.progress = 0, this.loading = false, this._queue.kill(), this._queue.pause();
      for (var p in this.resources) {
        var m = this.resources[p];
        m._onLoadBinding && m._onLoadBinding.detach(), m.isLoading && m.abort(), delete this.resources[p];
      }
      return this.resources = {}, this;
    }
    destroy() {
      this.progress = 0, this.loading = false, this._queue.kill(), this._queue.pause();
      for (var p in this.resources) {
        var m = this.resources[p];
        m.destroy && m.destroy(), delete this.resources[p];
      }
      this.baseUrl = "", this.defaultQueryString = "", this._beforeMiddleware = null, this._afterMiddleware = null, this._resourcesParsing = null, this._boundLoadResource = null, this._queue = null, this.resources = null, this.onProgress = null, this.onLoad = null, this.onError = null, this.onStart = null, this.onComplete = null;
    }
    loadAsync() {
      return new Promise((p, m) => {
        this.load(p);
      });
    }
    load(p) {
      if (typeof p == "function" && this.onComplete.once(p), this.loading) return this;
      if (this._queue.idle())
        this._onStart(), this._onComplete();
      else {
        for (var m = this._queue._tasks.length, y = l / m, x = 0; x < this._queue._tasks.length; ++x)
          this._queue._tasks[x].data.progressChunk = y;
        this._onStart(), this._queue.resume();
      }
      return this;
    }
    get concurrency() {
      return this._queue.concurrency;
    }
    set concurrency(p) {
      this._queue.concurrency = p;
    }
    _prepareUrl(p) {
      var m = (0, e.default)(p, {
        strictMode: true
      }), y;
      if (m.protocol || !m.path || p.indexOf("//") === 0 ? y = p : this.baseUrl.length && this.baseUrl.lastIndexOf("/") !== this.baseUrl.length - 1 && p.charAt(0) !== "/" ? y = this.baseUrl + "/" + p : y = this.baseUrl + p, this.defaultQueryString) {
        var x = c.exec(y)[0];
        y = y.substr(0, y.length - x.length), y.indexOf("?") !== -1 ? y += "&" + this.defaultQueryString : y += "?" + this.defaultQueryString, y += x;
      }
      return y;
    }
    _loadResource(p, m) {
      p._dequeue = m, t.eachSeries(this._beforeMiddleware, (y, x) => {
        y.call(this, p, () => {
          x(p.isComplete ? {} : null);
        });
      }, () => {
        p.isComplete ? this._onLoad(p) : (p._onLoadBinding = p.onComplete.once(this._onLoad, this), p.load());
      }, true);
    }
    _onStart() {
      this.progress = 0, this.loading = true, this.onStart.dispatch(this);
    }
    _onComplete() {
      this.progress = l, this.loading = false, this.onComplete.dispatch(this, this.resources);
    }
    _onLoad(p) {
      p._onLoadBinding = null, this._resourcesParsing.push(p), p._dequeue(), t.eachSeries(this._afterMiddleware, (m, y) => {
        m.call(this, p, y);
      }, () => {
        p.onAfterMiddleware.dispatch(p), this.progress = Math.min(l, this.progress + p.progressChunk), this.onProgress.dispatch(this, p), p.error ? this.onError.dispatch(p.error, this, p) : this.onLoad.dispatch(this, p), this._resourcesParsing.splice(this._resourcesParsing.indexOf(p), 1), this._queue.idle() && this._resourcesParsing.length === 0 && this._onComplete();
      }, true);
    }
  }
  return Loader.default = d, d._defaultBeforeMiddleware = [], d._defaultAfterMiddleware = [], d.pre = function(f) {
    return d._defaultBeforeMiddleware.push(f), d;
  }, d.use = function(f) {
    return d._defaultAfterMiddleware.push(f), d;
  }, Loader;
}
var hasRequiredResource;
function requireResource() {
  return hasRequiredResource || (hasRequiredResource = 1, function(i2) {
    Object.defineProperty(i2, "__esModule", {
      value: true
    }), Object.defineProperty(i2, "Resource", {
      enumerable: true,
      get: function() {
        return a.default;
      }
    }), Object.defineProperty(i2, "ResourceLoader", {
      enumerable: true,
      get: function() {
        return r.default;
      }
    });
    var e = s(requireB64()), t = s(requireAsync()), r = s(requireLoader$1()), a = s(requireResource$1());
    function s(u) {
      return u && u.__esModule ? u : { default: u };
    }
    r.default.base64 = e.default, r.default.async = t.default, r.default.encodeBinary = e.default, r.default.Resource = a.default;
  }(resource)), resource;
}
var hasRequiredTextureParser;
function requireTextureParser() {
  if (hasRequiredTextureParser) return textureParser;
  hasRequiredTextureParser = 1, Object.defineProperty(textureParser, "__esModule", {
    value: true
  }), textureParser.default = r;
  var i2 = requireResource(), e = t(requireTexture$1());
  function t(a) {
    return a && a.__esModule ? a : { default: a };
  }
  function r() {
    return function(a, s) {
      a.data && a.type === i2.Resource.TYPE.IMAGE && (a.texture = e.default.fromLoader(a.data, a.url, a.name)), s();
    };
  }
  return textureParser;
}
var spritesheetParser = {}, url = {}, punycode$1 = { exports: {} };
/*! https://mths.be/punycode v1.4.1 by @mathias */
var punycode = punycode$1.exports, hasRequiredPunycode;
function requirePunycode() {
  return hasRequiredPunycode || (hasRequiredPunycode = 1, function(i2, e) {
    (function(t) {
      var r = e && !e.nodeType && e, a = !i2.nodeType && i2, s = typeof window == "object" && window;
      (s.global === s || s.window === s || s.self === s) && (t = s);
      var u, l = 2147483647, c = 36, d = 1, f = 26, p = 38, m = 700, y = 72, x = 128, g = "-", _ = /^xn--/, T = /[^\x20-\x7E]/, E = /[\x2E\u3002\uFF0E\uFF61]/g, b = {
        overflow: "Overflow: input needs wider integers to process",
        "not-basic": "Illegal input >= 0x80 (not a basic code point)",
        "invalid-input": "Invalid input"
      }, C = c - d, w = Math.floor, A = String.fromCharCode, S;
      function F(W) {
        throw new RangeError(b[W]);
      }
      function M(W, V) {
        for (var K = W.length, J = []; K--; )
          J[K] = V(W[K]);
        return J;
      }
      function U(W, V) {
        var K = W.split("@"), J = "";
        K.length > 1 && (J = K[0] + "@", W = K[1]), W = W.replace(E, ".");
        var ae = W.split("."), re = M(ae, V).join(".");
        return J + re;
      }
      function B(W) {
        for (var V = [], K = 0, J = W.length, ae, re; K < J; )
          ae = W.charCodeAt(K++), ae >= 55296 && ae <= 56319 && K < J ? (re = W.charCodeAt(K++), (re & 64512) == 56320 ? V.push(((ae & 1023) << 10) + (re & 1023) + 65536) : (V.push(ae), K--)) : V.push(ae);
        return V;
      }
      function q(W) {
        return M(W, function(V) {
          var K = "";
          return V > 65535 && (V -= 65536, K += A(V >>> 10 & 1023 | 55296), V = 56320 | V & 1023), K += A(V), K;
        }).join("");
      }
      function z(W) {
        return W - 48 < 10 ? W - 22 : W - 65 < 26 ? W - 65 : W - 97 < 26 ? W - 97 : c;
      }
      function D(W, V) {
        return W + 22 + 75 * (W < 26) - ((V != 0) << 5);
      }
      function X(W, V, K) {
        var J = 0;
        for (W = K ? w(W / m) : W >> 1, W += w(W / V); W > C * f >> 1; J += c)
          W = w(W / C);
        return w(J + (C + 1) * W / (W + p));
      }
      function k(W) {
        var V = [], K = W.length, J, ae = 0, re = x, he = y, ge, me, Te, _e, ye, Ae, ke, Pe, Ee;
        for (ge = W.lastIndexOf(g), ge < 0 && (ge = 0), me = 0; me < ge; ++me)
          W.charCodeAt(me) >= 128 && F("not-basic"), V.push(W.charCodeAt(me));
        for (Te = ge > 0 ? ge + 1 : 0; Te < K; ) {
          for (_e = ae, ye = 1, Ae = c; Te >= K && F("invalid-input"), ke = z(W.charCodeAt(Te++)), (ke >= c || ke > w((l - ae) / ye)) && F("overflow"), ae += ke * ye, Pe = Ae <= he ? d : Ae >= he + f ? f : Ae - he, !(ke < Pe); Ae += c)
            Ee = c - Pe, ye > w(l / Ee) && F("overflow"), ye *= Ee;
          J = V.length + 1, he = X(ae - _e, J, _e == 0), w(ae / J) > l - re && F("overflow"), re += w(ae / J), ae %= J, V.splice(ae++, 0, re);
        }
        return q(V);
      }
      function I(W) {
        var V, K, J, ae, re, he, ge, me, Te, _e, ye, Ae = [], ke, Pe, Ee, Oe;
        for (W = B(W), ke = W.length, V = x, K = 0, re = y, he = 0; he < ke; ++he)
          ye = W[he], ye < 128 && Ae.push(A(ye));
        for (J = ae = Ae.length, ae && Ae.push(g); J < ke; ) {
          for (ge = l, he = 0; he < ke; ++he)
            ye = W[he], ye >= V && ye < ge && (ge = ye);
          for (Pe = J + 1, ge - V > w((l - K) / Pe) && F("overflow"), K += (ge - V) * Pe, V = ge, he = 0; he < ke; ++he)
            if (ye = W[he], ye < V && ++K > l && F("overflow"), ye == V) {
              for (me = K, Te = c; _e = Te <= re ? d : Te >= re + f ? f : Te - re, !(me < _e); Te += c)
                Oe = me - _e, Ee = c - _e, Ae.push(
                  A(D(_e + Oe % Ee, 0))
                ), me = w(Oe / Ee);
              Ae.push(A(D(me, 0))), re = X(K, Pe, J == ae), K = 0, ++J;
            }
          ++K, ++V;
        }
        return Ae.join("");
      }
      function P(W) {
        return U(W, function(V) {
          return _.test(V) ? k(V.slice(4).toLowerCase()) : V;
        });
      }
      function G(W) {
        return U(W, function(V) {
          return T.test(V) ? "xn--" + I(V) : V;
        });
      }
      if (u = {
        /**
         * A string representing the current Punycode.js version number.
         * @memberOf punycode
         * @type String
         */
        version: "1.4.1",
        /**
         * An object of methods to convert from JavaScript's internal character
         * representation (UCS-2) to Unicode code points, and back.
         * @see <https://mathiasbynens.be/notes/javascript-encoding>
         * @memberOf punycode
         * @type Object
         */
        ucs2: {
          decode: B,
          encode: q
        },
        decode: k,
        encode: I,
        toASCII: G,
        toUnicode: P
      }, r && a)
        if (i2.exports == r)
          a.exports = u;
        else
          for (S in u)
            u.hasOwnProperty(S) && (r[S] = u[S]);
      else
        t.punycode = u;
    })(punycode);
  }(punycode$1, punycode$1.exports)), punycode$1.exports;
}
var hasRequiredUrl;
function requireUrl() {
  if (hasRequiredUrl) return url;
  hasRequiredUrl = 1;
  var i2 = requirePunycode();
  function e() {
    this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null;
  }
  var t = /^([a-z0-9.+-]+:)/i, r = /:[0-9]*$/, a = /^(\/\/?(?!\/)[^?\s]*)(\?[^\s]*)?$/, s = [
    "<",
    ">",
    '"',
    "`",
    " ",
    "\r",
    `
`,
    "	"
  ], u = [
    "{",
    "}",
    "|",
    "\\",
    "^",
    "`"
  ].concat(s), l = ["'"].concat(u), c = [
    "%",
    "/",
    "?",
    ";",
    "#"
  ].concat(l), d = [
    "/",
    "?",
    "#"
  ], f = 255, p = /^[+a-z0-9A-Z_-]{0,63}$/, m = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, y = {
    javascript: true,
    "javascript:": true
  }, x = {
    javascript: true,
    "javascript:": true
  }, g = {
    http: true,
    https: true,
    ftp: true,
    gopher: true,
    file: true,
    "http:": true,
    "https:": true,
    "ftp:": true,
    "gopher:": true,
    "file:": true
  }, _ = /* @__PURE__ */ requireLib$3();
  function T(w, A, S) {
    if (w && typeof w == "object" && w instanceof e)
      return w;
    var F = new e();
    return F.parse(w, A, S), F;
  }
  e.prototype.parse = function(w, A, S) {
    if (typeof w != "string")
      throw new TypeError("Parameter 'url' must be a string, not " + typeof w);
    var F = w.indexOf("?"), M = F !== -1 && F < w.indexOf("#") ? "?" : "#", U = w.split(M), B = /\\/g;
    U[0] = U[0].replace(B, "/"), w = U.join(M);
    var q = w;
    if (q = q.trim(), !S && w.split("#").length === 1) {
      var z = a.exec(q);
      if (z)
        return this.path = q, this.href = q, this.pathname = z[1], z[2] ? (this.search = z[2], A ? this.query = _.parse(this.search.substr(1)) : this.query = this.search.substr(1)) : A && (this.search = "", this.query = {}), this;
    }
    var D = t.exec(q);
    if (D) {
      D = D[0];
      var X = D.toLowerCase();
      this.protocol = X, q = q.substr(D.length);
    }
    if (S || D || q.match(/^\/\/[^@/]+@[^@/]+/)) {
      var k = q.substr(0, 2) === "//";
      k && !(D && x[D]) && (q = q.substr(2), this.slashes = true);
    }
    if (!x[D] && (k || D && !g[D])) {
      for (var I = -1, P = 0; P < d.length; P++) {
        var G = q.indexOf(d[P]);
        G !== -1 && (I === -1 || G < I) && (I = G);
      }
      var W, V;
      I === -1 ? V = q.lastIndexOf("@") : V = q.lastIndexOf("@", I), V !== -1 && (W = q.slice(0, V), q = q.slice(V + 1), this.auth = decodeURIComponent(W)), I = -1;
      for (var P = 0; P < c.length; P++) {
        var G = q.indexOf(c[P]);
        G !== -1 && (I === -1 || G < I) && (I = G);
      }
      I === -1 && (I = q.length), this.host = q.slice(0, I), q = q.slice(I), this.parseHost(), this.hostname = this.hostname || "";
      var K = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
      if (!K)
        for (var J = this.hostname.split(/\./), P = 0, ae = J.length; P < ae; P++) {
          var re = J[P];
          if (re && !re.match(p)) {
            for (var he = "", ge = 0, me = re.length; ge < me; ge++)
              re.charCodeAt(ge) > 127 ? he += "x" : he += re[ge];
            if (!he.match(p)) {
              var Te = J.slice(0, P), _e = J.slice(P + 1), ye = re.match(m);
              ye && (Te.push(ye[1]), _e.unshift(ye[2])), _e.length && (q = "/" + _e.join(".") + q), this.hostname = Te.join(".");
              break;
            }
          }
        }
      this.hostname.length > f ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(), K || (this.hostname = i2.toASCII(this.hostname));
      var Ae = this.port ? ":" + this.port : "", ke = this.hostname || "";
      this.host = ke + Ae, this.href += this.host, K && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), q[0] !== "/" && (q = "/" + q));
    }
    if (!y[X])
      for (var P = 0, ae = l.length; P < ae; P++) {
        var Pe = l[P];
        if (q.indexOf(Pe) !== -1) {
          var Ee = encodeURIComponent(Pe);
          Ee === Pe && (Ee = escape(Pe)), q = q.split(Pe).join(Ee);
        }
      }
    var Oe = q.indexOf("#");
    Oe !== -1 && (this.hash = q.substr(Oe), q = q.slice(0, Oe));
    var $e = q.indexOf("?");
    if ($e !== -1 ? (this.search = q.substr($e), this.query = q.substr($e + 1), A && (this.query = _.parse(this.query)), q = q.slice(0, $e)) : A && (this.search = "", this.query = {}), q && (this.pathname = q), g[X] && this.hostname && !this.pathname && (this.pathname = "/"), this.pathname || this.search) {
      var Ae = this.pathname || "", gt = this.search || "";
      this.path = Ae + gt;
    }
    return this.href = this.format(), this;
  };
  function E(w) {
    return typeof w == "string" && (w = T(w)), w instanceof e ? w.format() : e.prototype.format.call(w);
  }
  e.prototype.format = function() {
    var w = this.auth || "";
    w && (w = encodeURIComponent(w), w = w.replace(/%3A/i, ":"), w += "@");
    var A = this.protocol || "", S = this.pathname || "", F = this.hash || "", M = false, U = "";
    this.host ? M = w + this.host : this.hostname && (M = w + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]"), this.port && (M += ":" + this.port)), this.query && typeof this.query == "object" && Object.keys(this.query).length && (U = _.stringify(this.query, {
      arrayFormat: "repeat",
      addQueryPrefix: false
    }));
    var B = this.search || U && "?" + U || "";
    return A && A.substr(-1) !== ":" && (A += ":"), this.slashes || (!A || g[A]) && M !== false ? (M = "//" + (M || ""), S && S.charAt(0) !== "/" && (S = "/" + S)) : M || (M = ""), F && F.charAt(0) !== "#" && (F = "#" + F), B && B.charAt(0) !== "?" && (B = "?" + B), S = S.replace(/[?#]/g, function(q) {
      return encodeURIComponent(q);
    }), B = B.replace("#", "%23"), A + M + S + B + F;
  };
  function b(w, A) {
    return T(w, false, true).resolve(A);
  }
  e.prototype.resolve = function(w) {
    return this.resolveObject(T(w, false, true)).format();
  };
  function C(w, A) {
    return w ? T(w, false, true).resolveObject(A) : A;
  }
  return e.prototype.resolveObject = function(w) {
    if (typeof w == "string") {
      var A = new e();
      A.parse(w, false, true), w = A;
    }
    for (var S = new e(), F = Object.keys(this), M = 0; M < F.length; M++) {
      var U = F[M];
      S[U] = this[U];
    }
    if (S.hash = w.hash, w.href === "")
      return S.href = S.format(), S;
    if (w.slashes && !w.protocol) {
      for (var B = Object.keys(w), q = 0; q < B.length; q++) {
        var z = B[q];
        z !== "protocol" && (S[z] = w[z]);
      }
      return g[S.protocol] && S.hostname && !S.pathname && (S.pathname = "/", S.path = S.pathname), S.href = S.format(), S;
    }
    if (w.protocol && w.protocol !== S.protocol) {
      if (!g[w.protocol]) {
        for (var D = Object.keys(w), X = 0; X < D.length; X++) {
          var k = D[X];
          S[k] = w[k];
        }
        return S.href = S.format(), S;
      }
      if (S.protocol = w.protocol, !w.host && !x[w.protocol]) {
        for (var ae = (w.pathname || "").split("/"); ae.length && !(w.host = ae.shift()); )
          ;
        w.host || (w.host = ""), w.hostname || (w.hostname = ""), ae[0] !== "" && ae.unshift(""), ae.length < 2 && ae.unshift(""), S.pathname = ae.join("/");
      } else
        S.pathname = w.pathname;
      if (S.search = w.search, S.query = w.query, S.host = w.host || "", S.auth = w.auth, S.hostname = w.hostname || w.host, S.port = w.port, S.pathname || S.search) {
        var I = S.pathname || "", P = S.search || "";
        S.path = I + P;
      }
      return S.slashes = S.slashes || w.slashes, S.href = S.format(), S;
    }
    var G = S.pathname && S.pathname.charAt(0) === "/", W = w.host || w.pathname && w.pathname.charAt(0) === "/", V = W || G || S.host && w.pathname, K = V, J = S.pathname && S.pathname.split("/") || [], ae = w.pathname && w.pathname.split("/") || [], re = S.protocol && !g[S.protocol];
    if (re && (S.hostname = "", S.port = null, S.host && (J[0] === "" ? J[0] = S.host : J.unshift(S.host)), S.host = "", w.protocol && (w.hostname = null, w.port = null, w.host && (ae[0] === "" ? ae[0] = w.host : ae.unshift(w.host)), w.host = null), V = V && (ae[0] === "" || J[0] === "")), W)
      S.host = w.host || w.host === "" ? w.host : S.host, S.hostname = w.hostname || w.hostname === "" ? w.hostname : S.hostname, S.search = w.search, S.query = w.query, J = ae;
    else if (ae.length)
      J || (J = []), J.pop(), J = J.concat(ae), S.search = w.search, S.query = w.query;
    else if (w.search != null) {
      if (re) {
        S.host = J.shift(), S.hostname = S.host;
        var he = S.host && S.host.indexOf("@") > 0 ? S.host.split("@") : false;
        he && (S.auth = he.shift(), S.hostname = he.shift(), S.host = S.hostname);
      }
      return S.search = w.search, S.query = w.query, (S.pathname !== null || S.search !== null) && (S.path = (S.pathname ? S.pathname : "") + (S.search ? S.search : "")), S.href = S.format(), S;
    }
    if (!J.length)
      return S.pathname = null, S.search ? S.path = "/" + S.search : S.path = null, S.href = S.format(), S;
    for (var ge = J.slice(-1)[0], me = (S.host || w.host || J.length > 1) && (ge === "." || ge === "..") || ge === "", Te = 0, _e = J.length; _e >= 0; _e--)
      ge = J[_e], ge === "." ? J.splice(_e, 1) : ge === ".." ? (J.splice(_e, 1), Te++) : Te && (J.splice(_e, 1), Te--);
    if (!V && !K)
      for (; Te--; Te)
        J.unshift("..");
    V && J[0] !== "" && (!J[0] || J[0].charAt(0) !== "/") && J.unshift(""), me && J.join("/").substr(-1) !== "/" && J.push("");
    var ye = J[0] === "" || J[0] && J[0].charAt(0) === "/";
    if (re) {
      S.hostname = ye ? "" : J.length ? J.shift() : "", S.host = S.hostname;
      var he = S.host && S.host.indexOf("@") > 0 ? S.host.split("@") : false;
      he && (S.auth = he.shift(), S.hostname = he.shift(), S.host = S.hostname);
    }
    return V = V || S.host && J.length, V && !ye && J.unshift(""), J.length > 0 ? S.pathname = J.join("/") : (S.pathname = null, S.path = null), (S.pathname !== null || S.search !== null) && (S.path = (S.pathname ? S.pathname : "") + (S.search ? S.search : "")), S.auth = w.auth || S.auth, S.slashes = S.slashes || w.slashes, S.href = S.format(), S;
  }, e.prototype.parseHost = function() {
    var w = this.host, A = r.exec(w);
    A && (A = A[0], A !== ":" && (this.port = A.substr(1)), w = w.substr(0, w.length - A.length)), w && (this.hostname = w);
  }, url.parse = T, url.resolve = b, url.resolveObject = C, url.format = E, url.Url = e, url;
}
var hasRequiredSpritesheetParser;
function requireSpritesheetParser() {
  if (hasRequiredSpritesheetParser) return spritesheetParser;
  hasRequiredSpritesheetParser = 1, Object.defineProperty(spritesheetParser, "__esModule", {
    value: true
  }), spritesheetParser.default = a, spritesheetParser.getResourcePath = s;
  var i2 = r(requireUrl()), e = requireResource(), t = r(requireSpritesheet());
  function r(u) {
    return u && u.__esModule ? u : { default: u };
  }
  function a() {
    return function(u, l) {
      var c = u.name + "_image";
      if (!u.data || u.type !== e.Resource.TYPE.JSON || !u.data.frames || this.resources[c]) {
        l();
        return;
      }
      var d = {
        crossOrigin: u.crossOrigin,
        metadata: u.metadata.imageMetadata,
        parentResource: u
      }, f = s(u, this.baseUrl);
      this.add(c, f, d, function(p) {
        if (p.error) {
          l(p.error);
          return;
        }
        var m = new t.default(p.texture.baseTexture, u.data, u.url);
        m.parse(() => {
          u.spritesheet = m, u.textures = m.textures, l();
        });
      });
    };
  }
  function s(u, l) {
    return u.isDataUrl ? u.data.meta.image : i2.default.resolve(u.url.replace(l, ""), u.data.meta.image);
  }
  return spritesheetParser;
}
var hasRequiredLoader;
function requireLoader() {
  if (hasRequiredLoader) return loader;
  hasRequiredLoader = 1, Object.defineProperty(loader, "__esModule", {
    value: true
  }), loader.default = void 0;
  var i2 = s(requireEventemitter3$1()), e = s(requireTextureParser()), t = requireUtils$3(), r = requireResource(), a = s(requireSpritesheetParser());
  function s(l) {
    return l && l.__esModule ? l : { default: l };
  }
  class u extends r.ResourceLoader {
    constructor(c, d) {
      super(c, d), i2.default.call(this);
      for (var f = 0; f < u._pixiMiddleware.length; ++f)
        this.use(u._pixiMiddleware[f]());
      this.onStart.add((p) => this.emit("start", p)), this.onLoad.add((p, m) => this.emit("load", p, m)), this.onProgress.add((p, m) => this.emit("progress", p, m)), this.onError.add((p, m, y) => this.emit("error", p, m, y)), this.onComplete.add((p, m) => this.emit("complete", p, m));
    }
    static addPixiMiddleware(c) {
      u._pixiMiddleware.push(c);
    }
    destroy() {
      this.removeAllListeners(), super.destroy();
    }
  }
  return loader.default = u, (0, t.inherit)(u, i2.default), u._pixiMiddleware = [e.default, a.default], loader;
}
var hasRequiredLoaders;
function requireLoaders() {
  return hasRequiredLoaders || (hasRequiredLoaders = 1, function(i2) {
    Object.defineProperty(i2, "__esModule", {
      value: true
    }), Object.defineProperty(i2, "Loader", {
      enumerable: true,
      get: function() {
        return e.default;
      }
    }), Object.defineProperty(i2, "Resource", {
      enumerable: true,
      get: function() {
        return t.Resource;
      }
    }), Object.defineProperty(i2, "getResourcePath", {
      enumerable: true,
      get: function() {
        return r.getResourcePath;
      }
    }), i2.shared = i2.loader = void 0, Object.defineProperty(i2, "spritesheetParser", {
      enumerable: true,
      get: function() {
        return r.default;
      }
    }), Object.defineProperty(i2, "textureParser", {
      enumerable: true,
      get: function() {
        return a.default;
      }
    });
    var e = l(requireLoader()), t = requireResource(), r = u(requireSpritesheetParser()), a = l(requireTextureParser());
    function s(f) {
      if (typeof WeakMap != "function") return null;
      var p = /* @__PURE__ */ new WeakMap(), m = /* @__PURE__ */ new WeakMap();
      return (s = function(y) {
        return y ? m : p;
      })(f);
    }
    function u(f, p) {
      if (f && f.__esModule)
        return f;
      if (f === null || typeof f != "object" && typeof f != "function")
        return { default: f };
      var m = s(p);
      if (m && m.has(f))
        return m.get(f);
      var y = {}, x = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var g in f)
        if (g !== "default" && Object.prototype.hasOwnProperty.call(f, g)) {
          var _ = x ? Object.getOwnPropertyDescriptor(f, g) : null;
          _ && (_.get || _.set) ? Object.defineProperty(y, g, _) : y[g] = f[g];
        }
      return y.default = f, m && m.set(f, y), y;
    }
    function l(f) {
      return f && f.__esModule ? f : { default: f };
    }
    var c = new e.default();
    i2.shared = c, c.destroy = () => {
    };
    var d = c || null;
    i2.loader = d;
  }(loaders)), loaders;
}
var hasRequiredLib$2;
function requireLib$2() {
  return hasRequiredLib$2 || (hasRequiredLib$2 = 1, function(i2) {
    Object.defineProperty(i2, "__esModule", {
      value: true
    });
    var e = {
      settings: true,
      utils: true,
      ticker: true,
      Ticker: true,
      CanvasRenderer: true,
      WebGLRenderer: true,
      Bounds: true,
      ProxyObj: true,
      DisplayObject: true,
      Container: true,
      Transform: true,
      TransformStatic: true,
      Sprite: true,
      AnimatedSprite: true,
      CanvasSpriteRenderer: true,
      CanvasTinter: true,
      SpriteRenderer: true,
      Text: true,
      TextStyle: true,
      TextMetrics: true,
      Graphics: true,
      GraphicsRenderer: true,
      Texture: true,
      TextureMatrix: true,
      BaseTexture: true,
      Shader: true,
      Spritesheet: true,
      WebGLManager: true,
      ObjectRenderer: true,
      Quad: true,
      SpriteMaskFilter: true,
      Filter: true,
      RenderTexture: true,
      BaseRenderTexture: true,
      Rectangle: true,
      Application: true,
      filters: true,
      loader: true,
      Loader: true,
      Resource: true,
      gl: true,
      Canvas: true,
      Context2d: true,
      CanvasRenderingContext2D: true,
      CanvasGradient: true,
      CanvasPattern: true,
      Image: true,
      ImageData: true,
      PNGStream: true,
      PDFStream: true,
      JPEGStream: true,
      DOMMatrix: true,
      DOMPoint: true,
      registerFont: true,
      deregisterAllFonts: true,
      parseFont: true,
      createCanvas: true,
      createImageData: true,
      loadImage: true,
      TextureCache: true,
      BaseTextureCache: true,
      addToTextureCache: true,
      removeFromTextureCache: true,
      removeFromBaseTextureCache: true,
      addToBaseTextureCache: true,
      destroyAllTextureCache: true,
      deleteAllTextureCache: true,
      destroyAndCleanAllCache: true
    };
    Object.defineProperty(i2, "AnimatedSprite", {
      enumerable: true,
      get: function() {
        return t.AnimatedSprite;
      }
    }), Object.defineProperty(i2, "Application", {
      enumerable: true,
      get: function() {
        return t.Application;
      }
    }), Object.defineProperty(i2, "BaseRenderTexture", {
      enumerable: true,
      get: function() {
        return t.BaseRenderTexture;
      }
    }), Object.defineProperty(i2, "BaseTexture", {
      enumerable: true,
      get: function() {
        return t.BaseTexture;
      }
    }), Object.defineProperty(i2, "BaseTextureCache", {
      enumerable: true,
      get: function() {
        return c.BaseTextureCache;
      }
    }), Object.defineProperty(i2, "Bounds", {
      enumerable: true,
      get: function() {
        return t.Bounds;
      }
    }), Object.defineProperty(i2, "Canvas", {
      enumerable: true,
      get: function() {
        return s.Canvas;
      }
    }), Object.defineProperty(i2, "CanvasGradient", {
      enumerable: true,
      get: function() {
        return s.CanvasGradient;
      }
    }), Object.defineProperty(i2, "CanvasPattern", {
      enumerable: true,
      get: function() {
        return s.CanvasPattern;
      }
    }), Object.defineProperty(i2, "CanvasRenderer", {
      enumerable: true,
      get: function() {
        return t.CanvasRenderer;
      }
    }), Object.defineProperty(i2, "CanvasRenderingContext2D", {
      enumerable: true,
      get: function() {
        return s.CanvasRenderingContext2D;
      }
    }), Object.defineProperty(i2, "CanvasSpriteRenderer", {
      enumerable: true,
      get: function() {
        return t.CanvasSpriteRenderer;
      }
    }), Object.defineProperty(i2, "CanvasTinter", {
      enumerable: true,
      get: function() {
        return t.CanvasTinter;
      }
    }), Object.defineProperty(i2, "Container", {
      enumerable: true,
      get: function() {
        return t.Container;
      }
    }), Object.defineProperty(i2, "Context2d", {
      enumerable: true,
      get: function() {
        return s.Context2d;
      }
    }), Object.defineProperty(i2, "DOMMatrix", {
      enumerable: true,
      get: function() {
        return s.DOMMatrix;
      }
    }), Object.defineProperty(i2, "DOMPoint", {
      enumerable: true,
      get: function() {
        return s.DOMPoint;
      }
    }), Object.defineProperty(i2, "DisplayObject", {
      enumerable: true,
      get: function() {
        return t.DisplayObject;
      }
    }), Object.defineProperty(i2, "Filter", {
      enumerable: true,
      get: function() {
        return t.Filter;
      }
    }), Object.defineProperty(i2, "Graphics", {
      enumerable: true,
      get: function() {
        return t.Graphics;
      }
    }), Object.defineProperty(i2, "GraphicsRenderer", {
      enumerable: true,
      get: function() {
        return t.GraphicsRenderer;
      }
    }), Object.defineProperty(i2, "Image", {
      enumerable: true,
      get: function() {
        return s.Image;
      }
    }), Object.defineProperty(i2, "ImageData", {
      enumerable: true,
      get: function() {
        return s.ImageData;
      }
    }), Object.defineProperty(i2, "JPEGStream", {
      enumerable: true,
      get: function() {
        return s.JPEGStream;
      }
    }), Object.defineProperty(i2, "Loader", {
      enumerable: true,
      get: function() {
        return a.Loader;
      }
    }), Object.defineProperty(i2, "ObjectRenderer", {
      enumerable: true,
      get: function() {
        return t.ObjectRenderer;
      }
    }), Object.defineProperty(i2, "PDFStream", {
      enumerable: true,
      get: function() {
        return s.PDFStream;
      }
    }), Object.defineProperty(i2, "PNGStream", {
      enumerable: true,
      get: function() {
        return s.PNGStream;
      }
    }), Object.defineProperty(i2, "ProxyObj", {
      enumerable: true,
      get: function() {
        return t.ProxyObj;
      }
    }), Object.defineProperty(i2, "Quad", {
      enumerable: true,
      get: function() {
        return t.Quad;
      }
    }), Object.defineProperty(i2, "Rectangle", {
      enumerable: true,
      get: function() {
        return t.Rectangle;
      }
    }), Object.defineProperty(i2, "RenderTexture", {
      enumerable: true,
      get: function() {
        return t.RenderTexture;
      }
    }), Object.defineProperty(i2, "Resource", {
      enumerable: true,
      get: function() {
        return a.Resource;
      }
    }), Object.defineProperty(i2, "Shader", {
      enumerable: true,
      get: function() {
        return t.Shader;
      }
    }), Object.defineProperty(i2, "Sprite", {
      enumerable: true,
      get: function() {
        return t.Sprite;
      }
    }), Object.defineProperty(i2, "SpriteMaskFilter", {
      enumerable: true,
      get: function() {
        return t.SpriteMaskFilter;
      }
    }), Object.defineProperty(i2, "SpriteRenderer", {
      enumerable: true,
      get: function() {
        return t.SpriteRenderer;
      }
    }), Object.defineProperty(i2, "Spritesheet", {
      enumerable: true,
      get: function() {
        return t.Spritesheet;
      }
    }), Object.defineProperty(i2, "Text", {
      enumerable: true,
      get: function() {
        return t.Text;
      }
    }), Object.defineProperty(i2, "TextMetrics", {
      enumerable: true,
      get: function() {
        return t.TextMetrics;
      }
    }), Object.defineProperty(i2, "TextStyle", {
      enumerable: true,
      get: function() {
        return t.TextStyle;
      }
    }), Object.defineProperty(i2, "Texture", {
      enumerable: true,
      get: function() {
        return t.Texture;
      }
    }), Object.defineProperty(i2, "TextureCache", {
      enumerable: true,
      get: function() {
        return c.TextureCache;
      }
    }), Object.defineProperty(i2, "TextureMatrix", {
      enumerable: true,
      get: function() {
        return t.TextureMatrix;
      }
    }), Object.defineProperty(i2, "Ticker", {
      enumerable: true,
      get: function() {
        return t.Ticker;
      }
    }), Object.defineProperty(i2, "Transform", {
      enumerable: true,
      get: function() {
        return t.Transform;
      }
    }), Object.defineProperty(i2, "TransformStatic", {
      enumerable: true,
      get: function() {
        return t.TransformStatic;
      }
    }), Object.defineProperty(i2, "WebGLManager", {
      enumerable: true,
      get: function() {
        return t.WebGLManager;
      }
    }), Object.defineProperty(i2, "WebGLRenderer", {
      enumerable: true,
      get: function() {
        return t.WebGLRenderer;
      }
    }), Object.defineProperty(i2, "addToBaseTextureCache", {
      enumerable: true,
      get: function() {
        return c.addToBaseTextureCache;
      }
    }), Object.defineProperty(i2, "addToTextureCache", {
      enumerable: true,
      get: function() {
        return c.addToTextureCache;
      }
    }), Object.defineProperty(i2, "createCanvas", {
      enumerable: true,
      get: function() {
        return s.createCanvas;
      }
    }), Object.defineProperty(i2, "createImageData", {
      enumerable: true,
      get: function() {
        return s.createImageData;
      }
    }), Object.defineProperty(i2, "deleteAllTextureCache", {
      enumerable: true,
      get: function() {
        return c.deleteAllTextureCache;
      }
    }), Object.defineProperty(i2, "deregisterAllFonts", {
      enumerable: true,
      get: function() {
        return s.deregisterAllFonts;
      }
    }), Object.defineProperty(i2, "destroyAllTextureCache", {
      enumerable: true,
      get: function() {
        return c.destroyAllTextureCache;
      }
    }), Object.defineProperty(i2, "destroyAndCleanAllCache", {
      enumerable: true,
      get: function() {
        return c.destroyAndCleanAllCache;
      }
    }), i2.filters = void 0, Object.defineProperty(i2, "gl", {
      enumerable: true,
      get: function() {
        return s.gl;
      }
    }), Object.defineProperty(i2, "loadImage", {
      enumerable: true,
      get: function() {
        return s.loadImage;
      }
    }), Object.defineProperty(i2, "loader", {
      enumerable: true,
      get: function() {
        return a.loader;
      }
    }), Object.defineProperty(i2, "parseFont", {
      enumerable: true,
      get: function() {
        return s.parseFont;
      }
    }), Object.defineProperty(i2, "registerFont", {
      enumerable: true,
      get: function() {
        return s.registerFont;
      }
    }), Object.defineProperty(i2, "removeFromBaseTextureCache", {
      enumerable: true,
      get: function() {
        return c.removeFromBaseTextureCache;
      }
    }), Object.defineProperty(i2, "removeFromTextureCache", {
      enumerable: true,
      get: function() {
        return c.removeFromTextureCache;
      }
    }), Object.defineProperty(i2, "settings", {
      enumerable: true,
      get: function() {
        return t.settings;
      }
    }), Object.defineProperty(i2, "ticker", {
      enumerable: true,
      get: function() {
        return t.ticker;
      }
    }), Object.defineProperty(i2, "utils", {
      enumerable: true,
      get: function() {
        return t.utils;
      }
    }), requireRequestAnimationFrame();
    var t = requireCore(), r = f(requireFilters());
    i2.filters = r;
    var a = requireLoaders(), s = requireCanvasGl(), u = require_const();
    Object.keys(u).forEach(function(p) {
      p === "default" || p === "__esModule" || Object.prototype.hasOwnProperty.call(e, p) || p in i2 && i2[p] === u[p] || Object.defineProperty(i2, p, {
        enumerable: true,
        get: function() {
          return u[p];
        }
      });
    });
    var l = requireMath$1();
    Object.keys(l).forEach(function(p) {
      p === "default" || p === "__esModule" || Object.prototype.hasOwnProperty.call(e, p) || p in i2 && i2[p] === l[p] || Object.defineProperty(i2, p, {
        enumerable: true,
        get: function() {
          return l[p];
        }
      });
    });
    var c = requireCache();
    function d(p) {
      if (typeof WeakMap != "function") return null;
      var m = /* @__PURE__ */ new WeakMap(), y = /* @__PURE__ */ new WeakMap();
      return (d = function(x) {
        return x ? y : m;
      })(p);
    }
    function f(p, m) {
      if (p.__esModule)
        return p;
      if (p === null || typeof p != "object" && typeof p != "function")
        return { default: p };
      var y = d(m);
      if (y && y.has(p))
        return y.get(p);
      var x = {}, g = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var _ in p)
        if (_ !== "default" && Object.prototype.hasOwnProperty.call(p, _)) {
          var T = g ? Object.getOwnPropertyDescriptor(p, _) : null;
          T && (T.get || T.set) ? Object.defineProperty(x, _, T) : x[_] = p[_];
        }
      return x.default = p, y && y.set(p, x), x;
    }
    t.utils.mixins.performMixins(), window.InkPaint = i2;
  }(lib$4)), lib$4;
}
var iota_1, hasRequiredIota;
function requireIota() {
  if (hasRequiredIota) return iota_1;
  hasRequiredIota = 1;
  function i2(e) {
    for (var t = new Array(e), r = 0; r < e; ++r)
      t[r] = r;
    return t;
  }
  return iota_1 = i2, iota_1;
}
var ndarray, hasRequiredNdarray;
function requireNdarray() {
  if (hasRequiredNdarray) return ndarray;
  hasRequiredNdarray = 1;
  var i2 = requireIota(), e = requireIsBuffer$1(), t = typeof Float64Array < "u";
  function r(d, f) {
    return d[0] - f[0];
  }
  function a() {
    var d = this.stride, f = new Array(d.length), p;
    for (p = 0; p < f.length; ++p)
      f[p] = [Math.abs(d[p]), p];
    f.sort(r);
    var m = new Array(f.length);
    for (p = 0; p < m.length; ++p)
      m[p] = f[p][1];
    return m;
  }
  function s(d, f) {
    var p = ["View", f, "d", d].join("");
    f < 0 && (p = "View_Nil" + d);
    var m = d === "generic";
    if (f === -1) {
      var y = "function " + p + "(a){this.data=a;};	var proto=" + p + ".prototype;	proto.dtype='" + d + "';	proto.index=function(){return -1};	proto.size=0;	proto.dimension=-1;	proto.shape=proto.stride=proto.order=[];	proto.lo=proto.hi=proto.transpose=proto.step=	function(){return new " + p + "(this.data);};	proto.get=proto.set=function(){};	proto.pick=function(){return null};	return function construct_" + p + "(a){return new " + p + "(a);}", F = new Function(y);
      return F();
    } else if (f === 0) {
      var y = "function " + p + "(a,d) {	this.data = a;	this.offset = d	};	var proto=" + p + ".prototype;	proto.dtype='" + d + "';	proto.index=function(){return this.offset};	proto.dimension=0;	proto.size=1;	proto.shape=	proto.stride=	proto.order=[];	proto.lo=	proto.hi=	proto.transpose=	proto.step=function " + p + "_copy() {	return new " + p + "(this.data,this.offset)	};	proto.pick=function " + p + "_pick(){	return TrivialArray(this.data);	};	proto.valueOf=proto.get=function " + p + "_get(){	return " + (m ? "this.data.get(this.offset)" : "this.data[this.offset]") + "};	proto.set=function " + p + "_set(v){	return " + (m ? "this.data.set(this.offset,v)" : "this.data[this.offset]=v") + "	};	return function construct_" + p + "(a,b,c,d){return new " + p + "(a,d)}", F = new Function("TrivialArray", y);
      return F(l[d][0]);
    }
    var y = ["'use strict'"], x = i2(f), g = x.map(function(M) {
      return "i" + M;
    }), _ = "this.offset+" + x.map(function(M) {
      return "this.stride[" + M + "]*i" + M;
    }).join("+"), T = x.map(function(M) {
      return "b" + M;
    }).join(","), E = x.map(function(M) {
      return "c" + M;
    }).join(",");
    y.push(
      "function " + p + "(a," + T + "," + E + ",d){this.data=a",
      "this.shape=[" + T + "]",
      "this.stride=[" + E + "]",
      "this.offset=d|0}",
      "var proto=" + p + ".prototype",
      "proto.dtype='" + d + "'",
      "proto.dimension=" + f
    ), y.push(
      "Object.defineProperty(proto,'size',{get:function " + p + "_size(){	return " + x.map(function(M) {
        return "this.shape[" + M + "]";
      }).join("*"),
      "}})"
    ), f === 1 ? y.push("proto.order=[0]") : (y.push("Object.defineProperty(proto,'order',{get:"), f < 4 ? (y.push("function " + p + "_order(){"), f === 2 ? y.push("return (Math.abs(this.stride[0])>Math.abs(this.stride[1]))?[1,0]:[0,1]}})") : f === 3 && y.push(
      "var s0=Math.abs(this.stride[0]),s1=Math.abs(this.stride[1]),s2=Math.abs(this.stride[2]);	if(s0>s1){	if(s1>s2){	return [2,1,0];	}else if(s0>s2){	return [1,2,0];	}else{	return [1,0,2];	}	}else if(s0>s2){	return [2,0,1];	}else if(s2>s1){	return [0,1,2];	}else{	return [0,2,1];	}}})"
    )) : y.push("ORDER})")), y.push(
      "proto.set=function " + p + "_set(" + g.join(",") + ",v){"
    ), m ? y.push("return this.data.set(" + _ + ",v)}") : y.push("return this.data[" + _ + "]=v}"), y.push("proto.get=function " + p + "_get(" + g.join(",") + "){"), m ? y.push("return this.data.get(" + _ + ")}") : y.push("return this.data[" + _ + "]}"), y.push(
      "proto.index=function " + p + "_index(",
      g.join(),
      "){return " + _ + "}"
    ), y.push("proto.hi=function " + p + "_hi(" + g.join(",") + "){return new " + p + "(this.data," + x.map(function(M) {
      return ["(typeof i", M, "!=='number'||i", M, "<0)?this.shape[", M, "]:i", M, "|0"].join("");
    }).join(",") + "," + x.map(function(M) {
      return "this.stride[" + M + "]";
    }).join(",") + ",this.offset)}");
    var b = x.map(function(M) {
      return "a" + M + "=this.shape[" + M + "]";
    }), C = x.map(function(M) {
      return "c" + M + "=this.stride[" + M + "]";
    });
    y.push("proto.lo=function " + p + "_lo(" + g.join(",") + "){var b=this.offset,d=0," + b.join(",") + "," + C.join(","));
    for (var w = 0; w < f; ++w)
      y.push(
        "if(typeof i" + w + "==='number'&&i" + w + ">=0){	d=i" + w + "|0;	b+=c" + w + "*d;	a" + w + "-=d}"
      );
    y.push("return new " + p + "(this.data," + x.map(function(M) {
      return "a" + M;
    }).join(",") + "," + x.map(function(M) {
      return "c" + M;
    }).join(",") + ",b)}"), y.push("proto.step=function " + p + "_step(" + g.join(",") + "){var " + x.map(function(M) {
      return "a" + M + "=this.shape[" + M + "]";
    }).join(",") + "," + x.map(function(M) {
      return "b" + M + "=this.stride[" + M + "]";
    }).join(",") + ",c=this.offset,d=0,ceil=Math.ceil");
    for (var w = 0; w < f; ++w)
      y.push(
        "if(typeof i" + w + "==='number'){	d=i" + w + "|0;	if(d<0){	c+=b" + w + "*(a" + w + "-1);	a" + w + "=ceil(-a" + w + "/d)	}else{	a" + w + "=ceil(a" + w + "/d)	}	b" + w + "*=d	}"
      );
    y.push("return new " + p + "(this.data," + x.map(function(M) {
      return "a" + M;
    }).join(",") + "," + x.map(function(M) {
      return "b" + M;
    }).join(",") + ",c)}");
    for (var A = new Array(f), S = new Array(f), w = 0; w < f; ++w)
      A[w] = "a[i" + w + "]", S[w] = "b[i" + w + "]";
    y.push(
      "proto.transpose=function " + p + "_transpose(" + g + "){" + g.map(function(M, U) {
        return M + "=(" + M + "===undefined?" + U + ":" + M + "|0)";
      }).join(";"),
      "var a=this.shape,b=this.stride;return new " + p + "(this.data," + A.join(",") + "," + S.join(",") + ",this.offset)}"
    ), y.push("proto.pick=function " + p + "_pick(" + g + "){var a=[],b=[],c=this.offset");
    for (var w = 0; w < f; ++w)
      y.push("if(typeof i" + w + "==='number'&&i" + w + ">=0){c=(c+this.stride[" + w + "]*i" + w + ")|0}else{a.push(this.shape[" + w + "]);b.push(this.stride[" + w + "])}");
    y.push("var ctor=CTOR_LIST[a.length+1];return ctor(this.data,a,b,c)}"), y.push("return function construct_" + p + "(data,shape,stride,offset){return new " + p + "(data," + x.map(function(M) {
      return "shape[" + M + "]";
    }).join(",") + "," + x.map(function(M) {
      return "stride[" + M + "]";
    }).join(",") + ",offset)}");
    var F = new Function("CTOR_LIST", "ORDER", y.join(`
`));
    return F(l[d], a);
  }
  function u(d) {
    if (e(d))
      return "buffer";
    if (t)
      switch (Object.prototype.toString.call(d)) {
        case "[object Float64Array]":
          return "float64";
        case "[object Float32Array]":
          return "float32";
        case "[object Int8Array]":
          return "int8";
        case "[object Int16Array]":
          return "int16";
        case "[object Int32Array]":
          return "int32";
        case "[object Uint8Array]":
          return "uint8";
        case "[object Uint16Array]":
          return "uint16";
        case "[object Uint32Array]":
          return "uint32";
        case "[object Uint8ClampedArray]":
          return "uint8_clamped";
        case "[object BigInt64Array]":
          return "bigint64";
        case "[object BigUint64Array]":
          return "biguint64";
      }
    return Array.isArray(d) ? "array" : "generic";
  }
  var l = {
    float32: [],
    float64: [],
    int8: [],
    int16: [],
    int32: [],
    uint8: [],
    uint16: [],
    uint32: [],
    array: [],
    uint8_clamped: [],
    bigint64: [],
    biguint64: [],
    buffer: [],
    generic: []
  };
  function c(d, f, p, m) {
    if (d === void 0) {
      var E = l.array[0];
      return E([]);
    } else typeof d == "number" && (d = [d]);
    f === void 0 && (f = [d.length]);
    var y = f.length;
    if (p === void 0) {
      p = new Array(y);
      for (var x = y - 1, g = 1; x >= 0; --x)
        p[x] = g, g *= f[x];
    }
    if (m === void 0) {
      m = 0;
      for (var x = 0; x < y; ++x)
        p[x] < 0 && (m -= (f[x] - 1) * p[x]);
    }
    for (var _ = u(d), T = l[_]; T.length <= y + 1; )
      T.push(s(_, T.length - 1));
    var E = T[y + 1];
    return E(d, f, p, m);
  }
  return ndarray = c, ndarray;
}
var omggif = {}, hasRequiredOmggif;
function requireOmggif() {
  if (hasRequiredOmggif) return omggif;
  hasRequiredOmggif = 1;
  function i2(a, s, u, d) {
    var c = 0, d = d === void 0 ? {} : d, f = d.loop === void 0 ? null : d.loop, p = d.palette === void 0 ? null : d.palette;
    if (s <= 0 || u <= 0 || s > 65535 || u > 65535)
      throw new Error("Width/Height invalid.");
    function m(C) {
      var w = C.length;
      if (w < 2 || w > 256 || w & w - 1)
        throw new Error(
          "Invalid code/color length, must be power of 2 and 2 .. 256."
        );
      return w;
    }
    a[c++] = 71, a[c++] = 73, a[c++] = 70, a[c++] = 56, a[c++] = 57, a[c++] = 97;
    var y = 0, x = 0;
    if (p !== null) {
      for (var g = m(p); g >>= 1; ) ++y;
      if (g = 1 << y, --y, d.background !== void 0) {
        if (x = d.background, x >= g)
          throw new Error("Background index out of range.");
        if (x === 0)
          throw new Error("Background index explicitly passed as 0.");
      }
    }
    if (a[c++] = s & 255, a[c++] = s >> 8 & 255, a[c++] = u & 255, a[c++] = u >> 8 & 255, a[c++] = (p !== null ? 128 : 0) | // Global Color Table Flag.
    y, a[c++] = x, a[c++] = 0, p !== null)
      for (var _ = 0, T = p.length; _ < T; ++_) {
        var E = p[_];
        a[c++] = E >> 16 & 255, a[c++] = E >> 8 & 255, a[c++] = E & 255;
      }
    if (f !== null) {
      if (f < 0 || f > 65535)
        throw new Error("Loop count invalid.");
      a[c++] = 33, a[c++] = 255, a[c++] = 11, a[c++] = 78, a[c++] = 69, a[c++] = 84, a[c++] = 83, a[c++] = 67, a[c++] = 65, a[c++] = 80, a[c++] = 69, a[c++] = 50, a[c++] = 46, a[c++] = 48, a[c++] = 3, a[c++] = 1, a[c++] = f & 255, a[c++] = f >> 8 & 255, a[c++] = 0;
    }
    var b = false;
    this.addFrame = function(C, w, A, S, F, M) {
      if (b === true && (--c, b = false), M = M === void 0 ? {} : M, C < 0 || w < 0 || C > 65535 || w > 65535)
        throw new Error("x/y invalid.");
      if (A <= 0 || S <= 0 || A > 65535 || S > 65535)
        throw new Error("Width/Height invalid.");
      if (F.length < A * S)
        throw new Error("Not enough pixels for the frame size.");
      var U = true, B = M.palette;
      if (B == null && (U = false, B = p), B == null)
        throw new Error("Must supply either a local or global palette.");
      for (var q = m(B), z = 0; q >>= 1; ) ++z;
      q = 1 << z;
      var D = M.delay === void 0 ? 0 : M.delay, X = M.disposal === void 0 ? 0 : M.disposal;
      if (X < 0 || X > 3)
        throw new Error("Disposal out of range.");
      var k = false, I = 0;
      if (M.transparent !== void 0 && M.transparent !== null && (k = true, I = M.transparent, I < 0 || I >= q))
        throw new Error("Transparent color index.");
      if ((X !== 0 || k || D !== 0) && (a[c++] = 33, a[c++] = 249, a[c++] = 4, a[c++] = X << 2 | (k === true ? 1 : 0), a[c++] = D & 255, a[c++] = D >> 8 & 255, a[c++] = I, a[c++] = 0), a[c++] = 44, a[c++] = C & 255, a[c++] = C >> 8 & 255, a[c++] = w & 255, a[c++] = w >> 8 & 255, a[c++] = A & 255, a[c++] = A >> 8 & 255, a[c++] = S & 255, a[c++] = S >> 8 & 255, a[c++] = U === true ? 128 | z - 1 : 0, U === true)
        for (var P = 0, G = B.length; P < G; ++P) {
          var W = B[P];
          a[c++] = W >> 16 & 255, a[c++] = W >> 8 & 255, a[c++] = W & 255;
        }
      return c = e(
        a,
        c,
        z < 2 ? 2 : z,
        F
      ), c;
    }, this.end = function() {
      return b === false && (a[c++] = 59, b = true), c;
    }, this.getOutputBuffer = function() {
      return a;
    }, this.setOutputBuffer = function(C) {
      a = C;
    }, this.getOutputBufferPosition = function() {
      return c;
    }, this.setOutputBufferPosition = function(C) {
      c = C;
    };
  }
  function e(a, s, u, l) {
    a[s++] = u;
    var c = s++, d = 1 << u, f = d - 1, p = d + 1, m = p + 1, y = u + 1, x = 0, g = 0;
    function _(M) {
      for (; x >= M; )
        a[s++] = g & 255, g >>= 8, x -= 8, s === c + 256 && (a[c] = 255, c = s++);
    }
    function T(M) {
      g |= M << x, x += y, _(8);
    }
    var E = l[0] & f, b = {};
    T(d);
    for (var C = 1, w = l.length; C < w; ++C) {
      var A = l[C] & f, S = E << 8 | A, F = b[S];
      if (F === void 0) {
        for (g |= E << x, x += y; x >= 8; )
          a[s++] = g & 255, g >>= 8, x -= 8, s === c + 256 && (a[c] = 255, c = s++);
        m === 4096 ? (T(d), m = p + 1, y = u + 1, b = {}) : (m >= 1 << y && ++y, b[S] = m++), E = A;
      } else
        E = F;
    }
    return T(E), T(p), _(1), c + 1 === s ? a[c] = 0 : (a[c] = s - c - 1, a[s++] = 0), s;
  }
  function t(a) {
    var s = 0;
    if (a[s++] !== 71 || a[s++] !== 73 || a[s++] !== 70 || a[s++] !== 56 || (a[s++] + 1 & 253) !== 56 || a[s++] !== 97)
      throw new Error("Invalid GIF 87a/89a header.");
    var u = a[s++] | a[s++] << 8, l = a[s++] | a[s++] << 8, c = a[s++], d = c >> 7, f = c & 7, p = 1 << f + 1;
    a[s++], a[s++];
    var m = null, y = null;
    d && (m = s, y = p, s += p * 3);
    var x = true, g = [], _ = 0, T = null, E = 0, b = null;
    for (this.width = u, this.height = l; x && s < a.length; )
      switch (a[s++]) {
        case 33:
          switch (a[s++]) {
            case 255:
              if (a[s] !== 11 || // 21 FF already read, check block size.
              // NETSCAPE2.0
              a[s + 1] == 78 && a[s + 2] == 69 && a[s + 3] == 84 && a[s + 4] == 83 && a[s + 5] == 67 && a[s + 6] == 65 && a[s + 7] == 80 && a[s + 8] == 69 && a[s + 9] == 50 && a[s + 10] == 46 && a[s + 11] == 48 && // Sub-block
              a[s + 12] == 3 && a[s + 13] == 1 && a[s + 16] == 0)
                s += 14, b = a[s++] | a[s++] << 8, s++;
              else
                for (s += 12; ; ) {
                  var C = a[s++];
                  if (!(C >= 0)) throw Error("Invalid block size");
                  if (C === 0) break;
                  s += C;
                }
              break;
            case 249:
              if (a[s++] !== 4 || a[s + 4] !== 0)
                throw new Error("Invalid graphics extension block.");
              var w = a[s++];
              _ = a[s++] | a[s++] << 8, T = a[s++], w & 1 || (T = null), E = w >> 2 & 7, s++;
              break;
            case 254:
              for (; ; ) {
                var C = a[s++];
                if (!(C >= 0)) throw Error("Invalid block size");
                if (C === 0) break;
                s += C;
              }
              break;
            default:
              throw new Error(
                "Unknown graphic control label: 0x" + a[s - 1].toString(16)
              );
          }
          break;
        case 44:
          var A = a[s++] | a[s++] << 8, S = a[s++] | a[s++] << 8, F = a[s++] | a[s++] << 8, M = a[s++] | a[s++] << 8, U = a[s++], B = U >> 7, q = U >> 6 & 1, z = U & 7, D = 1 << z + 1, X = m, k = y, I = false;
          if (B) {
            var I = true;
            X = s, k = D, s += D * 3;
          }
          var P = s;
          for (s++; ; ) {
            var C = a[s++];
            if (!(C >= 0)) throw Error("Invalid block size");
            if (C === 0) break;
            s += C;
          }
          g.push({
            x: A,
            y: S,
            width: F,
            height: M,
            has_local_palette: I,
            palette_offset: X,
            palette_size: k,
            data_offset: P,
            data_length: s - P,
            transparent_index: T,
            interlaced: !!q,
            delay: _,
            disposal: E
          });
          break;
        case 59:
          x = false;
          break;
        default:
          throw new Error("Unknown gif block: 0x" + a[s - 1].toString(16));
      }
    this.numFrames = function() {
      return g.length;
    }, this.loopCount = function() {
      return b;
    }, this.frameInfo = function(G) {
      if (G < 0 || G >= g.length)
        throw new Error("Frame index out of range.");
      return g[G];
    }, this.decodeAndBlitFrameBGRA = function(G, W) {
      var V = this.frameInfo(G), K = V.width * V.height, J = new Uint8Array(K);
      r(
        a,
        V.data_offset,
        J,
        K
      );
      var ae = V.palette_offset, re = V.transparent_index;
      re === null && (re = 256);
      var he = V.width, ge = u - he, me = he, Te = (V.y * u + V.x) * 4, _e = ((V.y + V.height) * u + V.x) * 4, ye = Te, Ae = ge * 4;
      V.interlaced === true && (Ae += u * 4 * 7);
      for (var ke = 8, Pe = 0, Ee = J.length; Pe < Ee; ++Pe) {
        var Oe = J[Pe];
        if (me === 0 && (ye += Ae, me = he, ye >= _e && (Ae = ge * 4 + u * 4 * (ke - 1), ye = Te + (he + ge) * (ke << 1), ke >>= 1)), Oe === re)
          ye += 4;
        else {
          var $e = a[ae + Oe * 3], gt = a[ae + Oe * 3 + 1], xt = a[ae + Oe * 3 + 2];
          W[ye++] = xt, W[ye++] = gt, W[ye++] = $e, W[ye++] = 255;
        }
        --me;
      }
    }, this.decodeAndBlitFrameRGBA = function(G, W) {
      var V = this.frameInfo(G), K = V.width * V.height, J = new Uint8Array(K);
      r(
        a,
        V.data_offset,
        J,
        K
      );
      var ae = V.palette_offset, re = V.transparent_index;
      re === null && (re = 256);
      var he = V.width, ge = u - he, me = he, Te = (V.y * u + V.x) * 4, _e = ((V.y + V.height) * u + V.x) * 4, ye = Te, Ae = ge * 4;
      V.interlaced === true && (Ae += u * 4 * 7);
      for (var ke = 8, Pe = 0, Ee = J.length; Pe < Ee; ++Pe) {
        var Oe = J[Pe];
        if (me === 0 && (ye += Ae, me = he, ye >= _e && (Ae = ge * 4 + u * 4 * (ke - 1), ye = Te + (he + ge) * (ke << 1), ke >>= 1)), Oe === re)
          ye += 4;
        else {
          var $e = a[ae + Oe * 3], gt = a[ae + Oe * 3 + 1], xt = a[ae + Oe * 3 + 2];
          W[ye++] = $e, W[ye++] = gt, W[ye++] = xt, W[ye++] = 255;
        }
        --me;
      }
    };
  }
  function r(a, s, u, l) {
    for (var c = a[s++], d = 1 << c, f = d + 1, p = f + 1, m = c + 1, y = (1 << m) - 1, x = 0, g = 0, _ = 0, T = a[s++], E = new Int32Array(4096), b = null; ; ) {
      for (; x < 16 && T !== 0; )
        g |= a[s++] << x, x += 8, T === 1 ? T = a[s++] : --T;
      if (x < m)
        break;
      var C = g & y;
      if (g >>= m, x -= m, C === d) {
        p = f + 1, m = c + 1, y = (1 << m) - 1, b = null;
        continue;
      } else if (C === f)
        break;
      for (var w = C < p ? C : b, A = 0, S = w; S > d; )
        S = E[S] >> 8, ++A;
      var F = S, M = _ + A + (w !== C ? 1 : 0);
      if (M > l) {
        console.log("Warning, gif stream longer than expected.");
        return;
      }
      u[_++] = F, _ += A;
      var U = _;
      for (w !== C && (u[_++] = F), S = w; A--; )
        S = E[S], u[--U] = S & 255, S >>= 8;
      b !== null && p < 4096 && (E[p++] = b << 8 | F, p >= y + 1 && m < 12 && (++m, y = y << 1 | 1)), b = C;
    }
    return _ !== l && console.log("Warning, gif stream shorter than expected."), u;
  }
  try {
    omggif.GifWriter = i2, omggif.GifReader = t;
  } catch {
  }
  return omggif;
}
var buffer$1 = {}, base64Js = {}, hasRequiredBase64Js;
function requireBase64Js() {
  if (hasRequiredBase64Js) return base64Js;
  hasRequiredBase64Js = 1, base64Js.byteLength = l, base64Js.toByteArray = d, base64Js.fromByteArray = m;
  for (var i2 = [], e = [], t = typeof Uint8Array < "u" ? Uint8Array : Array, r = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", a = 0, s = r.length; a < s; ++a)
    i2[a] = r[a], e[r.charCodeAt(a)] = a;
  e[45] = 62, e[95] = 63;
  function u(y) {
    var x = y.length;
    if (x % 4 > 0)
      throw new Error("Invalid string. Length must be a multiple of 4");
    var g = y.indexOf("=");
    g === -1 && (g = x);
    var _ = g === x ? 0 : 4 - g % 4;
    return [g, _];
  }
  function l(y) {
    var x = u(y), g = x[0], _ = x[1];
    return (g + _) * 3 / 4 - _;
  }
  function c(y, x, g) {
    return (x + g) * 3 / 4 - g;
  }
  function d(y) {
    var x, g = u(y), _ = g[0], T = g[1], E = new t(c(y, _, T)), b = 0, C = T > 0 ? _ - 4 : _, w;
    for (w = 0; w < C; w += 4)
      x = e[y.charCodeAt(w)] << 18 | e[y.charCodeAt(w + 1)] << 12 | e[y.charCodeAt(w + 2)] << 6 | e[y.charCodeAt(w + 3)], E[b++] = x >> 16 & 255, E[b++] = x >> 8 & 255, E[b++] = x & 255;
    return T === 2 && (x = e[y.charCodeAt(w)] << 2 | e[y.charCodeAt(w + 1)] >> 4, E[b++] = x & 255), T === 1 && (x = e[y.charCodeAt(w)] << 10 | e[y.charCodeAt(w + 1)] << 4 | e[y.charCodeAt(w + 2)] >> 2, E[b++] = x >> 8 & 255, E[b++] = x & 255), E;
  }
  function f(y) {
    return i2[y >> 18 & 63] + i2[y >> 12 & 63] + i2[y >> 6 & 63] + i2[y & 63];
  }
  function p(y, x, g) {
    for (var _, T = [], E = x; E < g; E += 3)
      _ = (y[E] << 16 & 16711680) + (y[E + 1] << 8 & 65280) + (y[E + 2] & 255), T.push(f(_));
    return T.join("");
  }
  function m(y) {
    for (var x, g = y.length, _ = g % 3, T = [], E = 16383, b = 0, C = g - _; b < C; b += E)
      T.push(p(y, b, b + E > C ? C : b + E));
    return _ === 1 ? (x = y[g - 1], T.push(
      i2[x >> 2] + i2[x << 4 & 63] + "=="
    )) : _ === 2 && (x = (y[g - 2] << 8) + y[g - 1], T.push(
      i2[x >> 10] + i2[x >> 4 & 63] + i2[x << 2 & 63] + "="
    )), T.join("");
  }
  return base64Js;
}
var ieee754 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
var hasRequiredIeee754;
function requireIeee754() {
  return hasRequiredIeee754 || (hasRequiredIeee754 = 1, ieee754.read = function(i2, e, t, r, a) {
    var s, u, l = a * 8 - r - 1, c = (1 << l) - 1, d = c >> 1, f = -7, p = t ? a - 1 : 0, m = t ? -1 : 1, y = i2[e + p];
    for (p += m, s = y & (1 << -f) - 1, y >>= -f, f += l; f > 0; s = s * 256 + i2[e + p], p += m, f -= 8)
      ;
    for (u = s & (1 << -f) - 1, s >>= -f, f += r; f > 0; u = u * 256 + i2[e + p], p += m, f -= 8)
      ;
    if (s === 0)
      s = 1 - d;
    else {
      if (s === c)
        return u ? NaN : (y ? -1 : 1) * (1 / 0);
      u = u + Math.pow(2, r), s = s - d;
    }
    return (y ? -1 : 1) * u * Math.pow(2, s - r);
  }, ieee754.write = function(i2, e, t, r, a, s) {
    var u, l, c, d = s * 8 - a - 1, f = (1 << d) - 1, p = f >> 1, m = a === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, y = r ? 0 : s - 1, x = r ? 1 : -1, g = e < 0 || e === 0 && 1 / e < 0 ? 1 : 0;
    for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (l = isNaN(e) ? 1 : 0, u = f) : (u = Math.floor(Math.log(e) / Math.LN2), e * (c = Math.pow(2, -u)) < 1 && (u--, c *= 2), u + p >= 1 ? e += m / c : e += m * Math.pow(2, 1 - p), e * c >= 2 && (u++, c /= 2), u + p >= f ? (l = 0, u = f) : u + p >= 1 ? (l = (e * c - 1) * Math.pow(2, a), u = u + p) : (l = e * Math.pow(2, p - 1) * Math.pow(2, a), u = 0)); a >= 8; i2[t + y] = l & 255, y += x, l /= 256, a -= 8)
      ;
    for (u = u << a | l, d += a; d > 0; i2[t + y] = u & 255, y += x, u /= 256, d -= 8)
      ;
    i2[t + y - x] |= g * 128;
  }), ieee754;
}
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
var hasRequiredBuffer$1;
function requireBuffer$1() {
  return hasRequiredBuffer$1 || (hasRequiredBuffer$1 = 1, function(i2) {
    const e = requireBase64Js(), t = requireIeee754(), r = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
    i2.Buffer = l, i2.SlowBuffer = E, i2.INSPECT_MAX_BYTES = 50;
    const a = 2147483647;
    i2.kMaxLength = a, l.TYPED_ARRAY_SUPPORT = s(), !l.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
      "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
    );
    function s() {
      try {
        const $ = new Uint8Array(1), Y = { foo: function() {
          return 42;
        } };
        return Object.setPrototypeOf(Y, Uint8Array.prototype), Object.setPrototypeOf($, Y), $.foo() === 42;
      } catch {
        return false;
      }
    }
    Object.defineProperty(l.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (l.isBuffer(this))
          return this.buffer;
      }
    }), Object.defineProperty(l.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (l.isBuffer(this))
          return this.byteOffset;
      }
    });
    function u($) {
      if ($ > a)
        throw new RangeError('The value "' + $ + '" is invalid for option "size"');
      const Y = new Uint8Array($);
      return Object.setPrototypeOf(Y, l.prototype), Y;
    }
    function l($, Y, ee) {
      if (typeof $ == "number") {
        if (typeof Y == "string")
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        return p($);
      }
      return c($, Y, ee);
    }
    l.poolSize = 8192;
    function c($, Y, ee) {
      if (typeof $ == "string")
        return m($, Y);
      if (ArrayBuffer.isView($))
        return x($);
      if ($ == null)
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof $
        );
      if (at($, ArrayBuffer) || $ && at($.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (at($, SharedArrayBuffer) || $ && at($.buffer, SharedArrayBuffer)))
        return g($, Y, ee);
      if (typeof $ == "number")
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      const be = $.valueOf && $.valueOf();
      if (be != null && be !== $)
        return l.from(be, Y, ee);
      const Se = _($);
      if (Se) return Se;
      if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof $[Symbol.toPrimitive] == "function")
        return l.from($[Symbol.toPrimitive]("string"), Y, ee);
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof $
      );
    }
    l.from = function($, Y, ee) {
      return c($, Y, ee);
    }, Object.setPrototypeOf(l.prototype, Uint8Array.prototype), Object.setPrototypeOf(l, Uint8Array);
    function d($) {
      if (typeof $ != "number")
        throw new TypeError('"size" argument must be of type number');
      if ($ < 0)
        throw new RangeError('The value "' + $ + '" is invalid for option "size"');
    }
    function f($, Y, ee) {
      return d($), $ <= 0 ? u($) : Y !== void 0 ? typeof ee == "string" ? u($).fill(Y, ee) : u($).fill(Y) : u($);
    }
    l.alloc = function($, Y, ee) {
      return f($, Y, ee);
    };
    function p($) {
      return d($), u($ < 0 ? 0 : T($) | 0);
    }
    l.allocUnsafe = function($) {
      return p($);
    }, l.allocUnsafeSlow = function($) {
      return p($);
    };
    function m($, Y) {
      if ((typeof Y != "string" || Y === "") && (Y = "utf8"), !l.isEncoding(Y))
        throw new TypeError("Unknown encoding: " + Y);
      const ee = b($, Y) | 0;
      let be = u(ee);
      const Se = be.write($, Y);
      return Se !== ee && (be = be.slice(0, Se)), be;
    }
    function y($) {
      const Y = $.length < 0 ? 0 : T($.length) | 0, ee = u(Y);
      for (let be = 0; be < Y; be += 1)
        ee[be] = $[be] & 255;
      return ee;
    }
    function x($) {
      if (at($, Uint8Array)) {
        const Y = new Uint8Array($);
        return g(Y.buffer, Y.byteOffset, Y.byteLength);
      }
      return y($);
    }
    function g($, Y, ee) {
      if (Y < 0 || $.byteLength < Y)
        throw new RangeError('"offset" is outside of buffer bounds');
      if ($.byteLength < Y + (ee || 0))
        throw new RangeError('"length" is outside of buffer bounds');
      let be;
      return Y === void 0 && ee === void 0 ? be = new Uint8Array($) : ee === void 0 ? be = new Uint8Array($, Y) : be = new Uint8Array($, Y, ee), Object.setPrototypeOf(be, l.prototype), be;
    }
    function _($) {
      if (l.isBuffer($)) {
        const Y = T($.length) | 0, ee = u(Y);
        return ee.length === 0 || $.copy(ee, 0, 0, Y), ee;
      }
      if ($.length !== void 0)
        return typeof $.length != "number" || ct($.length) ? u(0) : y($);
      if ($.type === "Buffer" && Array.isArray($.data))
        return y($.data);
    }
    function T($) {
      if ($ >= a)
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + a.toString(16) + " bytes");
      return $ | 0;
    }
    function E($) {
      return +$ != $ && ($ = 0), l.alloc(+$);
    }
    l.isBuffer = function($) {
      return $ != null && $._isBuffer === true && $ !== l.prototype;
    }, l.compare = function($, Y) {
      if (at($, Uint8Array) && ($ = l.from($, $.offset, $.byteLength)), at(Y, Uint8Array) && (Y = l.from(Y, Y.offset, Y.byteLength)), !l.isBuffer($) || !l.isBuffer(Y))
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      if ($ === Y) return 0;
      let ee = $.length, be = Y.length;
      for (let Se = 0, Ne = Math.min(ee, be); Se < Ne; ++Se)
        if ($[Se] !== Y[Se]) {
          ee = $[Se], be = Y[Se];
          break;
        }
      return ee < be ? -1 : be < ee ? 1 : 0;
    }, l.isEncoding = function($) {
      switch (String($).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    }, l.concat = function($, Y) {
      if (!Array.isArray($))
        throw new TypeError('"list" argument must be an Array of Buffers');
      if ($.length === 0)
        return l.alloc(0);
      let ee;
      if (Y === void 0)
        for (Y = 0, ee = 0; ee < $.length; ++ee)
          Y += $[ee].length;
      const be = l.allocUnsafe(Y);
      let Se = 0;
      for (ee = 0; ee < $.length; ++ee) {
        let Ne = $[ee];
        if (at(Ne, Uint8Array))
          Se + Ne.length > be.length ? (l.isBuffer(Ne) || (Ne = l.from(Ne)), Ne.copy(be, Se)) : Uint8Array.prototype.set.call(
            be,
            Ne,
            Se
          );
        else if (l.isBuffer(Ne))
          Ne.copy(be, Se);
        else
          throw new TypeError('"list" argument must be an Array of Buffers');
        Se += Ne.length;
      }
      return be;
    };
    function b($, Y) {
      if (l.isBuffer($))
        return $.length;
      if (ArrayBuffer.isView($) || at($, ArrayBuffer))
        return $.byteLength;
      if (typeof $ != "string")
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof $
        );
      const ee = $.length, be = arguments.length > 2 && arguments[2] === true;
      if (!be && ee === 0) return 0;
      let Se = false;
      for (; ; )
        switch (Y) {
          case "ascii":
          case "latin1":
          case "binary":
            return ee;
          case "utf8":
          case "utf-8":
            return $e($).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ee * 2;
          case "hex":
            return ee >>> 1;
          case "base64":
            return vt($).length;
          default:
            if (Se)
              return be ? -1 : $e($).length;
            Y = ("" + Y).toLowerCase(), Se = true;
        }
    }
    l.byteLength = b;
    function C($, Y, ee) {
      let be = false;
      if ((Y === void 0 || Y < 0) && (Y = 0), Y > this.length || ((ee === void 0 || ee > this.length) && (ee = this.length), ee <= 0) || (ee >>>= 0, Y >>>= 0, ee <= Y))
        return "";
      for ($ || ($ = "utf8"); ; )
        switch ($) {
          case "hex":
            return G(this, Y, ee);
          case "utf8":
          case "utf-8":
            return D(this, Y, ee);
          case "ascii":
            return I(this, Y, ee);
          case "latin1":
          case "binary":
            return P(this, Y, ee);
          case "base64":
            return z(this, Y, ee);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return W(this, Y, ee);
          default:
            if (be) throw new TypeError("Unknown encoding: " + $);
            $ = ($ + "").toLowerCase(), be = true;
        }
    }
    l.prototype._isBuffer = true;
    function w($, Y, ee) {
      const be = $[Y];
      $[Y] = $[ee], $[ee] = be;
    }
    l.prototype.swap16 = function() {
      const $ = this.length;
      if ($ % 2 !== 0)
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      for (let Y = 0; Y < $; Y += 2)
        w(this, Y, Y + 1);
      return this;
    }, l.prototype.swap32 = function() {
      const $ = this.length;
      if ($ % 4 !== 0)
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      for (let Y = 0; Y < $; Y += 4)
        w(this, Y, Y + 3), w(this, Y + 1, Y + 2);
      return this;
    }, l.prototype.swap64 = function() {
      const $ = this.length;
      if ($ % 8 !== 0)
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      for (let Y = 0; Y < $; Y += 8)
        w(this, Y, Y + 7), w(this, Y + 1, Y + 6), w(this, Y + 2, Y + 5), w(this, Y + 3, Y + 4);
      return this;
    }, l.prototype.toString = function() {
      const $ = this.length;
      return $ === 0 ? "" : arguments.length === 0 ? D(this, 0, $) : C.apply(this, arguments);
    }, l.prototype.toLocaleString = l.prototype.toString, l.prototype.equals = function($) {
      if (!l.isBuffer($)) throw new TypeError("Argument must be a Buffer");
      return this === $ ? true : l.compare(this, $) === 0;
    }, l.prototype.inspect = function() {
      let $ = "";
      const Y = i2.INSPECT_MAX_BYTES;
      return $ = this.toString("hex", 0, Y).replace(/(.{2})/g, "$1 ").trim(), this.length > Y && ($ += " ... "), "<Buffer " + $ + ">";
    }, r && (l.prototype[r] = l.prototype.inspect), l.prototype.compare = function($, Y, ee, be, Se) {
      if (at($, Uint8Array) && ($ = l.from($, $.offset, $.byteLength)), !l.isBuffer($))
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof $
        );
      if (Y === void 0 && (Y = 0), ee === void 0 && (ee = $ ? $.length : 0), be === void 0 && (be = 0), Se === void 0 && (Se = this.length), Y < 0 || ee > $.length || be < 0 || Se > this.length)
        throw new RangeError("out of range index");
      if (be >= Se && Y >= ee)
        return 0;
      if (be >= Se)
        return -1;
      if (Y >= ee)
        return 1;
      if (Y >>>= 0, ee >>>= 0, be >>>= 0, Se >>>= 0, this === $) return 0;
      let Ne = Se - be, je = ee - Y;
      const pt = Math.min(Ne, je), oe = this.slice(be, Se), le = $.slice(Y, ee);
      for (let Ue = 0; Ue < pt; ++Ue)
        if (oe[Ue] !== le[Ue]) {
          Ne = oe[Ue], je = le[Ue];
          break;
        }
      return Ne < je ? -1 : je < Ne ? 1 : 0;
    };
    function A($, Y, ee, be, Se) {
      if ($.length === 0) return -1;
      if (typeof ee == "string" ? (be = ee, ee = 0) : ee > 2147483647 ? ee = 2147483647 : ee < -2147483648 && (ee = -2147483648), ee = +ee, ct(ee) && (ee = Se ? 0 : $.length - 1), ee < 0 && (ee = $.length + ee), ee >= $.length) {
        if (Se) return -1;
        ee = $.length - 1;
      } else if (ee < 0)
        if (Se) ee = 0;
        else return -1;
      if (typeof Y == "string" && (Y = l.from(Y, be)), l.isBuffer(Y))
        return Y.length === 0 ? -1 : S($, Y, ee, be, Se);
      if (typeof Y == "number")
        return Y = Y & 255, typeof Uint8Array.prototype.indexOf == "function" ? Se ? Uint8Array.prototype.indexOf.call($, Y, ee) : Uint8Array.prototype.lastIndexOf.call($, Y, ee) : S($, [Y], ee, be, Se);
      throw new TypeError("val must be string, number or Buffer");
    }
    function S($, Y, ee, be, Se) {
      let Ne = 1, je = $.length, pt = Y.length;
      if (be !== void 0 && (be = String(be).toLowerCase(), be === "ucs2" || be === "ucs-2" || be === "utf16le" || be === "utf-16le")) {
        if ($.length < 2 || Y.length < 2)
          return -1;
        Ne = 2, je /= 2, pt /= 2, ee /= 2;
      }
      function oe(Ue, et) {
        return Ne === 1 ? Ue[et] : Ue.readUInt16BE(et * Ne);
      }
      let le;
      if (Se) {
        let Ue = -1;
        for (le = ee; le < je; le++)
          if (oe($, le) === oe(Y, Ue === -1 ? 0 : le - Ue)) {
            if (Ue === -1 && (Ue = le), le - Ue + 1 === pt) return Ue * Ne;
          } else
            Ue !== -1 && (le -= le - Ue), Ue = -1;
      } else
        for (ee + pt > je && (ee = je - pt), le = ee; le >= 0; le--) {
          let Ue = true;
          for (let et = 0; et < pt; et++)
            if (oe($, le + et) !== oe(Y, et)) {
              Ue = false;
              break;
            }
          if (Ue) return le;
        }
      return -1;
    }
    l.prototype.includes = function($, Y, ee) {
      return this.indexOf($, Y, ee) !== -1;
    }, l.prototype.indexOf = function($, Y, ee) {
      return A(this, $, Y, ee, true);
    }, l.prototype.lastIndexOf = function($, Y, ee) {
      return A(this, $, Y, ee, false);
    };
    function F($, Y, ee, be) {
      ee = Number(ee) || 0;
      const Se = $.length - ee;
      be ? (be = Number(be), be > Se && (be = Se)) : be = Se;
      const Ne = Y.length;
      be > Ne / 2 && (be = Ne / 2);
      let je;
      for (je = 0; je < be; ++je) {
        const pt = parseInt(Y.substr(je * 2, 2), 16);
        if (ct(pt)) return je;
        $[ee + je] = pt;
      }
      return je;
    }
    function M($, Y, ee, be) {
      return Xe($e(Y, $.length - ee), $, ee, be);
    }
    function U($, Y, ee, be) {
      return Xe(gt(Y), $, ee, be);
    }
    function B($, Y, ee, be) {
      return Xe(vt(Y), $, ee, be);
    }
    function q($, Y, ee, be) {
      return Xe(xt(Y, $.length - ee), $, ee, be);
    }
    l.prototype.write = function($, Y, ee, be) {
      if (Y === void 0)
        be = "utf8", ee = this.length, Y = 0;
      else if (ee === void 0 && typeof Y == "string")
        be = Y, ee = this.length, Y = 0;
      else if (isFinite(Y))
        Y = Y >>> 0, isFinite(ee) ? (ee = ee >>> 0, be === void 0 && (be = "utf8")) : (be = ee, ee = void 0);
      else
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      const Se = this.length - Y;
      if ((ee === void 0 || ee > Se) && (ee = Se), $.length > 0 && (ee < 0 || Y < 0) || Y > this.length)
        throw new RangeError("Attempt to write outside buffer bounds");
      be || (be = "utf8");
      let Ne = false;
      for (; ; )
        switch (be) {
          case "hex":
            return F(this, $, Y, ee);
          case "utf8":
          case "utf-8":
            return M(this, $, Y, ee);
          case "ascii":
          case "latin1":
          case "binary":
            return U(this, $, Y, ee);
          case "base64":
            return B(this, $, Y, ee);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return q(this, $, Y, ee);
          default:
            if (Ne) throw new TypeError("Unknown encoding: " + be);
            be = ("" + be).toLowerCase(), Ne = true;
        }
    }, l.prototype.toJSON = function() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function z($, Y, ee) {
      return Y === 0 && ee === $.length ? e.fromByteArray($) : e.fromByteArray($.slice(Y, ee));
    }
    function D($, Y, ee) {
      ee = Math.min($.length, ee);
      const be = [];
      let Se = Y;
      for (; Se < ee; ) {
        const Ne = $[Se];
        let je = null, pt = Ne > 239 ? 4 : Ne > 223 ? 3 : Ne > 191 ? 2 : 1;
        if (Se + pt <= ee) {
          let oe, le, Ue, et;
          switch (pt) {
            case 1:
              Ne < 128 && (je = Ne);
              break;
            case 2:
              oe = $[Se + 1], (oe & 192) === 128 && (et = (Ne & 31) << 6 | oe & 63, et > 127 && (je = et));
              break;
            case 3:
              oe = $[Se + 1], le = $[Se + 2], (oe & 192) === 128 && (le & 192) === 128 && (et = (Ne & 15) << 12 | (oe & 63) << 6 | le & 63, et > 2047 && (et < 55296 || et > 57343) && (je = et));
              break;
            case 4:
              oe = $[Se + 1], le = $[Se + 2], Ue = $[Se + 3], (oe & 192) === 128 && (le & 192) === 128 && (Ue & 192) === 128 && (et = (Ne & 15) << 18 | (oe & 63) << 12 | (le & 63) << 6 | Ue & 63, et > 65535 && et < 1114112 && (je = et));
          }
        }
        je === null ? (je = 65533, pt = 1) : je > 65535 && (je -= 65536, be.push(je >>> 10 & 1023 | 55296), je = 56320 | je & 1023), be.push(je), Se += pt;
      }
      return k(be);
    }
    const X = 4096;
    function k($) {
      const Y = $.length;
      if (Y <= X)
        return String.fromCharCode.apply(String, $);
      let ee = "", be = 0;
      for (; be < Y; )
        ee += String.fromCharCode.apply(
          String,
          $.slice(be, be += X)
        );
      return ee;
    }
    function I($, Y, ee) {
      let be = "";
      ee = Math.min($.length, ee);
      for (let Se = Y; Se < ee; ++Se)
        be += String.fromCharCode($[Se] & 127);
      return be;
    }
    function P($, Y, ee) {
      let be = "";
      ee = Math.min($.length, ee);
      for (let Se = Y; Se < ee; ++Se)
        be += String.fromCharCode($[Se]);
      return be;
    }
    function G($, Y, ee) {
      const be = $.length;
      (!Y || Y < 0) && (Y = 0), (!ee || ee < 0 || ee > be) && (ee = be);
      let Se = "";
      for (let Ne = Y; Ne < ee; ++Ne)
        Se += Rt[$[Ne]];
      return Se;
    }
    function W($, Y, ee) {
      const be = $.slice(Y, ee);
      let Se = "";
      for (let Ne = 0; Ne < be.length - 1; Ne += 2)
        Se += String.fromCharCode(be[Ne] + be[Ne + 1] * 256);
      return Se;
    }
    l.prototype.slice = function($, Y) {
      const ee = this.length;
      $ = ~~$, Y = Y === void 0 ? ee : ~~Y, $ < 0 ? ($ += ee, $ < 0 && ($ = 0)) : $ > ee && ($ = ee), Y < 0 ? (Y += ee, Y < 0 && (Y = 0)) : Y > ee && (Y = ee), Y < $ && (Y = $);
      const be = this.subarray($, Y);
      return Object.setPrototypeOf(be, l.prototype), be;
    };
    function V($, Y, ee) {
      if ($ % 1 !== 0 || $ < 0) throw new RangeError("offset is not uint");
      if ($ + Y > ee) throw new RangeError("Trying to access beyond buffer length");
    }
    l.prototype.readUintLE = l.prototype.readUIntLE = function($, Y, ee) {
      $ = $ >>> 0, Y = Y >>> 0, ee || V($, Y, this.length);
      let be = this[$], Se = 1, Ne = 0;
      for (; ++Ne < Y && (Se *= 256); )
        be += this[$ + Ne] * Se;
      return be;
    }, l.prototype.readUintBE = l.prototype.readUIntBE = function($, Y, ee) {
      $ = $ >>> 0, Y = Y >>> 0, ee || V($, Y, this.length);
      let be = this[$ + --Y], Se = 1;
      for (; Y > 0 && (Se *= 256); )
        be += this[$ + --Y] * Se;
      return be;
    }, l.prototype.readUint8 = l.prototype.readUInt8 = function($, Y) {
      return $ = $ >>> 0, Y || V($, 1, this.length), this[$];
    }, l.prototype.readUint16LE = l.prototype.readUInt16LE = function($, Y) {
      return $ = $ >>> 0, Y || V($, 2, this.length), this[$] | this[$ + 1] << 8;
    }, l.prototype.readUint16BE = l.prototype.readUInt16BE = function($, Y) {
      return $ = $ >>> 0, Y || V($, 2, this.length), this[$] << 8 | this[$ + 1];
    }, l.prototype.readUint32LE = l.prototype.readUInt32LE = function($, Y) {
      return $ = $ >>> 0, Y || V($, 4, this.length), (this[$] | this[$ + 1] << 8 | this[$ + 2] << 16) + this[$ + 3] * 16777216;
    }, l.prototype.readUint32BE = l.prototype.readUInt32BE = function($, Y) {
      return $ = $ >>> 0, Y || V($, 4, this.length), this[$] * 16777216 + (this[$ + 1] << 16 | this[$ + 2] << 8 | this[$ + 3]);
    }, l.prototype.readBigUInt64LE = It(function($) {
      $ = $ >>> 0, ke($, "offset");
      const Y = this[$], ee = this[$ + 7];
      (Y === void 0 || ee === void 0) && Pe($, this.length - 8);
      const be = Y + this[++$] * 2 ** 8 + this[++$] * 2 ** 16 + this[++$] * 2 ** 24, Se = this[++$] + this[++$] * 2 ** 8 + this[++$] * 2 ** 16 + ee * 2 ** 24;
      return BigInt(be) + (BigInt(Se) << BigInt(32));
    }), l.prototype.readBigUInt64BE = It(function($) {
      $ = $ >>> 0, ke($, "offset");
      const Y = this[$], ee = this[$ + 7];
      (Y === void 0 || ee === void 0) && Pe($, this.length - 8);
      const be = Y * 2 ** 24 + this[++$] * 2 ** 16 + this[++$] * 2 ** 8 + this[++$], Se = this[++$] * 2 ** 24 + this[++$] * 2 ** 16 + this[++$] * 2 ** 8 + ee;
      return (BigInt(be) << BigInt(32)) + BigInt(Se);
    }), l.prototype.readIntLE = function($, Y, ee) {
      $ = $ >>> 0, Y = Y >>> 0, ee || V($, Y, this.length);
      let be = this[$], Se = 1, Ne = 0;
      for (; ++Ne < Y && (Se *= 256); )
        be += this[$ + Ne] * Se;
      return Se *= 128, be >= Se && (be -= Math.pow(2, 8 * Y)), be;
    }, l.prototype.readIntBE = function($, Y, ee) {
      $ = $ >>> 0, Y = Y >>> 0, ee || V($, Y, this.length);
      let be = Y, Se = 1, Ne = this[$ + --be];
      for (; be > 0 && (Se *= 256); )
        Ne += this[$ + --be] * Se;
      return Se *= 128, Ne >= Se && (Ne -= Math.pow(2, 8 * Y)), Ne;
    }, l.prototype.readInt8 = function($, Y) {
      return $ = $ >>> 0, Y || V($, 1, this.length), this[$] & 128 ? (255 - this[$] + 1) * -1 : this[$];
    }, l.prototype.readInt16LE = function($, Y) {
      $ = $ >>> 0, Y || V($, 2, this.length);
      const ee = this[$] | this[$ + 1] << 8;
      return ee & 32768 ? ee | 4294901760 : ee;
    }, l.prototype.readInt16BE = function($, Y) {
      $ = $ >>> 0, Y || V($, 2, this.length);
      const ee = this[$ + 1] | this[$] << 8;
      return ee & 32768 ? ee | 4294901760 : ee;
    }, l.prototype.readInt32LE = function($, Y) {
      return $ = $ >>> 0, Y || V($, 4, this.length), this[$] | this[$ + 1] << 8 | this[$ + 2] << 16 | this[$ + 3] << 24;
    }, l.prototype.readInt32BE = function($, Y) {
      return $ = $ >>> 0, Y || V($, 4, this.length), this[$] << 24 | this[$ + 1] << 16 | this[$ + 2] << 8 | this[$ + 3];
    }, l.prototype.readBigInt64LE = It(function($) {
      $ = $ >>> 0, ke($, "offset");
      const Y = this[$], ee = this[$ + 7];
      (Y === void 0 || ee === void 0) && Pe($, this.length - 8);
      const be = this[$ + 4] + this[$ + 5] * 2 ** 8 + this[$ + 6] * 2 ** 16 + (ee << 24);
      return (BigInt(be) << BigInt(32)) + BigInt(Y + this[++$] * 2 ** 8 + this[++$] * 2 ** 16 + this[++$] * 2 ** 24);
    }), l.prototype.readBigInt64BE = It(function($) {
      $ = $ >>> 0, ke($, "offset");
      const Y = this[$], ee = this[$ + 7];
      (Y === void 0 || ee === void 0) && Pe($, this.length - 8);
      const be = (Y << 24) + // Overflow
      this[++$] * 2 ** 16 + this[++$] * 2 ** 8 + this[++$];
      return (BigInt(be) << BigInt(32)) + BigInt(this[++$] * 2 ** 24 + this[++$] * 2 ** 16 + this[++$] * 2 ** 8 + ee);
    }), l.prototype.readFloatLE = function($, Y) {
      return $ = $ >>> 0, Y || V($, 4, this.length), t.read(this, $, true, 23, 4);
    }, l.prototype.readFloatBE = function($, Y) {
      return $ = $ >>> 0, Y || V($, 4, this.length), t.read(this, $, false, 23, 4);
    }, l.prototype.readDoubleLE = function($, Y) {
      return $ = $ >>> 0, Y || V($, 8, this.length), t.read(this, $, true, 52, 8);
    }, l.prototype.readDoubleBE = function($, Y) {
      return $ = $ >>> 0, Y || V($, 8, this.length), t.read(this, $, false, 52, 8);
    };
    function K($, Y, ee, be, Se, Ne) {
      if (!l.isBuffer($)) throw new TypeError('"buffer" argument must be a Buffer instance');
      if (Y > Se || Y < Ne) throw new RangeError('"value" argument is out of bounds');
      if (ee + be > $.length) throw new RangeError("Index out of range");
    }
    l.prototype.writeUintLE = l.prototype.writeUIntLE = function($, Y, ee, be) {
      if ($ = +$, Y = Y >>> 0, ee = ee >>> 0, !be) {
        const je = Math.pow(2, 8 * ee) - 1;
        K(this, $, Y, ee, je, 0);
      }
      let Se = 1, Ne = 0;
      for (this[Y] = $ & 255; ++Ne < ee && (Se *= 256); )
        this[Y + Ne] = $ / Se & 255;
      return Y + ee;
    }, l.prototype.writeUintBE = l.prototype.writeUIntBE = function($, Y, ee, be) {
      if ($ = +$, Y = Y >>> 0, ee = ee >>> 0, !be) {
        const je = Math.pow(2, 8 * ee) - 1;
        K(this, $, Y, ee, je, 0);
      }
      let Se = ee - 1, Ne = 1;
      for (this[Y + Se] = $ & 255; --Se >= 0 && (Ne *= 256); )
        this[Y + Se] = $ / Ne & 255;
      return Y + ee;
    }, l.prototype.writeUint8 = l.prototype.writeUInt8 = function($, Y, ee) {
      return $ = +$, Y = Y >>> 0, ee || K(this, $, Y, 1, 255, 0), this[Y] = $ & 255, Y + 1;
    }, l.prototype.writeUint16LE = l.prototype.writeUInt16LE = function($, Y, ee) {
      return $ = +$, Y = Y >>> 0, ee || K(this, $, Y, 2, 65535, 0), this[Y] = $ & 255, this[Y + 1] = $ >>> 8, Y + 2;
    }, l.prototype.writeUint16BE = l.prototype.writeUInt16BE = function($, Y, ee) {
      return $ = +$, Y = Y >>> 0, ee || K(this, $, Y, 2, 65535, 0), this[Y] = $ >>> 8, this[Y + 1] = $ & 255, Y + 2;
    }, l.prototype.writeUint32LE = l.prototype.writeUInt32LE = function($, Y, ee) {
      return $ = +$, Y = Y >>> 0, ee || K(this, $, Y, 4, 4294967295, 0), this[Y + 3] = $ >>> 24, this[Y + 2] = $ >>> 16, this[Y + 1] = $ >>> 8, this[Y] = $ & 255, Y + 4;
    }, l.prototype.writeUint32BE = l.prototype.writeUInt32BE = function($, Y, ee) {
      return $ = +$, Y = Y >>> 0, ee || K(this, $, Y, 4, 4294967295, 0), this[Y] = $ >>> 24, this[Y + 1] = $ >>> 16, this[Y + 2] = $ >>> 8, this[Y + 3] = $ & 255, Y + 4;
    };
    function J($, Y, ee, be, Se) {
      Ae(Y, be, Se, $, ee, 7);
      let Ne = Number(Y & BigInt(4294967295));
      $[ee++] = Ne, Ne = Ne >> 8, $[ee++] = Ne, Ne = Ne >> 8, $[ee++] = Ne, Ne = Ne >> 8, $[ee++] = Ne;
      let je = Number(Y >> BigInt(32) & BigInt(4294967295));
      return $[ee++] = je, je = je >> 8, $[ee++] = je, je = je >> 8, $[ee++] = je, je = je >> 8, $[ee++] = je, ee;
    }
    function ae($, Y, ee, be, Se) {
      Ae(Y, be, Se, $, ee, 7);
      let Ne = Number(Y & BigInt(4294967295));
      $[ee + 7] = Ne, Ne = Ne >> 8, $[ee + 6] = Ne, Ne = Ne >> 8, $[ee + 5] = Ne, Ne = Ne >> 8, $[ee + 4] = Ne;
      let je = Number(Y >> BigInt(32) & BigInt(4294967295));
      return $[ee + 3] = je, je = je >> 8, $[ee + 2] = je, je = je >> 8, $[ee + 1] = je, je = je >> 8, $[ee] = je, ee + 8;
    }
    l.prototype.writeBigUInt64LE = It(function($, Y = 0) {
      return J(this, $, Y, BigInt(0), BigInt("0xffffffffffffffff"));
    }), l.prototype.writeBigUInt64BE = It(function($, Y = 0) {
      return ae(this, $, Y, BigInt(0), BigInt("0xffffffffffffffff"));
    }), l.prototype.writeIntLE = function($, Y, ee, be) {
      if ($ = +$, Y = Y >>> 0, !be) {
        const pt = Math.pow(2, 8 * ee - 1);
        K(this, $, Y, ee, pt - 1, -pt);
      }
      let Se = 0, Ne = 1, je = 0;
      for (this[Y] = $ & 255; ++Se < ee && (Ne *= 256); )
        $ < 0 && je === 0 && this[Y + Se - 1] !== 0 && (je = 1), this[Y + Se] = ($ / Ne >> 0) - je & 255;
      return Y + ee;
    }, l.prototype.writeIntBE = function($, Y, ee, be) {
      if ($ = +$, Y = Y >>> 0, !be) {
        const pt = Math.pow(2, 8 * ee - 1);
        K(this, $, Y, ee, pt - 1, -pt);
      }
      let Se = ee - 1, Ne = 1, je = 0;
      for (this[Y + Se] = $ & 255; --Se >= 0 && (Ne *= 256); )
        $ < 0 && je === 0 && this[Y + Se + 1] !== 0 && (je = 1), this[Y + Se] = ($ / Ne >> 0) - je & 255;
      return Y + ee;
    }, l.prototype.writeInt8 = function($, Y, ee) {
      return $ = +$, Y = Y >>> 0, ee || K(this, $, Y, 1, 127, -128), $ < 0 && ($ = 255 + $ + 1), this[Y] = $ & 255, Y + 1;
    }, l.prototype.writeInt16LE = function($, Y, ee) {
      return $ = +$, Y = Y >>> 0, ee || K(this, $, Y, 2, 32767, -32768), this[Y] = $ & 255, this[Y + 1] = $ >>> 8, Y + 2;
    }, l.prototype.writeInt16BE = function($, Y, ee) {
      return $ = +$, Y = Y >>> 0, ee || K(this, $, Y, 2, 32767, -32768), this[Y] = $ >>> 8, this[Y + 1] = $ & 255, Y + 2;
    }, l.prototype.writeInt32LE = function($, Y, ee) {
      return $ = +$, Y = Y >>> 0, ee || K(this, $, Y, 4, 2147483647, -2147483648), this[Y] = $ & 255, this[Y + 1] = $ >>> 8, this[Y + 2] = $ >>> 16, this[Y + 3] = $ >>> 24, Y + 4;
    }, l.prototype.writeInt32BE = function($, Y, ee) {
      return $ = +$, Y = Y >>> 0, ee || K(this, $, Y, 4, 2147483647, -2147483648), $ < 0 && ($ = 4294967295 + $ + 1), this[Y] = $ >>> 24, this[Y + 1] = $ >>> 16, this[Y + 2] = $ >>> 8, this[Y + 3] = $ & 255, Y + 4;
    }, l.prototype.writeBigInt64LE = It(function($, Y = 0) {
      return J(this, $, Y, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    }), l.prototype.writeBigInt64BE = It(function($, Y = 0) {
      return ae(this, $, Y, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function re($, Y, ee, be, Se, Ne) {
      if (ee + be > $.length) throw new RangeError("Index out of range");
      if (ee < 0) throw new RangeError("Index out of range");
    }
    function he($, Y, ee, be, Se) {
      return Y = +Y, ee = ee >>> 0, Se || re($, Y, ee, 4), t.write($, Y, ee, be, 23, 4), ee + 4;
    }
    l.prototype.writeFloatLE = function($, Y, ee) {
      return he(this, $, Y, true, ee);
    }, l.prototype.writeFloatBE = function($, Y, ee) {
      return he(this, $, Y, false, ee);
    };
    function ge($, Y, ee, be, Se) {
      return Y = +Y, ee = ee >>> 0, Se || re($, Y, ee, 8), t.write($, Y, ee, be, 52, 8), ee + 8;
    }
    l.prototype.writeDoubleLE = function($, Y, ee) {
      return ge(this, $, Y, true, ee);
    }, l.prototype.writeDoubleBE = function($, Y, ee) {
      return ge(this, $, Y, false, ee);
    }, l.prototype.copy = function($, Y, ee, be) {
      if (!l.isBuffer($)) throw new TypeError("argument should be a Buffer");
      if (ee || (ee = 0), !be && be !== 0 && (be = this.length), Y >= $.length && (Y = $.length), Y || (Y = 0), be > 0 && be < ee && (be = ee), be === ee || $.length === 0 || this.length === 0) return 0;
      if (Y < 0)
        throw new RangeError("targetStart out of bounds");
      if (ee < 0 || ee >= this.length) throw new RangeError("Index out of range");
      if (be < 0) throw new RangeError("sourceEnd out of bounds");
      be > this.length && (be = this.length), $.length - Y < be - ee && (be = $.length - Y + ee);
      const Se = be - ee;
      return this === $ && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(Y, ee, be) : Uint8Array.prototype.set.call(
        $,
        this.subarray(ee, be),
        Y
      ), Se;
    }, l.prototype.fill = function($, Y, ee, be) {
      if (typeof $ == "string") {
        if (typeof Y == "string" ? (be = Y, Y = 0, ee = this.length) : typeof ee == "string" && (be = ee, ee = this.length), be !== void 0 && typeof be != "string")
          throw new TypeError("encoding must be a string");
        if (typeof be == "string" && !l.isEncoding(be))
          throw new TypeError("Unknown encoding: " + be);
        if ($.length === 1) {
          const Ne = $.charCodeAt(0);
          (be === "utf8" && Ne < 128 || be === "latin1") && ($ = Ne);
        }
      } else typeof $ == "number" ? $ = $ & 255 : typeof $ == "boolean" && ($ = Number($));
      if (Y < 0 || this.length < Y || this.length < ee)
        throw new RangeError("Out of range index");
      if (ee <= Y)
        return this;
      Y = Y >>> 0, ee = ee === void 0 ? this.length : ee >>> 0, $ || ($ = 0);
      let Se;
      if (typeof $ == "number")
        for (Se = Y; Se < ee; ++Se)
          this[Se] = $;
      else {
        const Ne = l.isBuffer($) ? $ : l.from($, be), je = Ne.length;
        if (je === 0)
          throw new TypeError('The value "' + $ + '" is invalid for argument "value"');
        for (Se = 0; Se < ee - Y; ++Se)
          this[Se + Y] = Ne[Se % je];
      }
      return this;
    };
    const me = {};
    function Te($, Y, ee) {
      me[$] = class extends ee {
        constructor() {
          super(), Object.defineProperty(this, "message", {
            value: Y.apply(this, arguments),
            writable: true,
            configurable: true
          }), this.name = `${this.name} [${$}]`, this.stack, delete this.name;
        }
        get code() {
          return $;
        }
        set code(be) {
          Object.defineProperty(this, "code", {
            configurable: true,
            enumerable: true,
            value: be,
            writable: true
          });
        }
        toString() {
          return `${this.name} [${$}]: ${this.message}`;
        }
      };
    }
    Te(
      "ERR_BUFFER_OUT_OF_BOUNDS",
      function($) {
        return $ ? `${$} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
      },
      RangeError
    ), Te(
      "ERR_INVALID_ARG_TYPE",
      function($, Y) {
        return `The "${$}" argument must be of type number. Received type ${typeof Y}`;
      },
      TypeError
    ), Te(
      "ERR_OUT_OF_RANGE",
      function($, Y, ee) {
        let be = `The value of "${$}" is out of range.`, Se = ee;
        return Number.isInteger(ee) && Math.abs(ee) > 2 ** 32 ? Se = _e(String(ee)) : typeof ee == "bigint" && (Se = String(ee), (ee > BigInt(2) ** BigInt(32) || ee < -(BigInt(2) ** BigInt(32))) && (Se = _e(Se)), Se += "n"), be += ` It must be ${Y}. Received ${Se}`, be;
      },
      RangeError
    );
    function _e($) {
      let Y = "", ee = $.length;
      const be = $[0] === "-" ? 1 : 0;
      for (; ee >= be + 4; ee -= 3)
        Y = `_${$.slice(ee - 3, ee)}${Y}`;
      return `${$.slice(0, ee)}${Y}`;
    }
    function ye($, Y, ee) {
      ke(Y, "offset"), ($[Y] === void 0 || $[Y + ee] === void 0) && Pe(Y, $.length - (ee + 1));
    }
    function Ae($, Y, ee, be, Se, Ne) {
      if ($ > ee || $ < Y) {
        const je = typeof Y == "bigint" ? "n" : "";
        let pt;
        throw Y === 0 || Y === BigInt(0) ? pt = `>= 0${je} and < 2${je} ** ${(Ne + 1) * 8}${je}` : pt = `>= -(2${je} ** ${(Ne + 1) * 8 - 1}${je}) and < 2 ** ${(Ne + 1) * 8 - 1}${je}`, new me.ERR_OUT_OF_RANGE("value", pt, $);
      }
      ye(be, Se, Ne);
    }
    function ke($, Y) {
      if (typeof $ != "number")
        throw new me.ERR_INVALID_ARG_TYPE(Y, "number", $);
    }
    function Pe($, Y, ee) {
      throw Math.floor($) !== $ ? (ke($, ee), new me.ERR_OUT_OF_RANGE("offset", "an integer", $)) : Y < 0 ? new me.ERR_BUFFER_OUT_OF_BOUNDS() : new me.ERR_OUT_OF_RANGE(
        "offset",
        `>= 0 and <= ${Y}`,
        $
      );
    }
    const Ee = /[^+/0-9A-Za-z-_]/g;
    function Oe($) {
      if ($ = $.split("=")[0], $ = $.trim().replace(Ee, ""), $.length < 2) return "";
      for (; $.length % 4 !== 0; )
        $ = $ + "=";
      return $;
    }
    function $e($, Y) {
      Y = Y || 1 / 0;
      let ee;
      const be = $.length;
      let Se = null;
      const Ne = [];
      for (let je = 0; je < be; ++je) {
        if (ee = $.charCodeAt(je), ee > 55295 && ee < 57344) {
          if (!Se) {
            if (ee > 56319) {
              (Y -= 3) > -1 && Ne.push(239, 191, 189);
              continue;
            } else if (je + 1 === be) {
              (Y -= 3) > -1 && Ne.push(239, 191, 189);
              continue;
            }
            Se = ee;
            continue;
          }
          if (ee < 56320) {
            (Y -= 3) > -1 && Ne.push(239, 191, 189), Se = ee;
            continue;
          }
          ee = (Se - 55296 << 10 | ee - 56320) + 65536;
        } else Se && (Y -= 3) > -1 && Ne.push(239, 191, 189);
        if (Se = null, ee < 128) {
          if ((Y -= 1) < 0) break;
          Ne.push(ee);
        } else if (ee < 2048) {
          if ((Y -= 2) < 0) break;
          Ne.push(
            ee >> 6 | 192,
            ee & 63 | 128
          );
        } else if (ee < 65536) {
          if ((Y -= 3) < 0) break;
          Ne.push(
            ee >> 12 | 224,
            ee >> 6 & 63 | 128,
            ee & 63 | 128
          );
        } else if (ee < 1114112) {
          if ((Y -= 4) < 0) break;
          Ne.push(
            ee >> 18 | 240,
            ee >> 12 & 63 | 128,
            ee >> 6 & 63 | 128,
            ee & 63 | 128
          );
        } else
          throw new Error("Invalid code point");
      }
      return Ne;
    }
    function gt($) {
      const Y = [];
      for (let ee = 0; ee < $.length; ++ee)
        Y.push($.charCodeAt(ee) & 255);
      return Y;
    }
    function xt($, Y) {
      let ee, be, Se;
      const Ne = [];
      for (let je = 0; je < $.length && !((Y -= 2) < 0); ++je)
        ee = $.charCodeAt(je), be = ee >> 8, Se = ee % 256, Ne.push(Se), Ne.push(be);
      return Ne;
    }
    function vt($) {
      return e.toByteArray(Oe($));
    }
    function Xe($, Y, ee, be) {
      let Se;
      for (Se = 0; Se < be && !(Se + ee >= Y.length || Se >= $.length); ++Se)
        Y[Se + ee] = $[Se];
      return Se;
    }
    function at($, Y) {
      return $ instanceof Y || $ != null && $.constructor != null && $.constructor.name != null && $.constructor.name === Y.name;
    }
    function ct($) {
      return $ !== $;
    }
    const Rt = function() {
      const $ = "0123456789abcdef", Y = new Array(256);
      for (let ee = 0; ee < 16; ++ee) {
        const be = ee * 16;
        for (let Se = 0; Se < 16; ++Se)
          Y[be + Se] = $[ee] + $[Se];
      }
      return Y;
    }();
    function It($) {
      return typeof BigInt > "u" ? er : $;
    }
    function er() {
      throw new Error("BigInt not supported");
    }
  }(buffer$1)), buffer$1;
}
var uniq, hasRequiredUniq;
function requireUniq() {
  if (hasRequiredUniq) return uniq;
  hasRequiredUniq = 1;
  function i2(r, a) {
    for (var s = 1, u = r.length, l = r[0], c = r[0], d = 1; d < u; ++d)
      if (c = l, l = r[d], a(l, c)) {
        if (d === s) {
          s++;
          continue;
        }
        r[s++] = l;
      }
    return r.length = s, r;
  }
  function e(r) {
    for (var a = 1, s = r.length, u = r[0], l = r[0], c = 1; c < s; ++c, l = u)
      if (l = u, u = r[c], u !== l) {
        if (c === a) {
          a++;
          continue;
        }
        r[a++] = u;
      }
    return r.length = a, r;
  }
  function t(r, a, s) {
    return r.length === 0 ? r : a ? (s || r.sort(a), i2(r, a)) : (s || r.sort(), e(r));
  }
  return uniq = t, uniq;
}
var compile, hasRequiredCompile;
function requireCompile() {
  if (hasRequiredCompile) return compile;
  hasRequiredCompile = 1;
  var i2 = requireUniq();
  function e(l, c, d) {
    var f = l.length, p = c.arrayArgs.length, m = c.indexArgs.length > 0, y = [], x = [], g = 0, _ = 0, T, E;
    for (T = 0; T < f; ++T)
      x.push(["i", T, "=0"].join(""));
    for (E = 0; E < p; ++E)
      for (T = 0; T < f; ++T)
        _ = g, g = l[T], T === 0 ? x.push(["d", E, "s", T, "=t", E, "p", g].join("")) : x.push(["d", E, "s", T, "=(t", E, "p", g, "-s", _, "*t", E, "p", _, ")"].join(""));
    for (x.length > 0 && y.push("var " + x.join(",")), T = f - 1; T >= 0; --T)
      g = l[T], y.push(["for(i", T, "=0;i", T, "<s", g, ";++i", T, "){"].join(""));
    for (y.push(d), T = 0; T < f; ++T) {
      for (_ = g, g = l[T], E = 0; E < p; ++E)
        y.push(["p", E, "+=d", E, "s", T].join(""));
      m && (T > 0 && y.push(["index[", _, "]-=s", _].join("")), y.push(["++index[", g, "]"].join(""))), y.push("}");
    }
    return y.join(`
`);
  }
  function t(l, c, d, f) {
    for (var p = c.length, m = d.arrayArgs.length, y = d.blockSize, x = d.indexArgs.length > 0, g = [], _ = 0; _ < m; ++_)
      g.push(["var offset", _, "=p", _].join(""));
    for (var _ = l; _ < p; ++_)
      g.push(["for(var j" + _ + "=SS[", c[_], "]|0;j", _, ">0;){"].join("")), g.push(["if(j", _, "<", y, "){"].join("")), g.push(["s", c[_], "=j", _].join("")), g.push(["j", _, "=0"].join("")), g.push(["}else{s", c[_], "=", y].join("")), g.push(["j", _, "-=", y, "}"].join("")), x && g.push(["index[", c[_], "]=j", _].join(""));
    for (var _ = 0; _ < m; ++_) {
      for (var T = ["offset" + _], E = l; E < p; ++E)
        T.push(["j", E, "*t", _, "p", c[E]].join(""));
      g.push(["p", _, "=(", T.join("+"), ")"].join(""));
    }
    g.push(e(c, d, f));
    for (var _ = l; _ < p; ++_)
      g.push("}");
    return g.join(`
`);
  }
  function r(l) {
    for (var c = 0, d = l[0].length; c < d; ) {
      for (var f = 1; f < l.length; ++f)
        if (l[f][c] !== l[0][c])
          return c;
      ++c;
    }
    return c;
  }
  function a(l, c, d) {
    for (var f = l.body, p = [], m = [], y = 0; y < l.args.length; ++y) {
      var x = l.args[y];
      if (!(x.count <= 0)) {
        var g = new RegExp(x.name, "g"), _ = "", T = c.arrayArgs.indexOf(y);
        switch (c.argTypes[y]) {
          case "offset":
            var E = c.offsetArgIndex.indexOf(y), b = c.offsetArgs[E];
            T = b.array, _ = "+q" + E;
          case "array":
            _ = "p" + T + _;
            var C = "l" + y, w = "a" + T;
            if (c.arrayBlockIndices[T] === 0)
              x.count === 1 ? d[T] === "generic" ? x.lvalue ? (p.push(["var ", C, "=", w, ".get(", _, ")"].join("")), f = f.replace(g, C), m.push([w, ".set(", _, ",", C, ")"].join(""))) : f = f.replace(g, [w, ".get(", _, ")"].join("")) : f = f.replace(g, [w, "[", _, "]"].join("")) : d[T] === "generic" ? (p.push(["var ", C, "=", w, ".get(", _, ")"].join("")), f = f.replace(g, C), x.lvalue && m.push([w, ".set(", _, ",", C, ")"].join(""))) : (p.push(["var ", C, "=", w, "[", _, "]"].join("")), f = f.replace(g, C), x.lvalue && m.push([w, "[", _, "]=", C].join("")));
            else {
              for (var A = [x.name], S = [_], F = 0; F < Math.abs(c.arrayBlockIndices[T]); F++)
                A.push("\\s*\\[([^\\]]+)\\]"), S.push("$" + (F + 1) + "*t" + T + "b" + F);
              if (g = new RegExp(A.join(""), "g"), _ = S.join("+"), d[T] === "generic")
                throw new Error("cwise: Generic arrays not supported in combination with blocks!");
              f = f.replace(g, [w, "[", _, "]"].join(""));
            }
            break;
          case "scalar":
            f = f.replace(g, "Y" + c.scalarArgs.indexOf(y));
            break;
          case "index":
            f = f.replace(g, "index");
            break;
          case "shape":
            f = f.replace(g, "shape");
            break;
        }
      }
    }
    return [p.join(`
`), f, m.join(`
`)].join(`
`).trim();
  }
  function s(l) {
    for (var c = new Array(l.length), d = true, f = 0; f < l.length; ++f) {
      var p = l[f], m = p.match(/\d+/);
      m ? m = m[0] : m = "", p.charAt(0) === 0 ? c[f] = "u" + p.charAt(1) + m : c[f] = p.charAt(0) + m, f > 0 && (d = d && c[f] === c[f - 1]);
    }
    return d ? c[0] : c.join("");
  }
  function u(l, c) {
    for (var d = c[1].length - Math.abs(l.arrayBlockIndices[0]) | 0, f = new Array(l.arrayArgs.length), p = new Array(l.arrayArgs.length), m = 0; m < l.arrayArgs.length; ++m)
      p[m] = c[2 * m], f[m] = c[2 * m + 1];
    for (var y = [], x = [], g = [], _ = [], T = [], m = 0; m < l.arrayArgs.length; ++m) {
      l.arrayBlockIndices[m] < 0 ? (g.push(0), _.push(d), y.push(d), x.push(d + l.arrayBlockIndices[m])) : (g.push(l.arrayBlockIndices[m]), _.push(l.arrayBlockIndices[m] + d), y.push(0), x.push(l.arrayBlockIndices[m]));
      for (var E = [], b = 0; b < f[m].length; b++)
        g[m] <= f[m][b] && f[m][b] < _[m] && E.push(f[m][b] - g[m]);
      T.push(E);
    }
    for (var C = ["SS"], w = ["'use strict'"], A = [], b = 0; b < d; ++b)
      A.push(["s", b, "=SS[", b, "]"].join(""));
    for (var m = 0; m < l.arrayArgs.length; ++m) {
      C.push("a" + m), C.push("t" + m), C.push("p" + m);
      for (var b = 0; b < d; ++b)
        A.push(["t", m, "p", b, "=t", m, "[", g[m] + b, "]"].join(""));
      for (var b = 0; b < Math.abs(l.arrayBlockIndices[m]); ++b)
        A.push(["t", m, "b", b, "=t", m, "[", y[m] + b, "]"].join(""));
    }
    for (var m = 0; m < l.scalarArgs.length; ++m)
      C.push("Y" + m);
    if (l.shapeArgs.length > 0 && A.push("shape=SS.slice(0)"), l.indexArgs.length > 0) {
      for (var S = new Array(d), m = 0; m < d; ++m)
        S[m] = "0";
      A.push(["index=[", S.join(","), "]"].join(""));
    }
    for (var m = 0; m < l.offsetArgs.length; ++m) {
      for (var F = l.offsetArgs[m], M = [], b = 0; b < F.offset.length; ++b)
        F.offset[b] !== 0 && (F.offset[b] === 1 ? M.push(["t", F.array, "p", b].join("")) : M.push([F.offset[b], "*t", F.array, "p", b].join("")));
      M.length === 0 ? A.push("q" + m + "=0") : A.push(["q", m, "=", M.join("+")].join(""));
    }
    var U = i2([].concat(l.pre.thisVars).concat(l.body.thisVars).concat(l.post.thisVars));
    A = A.concat(U), A.length > 0 && w.push("var " + A.join(","));
    for (var m = 0; m < l.arrayArgs.length; ++m)
      w.push("p" + m + "|=0");
    l.pre.body.length > 3 && w.push(a(l.pre, l, p));
    var B = a(l.body, l, p), q = r(T);
    q < d ? w.push(t(q, T[0], l, B)) : w.push(e(T[0], l, B)), l.post.body.length > 3 && w.push(a(l.post, l, p)), l.debug && console.log("-----Generated cwise routine for ", c, `:
` + w.join(`
`) + `
----------`);
    var z = [l.funcName || "unnamed", "_cwise_loop_", f[0].join("s"), "m", q, s(p)].join(""), D = new Function(["function ", z, "(", C.join(","), "){", w.join(`
`), "} return ", z].join(""));
    return D();
  }
  return compile = u, compile;
}
var thunk, hasRequiredThunk;
function requireThunk() {
  if (hasRequiredThunk) return thunk;
  hasRequiredThunk = 1;
  var i2 = requireCompile();
  function e(t) {
    var r = ["'use strict'", "var CACHED={}"], a = [], s = t.funcName + "_cwise_thunk";
    r.push(["return function ", s, "(", t.shimArgs.join(","), "){"].join(""));
    for (var u = [], l = [], c = [[
      "array",
      t.arrayArgs[0],
      ".shape.slice(",
      // Slice shape so that we only retain the shape over which we iterate (which gets passed to the cwise operator as SS).
      Math.max(0, t.arrayBlockIndices[0]),
      t.arrayBlockIndices[0] < 0 ? "," + t.arrayBlockIndices[0] + ")" : ")"
    ].join("")], d = [], f = [], p = 0; p < t.arrayArgs.length; ++p) {
      var m = t.arrayArgs[p];
      a.push([
        "t",
        m,
        "=array",
        m,
        ".dtype,",
        "r",
        m,
        "=array",
        m,
        ".order"
      ].join("")), u.push("t" + m), u.push("r" + m), l.push("t" + m), l.push("r" + m + ".join()"), c.push("array" + m + ".data"), c.push("array" + m + ".stride"), c.push("array" + m + ".offset|0"), p > 0 && (d.push("array" + t.arrayArgs[0] + ".shape.length===array" + m + ".shape.length+" + (Math.abs(t.arrayBlockIndices[0]) - Math.abs(t.arrayBlockIndices[p]))), f.push("array" + t.arrayArgs[0] + ".shape[shapeIndex+" + Math.max(0, t.arrayBlockIndices[0]) + "]===array" + m + ".shape[shapeIndex+" + Math.max(0, t.arrayBlockIndices[p]) + "]"));
    }
    t.arrayArgs.length > 1 && (r.push("if (!(" + d.join(" && ") + ")) throw new Error('cwise: Arrays do not all have the same dimensionality!')"), r.push("for(var shapeIndex=array" + t.arrayArgs[0] + ".shape.length-" + Math.abs(t.arrayBlockIndices[0]) + "; shapeIndex-->0;) {"), r.push("if (!(" + f.join(" && ") + ")) throw new Error('cwise: Arrays do not all have the same shape!')"), r.push("}"));
    for (var p = 0; p < t.scalarArgs.length; ++p)
      c.push("scalar" + t.scalarArgs[p]);
    a.push(["type=[", l.join(","), "].join()"].join("")), a.push("proc=CACHED[type]"), r.push("var " + a.join(",")), r.push([
      "if(!proc){",
      "CACHED[type]=proc=compile([",
      u.join(","),
      "])}",
      "return proc(",
      c.join(","),
      ")}"
    ].join("")), t.debug && console.log(`-----Generated thunk:
` + r.join(`
`) + `
----------`);
    var y = new Function("compile", r.join(`
`));
    return y(i2.bind(void 0, t));
  }
  return thunk = e, thunk;
}
var compiler, hasRequiredCompiler;
function requireCompiler() {
  if (hasRequiredCompiler) return compiler;
  hasRequiredCompiler = 1;
  var i2 = requireThunk();
  function e() {
    this.argTypes = [], this.shimArgs = [], this.arrayArgs = [], this.arrayBlockIndices = [], this.scalarArgs = [], this.offsetArgs = [], this.offsetArgIndex = [], this.indexArgs = [], this.shapeArgs = [], this.funcName = "", this.pre = null, this.body = null, this.post = null, this.debug = false;
  }
  function t(r) {
    var a = new e();
    a.pre = r.pre, a.body = r.body, a.post = r.post;
    var s = r.args.slice(0);
    a.argTypes = s;
    for (var u = 0; u < s.length; ++u) {
      var l = s[u];
      if (l === "array" || typeof l == "object" && l.blockIndices) {
        if (a.argTypes[u] = "array", a.arrayArgs.push(u), a.arrayBlockIndices.push(l.blockIndices ? l.blockIndices : 0), a.shimArgs.push("array" + u), u < a.pre.args.length && a.pre.args[u].count > 0)
          throw new Error("cwise: pre() block may not reference array args");
        if (u < a.post.args.length && a.post.args[u].count > 0)
          throw new Error("cwise: post() block may not reference array args");
      } else if (l === "scalar")
        a.scalarArgs.push(u), a.shimArgs.push("scalar" + u);
      else if (l === "index") {
        if (a.indexArgs.push(u), u < a.pre.args.length && a.pre.args[u].count > 0)
          throw new Error("cwise: pre() block may not reference array index");
        if (u < a.body.args.length && a.body.args[u].lvalue)
          throw new Error("cwise: body() block may not write to array index");
        if (u < a.post.args.length && a.post.args[u].count > 0)
          throw new Error("cwise: post() block may not reference array index");
      } else if (l === "shape") {
        if (a.shapeArgs.push(u), u < a.pre.args.length && a.pre.args[u].lvalue)
          throw new Error("cwise: pre() block may not write to array shape");
        if (u < a.body.args.length && a.body.args[u].lvalue)
          throw new Error("cwise: body() block may not write to array shape");
        if (u < a.post.args.length && a.post.args[u].lvalue)
          throw new Error("cwise: post() block may not write to array shape");
      } else if (typeof l == "object" && l.offset)
        a.argTypes[u] = "offset", a.offsetArgs.push({ array: l.array, offset: l.offset }), a.offsetArgIndex.push(u);
      else
        throw new Error("cwise: Unknown argument type " + s[u]);
    }
    if (a.arrayArgs.length <= 0)
      throw new Error("cwise: No array arguments specified");
    if (a.pre.args.length > s.length)
      throw new Error("cwise: Too many arguments in pre() block");
    if (a.body.args.length > s.length)
      throw new Error("cwise: Too many arguments in body() block");
    if (a.post.args.length > s.length)
      throw new Error("cwise: Too many arguments in post() block");
    return a.debug = !!r.printCode || !!r.debug, a.funcName = r.funcName || "cwise", a.blockSize = r.blockSize || 64, i2(a);
  }
  return compiler = t, compiler;
}
var doConvert, hasRequiredDoConvert;
function requireDoConvert() {
  return hasRequiredDoConvert || (hasRequiredDoConvert = 1, doConvert = requireCompiler()({ args: ["array", "scalar", "index"], pre: { body: "{}", args: [], thisVars: [], localVars: [] }, body: { body: `{
var _inline_1_v=_inline_1_arg1_,_inline_1_i
for(_inline_1_i=0;_inline_1_i<_inline_1_arg2_.length-1;++_inline_1_i) {
_inline_1_v=_inline_1_v[_inline_1_arg2_[_inline_1_i]]
}
_inline_1_arg0_=_inline_1_v[_inline_1_arg2_[_inline_1_arg2_.length-1]]
}`, args: [{ name: "_inline_1_arg0_", lvalue: true, rvalue: false, count: 1 }, { name: "_inline_1_arg1_", lvalue: false, rvalue: true, count: 1 }, { name: "_inline_1_arg2_", lvalue: false, rvalue: true, count: 4 }], thisVars: [], localVars: ["_inline_1_i", "_inline_1_v"] }, post: { body: "{}", args: [], thisVars: [], localVars: [] }, funcName: "convert", blockSize: 64 })), doConvert;
}
var convert, hasRequiredConvert;
function requireConvert() {
  if (hasRequiredConvert) return convert;
  hasRequiredConvert = 1;
  var i2 = requireNdarray(), e = requireDoConvert();
  return convert = function(t, r) {
    for (var a = [], s = t, u = 1; Array.isArray(s); )
      a.push(s.length), u *= s.length, s = s[0];
    return a.length === 0 ? i2() : (r || (r = i2(new Float64Array(u), a)), e(r, t), r);
  }, convert;
}
var through = { exports: {} }, hasRequiredThrough;
function requireThrough() {
  return hasRequiredThrough || (hasRequiredThrough = 1, function(i2, e) {
    var t = require$$1$1;
    i2.exports = r, r.through = r;
    function r(a, s, u) {
      a = a || function(x) {
        this.queue(x);
      }, s = s || function() {
        this.queue(null);
      };
      var l = false, c = false, d = [], f = false, p = new t();
      p.readable = p.writable = true, p.paused = false, p.autoDestroy = !(u && u.autoDestroy === false), p.write = function(x) {
        return a.call(this, x), !p.paused;
      };
      function m() {
        for (; d.length && !p.paused; ) {
          var x = d.shift();
          if (x === null)
            return p.emit("end");
          p.emit("data", x);
        }
      }
      p.queue = p.push = function(x) {
        return f || (x === null && (f = true), d.push(x), m()), p;
      }, p.on("end", function() {
        p.readable = false, !p.writable && p.autoDestroy && process.nextTick(function() {
          p.destroy();
        });
      });
      function y() {
        p.writable = false, s.call(p), !p.readable && p.autoDestroy && p.destroy();
      }
      return p.end = function(x) {
        if (!l)
          return l = true, arguments.length && p.write(x), y(), p;
      }, p.destroy = function() {
        if (!c)
          return c = true, l = true, d.length = 0, p.writable = p.readable = false, p.emit("close"), p;
      }, p.pause = function() {
        if (!p.paused)
          return p.paused = true, p;
      }, p.resume = function() {
        return p.paused && (p.paused = false, p.emit("resume")), m(), p.paused || p.emit("drain"), p;
      }, p;
    }
  }(through)), through.exports;
}
var dataUriToBuffer_1, hasRequiredDataUriToBuffer;
function requireDataUriToBuffer() {
  if (hasRequiredDataUriToBuffer) return dataUriToBuffer_1;
  hasRequiredDataUriToBuffer = 1, dataUriToBuffer_1 = i2;
  function i2(e) {
    if (!/^data\:/i.test(e))
      throw new TypeError('`uri` does not appear to be a Data URI (must begin with "data:")');
    e = e.replace(/\r?\n/g, "");
    var t = e.indexOf(",");
    if (t === -1 || t <= 4) throw new TypeError("malformed data: URI");
    for (var r = e.substring(5, t).split(";"), a = false, s = "US-ASCII", u = 0; u < r.length; u++)
      r[u] == "base64" ? a = true : r[u].indexOf("charset=") == 0 && (s = r[u].substring(8));
    var l = unescape(e.substring(t + 1)), c = a ? "base64" : "ascii", d = new Buffer(l, c);
    return d.type = r[0] || "text/plain", d.charset = s, d;
  }
  return dataUriToBuffer_1;
}
var domPixels, hasRequiredDomPixels;
function requireDomPixels() {
  if (hasRequiredDomPixels) return domPixels;
  hasRequiredDomPixels = 1;
  var i2 = require$$1$1, e = requireNdarray(), t = requireOmggif().GifReader, r = requireBuffer$1().Buffer;
  requireConvert(), requireThrough();
  var a = requireDataUriToBuffer();
  function s(f, p) {
    var m = new Image();
    m.crossOrigin = "Anonymous", m.onload = function() {
      var y = document.createElement("canvas");
      y.width = m.width, y.height = m.height;
      var x = y.getContext("2d");
      x.drawImage(m, 0, 0);
      var g = x.getImageData(0, 0, m.width, m.height);
      p(null, e(new Uint8Array(g.data), [m.width, m.height, 4], [4, 4 * m.width, 1], 0));
    }, m.onerror = function(y) {
      p(y);
    }, m.src = f;
  }
  function u(f, p) {
    var m;
    try {
      m = new t(f);
    } catch (E) {
      p(E);
      return;
    }
    if (m.numFrames() > 0) {
      var y = [m.numFrames(), m.height, m.width, 4], x = new Uint8Array(y[0] * y[1] * y[2] * y[3]), g = e(x, y), _ = [];
      try {
        for (var T = 0; T < m.numFrames(); ++T)
          m.decodeAndBlitFrameRGBA(T, x.subarray(
            g.index(T, 0, 0, 0),
            g.index(T + 1, 0, 0, 0)
          )), _.push(m.frameInfo(T));
      } catch (E) {
        p(E);
        return;
      }
      p(null, g.transpose(0, 2, 1), _);
    } else {
      var y = [m.height, m.width, 4], x = new Uint8Array(y[0] * y[1] * y[2]), g = e(x, y);
      try {
        m.decodeAndBlitFrameRGBA(0, x);
      } catch (w) {
        p(w);
        return;
      }
      p(null, g.transpose(1, 0));
    }
  }
  function l(f, p) {
    var m = new XMLHttpRequest();
    m.open("GET", f, true), m.responseType = "arraybuffer", m.overrideMimeType && m.overrideMimeType("application/binary"), m.onerror = function(y) {
      p(y);
    }, m.onload = function() {
      if (m.readyState === 4) {
        var y = new Uint8Array(m.response);
        u(y, p);
      }
    }, m.send();
  }
  function c(f) {
    if (f[0] === void 0) {
      for (var p = f.length, m = new Uint8Array(p), y = 0; y < p; ++y)
        m[y] = f.get(y);
      return m;
    } else
      return new Uint8Array(f);
  }
  function d(f, p) {
    process.nextTick(function() {
      try {
        var m = a(f);
        m ? u(c(m), p) : p(new Error("Error parsing data URI"));
      } catch (y) {
        p(y);
      }
    });
  }
  return domPixels = function(f, p, m) {
    m || (m = p, p = "");
    var y = i2.extname(f);
    switch (p || y.toUpperCase()) {
      case ".GIF":
        l(f, m);
        break;
      default:
        r.isBuffer(f) && (f = "data:" + p + ";base64," + f.toString("base64")), f.indexOf("data:image/gif;") === 0 ? d(f, m) : s(f, m);
    }
  }, domPixels;
}
var utils, hasRequiredUtils;
function requireUtils() {
  if (hasRequiredUtils) return utils;
  hasRequiredUtils = 1;
  const { isBrowser: i2 } = requireLib$5(), e = {}, t = {
    safeRequire(r) {
      try {
        return commonjsRequire(r);
      } catch {
      }
    },
    nodeRequire(r) {
      return i2 ? null : t.safeRequire(r);
    },
    isUA(r) {
      return navigator && navigator.userAgent.toLowerCase().includes(r.toLowerCase());
    },
    async getPixels(r, a) {
      const s = requireDomPixels();
      return new Promise((u, l) => {
        s(r, a, (c, d, f) => {
          if (c) return l(c);
          u({ pixels: d, frameInfo: f });
        });
      });
    },
    /**
     * await all func done
     * @public
     */
    awaitMap(r, a) {
      const s = [];
      for (let u = 0; u < r.length; u++)
        s.push(a(r[u]));
      return Promise.all(s);
    },
    dmap(r, a, s = []) {
      const u = Array.isArray(r) ? [] : {}, l = Array.isArray(r) ? r.map((c, d) => [d, c]) : Object.entries(r);
      for (const [c, d] of l) {
        const f = [...s, c];
        typeof d == "object" ? u[c] = this.dmap(d, a, f) : u[c] = a(d, c, f);
      }
      return u;
    },
    /**
     * Generate auto-increment id based on type
     * @param {string} type - type
     * @return {string} id xxxx_10
     * @public
     */
    genId(r) {
      return e[r] === void 0 && (e[r] = 1), r + "_" + String(e[r]++);
    },
    /**
     * Generate 24-bit random number
     * @return {string} uid adsfUsdfn2
     * @public
     */
    genUuid() {
      return Math.random().toString(36).substr(-8) + Math.random().toString(36).substr(-8);
    },
    /**
     * Delete an element of the array
     * @param {array} arr - target array
     * @param {any} elem - an element
     * @return {array} Original array
     * @public
     */
    deleteArrayElement(r, a) {
      const s = r.indexOf(a);
      return s > -1 && r.splice(s, 1), r;
    },
    /**
     * Swap two elements of an array
     * @param {array} arr - target array
     * @param {any} elem1 - an element
     * @param {any} elem1 - other element
     * @return {array} Original array
     * @public
     */
    swapArrayElement(r, a, s) {
      const u = typeof a == "number" ? a : r.indexOf(a), l = typeof s == "number" ? s : r.indexOf(s), c = r[u];
      return r[u] = r[l], r[l] = c, r;
    },
    /**
     * Determine whether an array is a 2-latitude array
     * @param {array} arr - target array
     * @return {boolean} is a 2-latitude array
     * @public
     */
    isArray2D(r) {
      return !r || !r.length ? false : Array.isArray(r[0]);
    },
    /**
     * Remove undefined empty elements
     * @param {object} obj - target object
     * @return {object} target object
     * @public
     */
    deleteUndefined(r) {
      for (let a in r)
        r[a] === void 0 && delete r[a];
      return r;
    },
    /**
     * Destroy the elements in object
     * @param {object} obj - target object
     * @public
     */
    destroyObj(r) {
      if (typeof r == "object")
        for (let a in r)
          delete r[a];
    },
    /**
     * Merge one object into another object (not including the key to be removed)
     * @param {object} obj1 - target object
     * @param {object} obj2 - source object
     * @return {object} result object
     * @public
     */
    mergeExclude(r, a = {}, s = []) {
      for (let u in a)
        s.indexOf(u) < 0 && a[u] !== void 0 && (r[u] = a[u]);
      return r;
    },
    insertSubArray(r, a, s) {
      if (s) {
        r.splice(a, 1);
        for (let u = 0; u < s.length; u++)
          r.splice(a, 0, s[0]);
      }
    },
    /**
     * Calculate the even number of the input value
     * @param {object} num - input value
     * @return {object} result value
     * @public
     */
    courtship(r) {
      return r = r >> 0, r % 2 === 0 ? r : r - 1;
    },
    floor(r, a = 2) {
      const s = Math.pow(10, a);
      return Math.floor(r * s) / s;
    },
    sleep(r) {
      return new Promise((a) => setTimeout(a, r));
    },
    /**
     * Fix wrong file directory path // -> /
     * @param {string} path - file directory path
     * @public
     */
    fixFolderPath(r) {
      return r.replace(/\/\//gi, "/");
    },
    /**
     * toHash - Convert string to hash code
     * @param {string} str - Input string
     * @return {string} result hash string
     * @public
     */
    toHash(r) {
      let a = 0, s, u;
      for (s = 0; s < r.length; s++)
        u = r.charCodeAt(s), a = (a << 5) - a + u, a |= 0;
      return a + "";
    },
    getErrStack(r = {}) {
      return r = typeof r == "string" ? { message: r } : r, r = r.message || r.stack || r, r;
    },
    storage: {}
  };
  return utils = t, utils;
}
var mtempy = { exports: {} }, cryptoRandomString, hasRequiredCryptoRandomString;
function requireCryptoRandomString() {
  if (hasRequiredCryptoRandomString) return cryptoRandomString;
  hasRequiredCryptoRandomString = 1;
  const i2 = require$$1$1;
  return cryptoRandomString = (e) => {
    if (!Number.isFinite(e))
      throw new TypeError("Expected a finite number");
    return i2.randomBytes(Math.ceil(e / 2)).toString("hex").slice(0, e);
  }, cryptoRandomString;
}
var uniqueString, hasRequiredUniqueString;
function requireUniqueString() {
  if (hasRequiredUniqueString) return uniqueString;
  hasRequiredUniqueString = 1;
  const i2 = requireCryptoRandomString();
  return uniqueString = () => i2(32), uniqueString;
}
var tempDir, hasRequiredTempDir;
function requireTempDir() {
  if (hasRequiredTempDir) return tempDir;
  hasRequiredTempDir = 1;
  const i2 = require$$1$1, e = require$$1$1, t = Symbol.for("__RESOLVED_TEMP_DIRECTORY__");
  return window[t] || Object.defineProperty(window, t, {
    value: i2.realpathSync(e.tmpdir())
  }), tempDir = window[t], tempDir;
}
var isStream_1, hasRequiredIsStream;
function requireIsStream() {
  if (hasRequiredIsStream) return isStream_1;
  hasRequiredIsStream = 1;
  const i2 = (e) => e !== null && typeof e == "object" && typeof e.pipe == "function";
  return i2.writable = (e) => i2(e) && e.writable !== false && typeof e._write == "function" && typeof e._writableState == "object", i2.readable = (e) => i2(e) && e.readable !== false && typeof e._read == "function" && typeof e._readableState == "object", i2.duplex = (e) => i2.writable(e) && i2.readable(e), i2.transform = (e) => i2.duplex(e) && typeof e._transform == "function", isStream_1 = i2, isStream_1;
}
var util$1 = {}, isBufferBrowser$1, hasRequiredIsBufferBrowser$1;
function requireIsBufferBrowser$1() {
  return hasRequiredIsBufferBrowser$1 || (hasRequiredIsBufferBrowser$1 = 1, isBufferBrowser$1 = function(i2) {
    return i2 && typeof i2 == "object" && typeof i2.copy == "function" && typeof i2.fill == "function" && typeof i2.readUInt8 == "function";
  }), isBufferBrowser$1;
}
var inherits_browser$2 = { exports: {} }, hasRequiredInherits_browser$2;
function requireInherits_browser$2() {
  return hasRequiredInherits_browser$2 || (hasRequiredInherits_browser$2 = 1, typeof Object.create == "function" ? inherits_browser$2.exports = function(i2, e) {
    i2.super_ = e, i2.prototype = Object.create(e.prototype, {
      constructor: {
        value: i2,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  } : inherits_browser$2.exports = function(i2, e) {
    i2.super_ = e;
    var t = function() {
    };
    t.prototype = e.prototype, i2.prototype = new t(), i2.prototype.constructor = i2;
  }), inherits_browser$2.exports;
}
var hasRequiredUtil$1;
function requireUtil$1() {
  return hasRequiredUtil$1 || (hasRequiredUtil$1 = 1, function(i2) {
    var e = /%[sdj%]/g;
    i2.format = function(I) {
      if (!b(I)) {
        for (var P = [], G = 0; G < arguments.length; G++)
          P.push(a(arguments[G]));
        return P.join(" ");
      }
      for (var G = 1, W = arguments, V = W.length, K = String(I).replace(e, function(re) {
        if (re === "%%") return "%";
        if (G >= V) return re;
        switch (re) {
          case "%s":
            return String(W[G++]);
          case "%d":
            return Number(W[G++]);
          case "%j":
            try {
              return JSON.stringify(W[G++]);
            } catch {
              return "[Circular]";
            }
          default:
            return re;
        }
      }), J = W[G]; G < V; J = W[++G])
        _(J) || !S(J) ? K += " " + J : K += " " + a(J);
      return K;
    }, i2.deprecate = function(I, P) {
      if (w(window.process))
        return function() {
          return i2.deprecate(I, P).apply(this, arguments);
        };
      if (process.noDeprecation === true)
        return I;
      var G = false;
      function W() {
        if (!G) {
          if (process.throwDeprecation)
            throw new Error(P);
          process.traceDeprecation ? console.trace(P) : console.error(P), G = true;
        }
        return I.apply(this, arguments);
      }
      return W;
    };
    var t = {}, r;
    i2.debuglog = function(I) {
      if (w(r) && (r = ""), I = I.toUpperCase(), !t[I])
        if (new RegExp("\\b" + I + "\\b", "i").test(r)) {
          var P = process.pid;
          t[I] = function() {
            var G = i2.format.apply(i2, arguments);
            console.error("%s %d: %s", I, P, G);
          };
        } else
          t[I] = function() {
          };
      return t[I];
    };
    function a(I, P) {
      var G = {
        seen: [],
        stylize: u
      };
      return arguments.length >= 3 && (G.depth = arguments[2]), arguments.length >= 4 && (G.colors = arguments[3]), g(P) ? G.showHidden = P : P && i2._extend(G, P), w(G.showHidden) && (G.showHidden = false), w(G.depth) && (G.depth = 2), w(G.colors) && (G.colors = false), w(G.customInspect) && (G.customInspect = true), G.colors && (G.stylize = s), c(G, I, G.depth);
    }
    i2.inspect = a, a.colors = {
      bold: [1, 22],
      italic: [3, 23],
      underline: [4, 24],
      inverse: [7, 27],
      white: [37, 39],
      grey: [90, 39],
      black: [30, 39],
      blue: [34, 39],
      cyan: [36, 39],
      green: [32, 39],
      magenta: [35, 39],
      red: [31, 39],
      yellow: [33, 39]
    }, a.styles = {
      special: "cyan",
      number: "yellow",
      boolean: "yellow",
      undefined: "grey",
      null: "bold",
      string: "green",
      date: "magenta",
      // "name": intentionally not styling
      regexp: "red"
    };
    function s(I, P) {
      var G = a.styles[P];
      return G ? "\x1B[" + a.colors[G][0] + "m" + I + "\x1B[" + a.colors[G][1] + "m" : I;
    }
    function u(I, P) {
      return I;
    }
    function l(I) {
      var P = {};
      return I.forEach(function(G, W) {
        P[G] = true;
      }), P;
    }
    function c(I, P, G) {
      if (I.customInspect && P && U(P.inspect) && // Filter out the util module, it's inspect function is special
      P.inspect !== i2.inspect && // Also filter out any prototype objects using the circular check.
      !(P.constructor && P.constructor.prototype === P)) {
        var W = P.inspect(G, I);
        return b(W) || (W = c(I, W, G)), W;
      }
      var V = d(I, P);
      if (V)
        return V;
      var K = Object.keys(P), J = l(K);
      if (I.showHidden && (K = Object.getOwnPropertyNames(P)), M(P) && (K.indexOf("message") >= 0 || K.indexOf("description") >= 0))
        return f(P);
      if (K.length === 0) {
        if (U(P)) {
          var ae = P.name ? ": " + P.name : "";
          return I.stylize("[Function" + ae + "]", "special");
        }
        if (A(P))
          return I.stylize(RegExp.prototype.toString.call(P), "regexp");
        if (F(P))
          return I.stylize(Date.prototype.toString.call(P), "date");
        if (M(P))
          return f(P);
      }
      var re = "", he = false, ge = ["{", "}"];
      if (x(P) && (he = true, ge = ["[", "]"]), U(P)) {
        var me = P.name ? ": " + P.name : "";
        re = " [Function" + me + "]";
      }
      if (A(P) && (re = " " + RegExp.prototype.toString.call(P)), F(P) && (re = " " + Date.prototype.toUTCString.call(P)), M(P) && (re = " " + f(P)), K.length === 0 && (!he || P.length == 0))
        return ge[0] + re + ge[1];
      if (G < 0)
        return A(P) ? I.stylize(RegExp.prototype.toString.call(P), "regexp") : I.stylize("[Object]", "special");
      I.seen.push(P);
      var Te;
      return he ? Te = p(I, P, G, J, K) : Te = K.map(function(_e) {
        return m(I, P, G, J, _e, he);
      }), I.seen.pop(), y(Te, re, ge);
    }
    function d(I, P) {
      if (w(P))
        return I.stylize("undefined", "undefined");
      if (b(P)) {
        var G = "'" + JSON.stringify(P).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return I.stylize(G, "string");
      }
      if (E(P))
        return I.stylize("" + P, "number");
      if (g(P))
        return I.stylize("" + P, "boolean");
      if (_(P))
        return I.stylize("null", "null");
    }
    function f(I) {
      return "[" + Error.prototype.toString.call(I) + "]";
    }
    function p(I, P, G, W, V) {
      for (var K = [], J = 0, ae = P.length; J < ae; ++J)
        k(P, String(J)) ? K.push(m(
          I,
          P,
          G,
          W,
          String(J),
          true
        )) : K.push("");
      return V.forEach(function(re) {
        re.match(/^\d+$/) || K.push(m(
          I,
          P,
          G,
          W,
          re,
          true
        ));
      }), K;
    }
    function m(I, P, G, W, V, K) {
      var J, ae, re;
      if (re = Object.getOwnPropertyDescriptor(P, V) || { value: P[V] }, re.get ? re.set ? ae = I.stylize("[Getter/Setter]", "special") : ae = I.stylize("[Getter]", "special") : re.set && (ae = I.stylize("[Setter]", "special")), k(W, V) || (J = "[" + V + "]"), ae || (I.seen.indexOf(re.value) < 0 ? (_(G) ? ae = c(I, re.value, null) : ae = c(I, re.value, G - 1), ae.indexOf(`
`) > -1 && (K ? ae = ae.split(`
`).map(function(he) {
        return "  " + he;
      }).join(`
`).substr(2) : ae = `
` + ae.split(`
`).map(function(he) {
        return "   " + he;
      }).join(`
`))) : ae = I.stylize("[Circular]", "special")), w(J)) {
        if (K && V.match(/^\d+$/))
          return ae;
        J = JSON.stringify("" + V), J.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (J = J.substr(1, J.length - 2), J = I.stylize(J, "name")) : (J = J.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), J = I.stylize(J, "string"));
      }
      return J + ": " + ae;
    }
    function y(I, P, G) {
      var W = I.reduce(function(V, K) {
        return K.indexOf(`
`) >= 0, V + K.replace(/\u001b\[\d\d?m/g, "").length + 1;
      }, 0);
      return W > 60 ? G[0] + (P === "" ? "" : P + `
 `) + " " + I.join(`,
  `) + " " + G[1] : G[0] + P + " " + I.join(", ") + " " + G[1];
    }
    function x(I) {
      return Array.isArray(I);
    }
    i2.isArray = x;
    function g(I) {
      return typeof I == "boolean";
    }
    i2.isBoolean = g;
    function _(I) {
      return I === null;
    }
    i2.isNull = _;
    function T(I) {
      return I == null;
    }
    i2.isNullOrUndefined = T;
    function E(I) {
      return typeof I == "number";
    }
    i2.isNumber = E;
    function b(I) {
      return typeof I == "string";
    }
    i2.isString = b;
    function C(I) {
      return typeof I == "symbol";
    }
    i2.isSymbol = C;
    function w(I) {
      return I === void 0;
    }
    i2.isUndefined = w;
    function A(I) {
      return S(I) && q(I) === "[object RegExp]";
    }
    i2.isRegExp = A;
    function S(I) {
      return typeof I == "object" && I !== null;
    }
    i2.isObject = S;
    function F(I) {
      return S(I) && q(I) === "[object Date]";
    }
    i2.isDate = F;
    function M(I) {
      return S(I) && (q(I) === "[object Error]" || I instanceof Error);
    }
    i2.isError = M;
    function U(I) {
      return typeof I == "function";
    }
    i2.isFunction = U;
    function B(I) {
      return I === null || typeof I == "boolean" || typeof I == "number" || typeof I == "string" || typeof I == "symbol" || // ES6 symbol
      typeof I > "u";
    }
    i2.isPrimitive = B, i2.isBuffer = requireIsBufferBrowser$1();
    function q(I) {
      return Object.prototype.toString.call(I);
    }
    function z(I) {
      return I < 10 ? "0" + I.toString(10) : I.toString(10);
    }
    var D = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ];
    function X() {
      var I = /* @__PURE__ */ new Date(), P = [
        z(I.getHours()),
        z(I.getMinutes()),
        z(I.getSeconds())
      ].join(":");
      return [I.getDate(), D[I.getMonth()], P].join(" ");
    }
    i2.log = function() {
      console.log("%s - %s", X(), i2.format.apply(i2, arguments));
    }, i2.inherits = requireInherits_browser$2(), i2._extend = function(I, P) {
      if (!P || !S(P)) return I;
      for (var G = Object.keys(P), W = G.length; W--; )
        I[G[W]] = P[G[W]];
      return I;
    };
    function k(I, P) {
      return Object.prototype.hasOwnProperty.call(I, P);
    }
  }(util$1)), util$1;
}
/*!
 * glob-option-error | MIT (c) Shinnosuke Watanabe
 * https://github.com/shinnn/glob-option-error
*/
var globOptionError, hasRequiredGlobOptionError;
function requireGlobOptionError() {
  if (hasRequiredGlobOptionError) return globOptionError;
  hasRequiredGlobOptionError = 1;
  const { inspect: i2 } = requireUtil$1(), e = (r) => r.name === "TypeError", t = (r, a, s) => `${r}
  ${s + 1}. ${a.message}`;
  return globOptionError = function(...r) {
    const a = r.length;
    if (a !== 1)
      throw new TypeError(`Expected 1 argument (Array<errors>), but got ${a || "no"} arguments.`);
    const [s] = r;
    if (!Array.isArray(s))
      throw new TypeError(`Expected an array of errors, but got a non-array value ${i2(s)}.`);
    const u = s.length;
    if (u === 0)
      throw new RangeError("Expected an array with at least one error, but got [] (empty array).");
    if (u === 1)
      return s[0][Symbol.iterator] = function* () {
        yield s[0];
      }, s[0];
    const l = new (s.every(e) ? TypeError : Error)(s.reduce(
      t,
      `${u} errors found in the glob options:`
    ));
    return l[Symbol.iterator] = function* () {
      for (const c of s)
        yield c;
    }, l;
  }, globOptionError;
}
/*!
 * array-to-sentence | MIT (c) Shinnosuke Watanabe
 * https://github.com/shinnn/array-to-sentence
*/
function arrayToSentence(i2, e) {
  if (!Array.isArray(i2))
    throw new TypeError(String(i2) + " is not an array. Expected an array.");
  e = e || {};
  function t(r) {
    if (typeof e[r] != "string")
      throw new TypeError(
        String(e[r]) + " is not a string. `" + r + "` option must be a string."
      );
  }
  return e.separator === void 0 ? e.separator = ", " : t("separator"), e.lastSeparator === void 0 ? e.lastSeparator = " and " : t("lastSeparator"), i2.length === 0 ? "" : i2.length === 1 ? i2[0] : i2.slice(0, -1).join(e.separator) + e.lastSeparator + i2[i2.length - 1];
}
const index_jsnext = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: arrayToSentence
}, Symbol.toStringTag, { value: "Module" })), require$$1 = /* @__PURE__ */ getAugmentedNamespace(index_jsnext);
var isPlainObj, hasRequiredIsPlainObj;
function requireIsPlainObj() {
  if (hasRequiredIsPlainObj) return isPlainObj;
  hasRequiredIsPlainObj = 1;
  var i2 = Object.prototype.toString;
  return isPlainObj = function(e) {
    var t;
    return i2.call(e) === "[object Object]" && (t = Object.getPrototypeOf(e), t === null || t === Object.getPrototypeOf({}));
  }, isPlainObj;
}
function appendType(i2) {
  return i2 === void 0 ? "undefined" : i2 === null ? "null" : String(i2) + " (" + typeof i2 + ")";
}
/*!
 * indexed-filter | MIT (c) Shinnosuke Watanabe
 * https://github.com/shinnn/indexed-filter
*/
function indexedFilter(i2, e, t) {
  if (!Array.isArray(i2))
    throw new TypeError("Expected an array to be filtered, but got a non-array value " + appendType(i2) + ".");
  if (typeof e != "function")
    throw new TypeError("Expected a filter function, but got a non-function value " + appendType(e) + ".");
  var r = [];
  return i2.forEach(function(a, s, u) {
    e.call(this, a, s, u) && r.push({
      index: s,
      value: a
    });
  }, t), r;
}
const indexedFilter$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: indexedFilter
}, Symbol.toStringTag, { value: "Module" })), require$$3 = /* @__PURE__ */ getAugmentedNamespace(indexedFilter$1);
var kindOf, hasRequiredKindOf;
function requireKindOf() {
  if (hasRequiredKindOf) return kindOf;
  hasRequiredKindOf = 1;
  var i2 = Object.prototype.toString;
  kindOf = function(f) {
    if (f === void 0) return "undefined";
    if (f === null) return "null";
    var p = typeof f;
    if (p === "boolean") return "boolean";
    if (p === "string") return "string";
    if (p === "number") return "number";
    if (p === "symbol") return "symbol";
    if (p === "function")
      return u(f) ? "generatorfunction" : "function";
    if (t(f)) return "array";
    if (d(f)) return "buffer";
    if (c(f)) return "arguments";
    if (a(f)) return "date";
    if (r(f)) return "error";
    if (s(f)) return "regexp";
    switch (e(f)) {
      case "Symbol":
        return "symbol";
      case "Promise":
        return "promise";
      case "WeakMap":
        return "weakmap";
      case "WeakSet":
        return "weakset";
      case "Map":
        return "map";
      case "Set":
        return "set";
      case "Int8Array":
        return "int8array";
      case "Uint8Array":
        return "uint8array";
      case "Uint8ClampedArray":
        return "uint8clampedarray";
      case "Int16Array":
        return "int16array";
      case "Uint16Array":
        return "uint16array";
      case "Int32Array":
        return "int32array";
      case "Uint32Array":
        return "uint32array";
      case "Float32Array":
        return "float32array";
      case "Float64Array":
        return "float64array";
    }
    if (l(f))
      return "generator";
    switch (p = i2.call(f), p) {
      case "[object Object]":
        return "object";
      case "[object Map Iterator]":
        return "mapiterator";
      case "[object Set Iterator]":
        return "setiterator";
      case "[object String Iterator]":
        return "stringiterator";
      case "[object Array Iterator]":
        return "arrayiterator";
    }
    return p.slice(8, -1).toLowerCase().replace(/\s/g, "");
  };
  function e(f) {
    return typeof f.constructor == "function" ? f.constructor.name : null;
  }
  function t(f) {
    return Array.isArray ? Array.isArray(f) : f instanceof Array;
  }
  function r(f) {
    return f instanceof Error || typeof f.message == "string" && f.constructor && typeof f.constructor.stackTraceLimit == "number";
  }
  function a(f) {
    return f instanceof Date ? true : typeof f.toDateString == "function" && typeof f.getDate == "function" && typeof f.setDate == "function";
  }
  function s(f) {
    return f instanceof RegExp ? true : typeof f.flags == "string" && typeof f.ignoreCase == "boolean" && typeof f.multiline == "boolean" && typeof f.global == "boolean";
  }
  function u(f, p) {
    return e(f) === "GeneratorFunction";
  }
  function l(f) {
    return typeof f.throw == "function" && typeof f.return == "function" && typeof f.next == "function";
  }
  function c(f) {
    try {
      if (typeof f.length == "number" && typeof f.callee == "function")
        return true;
    } catch (p) {
      if (p.message.indexOf("callee") !== -1)
        return true;
    }
    return false;
  }
  function d(f) {
    return f.constructor && typeof f.constructor.isBuffer == "function" ? f.constructor.isBuffer(f) : false;
  }
  return kindOf;
}
var inspectWithKind, hasRequiredInspectWithKind;
function requireInspectWithKind() {
  if (hasRequiredInspectWithKind) return inspectWithKind;
  hasRequiredInspectWithKind = 1;
  const i2 = requireUtil$1().inspect, e = requireKindOf(), t = /* @__PURE__ */ new Set([
    "arguments",
    "array",
    "bigint",
    "boolean",
    "date",
    "number",
    "object",
    "regexp",
    "string"
  ]);
  return inspectWithKind = function(r, a) {
    const s = e(r), u = i2(r, Object.assign({
      // eslint-disable-line prefer-object-spread
      breakLength: 1 / 0,
      maxArrayLength: 10
    }, a));
    return s === "error" ? r.toString() : !t.has(s) || u.startsWith("Observable {") ? u : `${u} (${s})`;
  }, inspectWithKind;
}
var validateGlobOpts, hasRequiredValidateGlobOpts;
function requireValidateGlobOpts() {
  if (hasRequiredValidateGlobOpts) return validateGlobOpts;
  hasRequiredValidateGlobOpts = 1;
  const { inspect: i2 } = requireUtil$1(), e = require$$1, t = requireIsPlainObj(), r = require$$3, a = requireInspectWithKind(), s = "Expected node-glob options to be an object", u = "Expected every value in the `cache` option to be true, false, 'FILE', 'DIR' or an array", l = "Expected every value in the `statCache` option to be a fs.Stats instance", c = /* @__PURE__ */ new Set(["cwd", "root"]), d = /* @__PURE__ */ new Set([
    "dot",
    "nomount",
    "mark",
    "nosort",
    "stat",
    "silent",
    "strict",
    "nounique",
    "nonull",
    "debug",
    "nobrace",
    "noglobstar",
    "noext",
    "nocase",
    "matchBase",
    "nodir",
    "follow",
    "realpath",
    "absolute"
  ]), f = /* @__PURE__ */ new Map([
    ["noMount", "nomount"],
    ["nouniq", "nounique"],
    ["noUnique", "nounique"],
    ["noNull", "nonull"],
    ["noBrace", "nobrace"],
    ["noGlobStar", "noglobstar"],
    ["noExt", "noext"],
    ["noCase", "nocase"],
    ["matchbase", "matchBase"],
    ["noDir", "nodir"],
    ["realPath", "realpath"],
    ["realPathCache", "realpathCache"],
    ["realpathCaches", "realpathCache"],
    ["realPathCaches", "realpathCache"],
    ["caches", "cache"],
    ["statcache", "statCache"],
    ["statCaches", "statCache"],
    ["symlink", "symlinks"]
  ]), p = (y) => typeof y != "function", m = (y) => `${i2(y.value)} (at ${y.index})`;
  return validateGlobOpts = function(...y) {
    const x = y.length;
    if (x > 2)
      throw new TypeError(`Expected 0, 1 or 2 arguments ([<object>, <array>]), but got ${x}.`);
    const [g, _] = y;
    if (x === 2) {
      if (!Array.isArray(_))
        throw new TypeError(`Expected an array of functions, but got a non-array value ${a(_)}.`);
      const E = r(_, p), b = E.length;
      if (b !== 0)
        throw new TypeError(`Expected every element in the array to be a function, but found ${b === 1 ? "a non-function value" : "non-function values"} in the array: ${e(E.map(m))}.`);
    }
    if (g === "")
      return [new TypeError(`${s}, but got '' (empty string).`)];
    if (!g)
      return [];
    if (typeof g != "object" || Array.isArray(g))
      return [new TypeError(`${s}, but got ${a(g)}.`)];
    const T = [];
    g.sync !== void 0 && T.push(new Error(`\`sync\` option is deprecated and there’s no need to pass any values to that option, but ${i2(g.sync)} was provided.`));
    for (const E of c) {
      const b = g[E];
      b !== void 0 && typeof g[E] != "string" && T.push(new TypeError(`node-glob expected \`${E}\` option to be a directory path (string), but got ${a(b)}.`));
    }
    for (const E of d) {
      const b = g[E];
      b !== void 0 && typeof g[E] != "boolean" && T.push(new TypeError(`node-glob expected \`${E}\` option to be a Boolean value, but got ${a(b)}.`));
    }
    if (g.nodir === true && g.mark === true && T.push(new TypeError("Expected `mark` option not to be `true` when `nodir` option is `true`, because there is no need to differentiate directory paths from file paths when `nodir` option is enabled, but got `true`.")), g.cache !== void 0)
      if (!t(g.cache))
        T.push(new TypeError(`node-glob expected \`cache\` option to be an object, but got ${a(g.cache)}.`));
      else
        for (const E of Object.keys(g.cache)) {
          const b = g.cache[E];
          typeof b != "string" ? typeof b != "boolean" && !Array.isArray(b) && T.push(new TypeError(`${u}, but found an invalid value ${a(b)} in \`${E}\` property.`)) : b !== "FILE" && b !== "DIR" && T.push(new Error(`${u}, but found an invalid string ${i2(b)} in \`${E}\` property.`));
        }
    if (g.realpathCache !== void 0)
      if (!t(g.realpathCache))
        T.push(new TypeError(`node-glob expected \`realpathCache\` option to be an object, but got ${a(g.realpathCache)}.`));
      else
        for (const E of Object.keys(g.realpathCache)) {
          const b = g.realpathCache[E];
          typeof b != "string" && T.push(new TypeError(`Expected every value in the \`realpathCache\` option to be a string, but found a non-string value ${a(b)} in \`${E}\` property.`));
        }
    if (g.statCache !== void 0)
      if (!t(g.statCache))
        T.push(new TypeError(`node-glob expected \`statCache\` option to be an object, but got ${a(g.statCache)}.`));
      else
        for (const E of Object.keys(g.statCache)) {
          const b = g.statCache[E];
          b === null || typeof b != "object" || Array.isArray(b) ? T.push(new TypeError(`${l}, but found an invalid value ${i2(b)} in \`${E}\` property.`)) : typeof b.mode != "number" && T.push(new Error(`${l}, but found an invalid object ${i2(b)} in \`${E}\` property, which doesn't have a valid file mode.`));
        }
    if (g.symlinks !== void 0)
      if (!t(g.symlinks))
        T.push(new TypeError(`node-glob expected \`symlinks\` option to be an object, but got ${a(g.symlinks)}.`));
      else
        for (const E of Object.keys(g.symlinks)) {
          const b = g.symlinks[E];
          typeof b != "boolean" && T.push(new TypeError(`Expected every value in the \`symlink\` option to be Boolean, but found an invalid value ${a(b)} in \`${E}\` property.`));
        }
    if (g.ignore !== void 0)
      if (!Array.isArray(g.ignore))
        typeof g.ignore != "string" && T.push(new TypeError(`node-glob expected \`ignore\` option to be an array or string, but got ${a(g.ignore)}.`));
      else
        for (const E of g.ignore)
          typeof E != "string" && T.push(new TypeError(`Expected every value in the \`ignore\` option to be a string, but the array includes a non-string value ${a(E)}.`));
    for (const E of Object.keys(g)) {
      const b = f.get(E);
      b !== void 0 && T.push(new Error(`node-glob doesn't have \`${E}\` option. Probably you meant \`${b}\`.`));
    }
    for (const E of _ || []) {
      const b = E(g);
      if (b) {
        if (!(b instanceof Error))
          throw new TypeError(`Expected an additional validation function to return an error, but returned ${a(b)}.`);
        T.push(b);
      }
    }
    return T;
  }, validateGlobOpts;
}
/*!
 * assert-valid-glob-opts | MIT (c) Shinnosuke Watanabe
 * https://github.com/shinnn/assert-valid-glob-opts
*/
var assertValidGlobOpts, hasRequiredAssertValidGlobOpts;
function requireAssertValidGlobOpts() {
  if (hasRequiredAssertValidGlobOpts) return assertValidGlobOpts;
  hasRequiredAssertValidGlobOpts = 1;
  const i2 = requireGlobOptionError(), e = requireValidateGlobOpts();
  return assertValidGlobOpts = function(...t) {
    const r = e(...t);
    if (r.length !== 0)
      throw new i2(r);
  }, assertValidGlobOpts;
}
var polyfills, hasRequiredPolyfills;
function requirePolyfills() {
  if (hasRequiredPolyfills) return polyfills;
  hasRequiredPolyfills = 1;
  var i2 = require$$1$1, e = process.cwd, t = null, r = define_process_env_default.GRACEFUL_FS_PLATFORM || process.platform;
  process.cwd = function() {
    return t || (t = e.call(process)), t;
  };
  try {
    process.cwd();
  } catch {
  }
  if (typeof process.chdir == "function") {
    var a = process.chdir;
    process.chdir = function(u) {
      t = null, a.call(process, u);
    }, Object.setPrototypeOf && Object.setPrototypeOf(process.chdir, a);
  }
  polyfills = s;
  function s(u) {
    i2.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./) && l(u), u.lutimes || c(u), u.chown = p(u.chown), u.fchown = p(u.fchown), u.lchown = p(u.lchown), u.chmod = d(u.chmod), u.fchmod = d(u.fchmod), u.lchmod = d(u.lchmod), u.chownSync = m(u.chownSync), u.fchownSync = m(u.fchownSync), u.lchownSync = m(u.lchownSync), u.chmodSync = f(u.chmodSync), u.fchmodSync = f(u.fchmodSync), u.lchmodSync = f(u.lchmodSync), u.stat = y(u.stat), u.fstat = y(u.fstat), u.lstat = y(u.lstat), u.statSync = x(u.statSync), u.fstatSync = x(u.fstatSync), u.lstatSync = x(u.lstatSync), u.chmod && !u.lchmod && (u.lchmod = function(_, T, E) {
      E && process.nextTick(E);
    }, u.lchmodSync = function() {
    }), u.chown && !u.lchown && (u.lchown = function(_, T, E, b) {
      b && process.nextTick(b);
    }, u.lchownSync = function() {
    }), r === "win32" && (u.rename = typeof u.rename != "function" ? u.rename : function(_) {
      function T(E, b, C) {
        var w = Date.now(), A = 0;
        _(E, b, function S(F) {
          if (F && (F.code === "EACCES" || F.code === "EPERM" || F.code === "EBUSY") && Date.now() - w < 6e4) {
            setTimeout(function() {
              u.stat(b, function(M, U) {
                M && M.code === "ENOENT" ? _(E, b, S) : C(F);
              });
            }, A), A < 100 && (A += 10);
            return;
          }
          C && C(F);
        });
      }
      return Object.setPrototypeOf && Object.setPrototypeOf(T, _), T;
    }(u.rename)), u.read = typeof u.read != "function" ? u.read : function(_) {
      function T(E, b, C, w, A, S) {
        var F;
        if (S && typeof S == "function") {
          var M = 0;
          F = function(U, B, q) {
            if (U && U.code === "EAGAIN" && M < 10)
              return M++, _.call(u, E, b, C, w, A, F);
            S.apply(this, arguments);
          };
        }
        return _.call(u, E, b, C, w, A, F);
      }
      return Object.setPrototypeOf && Object.setPrototypeOf(T, _), T;
    }(u.read), u.readSync = typeof u.readSync != "function" ? u.readSync : /* @__PURE__ */ function(_) {
      return function(T, E, b, C, w) {
        for (var A = 0; ; )
          try {
            return _.call(u, T, E, b, C, w);
          } catch (S) {
            if (S.code === "EAGAIN" && A < 10) {
              A++;
              continue;
            }
            throw S;
          }
      };
    }(u.readSync);
    function l(_) {
      _.lchmod = function(T, E, b) {
        _.open(
          T,
          i2.O_WRONLY | i2.O_SYMLINK,
          E,
          function(C, w) {
            if (C) {
              b && b(C);
              return;
            }
            _.fchmod(w, E, function(A) {
              _.close(w, function(S) {
                b && b(A || S);
              });
            });
          }
        );
      }, _.lchmodSync = function(T, E) {
        var b = _.openSync(T, i2.O_WRONLY | i2.O_SYMLINK, E), C = true, w;
        try {
          w = _.fchmodSync(b, E), C = false;
        } finally {
          if (C)
            try {
              _.closeSync(b);
            } catch {
            }
          else
            _.closeSync(b);
        }
        return w;
      };
    }
    function c(_) {
      i2.hasOwnProperty("O_SYMLINK") && _.futimes ? (_.lutimes = function(T, E, b, C) {
        _.open(T, i2.O_SYMLINK, function(w, A) {
          if (w) {
            C && C(w);
            return;
          }
          _.futimes(A, E, b, function(S) {
            _.close(A, function(F) {
              C && C(S || F);
            });
          });
        });
      }, _.lutimesSync = function(T, E, b) {
        var C = _.openSync(T, i2.O_SYMLINK), w, A = true;
        try {
          w = _.futimesSync(C, E, b), A = false;
        } finally {
          if (A)
            try {
              _.closeSync(C);
            } catch {
            }
          else
            _.closeSync(C);
        }
        return w;
      }) : _.futimes && (_.lutimes = function(T, E, b, C) {
        C && process.nextTick(C);
      }, _.lutimesSync = function() {
      });
    }
    function d(_) {
      return _ && function(T, E, b) {
        return _.call(u, T, E, function(C) {
          g(C) && (C = null), b && b.apply(this, arguments);
        });
      };
    }
    function f(_) {
      return _ && function(T, E) {
        try {
          return _.call(u, T, E);
        } catch (b) {
          if (!g(b)) throw b;
        }
      };
    }
    function p(_) {
      return _ && function(T, E, b, C) {
        return _.call(u, T, E, b, function(w) {
          g(w) && (w = null), C && C.apply(this, arguments);
        });
      };
    }
    function m(_) {
      return _ && function(T, E, b) {
        try {
          return _.call(u, T, E, b);
        } catch (C) {
          if (!g(C)) throw C;
        }
      };
    }
    function y(_) {
      return _ && function(T, E, b) {
        typeof E == "function" && (b = E, E = null);
        function C(w, A) {
          A && (A.uid < 0 && (A.uid += 4294967296), A.gid < 0 && (A.gid += 4294967296)), b && b.apply(this, arguments);
        }
        return E ? _.call(u, T, E, C) : _.call(u, T, C);
      };
    }
    function x(_) {
      return _ && function(T, E) {
        var b = E ? _.call(u, T, E) : _.call(u, T);
        return b && (b.uid < 0 && (b.uid += 4294967296), b.gid < 0 && (b.gid += 4294967296)), b;
      };
    }
    function g(_) {
      if (!_ || _.code === "ENOSYS")
        return true;
      var T = !process.getuid || process.getuid() !== 0;
      return !!(T && (_.code === "EINVAL" || _.code === "EPERM"));
    }
  }
  return polyfills;
}
var legacyStreams, hasRequiredLegacyStreams;
function requireLegacyStreams() {
  if (hasRequiredLegacyStreams) return legacyStreams;
  hasRequiredLegacyStreams = 1;
  var i2 = require$$1$1.Stream;
  legacyStreams = e;
  function e(t) {
    return {
      ReadStream: r,
      WriteStream: a
    };
    function r(s, u) {
      if (!(this instanceof r)) return new r(s, u);
      i2.call(this);
      var l = this;
      this.path = s, this.fd = null, this.readable = true, this.paused = false, this.flags = "r", this.mode = 438, this.bufferSize = 64 * 1024, u = u || {};
      for (var c = Object.keys(u), d = 0, f = c.length; d < f; d++) {
        var p = c[d];
        this[p] = u[p];
      }
      if (this.encoding && this.setEncoding(this.encoding), this.start !== void 0) {
        if (typeof this.start != "number")
          throw TypeError("start must be a Number");
        if (this.end === void 0)
          this.end = 1 / 0;
        else if (typeof this.end != "number")
          throw TypeError("end must be a Number");
        if (this.start > this.end)
          throw new Error("start must be <= end");
        this.pos = this.start;
      }
      if (this.fd !== null) {
        process.nextTick(function() {
          l._read();
        });
        return;
      }
      t.open(this.path, this.flags, this.mode, function(m, y) {
        if (m) {
          l.emit("error", m), l.readable = false;
          return;
        }
        l.fd = y, l.emit("open", y), l._read();
      });
    }
    function a(s, u) {
      if (!(this instanceof a)) return new a(s, u);
      i2.call(this), this.path = s, this.fd = null, this.writable = true, this.flags = "w", this.encoding = "binary", this.mode = 438, this.bytesWritten = 0, u = u || {};
      for (var l = Object.keys(u), c = 0, d = l.length; c < d; c++) {
        var f = l[c];
        this[f] = u[f];
      }
      if (this.start !== void 0) {
        if (typeof this.start != "number")
          throw TypeError("start must be a Number");
        if (this.start < 0)
          throw new Error("start must be >= zero");
        this.pos = this.start;
      }
      this.busy = false, this._queue = [], this.fd === null && (this._open = t.open, this._queue.push([this._open, this.path, this.flags, this.mode, void 0]), this.flush());
    }
  }
  return legacyStreams;
}
var clone_1$1, hasRequiredClone$1;
function requireClone$1() {
  if (hasRequiredClone$1) return clone_1$1;
  hasRequiredClone$1 = 1, clone_1$1 = e;
  var i2 = Object.getPrototypeOf || function(t) {
    return t.__proto__;
  };
  function e(t) {
    if (t === null || typeof t != "object")
      return t;
    if (t instanceof Object)
      var r = { __proto__: i2(t) };
    else
      var r = /* @__PURE__ */ Object.create(null);
    return Object.getOwnPropertyNames(t).forEach(function(a) {
      Object.defineProperty(r, a, Object.getOwnPropertyDescriptor(t, a));
    }), r;
  }
  return clone_1$1;
}
var assert = { exports: {} }, util = {}, isBufferBrowser, hasRequiredIsBufferBrowser;
function requireIsBufferBrowser() {
  return hasRequiredIsBufferBrowser || (hasRequiredIsBufferBrowser = 1, isBufferBrowser = function(i2) {
    return i2 && typeof i2 == "object" && typeof i2.copy == "function" && typeof i2.fill == "function" && typeof i2.readUInt8 == "function";
  }), isBufferBrowser;
}
var inherits_browser$1 = { exports: {} }, hasRequiredInherits_browser$1;
function requireInherits_browser$1() {
  return hasRequiredInherits_browser$1 || (hasRequiredInherits_browser$1 = 1, typeof Object.create == "function" ? inherits_browser$1.exports = function(i2, e) {
    i2.super_ = e, i2.prototype = Object.create(e.prototype, {
      constructor: {
        value: i2,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  } : inherits_browser$1.exports = function(i2, e) {
    i2.super_ = e;
    var t = function() {
    };
    t.prototype = e.prototype, i2.prototype = new t(), i2.prototype.constructor = i2;
  }), inherits_browser$1.exports;
}
var hasRequiredUtil;
function requireUtil() {
  return hasRequiredUtil || (hasRequiredUtil = 1, function(i2) {
    var e = /%[sdj%]/g;
    i2.format = function(I) {
      if (!b(I)) {
        for (var P = [], G = 0; G < arguments.length; G++)
          P.push(a(arguments[G]));
        return P.join(" ");
      }
      for (var G = 1, W = arguments, V = W.length, K = String(I).replace(e, function(re) {
        if (re === "%%") return "%";
        if (G >= V) return re;
        switch (re) {
          case "%s":
            return String(W[G++]);
          case "%d":
            return Number(W[G++]);
          case "%j":
            try {
              return JSON.stringify(W[G++]);
            } catch {
              return "[Circular]";
            }
          default:
            return re;
        }
      }), J = W[G]; G < V; J = W[++G])
        _(J) || !S(J) ? K += " " + J : K += " " + a(J);
      return K;
    }, i2.deprecate = function(I, P) {
      if (w(window.process))
        return function() {
          return i2.deprecate(I, P).apply(this, arguments);
        };
      if (process.noDeprecation === true)
        return I;
      var G = false;
      function W() {
        if (!G) {
          if (process.throwDeprecation)
            throw new Error(P);
          process.traceDeprecation ? console.trace(P) : console.error(P), G = true;
        }
        return I.apply(this, arguments);
      }
      return W;
    };
    var t = {}, r;
    i2.debuglog = function(I) {
      if (w(r) && (r = ""), I = I.toUpperCase(), !t[I])
        if (new RegExp("\\b" + I + "\\b", "i").test(r)) {
          var P = process.pid;
          t[I] = function() {
            var G = i2.format.apply(i2, arguments);
            console.error("%s %d: %s", I, P, G);
          };
        } else
          t[I] = function() {
          };
      return t[I];
    };
    function a(I, P) {
      var G = {
        seen: [],
        stylize: u
      };
      return arguments.length >= 3 && (G.depth = arguments[2]), arguments.length >= 4 && (G.colors = arguments[3]), g(P) ? G.showHidden = P : P && i2._extend(G, P), w(G.showHidden) && (G.showHidden = false), w(G.depth) && (G.depth = 2), w(G.colors) && (G.colors = false), w(G.customInspect) && (G.customInspect = true), G.colors && (G.stylize = s), c(G, I, G.depth);
    }
    i2.inspect = a, a.colors = {
      bold: [1, 22],
      italic: [3, 23],
      underline: [4, 24],
      inverse: [7, 27],
      white: [37, 39],
      grey: [90, 39],
      black: [30, 39],
      blue: [34, 39],
      cyan: [36, 39],
      green: [32, 39],
      magenta: [35, 39],
      red: [31, 39],
      yellow: [33, 39]
    }, a.styles = {
      special: "cyan",
      number: "yellow",
      boolean: "yellow",
      undefined: "grey",
      null: "bold",
      string: "green",
      date: "magenta",
      // "name": intentionally not styling
      regexp: "red"
    };
    function s(I, P) {
      var G = a.styles[P];
      return G ? "\x1B[" + a.colors[G][0] + "m" + I + "\x1B[" + a.colors[G][1] + "m" : I;
    }
    function u(I, P) {
      return I;
    }
    function l(I) {
      var P = {};
      return I.forEach(function(G, W) {
        P[G] = true;
      }), P;
    }
    function c(I, P, G) {
      if (I.customInspect && P && U(P.inspect) && // Filter out the util module, it's inspect function is special
      P.inspect !== i2.inspect && // Also filter out any prototype objects using the circular check.
      !(P.constructor && P.constructor.prototype === P)) {
        var W = P.inspect(G, I);
        return b(W) || (W = c(I, W, G)), W;
      }
      var V = d(I, P);
      if (V)
        return V;
      var K = Object.keys(P), J = l(K);
      if (I.showHidden && (K = Object.getOwnPropertyNames(P)), M(P) && (K.indexOf("message") >= 0 || K.indexOf("description") >= 0))
        return f(P);
      if (K.length === 0) {
        if (U(P)) {
          var ae = P.name ? ": " + P.name : "";
          return I.stylize("[Function" + ae + "]", "special");
        }
        if (A(P))
          return I.stylize(RegExp.prototype.toString.call(P), "regexp");
        if (F(P))
          return I.stylize(Date.prototype.toString.call(P), "date");
        if (M(P))
          return f(P);
      }
      var re = "", he = false, ge = ["{", "}"];
      if (x(P) && (he = true, ge = ["[", "]"]), U(P)) {
        var me = P.name ? ": " + P.name : "";
        re = " [Function" + me + "]";
      }
      if (A(P) && (re = " " + RegExp.prototype.toString.call(P)), F(P) && (re = " " + Date.prototype.toUTCString.call(P)), M(P) && (re = " " + f(P)), K.length === 0 && (!he || P.length == 0))
        return ge[0] + re + ge[1];
      if (G < 0)
        return A(P) ? I.stylize(RegExp.prototype.toString.call(P), "regexp") : I.stylize("[Object]", "special");
      I.seen.push(P);
      var Te;
      return he ? Te = p(I, P, G, J, K) : Te = K.map(function(_e) {
        return m(I, P, G, J, _e, he);
      }), I.seen.pop(), y(Te, re, ge);
    }
    function d(I, P) {
      if (w(P))
        return I.stylize("undefined", "undefined");
      if (b(P)) {
        var G = "'" + JSON.stringify(P).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return I.stylize(G, "string");
      }
      if (E(P))
        return I.stylize("" + P, "number");
      if (g(P))
        return I.stylize("" + P, "boolean");
      if (_(P))
        return I.stylize("null", "null");
    }
    function f(I) {
      return "[" + Error.prototype.toString.call(I) + "]";
    }
    function p(I, P, G, W, V) {
      for (var K = [], J = 0, ae = P.length; J < ae; ++J)
        k(P, String(J)) ? K.push(m(
          I,
          P,
          G,
          W,
          String(J),
          true
        )) : K.push("");
      return V.forEach(function(re) {
        re.match(/^\d+$/) || K.push(m(
          I,
          P,
          G,
          W,
          re,
          true
        ));
      }), K;
    }
    function m(I, P, G, W, V, K) {
      var J, ae, re;
      if (re = Object.getOwnPropertyDescriptor(P, V) || { value: P[V] }, re.get ? re.set ? ae = I.stylize("[Getter/Setter]", "special") : ae = I.stylize("[Getter]", "special") : re.set && (ae = I.stylize("[Setter]", "special")), k(W, V) || (J = "[" + V + "]"), ae || (I.seen.indexOf(re.value) < 0 ? (_(G) ? ae = c(I, re.value, null) : ae = c(I, re.value, G - 1), ae.indexOf(`
`) > -1 && (K ? ae = ae.split(`
`).map(function(he) {
        return "  " + he;
      }).join(`
`).substr(2) : ae = `
` + ae.split(`
`).map(function(he) {
        return "   " + he;
      }).join(`
`))) : ae = I.stylize("[Circular]", "special")), w(J)) {
        if (K && V.match(/^\d+$/))
          return ae;
        J = JSON.stringify("" + V), J.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (J = J.substr(1, J.length - 2), J = I.stylize(J, "name")) : (J = J.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), J = I.stylize(J, "string"));
      }
      return J + ": " + ae;
    }
    function y(I, P, G) {
      var W = I.reduce(function(V, K) {
        return K.indexOf(`
`) >= 0, V + K.replace(/\u001b\[\d\d?m/g, "").length + 1;
      }, 0);
      return W > 60 ? G[0] + (P === "" ? "" : P + `
 `) + " " + I.join(`,
  `) + " " + G[1] : G[0] + P + " " + I.join(", ") + " " + G[1];
    }
    function x(I) {
      return Array.isArray(I);
    }
    i2.isArray = x;
    function g(I) {
      return typeof I == "boolean";
    }
    i2.isBoolean = g;
    function _(I) {
      return I === null;
    }
    i2.isNull = _;
    function T(I) {
      return I == null;
    }
    i2.isNullOrUndefined = T;
    function E(I) {
      return typeof I == "number";
    }
    i2.isNumber = E;
    function b(I) {
      return typeof I == "string";
    }
    i2.isString = b;
    function C(I) {
      return typeof I == "symbol";
    }
    i2.isSymbol = C;
    function w(I) {
      return I === void 0;
    }
    i2.isUndefined = w;
    function A(I) {
      return S(I) && q(I) === "[object RegExp]";
    }
    i2.isRegExp = A;
    function S(I) {
      return typeof I == "object" && I !== null;
    }
    i2.isObject = S;
    function F(I) {
      return S(I) && q(I) === "[object Date]";
    }
    i2.isDate = F;
    function M(I) {
      return S(I) && (q(I) === "[object Error]" || I instanceof Error);
    }
    i2.isError = M;
    function U(I) {
      return typeof I == "function";
    }
    i2.isFunction = U;
    function B(I) {
      return I === null || typeof I == "boolean" || typeof I == "number" || typeof I == "string" || typeof I == "symbol" || // ES6 symbol
      typeof I > "u";
    }
    i2.isPrimitive = B, i2.isBuffer = requireIsBufferBrowser();
    function q(I) {
      return Object.prototype.toString.call(I);
    }
    function z(I) {
      return I < 10 ? "0" + I.toString(10) : I.toString(10);
    }
    var D = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ];
    function X() {
      var I = /* @__PURE__ */ new Date(), P = [
        z(I.getHours()),
        z(I.getMinutes()),
        z(I.getSeconds())
      ].join(":");
      return [I.getDate(), D[I.getMonth()], P].join(" ");
    }
    i2.log = function() {
      console.log("%s - %s", X(), i2.format.apply(i2, arguments));
    }, i2.inherits = requireInherits_browser$1(), i2._extend = function(I, P) {
      if (!P || !S(P)) return I;
      for (var G = Object.keys(P), W = G.length; W--; )
        I[G[W]] = P[G[W]];
      return I;
    };
    function k(I, P) {
      return Object.prototype.hasOwnProperty.call(I, P);
    }
  }(util)), util;
}
var hasRequiredAssert;
function requireAssert() {
  if (hasRequiredAssert) return assert.exports;
  hasRequiredAssert = 1;
  var i2 = requireUtil(), e = Array.prototype.slice, t = Object.prototype.hasOwnProperty, r = assert.exports = c;
  r.AssertionError = function(g) {
    this.name = "AssertionError", this.actual = g.actual, this.expected = g.expected, this.operator = g.operator, g.message ? (this.message = g.message, this.generatedMessage = false) : (this.message = u(this), this.generatedMessage = true);
    var _ = g.stackStartFunction || l;
    if (Error.captureStackTrace)
      Error.captureStackTrace(this, _);
    else {
      var T = new Error();
      if (T.stack) {
        var E = T.stack, b = _.name, C = E.indexOf(`
` + b);
        if (C >= 0) {
          var w = E.indexOf(`
`, C + 1);
          E = E.substring(w + 1);
        }
        this.stack = E;
      }
    }
  }, i2.inherits(r.AssertionError, Error);
  function a(g, _) {
    return i2.isUndefined(_) ? "" + _ : i2.isNumber(_) && (isNaN(_) || !isFinite(_)) || i2.isFunction(_) || i2.isRegExp(_) ? _.toString() : _;
  }
  function s(g, _) {
    return i2.isString(g) ? g.length < _ ? g : g.slice(0, _) : g;
  }
  function u(g) {
    return s(JSON.stringify(g.actual, a), 128) + " " + g.operator + " " + s(JSON.stringify(g.expected, a), 128);
  }
  function l(g, _, T, E, b) {
    throw new r.AssertionError({
      message: T,
      actual: g,
      expected: _,
      operator: E,
      stackStartFunction: b
    });
  }
  r.fail = l;
  function c(g, _) {
    g || l(g, true, _, "==", r.ok);
  }
  r.ok = c, r.equal = function(g, _, T) {
    g != _ && l(g, _, T, "==", r.equal);
  }, r.notEqual = function(g, _, T) {
    g == _ && l(g, _, T, "!=", r.notEqual);
  }, r.deepEqual = function(g, _, T) {
    d(g, _) || l(g, _, T, "deepEqual", r.deepEqual);
  };
  function d(g, _) {
    if (g === _)
      return true;
    if (i2.isBuffer(g) && i2.isBuffer(_)) {
      if (g.length != _.length) return false;
      for (var T = 0; T < g.length; T++)
        if (g[T] !== _[T]) return false;
      return true;
    } else return i2.isDate(g) && i2.isDate(_) ? g.getTime() === _.getTime() : i2.isRegExp(g) && i2.isRegExp(_) ? g.source === _.source && g.global === _.global && g.multiline === _.multiline && g.lastIndex === _.lastIndex && g.ignoreCase === _.ignoreCase : !i2.isObject(g) && !i2.isObject(_) ? g == _ : p(g, _);
  }
  function f(g) {
    return Object.prototype.toString.call(g) == "[object Arguments]";
  }
  function p(g, _) {
    if (i2.isNullOrUndefined(g) || i2.isNullOrUndefined(_) || g.prototype !== _.prototype) return false;
    if (f(g))
      return f(_) ? (g = e.call(g), _ = e.call(_), d(g, _)) : false;
    try {
      var T = x(g), E = x(_), b, C;
    } catch {
      return false;
    }
    if (T.length != E.length)
      return false;
    for (T.sort(), E.sort(), C = T.length - 1; C >= 0; C--)
      if (T[C] != E[C])
        return false;
    for (C = T.length - 1; C >= 0; C--)
      if (b = T[C], !d(g[b], _[b])) return false;
    return true;
  }
  r.notDeepEqual = function(g, _, T) {
    d(g, _) && l(g, _, T, "notDeepEqual", r.notDeepEqual);
  }, r.strictEqual = function(g, _, T) {
    g !== _ && l(g, _, T, "===", r.strictEqual);
  }, r.notStrictEqual = function(g, _, T) {
    g === _ && l(g, _, T, "!==", r.notStrictEqual);
  };
  function m(g, _) {
    return !g || !_ ? false : Object.prototype.toString.call(_) == "[object RegExp]" ? _.test(g) : g instanceof _ ? true : _.call({}, g) === true;
  }
  function y(g, _, T, E) {
    var b;
    i2.isString(T) && (E = T, T = null);
    try {
      _();
    } catch (C) {
      b = C;
    }
    if (E = (T && T.name ? " (" + T.name + ")." : ".") + (E ? " " + E : "."), g && !b && l(b, T, "Missing expected exception" + E), !g && m(b, T) && l(b, T, "Got unwanted exception" + E), g && b && T && !m(b, T) || !g && b)
      throw b;
  }
  r.throws = function(g, _, T) {
    y.apply(this, [true].concat(e.call(arguments)));
  }, r.doesNotThrow = function(g, _) {
    y.apply(this, [false].concat(e.call(arguments)));
  }, r.ifError = function(g) {
    if (g)
      throw g;
  };
  var x = Object.keys || function(g) {
    var _ = [];
    for (var T in g)
      t.call(g, T) && _.push(T);
    return _;
  };
  return assert.exports;
}
var gracefulFs, hasRequiredGracefulFs;
function requireGracefulFs() {
  if (hasRequiredGracefulFs) return gracefulFs;
  hasRequiredGracefulFs = 1;
  var i2 = require$$1$1, e = requirePolyfills(), t = requireLegacyStreams(), r = requireClone$1(), a = requireUtil$1(), s, u;
  typeof Symbol == "function" && typeof Symbol.for == "function" ? (s = Symbol.for("graceful-fs.queue"), u = Symbol.for("graceful-fs.previous")) : (s = "___graceful-fs.queue", u = "___graceful-fs.previous");
  function l() {
  }
  function c(_, T) {
    Object.defineProperty(_, s, {
      get: function() {
        return T;
      }
    });
  }
  var d = l;
  if (a.debuglog ? d = a.debuglog("gfs4") : /\bgfs4\b/i.test("") && (d = function() {
    var _ = a.format.apply(a, arguments);
    _ = "GFS4: " + _.split(/\n/).join(`
GFS4: `), console.error(_);
  }), !i2[s]) {
    var f = window[s] || [];
    c(i2, f), i2.close = function(_) {
      function T(E, b) {
        return _.call(i2, E, function(C) {
          C || x(), typeof b == "function" && b.apply(this, arguments);
        });
      }
      return Object.defineProperty(T, u, {
        value: _
      }), T;
    }(i2.close), i2.closeSync = function(_) {
      function T(E) {
        _.apply(i2, arguments), x();
      }
      return Object.defineProperty(T, u, {
        value: _
      }), T;
    }(i2.closeSync), /\bgfs4\b/i.test("") && process.on("exit", function() {
      d(i2[s]), requireAssert().equal(i2[s].length, 0);
    });
  }
  window[s] || c(window, i2[s]), gracefulFs = p(r(i2)), define_process_env_default.TEST_GRACEFUL_FS_GLOBAL_PATCH && !i2.__patched && (gracefulFs = p(i2), i2.__patched = true);
  function p(_) {
    e(_), _.gracefulify = p, _.createReadStream = V, _.createWriteStream = K;
    var T = _.readFile;
    _.readFile = E;
    function E(re, he, ge) {
      return typeof he == "function" && (ge = he, he = null), me(re, he, ge);
      function me(Te, _e, ye, Ae) {
        return T(Te, _e, function(ke) {
          ke && (ke.code === "EMFILE" || ke.code === "ENFILE") ? m([me, [Te, _e, ye], ke, Ae || Date.now(), Date.now()]) : typeof ye == "function" && ye.apply(this, arguments);
        });
      }
    }
    var b = _.writeFile;
    _.writeFile = C;
    function C(re, he, ge, me) {
      return typeof ge == "function" && (me = ge, ge = null), Te(re, he, ge, me);
      function Te(_e, ye, Ae, ke, Pe) {
        return b(_e, ye, Ae, function(Ee) {
          Ee && (Ee.code === "EMFILE" || Ee.code === "ENFILE") ? m([Te, [_e, ye, Ae, ke], Ee, Pe || Date.now(), Date.now()]) : typeof ke == "function" && ke.apply(this, arguments);
        });
      }
    }
    var w = _.appendFile;
    w && (_.appendFile = A);
    function A(re, he, ge, me) {
      return typeof ge == "function" && (me = ge, ge = null), Te(re, he, ge, me);
      function Te(_e, ye, Ae, ke, Pe) {
        return w(_e, ye, Ae, function(Ee) {
          Ee && (Ee.code === "EMFILE" || Ee.code === "ENFILE") ? m([Te, [_e, ye, Ae, ke], Ee, Pe || Date.now(), Date.now()]) : typeof ke == "function" && ke.apply(this, arguments);
        });
      }
    }
    var S = _.copyFile;
    S && (_.copyFile = F);
    function F(re, he, ge, me) {
      return typeof ge == "function" && (me = ge, ge = 0), Te(re, he, ge, me);
      function Te(_e, ye, Ae, ke, Pe) {
        return S(_e, ye, Ae, function(Ee) {
          Ee && (Ee.code === "EMFILE" || Ee.code === "ENFILE") ? m([Te, [_e, ye, Ae, ke], Ee, Pe || Date.now(), Date.now()]) : typeof ke == "function" && ke.apply(this, arguments);
        });
      }
    }
    var M = _.readdir;
    _.readdir = B;
    var U = /^v[0-5]\./;
    function B(re, he, ge) {
      typeof he == "function" && (ge = he, he = null);
      var me = U.test(process.version) ? function(_e, ye, Ae, ke) {
        return M(_e, Te(
          _e,
          ye,
          Ae,
          ke
        ));
      } : function(_e, ye, Ae, ke) {
        return M(_e, ye, Te(
          _e,
          ye,
          Ae,
          ke
        ));
      };
      return me(re, he, ge);
      function Te(_e, ye, Ae, ke) {
        return function(Pe, Ee) {
          Pe && (Pe.code === "EMFILE" || Pe.code === "ENFILE") ? m([
            me,
            [_e, ye, Ae],
            Pe,
            ke || Date.now(),
            Date.now()
          ]) : (Ee && Ee.sort && Ee.sort(), typeof Ae == "function" && Ae.call(this, Pe, Ee));
        };
      }
    }
    if (process.version.substr(0, 4) === "v0.8") {
      var q = t(_);
      I = q.ReadStream, G = q.WriteStream;
    }
    var z = _.ReadStream;
    z && (I.prototype = Object.create(z.prototype), I.prototype.open = P);
    var D = _.WriteStream;
    D && (G.prototype = Object.create(D.prototype), G.prototype.open = W), Object.defineProperty(_, "ReadStream", {
      get: function() {
        return I;
      },
      set: function(re) {
        I = re;
      },
      enumerable: true,
      configurable: true
    }), Object.defineProperty(_, "WriteStream", {
      get: function() {
        return G;
      },
      set: function(re) {
        G = re;
      },
      enumerable: true,
      configurable: true
    });
    var X = I;
    Object.defineProperty(_, "FileReadStream", {
      get: function() {
        return X;
      },
      set: function(re) {
        X = re;
      },
      enumerable: true,
      configurable: true
    });
    var k = G;
    Object.defineProperty(_, "FileWriteStream", {
      get: function() {
        return k;
      },
      set: function(re) {
        k = re;
      },
      enumerable: true,
      configurable: true
    });
    function I(re, he) {
      return this instanceof I ? (z.apply(this, arguments), this) : I.apply(Object.create(I.prototype), arguments);
    }
    function P() {
      var re = this;
      ae(re.path, re.flags, re.mode, function(he, ge) {
        he ? (re.autoClose && re.destroy(), re.emit("error", he)) : (re.fd = ge, re.emit("open", ge), re.read());
      });
    }
    function G(re, he) {
      return this instanceof G ? (D.apply(this, arguments), this) : G.apply(Object.create(G.prototype), arguments);
    }
    function W() {
      var re = this;
      ae(re.path, re.flags, re.mode, function(he, ge) {
        he ? (re.destroy(), re.emit("error", he)) : (re.fd = ge, re.emit("open", ge));
      });
    }
    function V(re, he) {
      return new _.ReadStream(re, he);
    }
    function K(re, he) {
      return new _.WriteStream(re, he);
    }
    var J = _.open;
    _.open = ae;
    function ae(re, he, ge, me) {
      return typeof ge == "function" && (me = ge, ge = null), Te(re, he, ge, me);
      function Te(_e, ye, Ae, ke, Pe) {
        return J(_e, ye, Ae, function(Ee, Oe) {
          Ee && (Ee.code === "EMFILE" || Ee.code === "ENFILE") ? m([Te, [_e, ye, Ae, ke], Ee, Pe || Date.now(), Date.now()]) : typeof ke == "function" && ke.apply(this, arguments);
        });
      }
    }
    return _;
  }
  function m(_) {
    d("ENQUEUE", _[0].name, _[1]), i2[s].push(_), g();
  }
  var y;
  function x() {
    for (var _ = Date.now(), T = 0; T < i2[s].length; ++T)
      i2[s][T].length > 2 && (i2[s][T][3] = _, i2[s][T][4] = _);
    g();
  }
  function g() {
    if (clearTimeout(y), y = void 0, i2[s].length !== 0) {
      var _ = i2[s].shift(), T = _[0], E = _[1], b = _[2], C = _[3], w = _[4];
      if (C === void 0)
        d("RETRY", T.name, E), T.apply(null, E);
      else if (Date.now() - C >= 6e4) {
        d("TIMEOUT", T.name, E);
        var A = E.pop();
        typeof A == "function" && A.call(null, b);
      } else {
        var S = Date.now() - w, F = Math.max(w - C, 1), M = Math.min(F * 1.2, 100);
        S >= M ? (d("RETRY", T.name, E), T.apply(null, E.concat([C]))) : i2[s].push(_);
      }
      y === void 0 && (y = setTimeout(g, 0));
    }
  }
  return gracefulFs;
}
var old = {}, hasRequiredOld;
function requireOld() {
  if (hasRequiredOld) return old;
  hasRequiredOld = 1;
  var i2 = require$$1$1, e = process.platform === "win32", t = require$$1$1;
  function r() {
    var l;
    return l = c, l;
    function c(d) {
      if (d) {
        if (process.throwDeprecation)
          throw d;
        if (!process.noDeprecation) {
          var f = "fs: missing callback " + (d.stack || d.message);
          process.traceDeprecation ? console.trace(f) : console.error(f);
        }
      }
    }
  }
  function a(l) {
    return typeof l == "function" ? l : r();
  }
  if (i2.normalize, e)
    var s = /(.*?)(?:[\/\\]+|$)/g;
  else
    var s = /(.*?)(?:[\/]+|$)/g;
  if (e)
    var u = /^(?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/][^\\\/]+)?[\\\/]*/;
  else
    var u = /^[\/]*/;
  return old.realpathSync = function(l, c) {
    if (l = i2.resolve(l), c && Object.prototype.hasOwnProperty.call(c, l))
      return c[l];
    var d = l, f = {}, p = {}, m, y, x, g;
    _();
    function _() {
      var A = u.exec(l);
      m = A[0].length, y = A[0], x = A[0], g = "", e && !p[x] && (t.lstatSync(x), p[x] = true);
    }
    for (; m < l.length; ) {
      s.lastIndex = m;
      var T = s.exec(l);
      if (g = y, y += T[0], x = g + T[1], m = s.lastIndex, !(p[x] || c && c[x] === x)) {
        var E;
        if (c && Object.prototype.hasOwnProperty.call(c, x))
          E = c[x];
        else {
          var b = t.lstatSync(x);
          if (!b.isSymbolicLink()) {
            p[x] = true, c && (c[x] = x);
            continue;
          }
          var C = null;
          if (!e) {
            var w = b.dev.toString(32) + ":" + b.ino.toString(32);
            f.hasOwnProperty(w) && (C = f[w]);
          }
          C === null && (t.statSync(x), C = t.readlinkSync(x)), E = i2.resolve(g, C), c && (c[x] = E), e || (f[w] = C);
        }
        l = i2.resolve(E, l.slice(m)), _();
      }
    }
    return c && (c[d] = l), l;
  }, old.realpath = function(l, c, d) {
    if (typeof d != "function" && (d = a(c), c = null), l = i2.resolve(l), c && Object.prototype.hasOwnProperty.call(c, l))
      return process.nextTick(d.bind(null, null, c[l]));
    var f = l, p = {}, m = {}, y, x, g, _;
    T();
    function T() {
      var A = u.exec(l);
      y = A[0].length, x = A[0], g = A[0], _ = "", e && !m[g] ? t.lstat(g, function(S) {
        if (S) return d(S);
        m[g] = true, E();
      }) : process.nextTick(E);
    }
    function E() {
      if (y >= l.length)
        return c && (c[f] = l), d(null, l);
      s.lastIndex = y;
      var A = s.exec(l);
      return _ = x, x += A[0], g = _ + A[1], y = s.lastIndex, m[g] || c && c[g] === g ? process.nextTick(E) : c && Object.prototype.hasOwnProperty.call(c, g) ? w(c[g]) : t.lstat(g, b);
    }
    function b(A, S) {
      if (A) return d(A);
      if (!S.isSymbolicLink())
        return m[g] = true, c && (c[g] = g), process.nextTick(E);
      if (!e) {
        var F = S.dev.toString(32) + ":" + S.ino.toString(32);
        if (p.hasOwnProperty(F))
          return C(null, p[F], g);
      }
      t.stat(g, function(M) {
        if (M) return d(M);
        t.readlink(g, function(U, B) {
          e || (p[F] = B), C(U, B);
        });
      });
    }
    function C(A, S, F) {
      if (A) return d(A);
      var M = i2.resolve(_, S);
      c && (c[F] = M), w(M);
    }
    function w(A) {
      l = i2.resolve(A, l.slice(y)), T();
    }
  }, old;
}
var fs_realpath, hasRequiredFs_realpath;
function requireFs_realpath() {
  if (hasRequiredFs_realpath) return fs_realpath;
  hasRequiredFs_realpath = 1, fs_realpath = l, l.realpath = l, l.sync = c, l.realpathSync = c, l.monkeypatch = d, l.unmonkeypatch = f;
  var i2 = require$$1$1, e = i2.realpath, t = i2.realpathSync, r = process.version, a = /^v[0-5]\./.test(r), s = requireOld();
  function u(p) {
    return p && p.syscall === "realpath" && (p.code === "ELOOP" || p.code === "ENOMEM" || p.code === "ENAMETOOLONG");
  }
  function l(p, m, y) {
    if (a)
      return e(p, m, y);
    typeof m == "function" && (y = m, m = null), e(p, m, function(x, g) {
      u(x) ? s.realpath(p, m, y) : y(x, g);
    });
  }
  function c(p, m) {
    if (a)
      return t(p, m);
    try {
      return t(p, m);
    } catch (y) {
      if (u(y))
        return s.realpathSync(p, m);
      throw y;
    }
  }
  function d() {
    i2.realpath = l, i2.realpathSync = c;
  }
  function f() {
    i2.realpath = e, i2.realpathSync = t;
  }
  return fs_realpath;
}
var concatMap, hasRequiredConcatMap;
function requireConcatMap() {
  if (hasRequiredConcatMap) return concatMap;
  hasRequiredConcatMap = 1, concatMap = function(e, t) {
    for (var r = [], a = 0; a < e.length; a++) {
      var s = t(e[a], a);
      i2(s) ? r.push.apply(r, s) : r.push(s);
    }
    return r;
  };
  var i2 = Array.isArray || function(e) {
    return Object.prototype.toString.call(e) === "[object Array]";
  };
  return concatMap;
}
var balancedMatch, hasRequiredBalancedMatch;
function requireBalancedMatch() {
  if (hasRequiredBalancedMatch) return balancedMatch;
  hasRequiredBalancedMatch = 1, balancedMatch = i2;
  function i2(r, a, s) {
    r instanceof RegExp && (r = e(r, s)), a instanceof RegExp && (a = e(a, s));
    var u = t(r, a, s);
    return u && {
      start: u[0],
      end: u[1],
      pre: s.slice(0, u[0]),
      body: s.slice(u[0] + r.length, u[1]),
      post: s.slice(u[1] + a.length)
    };
  }
  function e(r, a) {
    var s = a.match(r);
    return s ? s[0] : null;
  }
  i2.range = t;
  function t(r, a, s) {
    var u, l, c, d, f, p = s.indexOf(r), m = s.indexOf(a, p + 1), y = p;
    if (p >= 0 && m > 0) {
      if (r === a)
        return [p, m];
      for (u = [], c = s.length; y >= 0 && !f; )
        y == p ? (u.push(y), p = s.indexOf(r, y + 1)) : u.length == 1 ? f = [u.pop(), m] : (l = u.pop(), l < c && (c = l, d = m), m = s.indexOf(a, y + 1)), y = p < m && p >= 0 ? p : m;
      u.length && (f = [c, d]);
    }
    return f;
  }
  return balancedMatch;
}
var braceExpansion, hasRequiredBraceExpansion;
function requireBraceExpansion() {
  if (hasRequiredBraceExpansion) return braceExpansion;
  hasRequiredBraceExpansion = 1;
  var i2 = requireConcatMap(), e = requireBalancedMatch();
  braceExpansion = p;
  var t = "\0SLASH" + Math.random() + "\0", r = "\0OPEN" + Math.random() + "\0", a = "\0CLOSE" + Math.random() + "\0", s = "\0COMMA" + Math.random() + "\0", u = "\0PERIOD" + Math.random() + "\0";
  function l(T) {
    return parseInt(T, 10) == T ? parseInt(T, 10) : T.charCodeAt(0);
  }
  function c(T) {
    return T.split("\\\\").join(t).split("\\{").join(r).split("\\}").join(a).split("\\,").join(s).split("\\.").join(u);
  }
  function d(T) {
    return T.split(t).join("\\").split(r).join("{").split(a).join("}").split(s).join(",").split(u).join(".");
  }
  function f(T) {
    if (!T)
      return [""];
    var E = [], b = e("{", "}", T);
    if (!b)
      return T.split(",");
    var C = b.pre, w = b.body, A = b.post, S = C.split(",");
    S[S.length - 1] += "{" + w + "}";
    var F = f(A);
    return A.length && (S[S.length - 1] += F.shift(), S.push.apply(S, F)), E.push.apply(E, S), E;
  }
  function p(T) {
    return T ? (T.substr(0, 2) === "{}" && (T = "\\{\\}" + T.substr(2)), _(c(T), true).map(d)) : [];
  }
  function m(T) {
    return "{" + T + "}";
  }
  function y(T) {
    return /^-?0\d/.test(T);
  }
  function x(T, E) {
    return T <= E;
  }
  function g(T, E) {
    return T >= E;
  }
  function _(T, E) {
    var b = [], C = e("{", "}", T);
    if (!C || /\$$/.test(C.pre)) return [T];
    var w = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(C.body), A = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(C.body), S = w || A, F = C.body.indexOf(",") >= 0;
    if (!S && !F)
      return C.post.match(/,.*\}/) ? (T = C.pre + "{" + C.body + a + C.post, _(T)) : [T];
    var M;
    if (S)
      M = C.body.split(/\.\./);
    else if (M = f(C.body), M.length === 1 && (M = _(M[0], false).map(m), M.length === 1)) {
      var B = C.post.length ? _(C.post, false) : [""];
      return B.map(function(me) {
        return C.pre + M[0] + me;
      });
    }
    var U = C.pre, B = C.post.length ? _(C.post, false) : [""], q;
    if (S) {
      var z = l(M[0]), D = l(M[1]), X = Math.max(M[0].length, M[1].length), k = M.length == 3 ? Math.abs(l(M[2])) : 1, I = x, P = D < z;
      P && (k *= -1, I = g);
      var G = M.some(y);
      q = [];
      for (var W = z; I(W, D); W += k) {
        var V;
        if (A)
          V = String.fromCharCode(W), V === "\\" && (V = "");
        else if (V = String(W), G) {
          var K = X - V.length;
          if (K > 0) {
            var J = new Array(K + 1).join("0");
            W < 0 ? V = "-" + J + V.slice(1) : V = J + V;
          }
        }
        q.push(V);
      }
    } else
      q = i2(M, function(ge) {
        return _(ge, false);
      });
    for (var ae = 0; ae < q.length; ae++)
      for (var re = 0; re < B.length; re++) {
        var he = U + q[ae] + B[re];
        (!E || S || he) && b.push(he);
      }
    return b;
  }
  return braceExpansion;
}
var minimatch_1, hasRequiredMinimatch;
function requireMinimatch() {
  if (hasRequiredMinimatch) return minimatch_1;
  hasRequiredMinimatch = 1, minimatch_1 = y, y.Minimatch = x;
  var i2 = function() {
    try {
      return require$$1$1;
    } catch {
    }
  }() || {
    sep: "/"
  };
  y.sep = i2.sep;
  var e = y.GLOBSTAR = x.GLOBSTAR = {}, t = requireBraceExpansion(), r = {
    "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
    "?": { open: "(?:", close: ")?" },
    "+": { open: "(?:", close: ")+" },
    "*": { open: "(?:", close: ")*" },
    "@": { open: "(?:", close: ")" }
  }, a = "[^/]", s = a + "*?", u = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?", l = "(?:(?!(?:\\/|^)\\.).)*?", c = d("().*{}+?[]^$\\!");
  function d(M) {
    return M.split("").reduce(function(U, B) {
      return U[B] = true, U;
    }, {});
  }
  var f = /\/+/;
  y.filter = p;
  function p(M, U) {
    return U = U || {}, function(B, q, z) {
      return y(B, M, U);
    };
  }
  function m(M, U) {
    U = U || {};
    var B = {};
    return Object.keys(M).forEach(function(q) {
      B[q] = M[q];
    }), Object.keys(U).forEach(function(q) {
      B[q] = U[q];
    }), B;
  }
  y.defaults = function(M) {
    if (!M || typeof M != "object" || !Object.keys(M).length)
      return y;
    var U = y, B = function(q, z, D) {
      return U(q, z, m(M, D));
    };
    return B.Minimatch = function(q, z) {
      return new U.Minimatch(q, m(M, z));
    }, B.Minimatch.defaults = function(q) {
      return U.defaults(m(M, q)).Minimatch;
    }, B.filter = function(q, z) {
      return U.filter(q, m(M, z));
    }, B.defaults = function(q) {
      return U.defaults(m(M, q));
    }, B.makeRe = function(q, z) {
      return U.makeRe(q, m(M, z));
    }, B.braceExpand = function(q, z) {
      return U.braceExpand(q, m(M, z));
    }, B.match = function(q, z, D) {
      return U.match(q, z, m(M, D));
    }, B;
  }, x.defaults = function(M) {
    return y.defaults(M).Minimatch;
  };
  function y(M, U, B) {
    return b(U), B || (B = {}), !B.nocomment && U.charAt(0) === "#" ? false : new x(U, B).match(M);
  }
  function x(M, U) {
    if (!(this instanceof x))
      return new x(M, U);
    b(M), U || (U = {}), M = M.trim(), !U.allowWindowsEscape && i2.sep !== "/" && (M = M.split(i2.sep).join("/")), this.options = U, this.set = [], this.pattern = M, this.regexp = null, this.negate = false, this.comment = false, this.empty = false, this.partial = !!U.partial, this.make();
  }
  x.prototype.debug = function() {
  }, x.prototype.make = g;
  function g() {
    var M = this.pattern, U = this.options;
    if (!U.nocomment && M.charAt(0) === "#") {
      this.comment = true;
      return;
    }
    if (!M) {
      this.empty = true;
      return;
    }
    this.parseNegate();
    var B = this.globSet = this.braceExpand();
    U.debug && (this.debug = function() {
      console.error.apply(console, arguments);
    }), this.debug(this.pattern, B), B = this.globParts = B.map(function(q) {
      return q.split(f);
    }), this.debug(this.pattern, B), B = B.map(function(q, z, D) {
      return q.map(this.parse, this);
    }, this), this.debug(this.pattern, B), B = B.filter(function(q) {
      return q.indexOf(false) === -1;
    }), this.debug(this.pattern, B), this.set = B;
  }
  x.prototype.parseNegate = _;
  function _() {
    var M = this.pattern, U = false, B = this.options, q = 0;
    if (!B.nonegate) {
      for (var z = 0, D = M.length; z < D && M.charAt(z) === "!"; z++)
        U = !U, q++;
      q && (this.pattern = M.substr(q)), this.negate = U;
    }
  }
  y.braceExpand = function(M, U) {
    return T(M, U);
  }, x.prototype.braceExpand = T;
  function T(M, U) {
    return U || (this instanceof x ? U = this.options : U = {}), M = typeof M > "u" ? this.pattern : M, b(M), U.nobrace || !/\{(?:(?!\{).)*\}/.test(M) ? [M] : t(M);
  }
  var E = 1024 * 64, b = function(M) {
    if (typeof M != "string")
      throw new TypeError("invalid pattern");
    if (M.length > E)
      throw new TypeError("pattern is too long");
  };
  x.prototype.parse = w;
  var C = {};
  function w(M, U) {
    b(M);
    var B = this.options;
    if (M === "**")
      if (B.noglobstar)
        M = "*";
      else
        return e;
    if (M === "") return "";
    var q = "", z = !!B.nocase, D = false, X = [], k = [], I, P = false, G = -1, W = -1, V = M.charAt(0) === "." ? "" : B.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)", K = this;
    function J() {
      if (I) {
        switch (I) {
          case "*":
            q += s, z = true;
            break;
          case "?":
            q += a, z = true;
            break;
          default:
            q += "\\" + I;
            break;
        }
        K.debug("clearStateChar %j %j", I, q), I = false;
      }
    }
    for (var ae = 0, re = M.length, he; ae < re && (he = M.charAt(ae)); ae++) {
      if (this.debug("%s	%s %s %j", M, ae, q, he), D && c[he]) {
        q += "\\" + he, D = false;
        continue;
      }
      switch (he) {
        case "/":
          return false;
        case "\\":
          J(), D = true;
          continue;
        case "?":
        case "*":
        case "+":
        case "@":
        case "!":
          if (this.debug("%s	%s %s %j <-- stateChar", M, ae, q, he), P) {
            this.debug("  in class"), he === "!" && ae === W + 1 && (he = "^"), q += he;
            continue;
          }
          K.debug("call clearStateChar %j", I), J(), I = he, B.noext && J();
          continue;
        case "(":
          if (P) {
            q += "(";
            continue;
          }
          if (!I) {
            q += "\\(";
            continue;
          }
          X.push({
            type: I,
            start: ae - 1,
            reStart: q.length,
            open: r[I].open,
            close: r[I].close
          }), q += I === "!" ? "(?:(?!(?:" : "(?:", this.debug("plType %j %j", I, q), I = false;
          continue;
        case ")":
          if (P || !X.length) {
            q += "\\)";
            continue;
          }
          J(), z = true;
          var ge = X.pop();
          q += ge.close, ge.type === "!" && k.push(ge), ge.reEnd = q.length;
          continue;
        case "|":
          if (P || !X.length || D) {
            q += "\\|", D = false;
            continue;
          }
          J(), q += "|";
          continue;
        case "[":
          if (J(), P) {
            q += "\\" + he;
            continue;
          }
          P = true, W = ae, G = q.length, q += he;
          continue;
        case "]":
          if (ae === W + 1 || !P) {
            q += "\\" + he, D = false;
            continue;
          }
          var me = M.substring(W + 1, ae);
          try {
            RegExp("[" + me + "]");
          } catch {
            var Te = this.parse(me, C);
            q = q.substr(0, G) + "\\[" + Te[0] + "\\]", z = z || Te[1], P = false;
            continue;
          }
          z = true, P = false, q += he;
          continue;
        default:
          J(), D ? D = false : c[he] && !(he === "^" && P) && (q += "\\"), q += he;
      }
    }
    for (P && (me = M.substr(W + 1), Te = this.parse(me, C), q = q.substr(0, G) + "\\[" + Te[0], z = z || Te[1]), ge = X.pop(); ge; ge = X.pop()) {
      var _e = q.slice(ge.reStart + ge.open.length);
      this.debug("setting tail", q, ge), _e = _e.replace(/((?:\\{2}){0,64})(\\?)\|/g, function(It, er, $) {
        return $ || ($ = "\\"), er + er + $ + "|";
      }), this.debug(`tail=%j
   %s`, _e, _e, ge, q);
      var ye = ge.type === "*" ? s : ge.type === "?" ? a : "\\" + ge.type;
      z = true, q = q.slice(0, ge.reStart) + ye + "\\(" + _e;
    }
    J(), D && (q += "\\\\");
    var Ae = false;
    switch (q.charAt(0)) {
      case "[":
      case ".":
      case "(":
        Ae = true;
    }
    for (var ke = k.length - 1; ke > -1; ke--) {
      var Pe = k[ke], Ee = q.slice(0, Pe.reStart), Oe = q.slice(Pe.reStart, Pe.reEnd - 8), $e = q.slice(Pe.reEnd - 8, Pe.reEnd), gt = q.slice(Pe.reEnd);
      $e += gt;
      var xt = Ee.split("(").length - 1, vt = gt;
      for (ae = 0; ae < xt; ae++)
        vt = vt.replace(/\)[+*?]?/, "");
      gt = vt;
      var Xe = "";
      gt === "" && U !== C && (Xe = "$");
      var at = Ee + Oe + gt + Xe + $e;
      q = at;
    }
    if (q !== "" && z && (q = "(?=.)" + q), Ae && (q = V + q), U === C)
      return [q, z];
    if (!z)
      return S(M);
    var ct = B.nocase ? "i" : "";
    try {
      var Rt = new RegExp("^" + q + "$", ct);
    } catch {
      return new RegExp("$.");
    }
    return Rt._glob = M, Rt._src = q, Rt;
  }
  y.makeRe = function(M, U) {
    return new x(M, U || {}).makeRe();
  }, x.prototype.makeRe = A;
  function A() {
    if (this.regexp || this.regexp === false) return this.regexp;
    var M = this.set;
    if (!M.length)
      return this.regexp = false, this.regexp;
    var U = this.options, B = U.noglobstar ? s : U.dot ? u : l, q = U.nocase ? "i" : "", z = M.map(function(D) {
      return D.map(function(X) {
        return X === e ? B : typeof X == "string" ? F(X) : X._src;
      }).join("\\/");
    }).join("|");
    z = "^(?:" + z + ")$", this.negate && (z = "^(?!" + z + ").*$");
    try {
      this.regexp = new RegExp(z, q);
    } catch {
      this.regexp = false;
    }
    return this.regexp;
  }
  y.match = function(M, U, B) {
    B = B || {};
    var q = new x(U, B);
    return M = M.filter(function(z) {
      return q.match(z);
    }), q.options.nonull && !M.length && M.push(U), M;
  }, x.prototype.match = function(M, U) {
    if (typeof U > "u" && (U = this.partial), this.debug("match", M, this.pattern), this.comment) return false;
    if (this.empty) return M === "";
    if (M === "/" && U) return true;
    var B = this.options;
    i2.sep !== "/" && (M = M.split(i2.sep).join("/")), M = M.split(f), this.debug(this.pattern, "split", M);
    var q = this.set;
    this.debug(this.pattern, "set", q);
    var z, D;
    for (D = M.length - 1; D >= 0 && (z = M[D], !z); D--)
      ;
    for (D = 0; D < q.length; D++) {
      var X = q[D], k = M;
      B.matchBase && X.length === 1 && (k = [z]);
      var I = this.matchOne(k, X, U);
      if (I)
        return B.flipNegate ? true : !this.negate;
    }
    return B.flipNegate ? false : this.negate;
  }, x.prototype.matchOne = function(M, U, B) {
    var q = this.options;
    this.debug(
      "matchOne",
      { this: this, file: M, pattern: U }
    ), this.debug("matchOne", M.length, U.length);
    for (var z = 0, D = 0, X = M.length, k = U.length; z < X && D < k; z++, D++) {
      this.debug("matchOne loop");
      var I = U[D], P = M[z];
      if (this.debug(U, I, P), I === false) return false;
      if (I === e) {
        this.debug("GLOBSTAR", [U, I, P]);
        var G = z, W = D + 1;
        if (W === k) {
          for (this.debug("** at the end"); z < X; z++)
            if (M[z] === "." || M[z] === ".." || !q.dot && M[z].charAt(0) === ".") return false;
          return true;
        }
        for (; G < X; ) {
          var V = M[G];
          if (this.debug(`
globstar while`, M, G, U, W, V), this.matchOne(M.slice(G), U.slice(W), B))
            return this.debug("globstar found match!", G, X, V), true;
          if (V === "." || V === ".." || !q.dot && V.charAt(0) === ".") {
            this.debug("dot detected!", M, G, U, W);
            break;
          }
          this.debug("globstar swallow a segment, and continue"), G++;
        }
        return !!(B && (this.debug(`
>>> no match, partial?`, M, G, U, W), G === X));
      }
      var K;
      if (typeof I == "string" ? (K = P === I, this.debug("string match", I, P, K)) : (K = P.match(I), this.debug("pattern match", I, P, K)), !K) return false;
    }
    if (z === X && D === k)
      return true;
    if (z === X)
      return B;
    if (D === k)
      return z === X - 1 && M[z] === "";
    throw new Error("wtf?");
  };
  function S(M) {
    return M.replace(/\\(.)/g, "$1");
  }
  function F(M) {
    return M.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
  }
  return minimatch_1;
}
var inherits_browser = { exports: {} }, hasRequiredInherits_browser;
function requireInherits_browser() {
  return hasRequiredInherits_browser || (hasRequiredInherits_browser = 1, typeof Object.create == "function" ? inherits_browser.exports = function(i2, e) {
    e && (i2.super_ = e, i2.prototype = Object.create(e.prototype, {
      constructor: {
        value: i2,
        enumerable: false,
        writable: true,
        configurable: true
      }
    }));
  } : inherits_browser.exports = function(i2, e) {
    if (e) {
      i2.super_ = e;
      var t = function() {
      };
      t.prototype = e.prototype, i2.prototype = new t(), i2.prototype.constructor = i2;
    }
  }), inherits_browser.exports;
}
var events, hasRequiredEvents;
function requireEvents() {
  if (hasRequiredEvents) return events;
  hasRequiredEvents = 1;
  function i2() {
    this._events = this._events || {}, this._maxListeners = this._maxListeners || void 0;
  }
  events = i2, i2.EventEmitter = i2, i2.prototype._events = void 0, i2.prototype._maxListeners = void 0, i2.defaultMaxListeners = 10, i2.prototype.setMaxListeners = function(s) {
    if (!t(s) || s < 0 || isNaN(s))
      throw TypeError("n must be a positive number");
    return this._maxListeners = s, this;
  }, i2.prototype.emit = function(s) {
    var u, l, c, d, f, p;
    if (this._events || (this._events = {}), s === "error" && (!this._events.error || r(this._events.error) && !this._events.error.length))
      throw u = arguments[1], u instanceof Error ? u : TypeError('Uncaught, unspecified "error" event.');
    if (l = this._events[s], a(l))
      return false;
    if (e(l))
      switch (arguments.length) {
        case 1:
          l.call(this);
          break;
        case 2:
          l.call(this, arguments[1]);
          break;
        case 3:
          l.call(this, arguments[1], arguments[2]);
          break;
        default:
          for (c = arguments.length, d = new Array(c - 1), f = 1; f < c; f++)
            d[f - 1] = arguments[f];
          l.apply(this, d);
      }
    else if (r(l)) {
      for (c = arguments.length, d = new Array(c - 1), f = 1; f < c; f++)
        d[f - 1] = arguments[f];
      for (p = l.slice(), c = p.length, f = 0; f < c; f++)
        p[f].apply(this, d);
    }
    return true;
  }, i2.prototype.addListener = function(s, u) {
    var l;
    if (!e(u))
      throw TypeError("listener must be a function");
    if (this._events || (this._events = {}), this._events.newListener && this.emit(
      "newListener",
      s,
      e(u.listener) ? u.listener : u
    ), this._events[s] ? r(this._events[s]) ? this._events[s].push(u) : this._events[s] = [this._events[s], u] : this._events[s] = u, r(this._events[s]) && !this._events[s].warned) {
      var l;
      a(this._maxListeners) ? l = i2.defaultMaxListeners : l = this._maxListeners, l && l > 0 && this._events[s].length > l && (this._events[s].warned = true, console.error(
        "(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.",
        this._events[s].length
      ), typeof console.trace == "function" && console.trace());
    }
    return this;
  }, i2.prototype.on = i2.prototype.addListener, i2.prototype.once = function(s, u) {
    if (!e(u))
      throw TypeError("listener must be a function");
    var l = false;
    function c() {
      this.removeListener(s, c), l || (l = true, u.apply(this, arguments));
    }
    return c.listener = u, this.on(s, c), this;
  }, i2.prototype.removeListener = function(s, u) {
    var l, c, d, f;
    if (!e(u))
      throw TypeError("listener must be a function");
    if (!this._events || !this._events[s])
      return this;
    if (l = this._events[s], d = l.length, c = -1, l === u || e(l.listener) && l.listener === u)
      delete this._events[s], this._events.removeListener && this.emit("removeListener", s, u);
    else if (r(l)) {
      for (f = d; f-- > 0; )
        if (l[f] === u || l[f].listener && l[f].listener === u) {
          c = f;
          break;
        }
      if (c < 0)
        return this;
      l.length === 1 ? (l.length = 0, delete this._events[s]) : l.splice(c, 1), this._events.removeListener && this.emit("removeListener", s, u);
    }
    return this;
  }, i2.prototype.removeAllListeners = function(s) {
    var u, l;
    if (!this._events)
      return this;
    if (!this._events.removeListener)
      return arguments.length === 0 ? this._events = {} : this._events[s] && delete this._events[s], this;
    if (arguments.length === 0) {
      for (u in this._events)
        u !== "removeListener" && this.removeAllListeners(u);
      return this.removeAllListeners("removeListener"), this._events = {}, this;
    }
    if (l = this._events[s], e(l))
      this.removeListener(s, l);
    else
      for (; l.length; )
        this.removeListener(s, l[l.length - 1]);
    return delete this._events[s], this;
  }, i2.prototype.listeners = function(s) {
    var u;
    return !this._events || !this._events[s] ? u = [] : e(this._events[s]) ? u = [this._events[s]] : u = this._events[s].slice(), u;
  }, i2.listenerCount = function(s, u) {
    var l;
    return !s._events || !s._events[u] ? l = 0 : e(s._events[u]) ? l = 1 : l = s._events[u].length, l;
  };
  function e(s) {
    return typeof s == "function";
  }
  function t(s) {
    return typeof s == "number";
  }
  function r(s) {
    return typeof s == "object" && s !== null;
  }
  function a(s) {
    return s === void 0;
  }
  return events;
}
var pathIsAbsolute = { exports: {} }, hasRequiredPathIsAbsolute;
function requirePathIsAbsolute() {
  if (hasRequiredPathIsAbsolute) return pathIsAbsolute.exports;
  hasRequiredPathIsAbsolute = 1;
  function i2(t) {
    return t.charAt(0) === "/";
  }
  function e(t) {
    var r = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/, a = r.exec(t), s = a[1] || "", u = !!(s && s.charAt(1) !== ":");
    return !!(a[2] || u);
  }
  return pathIsAbsolute.exports = process.platform === "win32" ? e : i2, pathIsAbsolute.exports.posix = i2, pathIsAbsolute.exports.win32 = e, pathIsAbsolute.exports;
}
var common = {}, hasRequiredCommon;
function requireCommon() {
  if (hasRequiredCommon) return common;
  hasRequiredCommon = 1, common.setopts = d, common.ownProp = i2, common.makeAbs = m, common.finish = f, common.mark = p, common.isIgnored = y, common.childrenIgnored = x;
  function i2(g, _) {
    return Object.prototype.hasOwnProperty.call(g, _);
  }
  var e = require$$1$1, t = require$$1$1, r = requireMinimatch(), a = requirePathIsAbsolute(), s = r.Minimatch;
  function u(g, _) {
    return g.localeCompare(_, "en");
  }
  function l(g, _) {
    g.ignore = _.ignore || [], Array.isArray(g.ignore) || (g.ignore = [g.ignore]), g.ignore.length && (g.ignore = g.ignore.map(c));
  }
  function c(g) {
    var _ = null;
    if (g.slice(-3) === "/**") {
      var T = g.replace(/(\/\*\*)+$/, "");
      _ = new s(T, { dot: true });
    }
    return {
      matcher: new s(g, { dot: true }),
      gmatcher: _
    };
  }
  function d(g, _, T) {
    if (T || (T = {}), T.matchBase && _.indexOf("/") === -1) {
      if (T.noglobstar)
        throw new Error("base matching requires globstar");
      _ = "**/" + _;
    }
    g.silent = !!T.silent, g.pattern = _, g.strict = T.strict !== false, g.realpath = !!T.realpath, g.realpathCache = T.realpathCache || /* @__PURE__ */ Object.create(null), g.follow = !!T.follow, g.dot = !!T.dot, g.mark = !!T.mark, g.nodir = !!T.nodir, g.nodir && (g.mark = true), g.sync = !!T.sync, g.nounique = !!T.nounique, g.nonull = !!T.nonull, g.nosort = !!T.nosort, g.nocase = !!T.nocase, g.stat = !!T.stat, g.noprocess = !!T.noprocess, g.absolute = !!T.absolute, g.fs = T.fs || e, g.maxLength = T.maxLength || 1 / 0, g.cache = T.cache || /* @__PURE__ */ Object.create(null), g.statCache = T.statCache || /* @__PURE__ */ Object.create(null), g.symlinks = T.symlinks || /* @__PURE__ */ Object.create(null), l(g, T), g.changedCwd = false;
    var E = process.cwd();
    i2(T, "cwd") ? (g.cwd = t.resolve(T.cwd), g.changedCwd = g.cwd !== E) : g.cwd = E, g.root = T.root || t.resolve(g.cwd, "/"), g.root = t.resolve(g.root), process.platform === "win32" && (g.root = g.root.replace(/\\/g, "/")), g.cwdAbs = a(g.cwd) ? g.cwd : m(g, g.cwd), process.platform === "win32" && (g.cwdAbs = g.cwdAbs.replace(/\\/g, "/")), g.nomount = !!T.nomount, T.nonegate = true, T.nocomment = true, T.allowWindowsEscape = false, g.minimatch = new s(_, T), g.options = g.minimatch.options;
  }
  function f(g) {
    for (var _ = g.nounique, T = _ ? [] : /* @__PURE__ */ Object.create(null), E = 0, b = g.matches.length; E < b; E++) {
      var C = g.matches[E];
      if (!C || Object.keys(C).length === 0) {
        if (g.nonull) {
          var w = g.minimatch.globSet[E];
          _ ? T.push(w) : T[w] = true;
        }
      } else {
        var A = Object.keys(C);
        _ ? T.push.apply(T, A) : A.forEach(function(S) {
          T[S] = true;
        });
      }
    }
    if (_ || (T = Object.keys(T)), g.nosort || (T = T.sort(u)), g.mark) {
      for (var E = 0; E < T.length; E++)
        T[E] = g._mark(T[E]);
      g.nodir && (T = T.filter(function(S) {
        var F = !/\/$/.test(S), M = g.cache[S] || g.cache[m(g, S)];
        return F && M && (F = M !== "DIR" && !Array.isArray(M)), F;
      }));
    }
    g.ignore.length && (T = T.filter(function(S) {
      return !y(g, S);
    })), g.found = T;
  }
  function p(g, _) {
    var T = m(g, _), E = g.cache[T], b = _;
    if (E) {
      var C = E === "DIR" || Array.isArray(E), w = _.slice(-1) === "/";
      if (C && !w ? b += "/" : !C && w && (b = b.slice(0, -1)), b !== _) {
        var A = m(g, b);
        g.statCache[A] = g.statCache[T], g.cache[A] = g.cache[T];
      }
    }
    return b;
  }
  function m(g, _) {
    var T = _;
    return _.charAt(0) === "/" ? T = t.join(g.root, _) : a(_) || _ === "" ? T = _ : g.changedCwd ? T = t.resolve(g.cwd, _) : T = t.resolve(_), process.platform === "win32" && (T = T.replace(/\\/g, "/")), T;
  }
  function y(g, _) {
    return g.ignore.length ? g.ignore.some(function(T) {
      return T.matcher.match(_) || !!(T.gmatcher && T.gmatcher.match(_));
    }) : false;
  }
  function x(g, _) {
    return g.ignore.length ? g.ignore.some(function(T) {
      return !!(T.gmatcher && T.gmatcher.match(_));
    }) : false;
  }
  return common;
}
var sync, hasRequiredSync;
function requireSync() {
  if (hasRequiredSync) return sync;
  hasRequiredSync = 1, sync = f, f.GlobSync = p;
  var i2 = requireFs_realpath(), e = requireMinimatch();
  e.Minimatch, requireGlob().Glob, requireUtil$1();
  var t = require$$1$1, r = requireAssert(), a = requirePathIsAbsolute(), s = requireCommon(), u = s.setopts, l = s.ownProp, c = s.childrenIgnored, d = s.isIgnored;
  function f(m, y) {
    if (typeof y == "function" || arguments.length === 3)
      throw new TypeError(`callback provided to sync glob
See: https://github.com/isaacs/node-glob/issues/167`);
    return new p(m, y).found;
  }
  function p(m, y) {
    if (!m)
      throw new Error("must provide pattern");
    if (typeof y == "function" || arguments.length === 3)
      throw new TypeError(`callback provided to sync glob
See: https://github.com/isaacs/node-glob/issues/167`);
    if (!(this instanceof p))
      return new p(m, y);
    if (u(this, m, y), this.noprocess)
      return this;
    var x = this.minimatch.set.length;
    this.matches = new Array(x);
    for (var g = 0; g < x; g++)
      this._process(this.minimatch.set[g], g, false);
    this._finish();
  }
  return p.prototype._finish = function() {
    if (r.ok(this instanceof p), this.realpath) {
      var m = this;
      this.matches.forEach(function(y, x) {
        var g = m.matches[x] = /* @__PURE__ */ Object.create(null);
        for (var _ in y)
          try {
            _ = m._makeAbs(_);
            var T = i2.realpathSync(_, m.realpathCache);
            g[T] = true;
          } catch (E) {
            if (E.syscall === "stat")
              g[m._makeAbs(_)] = true;
            else
              throw E;
          }
      });
    }
    s.finish(this);
  }, p.prototype._process = function(m, y, x) {
    r.ok(this instanceof p);
    for (var g = 0; typeof m[g] == "string"; )
      g++;
    var _;
    switch (g) {
      case m.length:
        this._processSimple(m.join("/"), y);
        return;
      case 0:
        _ = null;
        break;
      default:
        _ = m.slice(0, g).join("/");
        break;
    }
    var T = m.slice(g), E;
    _ === null ? E = "." : ((a(_) || a(m.map(function(w) {
      return typeof w == "string" ? w : "[*]";
    }).join("/"))) && (!_ || !a(_)) && (_ = "/" + _), E = _);
    var b = this._makeAbs(E);
    if (!c(this, E)) {
      var C = T[0] === e.GLOBSTAR;
      C ? this._processGlobStar(_, E, b, T, y, x) : this._processReaddir(_, E, b, T, y, x);
    }
  }, p.prototype._processReaddir = function(m, y, x, g, _, T) {
    var E = this._readdir(x, T);
    if (E) {
      for (var b = g[0], C = !!this.minimatch.negate, w = b._glob, A = this.dot || w.charAt(0) === ".", S = [], F = 0; F < E.length; F++) {
        var M = E[F];
        if (M.charAt(0) !== "." || A) {
          var U;
          C && !m ? U = !M.match(b) : U = M.match(b), U && S.push(M);
        }
      }
      var B = S.length;
      if (B !== 0) {
        if (g.length === 1 && !this.mark && !this.stat) {
          this.matches[_] || (this.matches[_] = /* @__PURE__ */ Object.create(null));
          for (var F = 0; F < B; F++) {
            var M = S[F];
            m && (m.slice(-1) !== "/" ? M = m + "/" + M : M = m + M), M.charAt(0) === "/" && !this.nomount && (M = t.join(this.root, M)), this._emitMatch(_, M);
          }
          return;
        }
        g.shift();
        for (var F = 0; F < B; F++) {
          var M = S[F], q;
          m ? q = [m, M] : q = [M], this._process(q.concat(g), _, T);
        }
      }
    }
  }, p.prototype._emitMatch = function(m, y) {
    if (!d(this, y)) {
      var x = this._makeAbs(y);
      if (this.mark && (y = this._mark(y)), this.absolute && (y = x), !this.matches[m][y]) {
        if (this.nodir) {
          var g = this.cache[x];
          if (g === "DIR" || Array.isArray(g))
            return;
        }
        this.matches[m][y] = true, this.stat && this._stat(y);
      }
    }
  }, p.prototype._readdirInGlobStar = function(m) {
    if (this.follow)
      return this._readdir(m, false);
    var y, x;
    try {
      x = this.fs.lstatSync(m);
    } catch (_) {
      if (_.code === "ENOENT")
        return null;
    }
    var g = x && x.isSymbolicLink();
    return this.symlinks[m] = g, !g && x && !x.isDirectory() ? this.cache[m] = "FILE" : y = this._readdir(m, false), y;
  }, p.prototype._readdir = function(m, y) {
    if (y && !l(this.symlinks, m))
      return this._readdirInGlobStar(m);
    if (l(this.cache, m)) {
      var x = this.cache[m];
      if (!x || x === "FILE")
        return null;
      if (Array.isArray(x))
        return x;
    }
    try {
      return this._readdirEntries(m, this.fs.readdirSync(m));
    } catch (g) {
      return this._readdirError(m, g), null;
    }
  }, p.prototype._readdirEntries = function(m, y) {
    if (!this.mark && !this.stat)
      for (var x = 0; x < y.length; x++) {
        var g = y[x];
        m === "/" ? g = m + g : g = m + "/" + g, this.cache[g] = true;
      }
    return this.cache[m] = y, y;
  }, p.prototype._readdirError = function(m, y) {
    switch (y.code) {
      case "ENOTSUP":
      case "ENOTDIR":
        var x = this._makeAbs(m);
        if (this.cache[x] = "FILE", x === this.cwdAbs) {
          var g = new Error(y.code + " invalid cwd " + this.cwd);
          throw g.path = this.cwd, g.code = y.code, g;
        }
        break;
      case "ENOENT":
      case "ELOOP":
      case "ENAMETOOLONG":
      case "UNKNOWN":
        this.cache[this._makeAbs(m)] = false;
        break;
      default:
        if (this.cache[this._makeAbs(m)] = false, this.strict)
          throw y;
        this.silent || console.error("glob error", y);
        break;
    }
  }, p.prototype._processGlobStar = function(m, y, x, g, _, T) {
    var E = this._readdir(x, T);
    if (E) {
      var b = g.slice(1), C = m ? [m] : [], w = C.concat(b);
      this._process(w, _, false);
      var A = E.length, S = this.symlinks[x];
      if (!(S && T))
        for (var F = 0; F < A; F++) {
          var M = E[F];
          if (!(M.charAt(0) === "." && !this.dot)) {
            var U = C.concat(E[F], b);
            this._process(U, _, true);
            var B = C.concat(E[F], g);
            this._process(B, _, true);
          }
        }
    }
  }, p.prototype._processSimple = function(m, y) {
    var x = this._stat(m);
    if (this.matches[y] || (this.matches[y] = /* @__PURE__ */ Object.create(null)), !!x) {
      if (m && a(m) && !this.nomount) {
        var g = /[\/\\]$/.test(m);
        m.charAt(0) === "/" ? m = t.join(this.root, m) : (m = t.resolve(this.root, m), g && (m += "/"));
      }
      process.platform === "win32" && (m = m.replace(/\\/g, "/")), this._emitMatch(y, m);
    }
  }, p.prototype._stat = function(m) {
    var y = this._makeAbs(m), x = m.slice(-1) === "/";
    if (m.length > this.maxLength)
      return false;
    if (!this.stat && l(this.cache, y)) {
      var T = this.cache[y];
      if (Array.isArray(T) && (T = "DIR"), !x || T === "DIR")
        return T;
      if (x && T === "FILE")
        return false;
    }
    var g = this.statCache[y];
    if (!g) {
      var _;
      try {
        _ = this.fs.lstatSync(y);
      } catch (E) {
        if (E && (E.code === "ENOENT" || E.code === "ENOTDIR"))
          return this.statCache[y] = false, false;
      }
      if (_ && _.isSymbolicLink())
        try {
          g = this.fs.statSync(y);
        } catch {
          g = _;
        }
      else
        g = _;
    }
    this.statCache[y] = g;
    var T = true;
    return g && (T = g.isDirectory() ? "DIR" : "FILE"), this.cache[y] = this.cache[y] || T, x && T === "FILE" ? false : T;
  }, p.prototype._mark = function(m) {
    return s.mark(this, m);
  }, p.prototype._makeAbs = function(m) {
    return s.makeAbs(this, m);
  }, sync;
}
var wrappy_1, hasRequiredWrappy;
function requireWrappy() {
  if (hasRequiredWrappy) return wrappy_1;
  hasRequiredWrappy = 1, wrappy_1 = i2;
  function i2(e, t) {
    if (e && t) return i2(e)(t);
    if (typeof e != "function")
      throw new TypeError("need wrapper function");
    return Object.keys(e).forEach(function(a) {
      r[a] = e[a];
    }), r;
    function r() {
      for (var a = new Array(arguments.length), s = 0; s < a.length; s++)
        a[s] = arguments[s];
      var u = e.apply(this, a), l = a[a.length - 1];
      return typeof u == "function" && u !== l && Object.keys(l).forEach(function(c) {
        u[c] = l[c];
      }), u;
    }
  }
  return wrappy_1;
}
var once = { exports: {} }, hasRequiredOnce;
function requireOnce() {
  if (hasRequiredOnce) return once.exports;
  hasRequiredOnce = 1;
  var i2 = requireWrappy();
  once.exports = i2(e), once.exports.strict = i2(t), e.proto = e(function() {
    Object.defineProperty(Function.prototype, "once", {
      value: function() {
        return e(this);
      },
      configurable: true
    }), Object.defineProperty(Function.prototype, "onceStrict", {
      value: function() {
        return t(this);
      },
      configurable: true
    });
  });
  function e(r) {
    var a = function() {
      return a.called ? a.value : (a.called = true, a.value = r.apply(this, arguments));
    };
    return a.called = false, a;
  }
  function t(r) {
    var a = function() {
      if (a.called)
        throw new Error(a.onceError);
      return a.called = true, a.value = r.apply(this, arguments);
    }, s = r.name || "Function wrapped with `once`";
    return a.onceError = s + " shouldn't be called more than once", a.called = false, a;
  }
  return once.exports;
}
var inflight_1, hasRequiredInflight;
function requireInflight() {
  if (hasRequiredInflight) return inflight_1;
  hasRequiredInflight = 1;
  var i2 = requireWrappy(), e = /* @__PURE__ */ Object.create(null), t = requireOnce();
  inflight_1 = i2(r);
  function r(u, l) {
    return e[u] ? (e[u].push(l), null) : (e[u] = [l], a(u));
  }
  function a(u) {
    return t(function l() {
      var c = e[u], d = c.length, f = s(arguments);
      try {
        for (var p = 0; p < d; p++)
          c[p].apply(null, f);
      } finally {
        c.length > d ? (c.splice(0, d), process.nextTick(function() {
          l.apply(null, f);
        })) : delete e[u];
      }
    });
  }
  function s(u) {
    for (var l = u.length, c = [], d = 0; d < l; d++) c[d] = u[d];
    return c;
  }
  return inflight_1;
}
var glob_1, hasRequiredGlob;
function requireGlob() {
  if (hasRequiredGlob) return glob_1;
  hasRequiredGlob = 1, glob_1 = g;
  var i2 = requireFs_realpath(), e = requireMinimatch();
  e.Minimatch;
  var t = requireInherits_browser(), r = requireEvents().EventEmitter, a = require$$1$1, s = requireAssert(), u = requirePathIsAbsolute(), l = requireSync(), c = requireCommon(), d = c.setopts, f = c.ownProp, p = requireInflight();
  requireUtil$1();
  var m = c.childrenIgnored, y = c.isIgnored, x = requireOnce();
  function g(C, w, A) {
    if (typeof w == "function" && (A = w, w = {}), w || (w = {}), w.sync) {
      if (A)
        throw new TypeError("callback provided to sync glob");
      return l(C, w);
    }
    return new E(C, w, A);
  }
  g.sync = l;
  var _ = g.GlobSync = l.GlobSync;
  g.glob = g;
  function T(C, w) {
    if (w === null || typeof w != "object")
      return C;
    for (var A = Object.keys(w), S = A.length; S--; )
      C[A[S]] = w[A[S]];
    return C;
  }
  g.hasMagic = function(C, w) {
    var A = T({}, w);
    A.noprocess = true;
    var S = new E(C, A), F = S.minimatch.set;
    if (!C)
      return false;
    if (F.length > 1)
      return true;
    for (var M = 0; M < F[0].length; M++)
      if (typeof F[0][M] != "string")
        return true;
    return false;
  }, g.Glob = E, t(E, r);
  function E(C, w, A) {
    if (typeof w == "function" && (A = w, w = null), w && w.sync) {
      if (A)
        throw new TypeError("callback provided to sync glob");
      return new _(C, w);
    }
    if (!(this instanceof E))
      return new E(C, w, A);
    d(this, C, w), this._didRealPath = false;
    var S = this.minimatch.set.length;
    this.matches = new Array(S), typeof A == "function" && (A = x(A), this.on("error", A), this.on("end", function(q) {
      A(null, q);
    }));
    var F = this;
    if (this._processing = 0, this._emitQueue = [], this._processQueue = [], this.paused = false, this.noprocess)
      return this;
    if (S === 0)
      return B();
    for (var M = true, U = 0; U < S; U++)
      this._process(this.minimatch.set[U], U, false, B);
    M = false;
    function B() {
      --F._processing, F._processing <= 0 && (M ? process.nextTick(function() {
        F._finish();
      }) : F._finish());
    }
  }
  E.prototype._finish = function() {
    if (s(this instanceof E), !this.aborted) {
      if (this.realpath && !this._didRealpath)
        return this._realpath();
      c.finish(this), this.emit("end", this.found);
    }
  }, E.prototype._realpath = function() {
    if (this._didRealpath)
      return;
    this._didRealpath = true;
    var C = this.matches.length;
    if (C === 0)
      return this._finish();
    for (var w = this, A = 0; A < this.matches.length; A++)
      this._realpathSet(A, S);
    function S() {
      --C === 0 && w._finish();
    }
  }, E.prototype._realpathSet = function(C, w) {
    var A = this.matches[C];
    if (!A)
      return w();
    var S = Object.keys(A), F = this, M = S.length;
    if (M === 0)
      return w();
    var U = this.matches[C] = /* @__PURE__ */ Object.create(null);
    S.forEach(function(B, q) {
      B = F._makeAbs(B), i2.realpath(B, F.realpathCache, function(z, D) {
        z ? z.syscall === "stat" ? U[B] = true : F.emit("error", z) : U[D] = true, --M === 0 && (F.matches[C] = U, w());
      });
    });
  }, E.prototype._mark = function(C) {
    return c.mark(this, C);
  }, E.prototype._makeAbs = function(C) {
    return c.makeAbs(this, C);
  }, E.prototype.abort = function() {
    this.aborted = true, this.emit("abort");
  }, E.prototype.pause = function() {
    this.paused || (this.paused = true, this.emit("pause"));
  }, E.prototype.resume = function() {
    if (this.paused) {
      if (this.emit("resume"), this.paused = false, this._emitQueue.length) {
        var C = this._emitQueue.slice(0);
        this._emitQueue.length = 0;
        for (var w = 0; w < C.length; w++) {
          var A = C[w];
          this._emitMatch(A[0], A[1]);
        }
      }
      if (this._processQueue.length) {
        var S = this._processQueue.slice(0);
        this._processQueue.length = 0;
        for (var w = 0; w < S.length; w++) {
          var F = S[w];
          this._processing--, this._process(F[0], F[1], F[2], F[3]);
        }
      }
    }
  }, E.prototype._process = function(C, w, A, S) {
    if (s(this instanceof E), s(typeof S == "function"), !this.aborted) {
      if (this._processing++, this.paused) {
        this._processQueue.push([C, w, A, S]);
        return;
      }
      for (var F = 0; typeof C[F] == "string"; )
        F++;
      var M;
      switch (F) {
        case C.length:
          this._processSimple(C.join("/"), w, S);
          return;
        case 0:
          M = null;
          break;
        default:
          M = C.slice(0, F).join("/");
          break;
      }
      var U = C.slice(F), B;
      M === null ? B = "." : ((u(M) || u(C.map(function(D) {
        return typeof D == "string" ? D : "[*]";
      }).join("/"))) && (!M || !u(M)) && (M = "/" + M), B = M);
      var q = this._makeAbs(B);
      if (m(this, B))
        return S();
      var z = U[0] === e.GLOBSTAR;
      z ? this._processGlobStar(M, B, q, U, w, A, S) : this._processReaddir(M, B, q, U, w, A, S);
    }
  }, E.prototype._processReaddir = function(C, w, A, S, F, M, U) {
    var B = this;
    this._readdir(A, M, function(q, z) {
      return B._processReaddir2(C, w, A, S, F, M, z, U);
    });
  }, E.prototype._processReaddir2 = function(C, w, A, S, F, M, U, B) {
    if (!U)
      return B();
    for (var q = S[0], z = !!this.minimatch.negate, D = q._glob, X = this.dot || D.charAt(0) === ".", k = [], I = 0; I < U.length; I++) {
      var P = U[I];
      if (P.charAt(0) !== "." || X) {
        var G;
        z && !C ? G = !P.match(q) : G = P.match(q), G && k.push(P);
      }
    }
    var W = k.length;
    if (W === 0)
      return B();
    if (S.length === 1 && !this.mark && !this.stat) {
      this.matches[F] || (this.matches[F] = /* @__PURE__ */ Object.create(null));
      for (var I = 0; I < W; I++) {
        var P = k[I];
        C && (C !== "/" ? P = C + "/" + P : P = C + P), P.charAt(0) === "/" && !this.nomount && (P = a.join(this.root, P)), this._emitMatch(F, P);
      }
      return B();
    }
    S.shift();
    for (var I = 0; I < W; I++) {
      var P = k[I];
      C && (C !== "/" ? P = C + "/" + P : P = C + P), this._process([P].concat(S), F, M, B);
    }
    B();
  }, E.prototype._emitMatch = function(C, w) {
    if (!this.aborted && !y(this, w)) {
      if (this.paused) {
        this._emitQueue.push([C, w]);
        return;
      }
      var A = u(w) ? w : this._makeAbs(w);
      if (this.mark && (w = this._mark(w)), this.absolute && (w = A), !this.matches[C][w]) {
        if (this.nodir) {
          var S = this.cache[A];
          if (S === "DIR" || Array.isArray(S))
            return;
        }
        this.matches[C][w] = true;
        var F = this.statCache[A];
        F && this.emit("stat", w, F), this.emit("match", w);
      }
    }
  }, E.prototype._readdirInGlobStar = function(C, w) {
    if (this.aborted)
      return;
    if (this.follow)
      return this._readdir(C, false, w);
    var A = "lstat\0" + C, S = this, F = p(A, M);
    F && S.fs.lstat(C, F);
    function M(U, B) {
      if (U && U.code === "ENOENT")
        return w();
      var q = B && B.isSymbolicLink();
      S.symlinks[C] = q, !q && B && !B.isDirectory() ? (S.cache[C] = "FILE", w()) : S._readdir(C, false, w);
    }
  }, E.prototype._readdir = function(C, w, A) {
    if (!this.aborted && (A = p("readdir\0" + C + "\0" + w, A), !!A)) {
      if (w && !f(this.symlinks, C))
        return this._readdirInGlobStar(C, A);
      if (f(this.cache, C)) {
        var S = this.cache[C];
        if (!S || S === "FILE")
          return A();
        if (Array.isArray(S))
          return A(null, S);
      }
      var F = this;
      F.fs.readdir(C, b(this, C, A));
    }
  };
  function b(C, w, A) {
    return function(S, F) {
      S ? C._readdirError(w, S, A) : C._readdirEntries(w, F, A);
    };
  }
  return E.prototype._readdirEntries = function(C, w, A) {
    if (!this.aborted) {
      if (!this.mark && !this.stat)
        for (var S = 0; S < w.length; S++) {
          var F = w[S];
          C === "/" ? F = C + F : F = C + "/" + F, this.cache[F] = true;
        }
      return this.cache[C] = w, A(null, w);
    }
  }, E.prototype._readdirError = function(C, w, A) {
    if (!this.aborted) {
      switch (w.code) {
        case "ENOTSUP":
        case "ENOTDIR":
          var S = this._makeAbs(C);
          if (this.cache[S] = "FILE", S === this.cwdAbs) {
            var F = new Error(w.code + " invalid cwd " + this.cwd);
            F.path = this.cwd, F.code = w.code, this.emit("error", F), this.abort();
          }
          break;
        case "ENOENT":
        case "ELOOP":
        case "ENAMETOOLONG":
        case "UNKNOWN":
          this.cache[this._makeAbs(C)] = false;
          break;
        default:
          this.cache[this._makeAbs(C)] = false, this.strict && (this.emit("error", w), this.abort()), this.silent || console.error("glob error", w);
          break;
      }
      return A();
    }
  }, E.prototype._processGlobStar = function(C, w, A, S, F, M, U) {
    var B = this;
    this._readdir(A, M, function(q, z) {
      B._processGlobStar2(C, w, A, S, F, M, z, U);
    });
  }, E.prototype._processGlobStar2 = function(C, w, A, S, F, M, U, B) {
    if (!U)
      return B();
    var q = S.slice(1), z = C ? [C] : [], D = z.concat(q);
    this._process(D, F, false, B);
    var X = this.symlinks[A], k = U.length;
    if (X && M)
      return B();
    for (var I = 0; I < k; I++) {
      var P = U[I];
      if (!(P.charAt(0) === "." && !this.dot)) {
        var G = z.concat(U[I], q);
        this._process(G, F, true, B);
        var W = z.concat(U[I], S);
        this._process(W, F, true, B);
      }
    }
    B();
  }, E.prototype._processSimple = function(C, w, A) {
    var S = this;
    this._stat(C, function(F, M) {
      S._processSimple2(C, w, F, M, A);
    });
  }, E.prototype._processSimple2 = function(C, w, A, S, F) {
    if (this.matches[w] || (this.matches[w] = /* @__PURE__ */ Object.create(null)), !S)
      return F();
    if (C && u(C) && !this.nomount) {
      var M = /[\/\\]$/.test(C);
      C.charAt(0) === "/" ? C = a.join(this.root, C) : (C = a.resolve(this.root, C), M && (C += "/"));
    }
    process.platform === "win32" && (C = C.replace(/\\/g, "/")), this._emitMatch(w, C), F();
  }, E.prototype._stat = function(C, w) {
    var A = this._makeAbs(C), S = C.slice(-1) === "/";
    if (C.length > this.maxLength)
      return w();
    if (!this.stat && f(this.cache, A)) {
      var F = this.cache[A];
      if (Array.isArray(F) && (F = "DIR"), !S || F === "DIR")
        return w(null, F);
      if (S && F === "FILE")
        return w();
    }
    var M = this.statCache[A];
    if (M !== void 0) {
      if (M === false)
        return w(null, M);
      var U = M.isDirectory() ? "DIR" : "FILE";
      return S && U === "FILE" ? w() : w(null, U, M);
    }
    var B = this, q = p("stat\0" + A, z);
    q && B.fs.lstat(A, q);
    function z(D, X) {
      if (X && X.isSymbolicLink())
        return B.fs.stat(A, function(k, I) {
          k ? B._stat2(C, A, null, X, w) : B._stat2(C, A, k, I, w);
        });
      B._stat2(C, A, D, X, w);
    }
  }, E.prototype._stat2 = function(C, w, A, S, F) {
    if (A && (A.code === "ENOENT" || A.code === "ENOTDIR"))
      return this.statCache[w] = false, F();
    var M = C.slice(-1) === "/";
    if (this.statCache[w] = S, w.slice(-1) === "/" && S && !S.isDirectory())
      return F(null, false, S);
    var U = true;
    return S && (U = S.isDirectory() ? "DIR" : "FILE"), this.cache[w] = this.cache[w] || U, M && U === "FILE" ? F() : F(null, U, S);
  }, glob_1;
}
var rimraf_1, hasRequiredRimraf;
function requireRimraf() {
  if (hasRequiredRimraf) return rimraf_1;
  hasRequiredRimraf = 1, rimraf_1 = d, d.sync = g;
  var i2 = requireAssert(), e = require$$1$1, t = require$$1$1, r = void 0;
  try {
    r = requireGlob();
  } catch {
  }
  var a = parseInt("666", 8), s = {
    nosort: true,
    silent: true
  }, u = 0, l = process.platform === "win32";
  function c(E) {
    var b = [
      "unlink",
      "chmod",
      "stat",
      "lstat",
      "rmdir",
      "readdir"
    ];
    if (b.forEach(function(C) {
      E[C] = E[C] || t[C], C = C + "Sync", E[C] = E[C] || t[C];
    }), E.maxBusyTries = E.maxBusyTries || 3, E.emfileWait = E.emfileWait || 1e3, E.glob === false && (E.disableGlob = true), E.disableGlob !== true && r === void 0)
      throw Error("glob dependency not found, set `options.disableGlob = true` if intentional");
    E.disableGlob = E.disableGlob || false, E.glob = E.glob || s;
  }
  function d(E, b, C) {
    typeof b == "function" && (C = b, b = {}), i2(E, "rimraf: missing path"), i2.equal(typeof E, "string", "rimraf: path should be a string"), i2.equal(typeof C, "function", "rimraf: callback function required"), i2(b, "rimraf: invalid options argument provided"), i2.equal(typeof b, "object", "rimraf: options should be object"), c(b);
    var w = 0, A = null, S = 0;
    if (b.disableGlob || !r.hasMagic(E))
      return M(null, [E]);
    b.lstat(E, function(U, B) {
      if (!U)
        return M(null, [E]);
      r(E, b.glob, M);
    });
    function F(U) {
      A = A || U, --S === 0 && C(A);
    }
    function M(U, B) {
      if (U)
        return C(U);
      if (S = B.length, S === 0)
        return C();
      B.forEach(function(q) {
        f(q, b, function z(D) {
          if (D) {
            if ((D.code === "EBUSY" || D.code === "ENOTEMPTY" || D.code === "EPERM") && w < b.maxBusyTries) {
              w++;
              var X = w * 100;
              return setTimeout(function() {
                f(q, b, z);
              }, X);
            }
            if (D.code === "EMFILE" && u < b.emfileWait)
              return setTimeout(function() {
                f(q, b, z);
              }, u++);
            D.code === "ENOENT" && (D = null);
          }
          u = 0, F(D);
        });
      });
    }
  }
  function f(E, b, C) {
    i2(E), i2(b), i2(typeof C == "function"), b.lstat(E, function(w, A) {
      if (w && w.code === "ENOENT")
        return C(null);
      if (w && w.code === "EPERM" && l && p(E, b, w, C), A && A.isDirectory())
        return y(E, b, w, C);
      b.unlink(E, function(S) {
        if (S) {
          if (S.code === "ENOENT")
            return C(null);
          if (S.code === "EPERM")
            return l ? p(E, b, S, C) : y(E, b, S, C);
          if (S.code === "EISDIR")
            return y(E, b, S, C);
        }
        return C(S);
      });
    });
  }
  function p(E, b, C, w) {
    i2(E), i2(b), i2(typeof w == "function"), C && i2(C instanceof Error), b.chmod(E, a, function(A) {
      A ? w(A.code === "ENOENT" ? null : C) : b.stat(E, function(S, F) {
        S ? w(S.code === "ENOENT" ? null : C) : F.isDirectory() ? y(E, b, C, w) : b.unlink(E, w);
      });
    });
  }
  function m(E, b, C) {
    i2(E), i2(b), C && i2(C instanceof Error);
    try {
      b.chmodSync(E, a);
    } catch (A) {
      if (A.code === "ENOENT")
        return;
      throw C;
    }
    try {
      var w = b.statSync(E);
    } catch (A) {
      if (A.code === "ENOENT")
        return;
      throw C;
    }
    w.isDirectory() ? _(E, b, C) : b.unlinkSync(E);
  }
  function y(E, b, C, w) {
    i2(E), i2(b), C && i2(C instanceof Error), i2(typeof w == "function"), b.rmdir(E, function(A) {
      A && (A.code === "ENOTEMPTY" || A.code === "EEXIST" || A.code === "EPERM") ? x(E, b, w) : A && A.code === "ENOTDIR" ? w(C) : w(A);
    });
  }
  function x(E, b, C) {
    i2(E), i2(b), i2(typeof C == "function"), b.readdir(E, function(w, A) {
      if (w)
        return C(w);
      var S = A.length;
      if (S === 0)
        return b.rmdir(E, C);
      var F;
      A.forEach(function(M) {
        d(e.join(E, M), b, function(U) {
          if (!F) {
            if (U)
              return C(F = U);
            --S === 0 && b.rmdir(E, C);
          }
        });
      });
    });
  }
  function g(E, b) {
    b = b || {}, c(b), i2(E, "rimraf: missing path"), i2.equal(typeof E, "string", "rimraf: path should be a string"), i2(b, "rimraf: missing options"), i2.equal(typeof b, "object", "rimraf: options should be object");
    var C;
    if (b.disableGlob || !r.hasMagic(E))
      C = [E];
    else
      try {
        b.lstatSync(E), C = [E];
      } catch {
        C = r.sync(E, b.glob);
      }
    if (C.length)
      for (var w = 0; w < C.length; w++) {
        var E = C[w];
        try {
          var A = b.lstatSync(E);
        } catch (F) {
          if (F.code === "ENOENT")
            return;
          F.code === "EPERM" && l && m(E, b, F);
        }
        try {
          A && A.isDirectory() ? _(E, b, null) : b.unlinkSync(E);
        } catch (F) {
          if (F.code === "ENOENT")
            return;
          if (F.code === "EPERM")
            return l ? m(E, b, F) : _(E, b, F);
          if (F.code !== "EISDIR")
            throw F;
          _(E, b, F);
        }
      }
  }
  function _(E, b, C) {
    i2(E), i2(b), C && i2(C instanceof Error);
    try {
      b.rmdirSync(E);
    } catch (w) {
      if (w.code === "ENOENT")
        return;
      if (w.code === "ENOTDIR")
        throw C;
      (w.code === "ENOTEMPTY" || w.code === "EEXIST" || w.code === "EPERM") && T(E, b);
    }
  }
  function T(E, b) {
    i2(E), i2(b), b.readdirSync(E).forEach(function(F) {
      g(e.join(E, F), b);
    });
    var C = l ? 100 : 1, w = 0;
    do {
      var A = true;
      try {
        var S = b.rmdirSync(E, b);
        return A = false, S;
      } finally {
        if (++w < C && A)
          continue;
      }
    } while (true);
  }
  return rimraf_1;
}
var rmfr, hasRequiredRmfr;
function requireRmfr() {
  if (hasRequiredRmfr) return rmfr;
  hasRequiredRmfr = 1;
  const { promisify: i2 } = requireUtil$1(), { resolve: e } = require$$1$1, t = requireAssertValidGlobOpts(), { chmod: r, readdir: a, rmdir: s, unlink: u } = requireGracefulFs(), { hasMagic: l } = requireGlob(), c = requireInspectWithKind(), d = requireRimraf(), f = "https://github.com/isaacs/rimraf#options", p = [
    "unlink",
    "chmod",
    "stat",
    "lstat",
    "rmdir",
    "readdir"
  ], m = [
    "mark",
    "stat"
  ], y = [
    "nosort",
    "nounique"
  ], x = i2(d);
  return rmfr = async function(...g) {
    const _ = g.length;
    if (_ !== 1 && _ !== 2)
      throw new RangeError(`Expected 1 or 2 arguments (<string>[, <Object>]), but got ${_ === 0 ? "no" : _} arguments.`);
    const T = {
      glob: false,
      chmod: r,
      readdir: a,
      rmdir: s,
      unlink: u
    };
    if (_ === 1)
      return x(g[0], T);
    const [E] = g;
    if (typeof g[1] != "object")
      throw new TypeError(`Expected an option object passed to rimraf (${f}), but got ${c(g[1])}.`);
    const b = Object.assign(T, g[1]), C = [];
    for (const A of p)
      b[A] !== void 0 && typeof b[A] != "function" && C.push(`\`${A}\` option must be a function, but got ${c(b[A])}.`);
    b.maxBusyTries !== void 0 && typeof b.maxBusyTries != "number" && C.push(`\`maxBusyTries\` option must be a number, but got ${c(b.maxBusyTries)}.`), b.emfileWait !== void 0 && typeof b.emfileWait != "number" && C.push(`\`emfileWait\` option must be a number, but got ${c(b.emfileWait)}.`), b.disableGlob !== void 0 && C.push(`rmfr doesn't support \`disableGlob\` option, but a value ${c(b.disableGlob)} was provided. rmfr disables glob feature by default.`);
    const w = {
      nosort: true,
      nounique: true,
      silent: true
    };
    if (b.glob === true)
      b.glob = w;
    else if (typeof b.glob == "object") {
      t(b.glob);
      const A = b.glob.cwd !== void 0;
      for (const S of m) {
        const F = b.glob[S];
        F && C.push(`rmfr doesn't support \`${S}\` option in \`glob\` option, but got ${c(F)}.`);
      }
      for (const S of y)
        b.glob[S] === false && C.push(`rmfr doesn't allow \`${S}\` option in \`glob\` option to be disabled, but \`false\` was passed to it.`);
      if (b.glob = Object.assign(T, b.glob, {
        // Remove this line when isaacs/rimraf#133 is merged
        absolute: A
      }), C.length === 0 && A && !l(E, b.glob))
        return x(e(b.glob.cwd, E), Object.assign(b, {
          disableGlob: true
        }));
    } else b.glob !== false && C.push(`\`glob\` option must be an object passed to \`glob\` or a Boolean value, but got ${c(b.glob)}.`);
    if (C.length === 1)
      throw new TypeError(C[0]);
    if (C.length !== 0)
      throw new TypeError(`There was ${C.length} errors in rimraf options you provided:
${C.map((A) => `  * ${A}`).join(`
`)}
`);
    return x(E, b);
  }, rmfr;
}
var hasRequiredMtempy;
function requireMtempy() {
  return hasRequiredMtempy || (hasRequiredMtempy = 1, function(i2) {
    const e = require$$1$1, t = require$$1$1, r = requireUniqueString(), a = requireTempDir(), s = requireIsStream(), u = requireRmfr(), l = require$$1$1, { promisify: c } = requireUtil$1(), d = c(l.pipeline), { writeFile: f } = e.promises, p = (x = "") => t.join(a, x + r()), m = async (x, g) => d(g, e.createWriteStream(x)), y = (x, { extraArguments: g = 0 } = {}) => async (..._) => {
      const [T, E] = _.slice(g), b = await x(..._.slice(0, g), E), C = await T(b);
      return await u(b), C;
    };
    i2.exports.file = (x) => {
      if (x = {
        ...x
      }, x.name) {
        if (x.extension !== void 0 && x.extension !== null)
          throw new Error("The `name` and `extension` options are mutually exclusive");
        return t.join(i2.exports.directory(), x.name);
      }
      return p() + (x.extension === void 0 || x.extension === null ? "" : "." + x.extension.replace(/^\./, ""));
    }, i2.exports.file.task = y(i2.exports.file), i2.exports.directory = ({ prefix: x = "" } = {}) => {
      const g = p(x);
      return e.mkdirSync(g), g;
    }, i2.exports.directory.task = y(i2.exports.directory), i2.exports.write = async (x, g) => {
      const _ = i2.exports.file(g);
      return await (s(x) ? m : f)(_, x), _;
    }, i2.exports.write.task = y(i2.exports.write, { extraArguments: 1 }), i2.exports.writeSync = (x, g) => {
      const _ = i2.exports.file(g);
      return e.writeFileSync(_, x), _;
    }, Object.defineProperty(i2.exports, "root", {
      get() {
        return a;
      }
    });
  }(mtempy)), mtempy.exports;
}
var conf, hasRequiredConf;
function requireConf() {
  if (hasRequiredConf) return conf;
  hasRequiredConf = 1;
  const { isBrowser: i2 } = requireLib$5(), e = require$$1$1, t = requireUtils();
  class r {
    constructor(u = {}) {
      if (this.conf = u, this.conf.pathId = this.conf.pathId || t.genUuid(), this.copyByDefaultVal(u, "crf", 20), this.copyByDefaultVal(u, "vb", null), this.copyByDefaultVal(u, "cover", null), this.copyByDefaultVal(u, "pool", false), this.copyByDefaultVal(u, "debug", false), this.copyByDefaultVal(u, "preload", true), this.copyByDefaultVal(u, "antialias", true), this.copyByDefaultVal(u, "audioLoop", true), this.copyByDefaultVal(u, "ffmpeglog", false), this.copyByDefaultVal(u, "ext", "mp4"), this.copyByDefaultVal(u, "preset", "ultrafast"), this.copyByDefaultVal(u, "cacheFormat", "raw"), this.copyByDefaultVal(u, "cacheQuality", 80), this.copyByDefaultVal(u, "adjustPlaySpeed", false), this.copyByDefaultVal(u, "resolution", 1), this.copyByDefaultVal(u, "audioSampleRate", 44100), this.copyByDefaultVal(u, "defaultOutputOptions", {
        merge: true,
        options: []
      }), this.copyFromMultipleVal(u, "fps", "rfps", 24), this.copyFromMultipleVal(u, "width", "w", 800), this.copyFromMultipleVal(u, "height", "h", 450), this.copyFromMultipleVal(u, "parallel", "frames", 1), this.copyFromMultipleVal(u, "render", "renderer", "canvas"), this.copyFromMultipleVal(u, "normalizeAudio", "norAudio", true), this.copyFromMultipleVal(u, "clarity", "renderClarity", "medium"), !i2) {
        const l = requireMtempy();
        this.copyFromMultipleVal(u, "outputDir", "dir", e.join("./")), this.copyFromMultipleVal(u, "cacheDir", "cacheDir", l.directory()), this.copyFromMultipleVal(u, "output", "out", e.join("./", `${this.conf.pathId}.mp4`)), this.copyFromMultipleVal(u, "highWaterMark", "size", define_process_env_default.HIGH_WATER_MARK || "200kb");
      }
    }
    /**
     * Get the val corresponding to the key
     * @param {string} key - key
     * @return {any} val
     * @public
     */
    getVal(u) {
      return u === "detailedCacheDir" ? this.getCacheDir() : this.conf[u];
    }
    /**
     * Set the val corresponding to the key
     * @param {string} key - key
     * @param {any} val - val
     * @public
     */
    setVal(u, l) {
      this.conf[u] = l;
    }
    /**
     * Get the width and height in the configuration (add separator)
     * @param {string} dot - separator
     * @retrun {string} 'widthxheight'
     * @public
     */
    getWH(u = "x") {
      return this.getVal("width") + u + this.getVal("height");
    }
    /**
     * Get the cache directory
     * @retrun {string} path
     * @public
     */
    getCacheDir() {
      let u = this.getVal("cacheDir"), l = this.getVal("pathId");
      return e.join(u, l);
    }
    copyByDefaultVal(u, l, c) {
      this.conf[l] = u[l] === void 0 ? c : u[l];
    }
    /**
     * Guarantee that a key must have value
     * @public
     */
    copyFromMultipleVal(u, l, c, d) {
      this.conf[l] = u[l] || u[c] || d;
    }
    /**
     * A fake proxy Conf object
     * @public
     */
    static getFakeConf() {
      return a;
    }
  }
  const a = {
    // eslint-disable-next-line
    getVal(s) {
      return null;
    },
    // eslint-disable-next-line
    setVal(s, u) {
      return null;
    }
  };
  return conf = r, conf;
}
var pool$1, hasRequiredPool$1;
function requirePool$1() {
  return hasRequiredPool$1 || (hasRequiredPool$1 = 1, pool$1 = {
    cache: {},
    get(i2, e) {
      return !this.cache[i2] || !this.cache[i2].length ? e() : this.cache[i2].pop();
    },
    put(i2, e) {
      e && (this.cache[i2] || (this.cache[i2] = []), this.cache[i2].push(e));
    },
    resetNode(i2) {
      return i2.removeAllChildren && i2.removeAllChildren(), i2;
    },
    toString() {
      let i2 = "Pool: ";
      for (let e in this.cache) {
        const t = this.cache[e], r = t ? t.length : 0;
        i2 += `${e}-length:${r}  `;
      }
      return i2;
    }
  }), pool$1;
}
var event$1, hasRequiredEvent;
function requireEvent() {
  if (hasRequiredEvent) return event$1;
  hasRequiredEvent = 1;
  class i2 {
    constructor(t) {
      this.init(t);
    }
    init(t = {}) {
      t.type = t.type || "normal", Object.assign(this, t);
    }
  }
  return event$1 = i2, event$1;
}
var eventemitter3 = { exports: {} }, hasRequiredEventemitter3;
function requireEventemitter3() {
  return hasRequiredEventemitter3 || (hasRequiredEventemitter3 = 1, function(i2) {
    var e = Object.prototype.hasOwnProperty, t = "~";
    function r() {
    }
    Object.create && (r.prototype = /* @__PURE__ */ Object.create(null), new r().__proto__ || (t = false));
    function a(c, d, f) {
      this.fn = c, this.context = d, this.once = f || false;
    }
    function s(c, d, f, p, m) {
      if (typeof f != "function")
        throw new TypeError("The listener must be a function");
      var y = new a(f, p || c, m), x = t ? t + d : d;
      return c._events[x] ? c._events[x].fn ? c._events[x] = [c._events[x], y] : c._events[x].push(y) : (c._events[x] = y, c._eventsCount++), c;
    }
    function u(c, d) {
      --c._eventsCount === 0 ? c._events = new r() : delete c._events[d];
    }
    function l() {
      this._events = new r(), this._eventsCount = 0;
    }
    l.prototype.eventNames = function() {
      var c = [], d, f;
      if (this._eventsCount === 0) return c;
      for (f in d = this._events)
        e.call(d, f) && c.push(t ? f.slice(1) : f);
      return Object.getOwnPropertySymbols ? c.concat(Object.getOwnPropertySymbols(d)) : c;
    }, l.prototype.listeners = function(c) {
      var d = t ? t + c : c, f = this._events[d];
      if (!f) return [];
      if (f.fn) return [f.fn];
      for (var p = 0, m = f.length, y = new Array(m); p < m; p++)
        y[p] = f[p].fn;
      return y;
    }, l.prototype.listenerCount = function(c) {
      var d = t ? t + c : c, f = this._events[d];
      return f ? f.fn ? 1 : f.length : 0;
    }, l.prototype.emit = function(c, d, f, p, m, y) {
      var x = t ? t + c : c;
      if (!this._events[x]) return false;
      var g = this._events[x], _ = arguments.length, T, E;
      if (g.fn) {
        switch (g.once && this.removeListener(c, g.fn, void 0, true), _) {
          case 1:
            return g.fn.call(g.context), true;
          case 2:
            return g.fn.call(g.context, d), true;
          case 3:
            return g.fn.call(g.context, d, f), true;
          case 4:
            return g.fn.call(g.context, d, f, p), true;
          case 5:
            return g.fn.call(g.context, d, f, p, m), true;
          case 6:
            return g.fn.call(g.context, d, f, p, m, y), true;
        }
        for (E = 1, T = new Array(_ - 1); E < _; E++)
          T[E - 1] = arguments[E];
        g.fn.apply(g.context, T);
      } else {
        var b = g.length, C;
        for (E = 0; E < b; E++)
          switch (g[E].once && this.removeListener(c, g[E].fn, void 0, true), _) {
            case 1:
              g[E].fn.call(g[E].context);
              break;
            case 2:
              g[E].fn.call(g[E].context, d);
              break;
            case 3:
              g[E].fn.call(g[E].context, d, f);
              break;
            case 4:
              g[E].fn.call(g[E].context, d, f, p);
              break;
            default:
              if (!T) for (C = 1, T = new Array(_ - 1); C < _; C++)
                T[C - 1] = arguments[C];
              g[E].fn.apply(g[E].context, T);
          }
      }
      return true;
    }, l.prototype.on = function(c, d, f) {
      return s(this, c, d, f, false);
    }, l.prototype.once = function(c, d, f) {
      return s(this, c, d, f, true);
    }, l.prototype.removeListener = function(c, d, f, p) {
      var m = t ? t + c : c;
      if (!this._events[m]) return this;
      if (!d)
        return u(this, m), this;
      var y = this._events[m];
      if (y.fn)
        y.fn === d && (!p || y.once) && (!f || y.context === f) && u(this, m);
      else {
        for (var x = 0, g = [], _ = y.length; x < _; x++)
          (y[x].fn !== d || p && !y[x].once || f && y[x].context !== f) && g.push(y[x]);
        g.length ? this._events[m] = g.length === 1 ? g[0] : g : u(this, m);
      }
      return this;
    }, l.prototype.removeAllListeners = function(c) {
      var d;
      return c ? (d = t ? t + c : c, this._events[d] && u(this, d)) : (this._events = new r(), this._eventsCount = 0), this;
    }, l.prototype.off = l.prototype.removeListener, l.prototype.addListener = l.prototype.on, l.prefixed = t, l.EventEmitter = l, i2.exports = l;
  }(eventemitter3)), eventemitter3.exports;
}
var eventer, hasRequiredEventer;
function requireEventer() {
  if (hasRequiredEventer) return eventer;
  hasRequiredEventer = 1;
  const i2 = requireEvent(), e = requireEventemitter3(), t = requireUtils();
  class r extends e {
    constructor() {
      super();
    }
    /**
     * Trigger the progress event
     * @public
     */
    emitProgress(s) {
      this.progressEvent || (this.progressEvent = new i2()), this.progressEvent.init(s), this.emit("progress", this.progressEvent);
    }
    /**
     * Trigger an error event, you can locate the location of the error
     * @public
     */
    emitError({ pos: s, error: u }) {
      const l = new i2();
      l.pos = s, l.error = t.getErrStack(u), this.emit("error", l);
    }
    /**
     * Trigger an ordinary event
     * @public
     */
    emit(s, u = {}) {
      if (typeof s == "object") {
        const l = new i2(s);
        s = l.type, u = l;
      } else
        u.type = s;
      u.target = this, super.emit(s, u), super.emit("*-*", u);
    }
    /**
     * Bundle bubbling function
     * @public
     */
    bubble(s) {
      s.on("*-*", (u) => this.emit(u.type, u));
    }
    destroy() {
      this.removeAllListeners();
    }
  }
  return eventer = r, eventer;
}
var base, hasRequiredBase;
function requireBase() {
  if (hasRequiredBase) return base;
  hasRequiredBase = 1;
  const i2 = requireConf(), e = requireUtils(), t = requireEventer();
  class r extends t {
    constructor(s) {
      super(), this.conf = { type: "base", ...s }, this.parent = null, this.retry = 3, this.genId(), this.conf.parent && typeof this.conf.parent.addChild == "function" && (this.conf.parent.addChild(this), delete this.conf.parent), this.conf.refId || (this.conf.refId = e.genUuid());
    }
    get refId() {
      return this.conf.refId;
    }
    get changed() {
      return `${Date.now()}`;
    }
    set changed(s) {
    }
    get groupId() {
      return this.conf.groupId;
    }
    set groupId(s) {
      return this.conf.groupId = s;
    }
    get type() {
      return this.conf.type;
    }
    set type(s) {
      return this.conf.type = s;
    }
    get name() {
      return this.conf.name;
    }
    set name(s) {
      return this.conf.name = s;
    }
    get parents() {
      return !this.parent || !this.parent.parents ? [] : [...this.parent.parents, this.parent];
    }
    getParam(s) {
      if (!s || typeof s != "string") return;
      if (!s.includes(".")) return this[s];
      let u = this;
      for (const l of s.split(".")) {
        if (typeof u != "object") return;
        u = u[l];
      }
      return u;
    }
    setParam(s, u) {
      if (!s || typeof s != "string") throw new Error(`Invalid key: ${s}`);
      let l = this.conf;
      if (!s.includes(".")) return l[s] = u;
      let c = s.split(".");
      for (let d = 0; d < c.length; d++) {
        const f = c[d];
        if (d === c.length - 1) return l[f] = u;
        typeof l[f] != "object" && (l[f] = isNaN(c[d + 1]) ? {} : []), l = l[f];
      }
    }
    vu(s, u) {
      return s;
    }
    refresh() {
    }
    /**
     * Generate self-increasing unique id
     * @return {string} unique id
     * @public
     */
    genId() {
      const { type: s, id: u } = this.conf;
      this.id = e.genId(u || s);
    }
    /**
     * Get the logical root node of the instance
     * @return {FFBase} root node
     * @public
     */
    root() {
      return this.parent && this.parent.root ? this.parent.root() : this;
    }
    /**
     * Get the conf configuration on the logical root node of the instance
     * If the val parameter is set, the val value of conf is set
     * @param {string} key - configuration key
     * @param {any} val - configuration val
     * @return {object|any} root node
     * @public
     */
    rootConf(s, u) {
      let l = i2.getFakeConf();
      const c = this.root();
      return c && c.type === "creator" && c._conf && (l = c._conf), s ? (u !== void 0 && l.setVal(s, u), l.getVal(s)) : l;
    }
    /**
     * Add callback hook
     * @public
     */
    addFrameCallback() {
      var s;
      (s = this.creator()) == null || s.addFrameCallback(this);
    }
    /**
     * Remove callback hook
     * @public
     */
    removeFrameCallback() {
      var s;
      (s = this.creator()) == null || s.removeFrameCallback(this);
    }
    creator() {
      if (!this._creator) {
        const s = this.root();
        s.type === "creator" && (this._creator = s);
      }
      return this._creator;
    }
    /**
     * Destroy the component
     * @public
     */
    destroy() {
      super.destroy(), this.conf = null, this.parent = null, this._creator = null;
    }
  }
  return base = r, base;
}
var clip, hasRequiredClip;
function requireClip() {
  if (hasRequiredClip) return clip;
  hasRequiredClip = 1;
  const i2 = requireBase(), { DisplayObject: e, createCanvas: t } = requireLib$2(), { dmap: r } = requireUtils(), { isBrowser: a } = requireLib$5();
  class s extends i2 {
    constructor(l = {}) {
      super({ type: "clip", ...l }), this.canvasWidth = l.canvasWidth, this.canvasHeight = l.canvasHeight, this.visible = false, this.zIndex = 0, this.children = [], this.active = l.active !== void 0 ? !!l.active : true, this.onTime = () => false, this.createDisplay();
    }
    get muted() {
      for (const l of this.parents)
        if (l.conf.mute) return true;
      return false;
    }
    get displayParent() {
      for (const l of this.parents.reverse())
        if (l.type === "scene") return l;
      return this.creator();
    }
    toJson(l = false) {
      const c = { ...this.conf };
      for (const f of Object.keys(c))
        f.startsWith("cached") && c[f].startsWith("blob:") && delete c[f];
      delete c.srcFile, delete c.canvasHeight, delete c.canvasWidth, delete c.innerHTML, l && delete c.userfile, this.children && Array.isArray(this.children) && (c.children = this.children.map((f) => f.toJson(l)));
      const d = (f) => {
        if (f)
          for (const [p, m] of Object.entries(f))
            p === "innerHTML" ? delete f[p] : m && typeof m == "object" && d(m);
      };
      return d(c), c;
    }
    createDisplay() {
      this.display = new e();
    }
    addChild(l, c = null) {
      return Array.isArray(l) ? (l.map((d) => this.addChild(d, c)), this) : this.hasChild(l) ? (c && this.hasChild(c) && (this.children = this.children.filter((d) => d.id !== l.id), this.children.splice(this.children.findIndex((d) => d.id == c.id), 0, l)), this) : (l.parent = this, c && this.hasChild(c) ? this.children.splice(this.children.findIndex((d) => d.id == c.id), 0, l) : this.children.push(l), this);
    }
    remove() {
      return this.parent && this.parent.removeChild(this), this;
    }
    hasChild(l) {
      return !!this.children.find((c) => c.id == (l == null ? void 0 : l.id));
    }
    removeChild(l) {
      return this.hasChild(l) ? (this.children = this.children.filter((c) => c.id !== l.id), l.parent = null, this) : this;
    }
    _materialTime(l, c = false) {
      const d = this.material.getDuration();
      let f = l - this.absStartTime, p = 0;
      for (; this.loop && f >= d; )
        f = Math.max(0, f - d), p++;
      return c && (f = this.material.seekTime(f)), { time: f, loops: p };
    }
    addDisplayChild(l) {
      this.parent.addDisplayChild(l);
    }
    removeDisplayChild(l) {
      l.parent && (l.parent.removeChild(l), l.locked = false);
    }
    setMask(l) {
      this.display.mask !== l && (this.display.mask = l);
    }
    removeMask() {
      this.display.mask = null;
    }
    disable() {
      this.active = this.conf.active = false, this.parent && (this.hide(), this.removeTimelineCallback());
    }
    enable() {
      this.active = this.conf.active = true, this.parent && (this.touch(), this.addTimelineCallback());
    }
    touch() {
      this.onTime(this.creator().currentTime / 1e3);
    }
    addTimelineCallback() {
      this.active && this.addFrameCallback();
    }
    removeTimelineCallback() {
      this.removeFrameCallback();
    }
    async drawing(l = 0, c = 0) {
      return !!this.onTime(l * 1e-3);
    }
    preProcessing() {
      return new Promise((l) => l());
    }
    prepareMaterial() {
      return new Promise((l) => l());
    }
    show() {
      this.visible = true, this.display && (this.display.zIndex = this.zIndex, this.parent.addDisplayChild(this.display), this.conf.asMask && (this.display.binaryMask = !!this.conf.binaryMask, this.display.reverseMask = !!this.conf.reverseMask, this.parent.setMask(this.display)));
    }
    hide() {
      this.visible = false, this.display && (this.parent.removeDisplayChild(this.display), this.conf.asMask && this.parent.removeMask());
    }
    getAudioFrame(l, c = 1024) {
      if (!this.audioBuffer || !this.onTime(l * 1e-3, false)) return null;
      const d = [], f = this.volume;
      let p = this.creator().getConf("audioSampleRate");
      a || (p = p / this.audioBuffer.numberOfChannels);
      for (let m = 0; m < this.audioBuffer.numberOfChannels; m++) {
        const y = this.audioBuffer.getChannelData(m), x = new Float32Array(c), g = Math.round(l / 1e3 * p);
        for (let _ = 0; _ < x.length; _++) {
          const T = y[g + _] || 0;
          x[_] = f !== void 0 ? T * f : T;
        }
        d.push(x);
      }
      return d;
    }
    annotate() {
      var l, c;
      let [d, f] = [this.absStartTime, this.absEndTime], [p, m] = [d, f];
      const y = this.displayParent;
      if (((l = this.prevSibling) == null ? void 0 : l.type) === "trans")
        if (this.prevSibling.nextSibling === this) {
          const x = d - this.prevSibling.absEndTime, g = this.prevSibling.duration * 0.5 - x;
          p += g, d -= g;
        } else
          this.prevSibling = null;
      else y.absDrawStartTime < y.absShowStartTime && d <= y.absStartTime && (p = d = Math.min(d, y.absDrawStartTime));
      if (((c = this.nextSibling) == null ? void 0 : c.type) === "trans")
        if (this.nextSibling.prevSibling === this) {
          const x = this.nextSibling.duration * 0.5;
          m -= x, f += x;
        } else
          this.nextSibling = null;
      else y.absDrawEndTime > y.absShowEndTime && f >= y.absEndTime && (m = f = Math.max(d, y.absDrawEndTime));
      this.absShowStartTime = p, this.absShowEndTime = m, this.absDrawStartTime = d, this.absDrawEndTime = f, this.addTimelineCallback(), this.onTime = (x, g = true, _ = "draw") => {
        const T = x >= p && x < m && this.active, E = x >= d && x < f && this.active;
        return g && (T ? this.show() : this.hide()), _ === "draw" ? E : T;
      };
    }
    get basezIndex() {
      var l;
      return Math.min(Number(this.conf.zIndex), 999) * 1e3 || ((l = this.parent) == null ? void 0 : l.basezIndex) || 0;
    }
    get allNodes() {
      let l = this.children;
      return this.children.map((c) => {
        l = l.concat(c.allNodes);
      }), l;
    }
    getByRefId(l) {
      return this.allNodes.find((c) => c.refId === l);
    }
    get absStartTime() {
      var l;
      return this.rt(Math.max(0, ((l = this.parent) == null ? void 0 : l.absStartTime) + this.startTime));
    }
    get absEndTime() {
      var l;
      return this.rt(((l = this.parent) == null ? void 0 : l.absStartTime) + this.endTime);
    }
    get realAbsEndTime() {
      var l;
      return this.rt(((l = this.parent) == null ? void 0 : l.absStartTime) + this.realEndTime);
    }
    get default() {
      var l, c;
      return {
        startTime: (((l = this.parent) == null ? void 0 : l.type) === "spine" ? (c = this.prevSibling) == null ? void 0 : c.endTime : 0) || 0,
        endTime: "100%"
      };
    }
    get startTime() {
      const l = this.time(this.conf.start);
      return this.rt(isNaN(l) ? this.time(this.default.startTime) : l);
    }
    get duration() {
      return this.rt(this.endTime - this.startTime);
    }
    get endTime() {
      var l;
      const c = this.realEndTime;
      return ((l = this.parent) == null ? void 0 : l.type) !== "scene" ? this.rt(c) : this.rt(Math.min(this.parent.duration, c));
    }
    get realEndTime() {
      const l = this.time(this.conf.end);
      if (!isNaN(l)) return l;
      let c = this.time(this.conf.duration);
      if (c = isNaN(c) ? this.time(this.default.duration) : c, !isNaN(c)) return this.startTime + c;
      const d = this.time(this.default.endTime);
      return d > this.startTime ? d : this.startTime + 3;
    }
    get flexibleDuration() {
      return this.conf.duration && this.conf.duration.toString().includes("%") || this.conf.end && this.conf.end.toString().includes("%");
    }
    get fps() {
      return this._fps || (this._fps = this.rootConf("fps")), this._fps;
    }
    rt(l) {
      return Math.round(l * 1e3) / 1e3;
    }
    time(l) {
      const c = this.parent ? this.parent.duration : NaN;
      if (typeof l == "string" && l.endsWith("%") && !isNaN(l.replace("%", "")))
        return c * Number(l.replace("%", "")) * 0.01;
      if (typeof l == "string") {
        if (l = l.replaceAll(" ", ""), l.includes("%+") && l.split("%+").length === 2) {
          const [d, f] = l.split("%+");
          return Number(d) * 0.01 * c + Number(f);
        } else if (l.includes("%-") && l.split("%-").length === 2) {
          const [d, f] = l.split("%-");
          return Number(d) * 0.01 * c - Number(f);
        }
      }
      return Number(l);
    }
    px(l) {
      const c = Number(l);
      if (!isNaN(c)) return c;
      if (typeof l == "object") return r(l, (p) => this.px(p));
      const [d, f] = this.deunit(l);
      return d;
    }
    vu(l, c) {
      let [d, f] = this.deunit(c === void 0 ? l : c), p = this.px(l);
      return f || (f = "rpx"), this.enunit(p, f);
    }
    setConfRpx(l, c) {
      this.conf[l] = this.vu(c, this.conf[l]);
    }
    units() {
      const l = this.creator();
      return l && (this.canvasWidth = l.width, this.canvasHeight = l.height), [
        ["rpx", this.canvasWidth, 360],
        ["px", 360, 360],
        ["vw", this.canvasWidth, 100],
        ["vh", this.canvasHeight, 100]
      ];
    }
    /**
     * 把px单位的数值, 转换为给定unit单位的值
     * 返回数字/字符串
     */
    enunit(l, c) {
      const d = this.units().filter((p) => p[0] === c)[0];
      if (!d) return l;
      let f = (l * (d[2] / d[1])).toFixed(3);
      return Math.abs(f - Math.round(f)) < 1e-3 && (f = Math.round(f)), `${f}${c}`;
    }
    /**
     * 把某单位的数值，转换为px的值
     * 返回数组 [num_px, unit]
     */
    deunit(l) {
      if (typeof l == "number" || !l) return [l, null];
      const c = l.toString().toLowerCase().trim(), d = (f, p, m, y) => {
        if (!f.endsWith(p)) return null;
        const x = Number(f.substring(0, f.length - p.length));
        return isNaN(x) ? null : x * (m / y);
      };
      for (const f of this.units()) {
        const p = d(c, f[0], f[1], f[2]);
        if (p !== null) return [p, f[0]];
      }
      return [l, null];
    }
    subImage(l, c, { width: d, height: f, format: p = "jpeg", fit: m = "cover" } = {}) {
      !d && !f ? (d = c.w, f = c.h) : d ? f || (f = c.h / c.w * d) : d = c.w / c.h * f;
      const y = t(d, f), x = y.getContext("2d"), g = Math[m === "cover" ? "max" : "min"](d / c.w, f / c.h), [_, T] = [c.w * g, c.h * g];
      return x.drawImage(
        l,
        c.x,
        c.y,
        c.w,
        c.h,
        (d - _) / 2,
        (f - T) / 2,
        _,
        T
      ), p === "canvas" ? y : y.toDataURL(`image/${p}`);
    }
    get mask() {
      return this.allNodes.find((l) => l.conf.asMask);
    }
    get controls() {
      return this.conf.controls;
    }
    destroy() {
      this.destroyed || (this.destroyed = true, this.removeTimelineCallback(), this.children.map((l) => l.destroy()), this.children = null, this.display && this.display.destroy(true), this.display = null, this.parent = null, this.prevSibling = null, this.nextSibling = null, super.destroy());
    }
  }
  return clip = s, clip;
}
var _freeGlobal, hasRequired_freeGlobal;
function require_freeGlobal() {
  if (hasRequired_freeGlobal) return _freeGlobal;
  hasRequired_freeGlobal = 1;
  var i2 = typeof window == "object" && window && window.Object === Object && window;
  return _freeGlobal = i2, _freeGlobal;
}
var _root, hasRequired_root;
function require_root() {
  if (hasRequired_root) return _root;
  hasRequired_root = 1;
  var i2 = require_freeGlobal(), e = typeof self == "object" && self && self.Object === Object && self, t = i2 || e || Function("return this")();
  return _root = t, _root;
}
var _Symbol, hasRequired_Symbol;
function require_Symbol() {
  if (hasRequired_Symbol) return _Symbol;
  hasRequired_Symbol = 1;
  var i2 = require_root(), e = i2.Symbol;
  return _Symbol = e, _Symbol;
}
var _getRawTag, hasRequired_getRawTag;
function require_getRawTag() {
  if (hasRequired_getRawTag) return _getRawTag;
  hasRequired_getRawTag = 1;
  var i2 = require_Symbol(), e = Object.prototype, t = e.hasOwnProperty, r = e.toString, a = i2 ? i2.toStringTag : void 0;
  function s(u) {
    var l = t.call(u, a), c = u[a];
    try {
      u[a] = void 0;
      var d = true;
    } catch {
    }
    var f = r.call(u);
    return d && (l ? u[a] = c : delete u[a]), f;
  }
  return _getRawTag = s, _getRawTag;
}
var _objectToString, hasRequired_objectToString;
function require_objectToString() {
  if (hasRequired_objectToString) return _objectToString;
  hasRequired_objectToString = 1;
  var i2 = Object.prototype, e = i2.toString;
  function t(r) {
    return e.call(r);
  }
  return _objectToString = t, _objectToString;
}
var _baseGetTag, hasRequired_baseGetTag;
function require_baseGetTag() {
  if (hasRequired_baseGetTag) return _baseGetTag;
  hasRequired_baseGetTag = 1;
  var i2 = require_Symbol(), e = require_getRawTag(), t = require_objectToString(), r = "[object Null]", a = "[object Undefined]", s = i2 ? i2.toStringTag : void 0;
  function u(l) {
    return l == null ? l === void 0 ? a : r : s && s in Object(l) ? e(l) : t(l);
  }
  return _baseGetTag = u, _baseGetTag;
}
var isObjectLike_1, hasRequiredIsObjectLike;
function requireIsObjectLike() {
  if (hasRequiredIsObjectLike) return isObjectLike_1;
  hasRequiredIsObjectLike = 1;
  function i2(e) {
    return e != null && typeof e == "object";
  }
  return isObjectLike_1 = i2, isObjectLike_1;
}
var isSymbol_1, hasRequiredIsSymbol;
function requireIsSymbol() {
  if (hasRequiredIsSymbol) return isSymbol_1;
  hasRequiredIsSymbol = 1;
  var i2 = require_baseGetTag(), e = requireIsObjectLike(), t = "[object Symbol]";
  function r(a) {
    return typeof a == "symbol" || e(a) && i2(a) == t;
  }
  return isSymbol_1 = r, isSymbol_1;
}
var _baseExtremum, hasRequired_baseExtremum;
function require_baseExtremum() {
  if (hasRequired_baseExtremum) return _baseExtremum;
  hasRequired_baseExtremum = 1;
  var i2 = requireIsSymbol();
  function e(t, r, a) {
    for (var s = -1, u = t.length; ++s < u; ) {
      var l = t[s], c = r(l);
      if (c != null && (d === void 0 ? c === c && !i2(c) : a(c, d)))
        var d = c, f = l;
    }
    return f;
  }
  return _baseExtremum = e, _baseExtremum;
}
var _baseLt, hasRequired_baseLt;
function require_baseLt() {
  if (hasRequired_baseLt) return _baseLt;
  hasRequired_baseLt = 1;
  function i2(e, t) {
    return e < t;
  }
  return _baseLt = i2, _baseLt;
}
var identity_1, hasRequiredIdentity;
function requireIdentity() {
  if (hasRequiredIdentity) return identity_1;
  hasRequiredIdentity = 1;
  function i2(e) {
    return e;
  }
  return identity_1 = i2, identity_1;
}
var min_1, hasRequiredMin;
function requireMin() {
  if (hasRequiredMin) return min_1;
  hasRequiredMin = 1;
  var i2 = require_baseExtremum(), e = require_baseLt(), t = requireIdentity();
  function r(a) {
    return a && a.length ? i2(a, t, e) : void 0;
  }
  return min_1 = r, min_1;
}
var date, hasRequiredDate;
function requireDate() {
  return hasRequiredDate || (hasRequiredDate = 1, date = {
    /**
     * Convert seconds to hh:mm:ss format
     * @param {number} sec - second
     * @return {string} hh:mm:ss result
     * @public
     */
    secondsToHms(i2) {
      if (typeof i2 == "string") return i2;
      let e = Math.floor(i2 / 3600), t = Math.floor((i2 - e * 3600) / 60), r = (i2 - e * 3600 - t * 60).toFixed(3);
      return e < 10 && (e = "0" + e), t < 10 && (t = "0" + t), r < 10 && (r = "0" + r), e + ":" + t + ":" + r;
    },
    /**
     * Convert hh:mm:ss format time to seconds
     * @param {string} hms - hh:mm:ss format time
     * @return {number} seconds second
     * @public
     */
    hmsToSeconds(i2) {
      if (typeof i2 == "number") return i2;
      const e = i2.split(":");
      return e.length === 2 && e.unshift(0), +e[0] * 60 * 60 + +e[1] * 60 + +e[2];
    },
    /**
     * Convert time to millisecond format
     * @param {number} time - second time
     * @return {string} millisecondt
     * @public
     */
    toMilliseconds(i2) {
      return i2 === 0 ? 0 : i2 * 1e3;
    },
    /**
     * Convert time to second format
     * @param {number} time - millisecondt time
     * @return {string} second
     * @public
     */
    toSeconds(i2) {
      return i2 === 0 ? 0 : i2 > 100 ? i2 / 1e3 : i2;
    }
  }), date;
}
var material, hasRequiredMaterial;
function requireMaterial() {
  if (hasRequiredMaterial) return material;
  hasRequiredMaterial = 1;
  const i2 = requireMin(), e = require$$1$1, t = requireDate();
  requireUtils(), requireLib$2();
  const { nodeRequire: r } = requireUtils(), a = r("../utils/fs"), s = -1;
  class u {
    constructor(c) {
      this.creator = null, this.info = {}, this.path = "", this.forceTrim = false, this.start = s, this.end = s, this.length = NaN, this.fps = 30, this.duration = NaN, this.setSpeed(Number(c.speed) || 1), this.parseConf(c);
    }
    static playing(c) {
      return c.currentTime > 0 && !c.paused && !c.ended && c.readyState > 2;
    }
    setSpeed(c) {
      this.speed = Math.round(c * 100) / 100;
    }
    seekTime(c, d = {}) {
      const f = c * this.speed + this.getStartOffset(), p = this.forceTrim ? this.getStartOffset() : 0.01, m = this.forceTrim ? this.getEndOffset() : this.length;
      return (f < p || f > m) && (d.overflow = true), Math.min(m, Math.max(p, f));
    }
    parseConf(c) {
      this.conf = c, this.type = c.type, this.path = c.cachedSrc || c.src || c.path || c.image || c.url, this.parseTimeConf(c);
    }
    parseTimeConf(c) {
      this.start = this.parseTimeNumber(c.ss), this.end = this.parseTimeNumber(c.to);
    }
    parseTimeNumber(c) {
      return typeof c == "string" && c.includes(":") ? t.hmsToSeconds(c) : (c = Number(c), isNaN(c) ? s : c);
    }
    getStartOffset() {
      return this.start == s ? 0 : this.start;
    }
    getEndOffset(c = false) {
      const d = [], f = this.getStartOffset() + this.duration * this.speed;
      return c && !isNaN(f) && d.push(f), isNaN(this.length) || d.push(this.length), this.end !== s && d.push(this.end), d.length > 0 ? i2(d) : NaN;
    }
    getStartHms() {
      return t.secondsToHms(this.getStartOffset());
    }
    getEndHms() {
      return t.secondsToHms(this.getEndOffset(true));
    }
    getSliceOpts(c = true) {
      let d = [];
      return this.getStartOffset() > 0 && (d = d.concat(["-ss", this.getStartHms()])), this.getEndOffset(true) < this.length && c && (d = d.concat(["-to", this.getEndHms()])), d;
    }
    getOutputPath(c, d) {
      return a.ensureDir(c), e.join(c, d);
    }
    /**
     * Obtain duration based on movie information
     * @return {number} movie information duration
     * @public
     */
    getDuration(c = false) {
      return Math.max(0, this.getSourceDuration(c) / this.speed);
    }
    getSourceDuration(c) {
      return this.getEndOffset(c) - this.getStartOffset();
    }
    toString() {
      return `${this.type}:${this.path}-length:${this.length}`;
    }
    destroy() {
      this.creator = null, this.info = null, this.path = "", this.length = 0;
    }
  }
  return material = u, material;
}
var xhr, hasRequiredXhr;
function requireXhr() {
  if (hasRequiredXhr) return xhr;
  hasRequiredXhr = 1;
  const { isBrowser: i2, isWebWorker: e } = requireLib$5(), { nodeRequire: t, genUuid: r } = requireUtils(), a = t("./node-fetch"), s = requireMd5(), u = {}, l = {};
  return window && (window.MIRAP_XHRS = l, window.MIRAP_RESP_CACHE = u), xhr = {
    async cancel(c) {
      for (const [d, f] of Object.entries(l))
        c === f._cid && f.abort();
      for (const [d, f] of Object.entries(u)) {
        const p = await f;
        c === p.cid && delete u[d];
      }
    },
    async getRemote(c, d, f = null) {
      const p = s(c);
      return u[p] || (u[p] = new Promise(function(m) {
        if (i2 || e) {
          const y = r(), x = new XMLHttpRequest();
          x.addEventListener("load", () => {
            delete l[y];
            const g = x.getResponseHeader("Content-Type");
            m({ data: x.response, type: g, cid: d });
          }), x.addEventListener("error", (g) => {
            delete l[y], m({ url: c, cid: d });
          }), x.addEventListener("abort", (g) => {
            delete l[y], m({ url: c, cid: d });
          }), x.addEventListener("progress", (g) => {
            f && f(g);
          }), x.open("get", c), x.responseType = "blob", x._cid = d, x.send(), l[y] = x;
        } else
          a(c).then((y) => {
            const x = y.headers.get("content-type");
            m({ data: y, type: x });
          });
      })), u[p];
    }
  }, xhr;
}
var fourierTransform, hasRequiredFourierTransform;
function requireFourierTransform() {
  if (hasRequiredFourierTransform) return fourierTransform;
  hasRequiredFourierTransform = 1, fourierTransform = function(e, t) {
    if (!e) throw Error("Input waveform is not provided, pass input array.");
    var r = e.length, a = Math.floor(Math.log(r) / Math.LN2);
    if (Math.pow(2, a) !== r) throw Error("Invalid array size, must be a power of 2.");
    t || (t = new Array(r / 2));
    var s = r, u = new Array(r), l = 2 * Math.PI, c = Math.sqrt, d = s >>> 1, f = 2 / s, p, m, y, x, g, _, T, E, b, C, w, A, S, F, M, U, B, q, z, D, X, k, I, P, G, W;
    i2(r, u, e);
    for (var V = 0, K = 4; V < s; K *= 4) {
      for (var J = V; J < s; J += K)
        B = u[J] - u[J + 1], u[J] += u[J + 1], u[J + 1] = B;
      V = 2 * (K - 1);
    }
    for (p = 2, x = s >>> 1; x = x >>> 1; ) {
      V = 0, p = p << 1, K = p << 1, m = p >>> 2, y = p >>> 3;
      do {
        if (m !== 1)
          for (J = V; J < s; J += K)
            b = J, C = b + m, w = C + m, A = w + m, g = u[w] + u[A], u[A] -= u[w], u[w] = u[b] - g, u[b] += g, b += y, C += y, w += y, A += y, g = u[w] + u[A], _ = u[w] - u[A], g = -g * Math.SQRT1_2, _ *= Math.SQRT1_2, B = u[C], u[A] = g + B, u[w] = g - B, u[C] = u[b] - _, u[b] += _;
        else
          for (J = V; J < s; J += K)
            b = J, C = b + m, w = C + m, A = w + m, g = u[w] + u[A], u[A] -= u[w], u[w] = u[b] - g, u[b] += g;
        V = (K << 1) - p, K = K << 2;
      } while (V < s);
      k = l / p;
      for (var ae = 1; ae < y; ae++) {
        I = ae * k, z = Math.sin(I), q = Math.cos(I), D = 4 * q * (q * q - 0.75), X = 4 * z * (0.75 - z * z), V = 0, K = p << 1;
        do {
          for (J = V; J < s; J += K)
            b = J + ae, C = b + m, w = C + m, A = w + m, S = J + m - ae, F = S + m, M = F + m, U = M + m, _ = u[M] * q - u[w] * z, g = u[M] * z + u[w] * q, E = u[U] * D - u[A] * X, T = u[U] * X + u[A] * D, B = _ - E, _ += E, E = B, u[U] = _ + u[F], u[w] = _ - u[F], B = T - g, g += T, T = B, u[A] = T + u[C], u[M] = T - u[C], u[F] = u[b] - g, u[b] += g, u[C] = E + u[S], u[S] -= E;
          V = (K << 1) - p, K = K << 2;
        } while (V < s);
      }
    }
    for (; --d; )
      P = u[d], G = u[s - d - 1], W = f * c(P * P + G * G), t[d] = W;
    return t[0] = Math.abs(f * u[0]), t;
  };
  function i2(e, t, r) {
    var a = e >>> 1, s = e - 1, u = 1, l = 0, c;
    t[0] = r[0];
    do {
      for (l += a, t[u] = r[l], t[l] = r[u], u++, c = a << 1; c = c >> 1, !((l ^= c) & c); )
        ;
      l >= u && (t[u] = r[l], t[l] = r[u], t[s - u] = r[s - l], t[s - l] = r[s - u]), u++;
    } while (u < a);
    t[s] = r[s];
  }
  return fourierTransform;
}
var math, hasRequiredMath;
function requireMath() {
  if (hasRequiredMath) return math;
  hasRequiredMath = 1;
  function i2(u, l, c) {
    return u < l ? l : u > c ? c : u;
  }
  function e(u, l, c) {
    const d = (u - l) / (c - l);
    return i2(d, 0, 1);
  }
  function t(u) {
    return ~~u;
  }
  function r(u) {
    return Math.exp(0.1151292546497023 * u);
  }
  function a(u) {
    return 20 * s(u);
  }
  function s(u) {
    return Math.log(u) / Math.LN10;
  }
  return math = {
    clamp: i2,
    normalize: e,
    floor: t,
    db2mag: r,
    mag2db: a,
    log10: s,
    blackman: (u, l) => {
      const c = 6.283185307179586 * u / (l - 1);
      return 0.42 - 0.5 * Math.cos(c) + 0.08 * Math.cos(2 * c);
    }
  }, math;
}
var audio$1, hasRequiredAudio$1;
function requireAudio$1() {
  if (hasRequiredAudio$1) return audio$1;
  hasRequiredAudio$1 = 1;
  const { isBrowser: i2 } = requireLib$5(), { getRemote: e } = requireXhr(), { nodeRequire: t } = requireUtils(), r = requireFourierTransform(), { db2mag: a, floor: s, mag2db: u, normalize: l, blackman: c } = requireMath(), d = require$$1$1;
  let f;
  i2 ? f = window.AudioContext || window.webkitAudioContext || window.mozAudioContext || window.msAudioContext : f = t("web-audio-api").AudioContext;
  const p = class Bm {
    constructor(x) {
      this.properties = Bm.defaultProperties, this.properties.fftSize = x, this.init();
    }
    minute(x) {
      const g = Math.floor(x / 60);
      return g < 10 ? "0" + g : g;
    }
    second(x) {
      const g = Math.floor(x % 60);
      return g < 10 ? "0" + g : g;
    }
    init() {
      const {
        properties: { fftSize: x }
      } = this;
      this.oriFFT = new Float32Array(x / 2), this.td = new Float32Array(x), this.blackmanTable = new Float32Array(x);
      for (let g = 0; g < x; g++)
        this.blackmanTable[g] = c(g, x);
      this.buffer = new Float32Array(x), this.smoothing = new Float32Array(x / 2);
    }
    getFloatTimeDomainData(x) {
      x.set(this.buffer);
    }
    getFloatFrequencyData(x) {
      const { fftSize: g, smoothingTimeConstant: _ } = this.properties, T = new Float32Array(g);
      this.getFloatTimeDomainData(T);
      for (let b = 0; b < g; b++)
        T[b] = T[b] * this.blackmanTable[b] || 0;
      const E = r(T);
      for (let b = 0, C = g / 2; b < C; b++)
        x[b] = E[b];
    }
    getByteTimeDomainData(x) {
      const { fftSize: g } = this.properties, _ = new Float32Array(g);
      this.getFloatTimeDomainData(_);
      for (let T = 0, E = _.length; T < E; T++)
        x[T] = Math.round(l(_[T], -1, 1) * 255);
    }
    getByteFrequencyData(x) {
      const { fftSize: g } = this.properties, _ = new Float32Array(g / 2);
      this.getFloatFrequencyData(_);
      for (let T = 0, E = _.length; T < E; T++)
        x[T] = _[T] * 255 / 2;
    }
    process(x) {
      const { fftSize: g } = this.properties, _ = new Float32Array(g);
      for (let C of x)
        for (let w = 0; w < g; w++)
          _[w] += C[w] || 0;
      this.buffer = _, this.updateTimeData(), this.updateFrequencyData();
      let T = this.td[0], E = this.td[0], b = 0;
      for (let C = 0; C < this.td.length; C++)
        this.td[C] > T && (T = this.td[C]), this.td[C] < E && (E = this.td[C]), b += this.td[C];
      this.max = T, this.min = E, this.avg = b / this.td.length, this.fft = this.oriFFT, this.gain = this.oriFFT.reduce((C, w) => C + w) / this.oriFFT.length;
    }
    updateFrequencyData() {
      this.getByteFrequencyData(this.oriFFT);
    }
    updateTimeData() {
      this.td = this.buffer;
    }
    reset() {
      this.fft.fill(0), this.oriFFT.fill(0), this.td.fill(0), this.smoothing.fill(0);
    }
  };
  return hv(p, "defaultProperties", {
    fftSize: 1024
  }), audio$1 = {
    getBuffer: async (y, x, g, _, T) => {
      const E = new f({ sampleRate: g });
      let b;
      return i2 ? b = await (await e(y, x, (C) => {
        const { total: w, loaded: A } = C;
        w && T && T(A / w);
      })).data.arrayBuffer() : b = d.readFileSync(y), new Promise((C) => {
        E.decodeAudioData(b, (w) => {
          if (_ > 0) {
            const S = Math.round(_ * w.sampleRate), F = w.numberOfChannels, M = E.createBuffer(F, w.length + S, w.sampleRate), U = new Float32Array(S);
            for (var A = 0; A < F; A++) {
              const B = M.getChannelData(A);
              B.set(w.getChannelData(A), 0), B.set(U, w.length);
            }
            w = M;
          }
          C(w);
        });
      });
    },
    Analyser: p
  }, audio$1;
}
class FifoSampleBuffer {
  constructor() {
    this._vector = new Float32Array(), this._position = 0, this._frameCount = 0;
  }
  get vector() {
    return this._vector;
  }
  get position() {
    return this._position;
  }
  get startIndex() {
    return this._position * 2;
  }
  get frameCount() {
    return this._frameCount;
  }
  get endIndex() {
    return (this._position + this._frameCount) * 2;
  }
  clear() {
    this.receive(this._frameCount), this.rewind();
  }
  put(e) {
    this._frameCount += e;
  }
  putSamples(e, t, r = 0) {
    t = t || 0;
    const a = t * 2;
    r >= 0 || (r = (e.length - a) / 2);
    const s = r * 2;
    this.ensureCapacity(r + this._frameCount);
    const u = this.endIndex;
    this.vector.set(e.subarray(a, a + s), u), this._frameCount += r;
  }
  putBuffer(e, t, r = 0) {
    t = t || 0, r >= 0 || (r = e.frameCount - t), this.putSamples(e.vector, e.position + t, r);
  }
  receive(e) {
    (!(e >= 0) || e > this._frameCount) && (e = this.frameCount), this._frameCount -= e, this._position += e;
  }
  receiveSamples(e, t = 0) {
    const r = t * 2, a = this.startIndex;
    e.set(this._vector.subarray(a, a + r)), this.receive(t);
  }
  extract(e, t = 0, r = 0) {
    const a = this.startIndex + t * 2, s = r * 2;
    e.set(this._vector.subarray(a, a + s));
  }
  ensureCapacity(e = 0) {
    const t = parseInt(e * 2);
    if (this._vector.length < t) {
      const r = new Float32Array(t);
      r.set(this._vector.subarray(this.startIndex, this.endIndex)), this._vector = r, this._position = 0;
    } else
      this.rewind();
  }
  ensureAdditionalCapacity(e = 0) {
    this.ensureCapacity(this._frameCount + e);
  }
  rewind() {
    this._position > 0 && (this._vector.set(this._vector.subarray(this.startIndex, this.endIndex)), this._position = 0);
  }
}
class AbstractFifoSamplePipe {
  constructor(e) {
    e ? (this._inputBuffer = new FifoSampleBuffer(), this._outputBuffer = new FifoSampleBuffer()) : this._inputBuffer = this._outputBuffer = null;
  }
  get inputBuffer() {
    return this._inputBuffer;
  }
  set inputBuffer(e) {
    this._inputBuffer = e;
  }
  get outputBuffer() {
    return this._outputBuffer;
  }
  set outputBuffer(e) {
    this._outputBuffer = e;
  }
  clear() {
    this._inputBuffer.clear(), this._outputBuffer.clear();
  }
}
class RateTransposer extends AbstractFifoSamplePipe {
  constructor(e) {
    super(e), this.reset(), this._rate = 1;
  }
  set rate(e) {
    this._rate = e;
  }
  reset() {
    this.slopeCount = 0, this.prevSampleL = 0, this.prevSampleR = 0;
  }
  clone() {
    const e = new RateTransposer();
    return e.rate = this._rate, e;
  }
  process() {
    const e = this._inputBuffer.frameCount;
    this._outputBuffer.ensureAdditionalCapacity(e / this._rate + 1);
    const t = this.transpose(e);
    this._inputBuffer.receive(), this._outputBuffer.put(t);
  }
  transpose(e = 0) {
    if (e === 0)
      return 0;
    const t = this._inputBuffer.vector, r = this._inputBuffer.startIndex, a = this._outputBuffer.vector, s = this._outputBuffer.endIndex;
    let u = 0, l = 0;
    for (; this.slopeCount < 1; )
      a[s + 2 * l] = (1 - this.slopeCount) * this.prevSampleL + this.slopeCount * t[r], a[s + 2 * l + 1] = (1 - this.slopeCount) * this.prevSampleR + this.slopeCount * t[r + 1], l = l + 1, this.slopeCount += this._rate;
    if (this.slopeCount -= 1, e !== 1)
      e: for (; ; ) {
        for (; this.slopeCount > 1; )
          if (this.slopeCount -= 1, u = u + 1, u >= e - 1)
            break e;
        const c = r + 2 * u;
        a[s + 2 * l] = (1 - this.slopeCount) * t[c] + this.slopeCount * t[c + 2], a[s + 2 * l + 1] = (1 - this.slopeCount) * t[c + 1] + this.slopeCount * t[c + 3], l = l + 1, this.slopeCount += this._rate;
      }
    return this.prevSampleL = t[r + 2 * e - 2], this.prevSampleR = t[r + 2 * e - 1], l;
  }
}
class FilterSupport {
  constructor(e) {
    this._pipe = e;
  }
  get pipe() {
    return this._pipe;
  }
  get inputBuffer() {
    return this._pipe.inputBuffer;
  }
  get outputBuffer() {
    return this._pipe.outputBuffer;
  }
  fillInputBuffer() {
    throw new Error("fillInputBuffer() not overridden");
  }
  fillOutputBuffer(e = 0) {
    for (; this.outputBuffer.frameCount < e; ) {
      const t = 16384 - this.inputBuffer.frameCount;
      if (this.fillInputBuffer(t), this.inputBuffer.frameCount < 8192 * 2)
        break;
      this._pipe.process();
    }
  }
  clear() {
    this._pipe.clear();
  }
}
const noop = function() {
};
class SimpleFilter extends FilterSupport {
  constructor(e, t, r = noop) {
    super(t), this.callback = r, this.sourceSound = e, this.historyBufferSize = 22050, this._sourcePosition = 0, this.outputBufferPosition = 0, this._position = 0;
  }
  get position() {
    return this._position;
  }
  set position(e) {
    if (e > this._position)
      throw new RangeError("New position may not be greater than current position");
    const t = this.outputBufferPosition - (this._position - e);
    if (t < 0)
      throw new RangeError("New position falls outside of history buffer");
    this.outputBufferPosition = t, this._position = e;
  }
  get sourcePosition() {
    return this._sourcePosition;
  }
  set sourcePosition(e) {
    this.clear(), this._sourcePosition = e;
  }
  onEnd() {
    this.callback();
  }
  fillInputBuffer(e = 0) {
    const t = new Float32Array(e * 2), r = this.sourceSound.extract(t, e, this._sourcePosition);
    this._sourcePosition += r, this.inputBuffer.putSamples(t, 0, r);
  }
  extract(e, t = 0) {
    this.fillOutputBuffer(this.outputBufferPosition + t);
    const r = Math.min(t, this.outputBuffer.frameCount - this.outputBufferPosition);
    this.outputBuffer.extract(e, this.outputBufferPosition, r);
    const a = this.outputBufferPosition + r;
    return this.outputBufferPosition = Math.min(this.historyBufferSize, a), this.outputBuffer.receive(Math.max(a - this.historyBufferSize, 0)), this._position += r, r;
  }
  handleSampleData(e) {
    this.extract(e.data, 4096);
  }
  clear() {
    super.clear(), this.outputBufferPosition = 0;
  }
}
const USE_AUTO_SEQUENCE_LEN = 0, DEFAULT_SEQUENCE_MS = USE_AUTO_SEQUENCE_LEN, USE_AUTO_SEEKWINDOW_LEN = 0, DEFAULT_SEEKWINDOW_MS = USE_AUTO_SEEKWINDOW_LEN, DEFAULT_OVERLAP_MS = 8, _SCAN_OFFSETS = [[124, 186, 248, 310, 372, 434, 496, 558, 620, 682, 744, 806, 868, 930, 992, 1054, 1116, 1178, 1240, 1302, 1364, 1426, 1488, 0], [-100, -75, -50, -25, 25, 50, 75, 100, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [-20, -15, -10, -5, 5, 10, 15, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [-4, -3, -2, -1, 1, 2, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], AUTOSEQ_TEMPO_LOW = 0.5, AUTOSEQ_TEMPO_TOP = 2, AUTOSEQ_AT_MIN = 125, AUTOSEQ_AT_MAX = 50, AUTOSEQ_K = (AUTOSEQ_AT_MAX - AUTOSEQ_AT_MIN) / (AUTOSEQ_TEMPO_TOP - AUTOSEQ_TEMPO_LOW), AUTOSEQ_C = AUTOSEQ_AT_MIN - AUTOSEQ_K * AUTOSEQ_TEMPO_LOW, AUTOSEEK_AT_MIN = 25, AUTOSEEK_AT_MAX = 15, AUTOSEEK_K = (AUTOSEEK_AT_MAX - AUTOSEEK_AT_MIN) / (AUTOSEQ_TEMPO_TOP - AUTOSEQ_TEMPO_LOW), AUTOSEEK_C = AUTOSEEK_AT_MIN - AUTOSEEK_K * AUTOSEQ_TEMPO_LOW;
class Stretch extends AbstractFifoSamplePipe {
  constructor(e) {
    super(e), this._quickSeek = true, this.midBufferDirty = false, this.midBuffer = null, this.overlapLength = 0, this.autoSeqSetting = true, this.autoSeekSetting = true, this._tempo = 1, this.setParameters(44100, DEFAULT_SEQUENCE_MS, DEFAULT_SEEKWINDOW_MS, DEFAULT_OVERLAP_MS);
  }
  clear() {
    super.clear(), this.clearMidBuffer();
  }
  clearMidBuffer() {
    this.midBufferDirty && (this.midBufferDirty = false, this.midBuffer = null);
  }
  setParameters(e, t, r, a) {
    e > 0 && (this.sampleRate = e), a > 0 && (this.overlapMs = a), t > 0 ? (this.sequenceMs = t, this.autoSeqSetting = false) : this.autoSeqSetting = true, r > 0 ? (this.seekWindowMs = r, this.autoSeekSetting = false) : this.autoSeekSetting = true, this.calculateSequenceParameters(), this.calculateOverlapLength(this.overlapMs), this.tempo = this._tempo;
  }
  set tempo(e) {
    let t;
    this._tempo = e, this.calculateSequenceParameters(), this.nominalSkip = this._tempo * (this.seekWindowLength - this.overlapLength), this.skipFract = 0, t = Math.floor(this.nominalSkip + 0.5), this.sampleReq = Math.max(t + this.overlapLength, this.seekWindowLength) + this.seekLength;
  }
  get tempo() {
    return this._tempo;
  }
  get inputChunkSize() {
    return this.sampleReq;
  }
  get outputChunkSize() {
    return this.overlapLength + Math.max(0, this.seekWindowLength - 2 * this.overlapLength);
  }
  calculateOverlapLength(e = 0) {
    let t;
    t = this.sampleRate * e / 1e3, t = t < 16 ? 16 : t, t -= t % 8, this.overlapLength = t, this.refMidBuffer = new Float32Array(this.overlapLength * 2), this.midBuffer = new Float32Array(this.overlapLength * 2);
  }
  checkLimits(e, t, r) {
    return e < t ? t : e > r ? r : e;
  }
  calculateSequenceParameters() {
    let e, t;
    this.autoSeqSetting && (e = AUTOSEQ_C + AUTOSEQ_K * this._tempo, e = this.checkLimits(e, AUTOSEQ_AT_MAX, AUTOSEQ_AT_MIN), this.sequenceMs = Math.floor(e + 0.5)), this.autoSeekSetting && (t = AUTOSEEK_C + AUTOSEEK_K * this._tempo, t = this.checkLimits(t, AUTOSEEK_AT_MAX, AUTOSEEK_AT_MIN), this.seekWindowMs = Math.floor(t + 0.5)), this.seekWindowLength = Math.floor(this.sampleRate * this.sequenceMs / 1e3), this.seekLength = Math.floor(this.sampleRate * this.seekWindowMs / 1e3);
  }
  set quickSeek(e) {
    this._quickSeek = e;
  }
  clone() {
    const e = new Stretch();
    return e.tempo = this._tempo, e.setParameters(this.sampleRate, this.sequenceMs, this.seekWindowMs, this.overlapMs), e;
  }
  seekBestOverlapPosition() {
    return this._quickSeek ? this.seekBestOverlapPositionStereoQuick() : this.seekBestOverlapPositionStereo();
  }
  seekBestOverlapPositionStereo() {
    let e, t, r, a = 0;
    for (this.preCalculateCorrelationReferenceStereo(), e = 0, t = Number.MIN_VALUE; a < this.seekLength; a = a + 1)
      r = this.calculateCrossCorrelationStereo(2 * a, this.refMidBuffer), r > t && (t = r, e = a);
    return e;
  }
  seekBestOverlapPositionStereoQuick() {
    let e, t, r, a = 0, s, u;
    for (this.preCalculateCorrelationReferenceStereo(), t = Number.MIN_VALUE, e = 0, s = 0, u = 0; a < 4; a = a + 1) {
      let l = 0;
      for (; _SCAN_OFFSETS[a][l] && (u = s + _SCAN_OFFSETS[a][l], !(u >= this.seekLength)); )
        r = this.calculateCrossCorrelationStereo(2 * u, this.refMidBuffer), r > t && (t = r, e = u), l = l + 1;
      s = e;
    }
    return e;
  }
  preCalculateCorrelationReferenceStereo() {
    let e = 0, t, r;
    for (; e < this.overlapLength; e = e + 1)
      r = e * (this.overlapLength - e), t = e * 2, this.refMidBuffer[t] = this.midBuffer[t] * r, this.refMidBuffer[t + 1] = this.midBuffer[t + 1] * r;
  }
  calculateCrossCorrelationStereo(e, t) {
    const r = this._inputBuffer.vector;
    e += this._inputBuffer.startIndex;
    let a = 0, s = 2;
    const u = 2 * this.overlapLength;
    let l;
    for (; s < u; s = s + 2)
      l = s + e, a += r[l] * t[s] + r[l + 1] * t[s + 1];
    return a;
  }
  overlap(e) {
    this.overlapStereo(2 * e);
  }
  overlapStereo(e) {
    const t = this._inputBuffer.vector;
    e += this._inputBuffer.startIndex;
    const r = this._outputBuffer.vector, a = this._outputBuffer.endIndex;
    let s = 0, u, l;
    const c = 1 / this.overlapLength;
    let d, f, p;
    for (; s < this.overlapLength; s = s + 1)
      l = (this.overlapLength - s) * c, d = s * c, u = 2 * s, f = u + e, p = u + a, r[p + 0] = t[f + 0] * d + this.midBuffer[u + 0] * l, r[p + 1] = t[f + 1] * d + this.midBuffer[u + 1] * l;
  }
  process() {
    let e, t, r;
    if (this.midBuffer === null) {
      if (this._inputBuffer.frameCount < this.overlapLength)
        return;
      this.midBuffer = new Float32Array(this.overlapLength * 2), this._inputBuffer.receiveSamples(this.midBuffer, this.overlapLength);
    }
    for (; this._inputBuffer.frameCount >= this.sampleReq; ) {
      e = this.seekBestOverlapPosition(), this._outputBuffer.ensureAdditionalCapacity(this.overlapLength), this.overlap(Math.floor(e)), this._outputBuffer.put(this.overlapLength), t = this.seekWindowLength - 2 * this.overlapLength, t > 0 && this._outputBuffer.putBuffer(this._inputBuffer, e + this.overlapLength, t);
      const a = this._inputBuffer.startIndex + 2 * (e + this.seekWindowLength - this.overlapLength);
      this.midBuffer.set(this._inputBuffer.vector.subarray(a, a + 2 * this.overlapLength)), this.skipFract += this.nominalSkip, r = Math.floor(this.skipFract), this.skipFract -= r, this._inputBuffer.receive(r);
    }
  }
}
const testFloatEqual = function(i2, e) {
  return (i2 > e ? i2 - e : e - i2) > 1e-10;
};
class SoundTouch {
  constructor() {
    this.transposer = new RateTransposer(false), this.stretch = new Stretch(false), this._inputBuffer = new FifoSampleBuffer(), this._intermediateBuffer = new FifoSampleBuffer(), this._outputBuffer = new FifoSampleBuffer(), this._rate = 0, this._tempo = 0, this.virtualPitch = 1, this.virtualRate = 1, this.virtualTempo = 1, this.calculateEffectiveRateAndTempo();
  }
  clear() {
    this.transposer.clear(), this.stretch.clear();
  }
  clone() {
    const e = new SoundTouch();
    return e.rate = this.rate, e.tempo = this.tempo, e;
  }
  get rate() {
    return this._rate;
  }
  set rate(e) {
    this.virtualRate = e, this.calculateEffectiveRateAndTempo();
  }
  set rateChange(e) {
    this._rate = 1 + 0.01 * e;
  }
  get tempo() {
    return this._tempo;
  }
  set tempo(e) {
    this.virtualTempo = e, this.calculateEffectiveRateAndTempo();
  }
  set tempoChange(e) {
    this.tempo = 1 + 0.01 * e;
  }
  set pitch(e) {
    this.virtualPitch = e, this.calculateEffectiveRateAndTempo();
  }
  set pitchOctaves(e) {
    this.pitch = Math.exp(0.69314718056 * e), this.calculateEffectiveRateAndTempo();
  }
  set pitchSemitones(e) {
    this.pitchOctaves = e / 12;
  }
  get inputBuffer() {
    return this._inputBuffer;
  }
  get outputBuffer() {
    return this._outputBuffer;
  }
  calculateEffectiveRateAndTempo() {
    const e = this._tempo, t = this._rate;
    this._tempo = this.virtualTempo / this.virtualPitch, this._rate = this.virtualRate * this.virtualPitch, testFloatEqual(this._tempo, e) && (this.stretch.tempo = this._tempo), testFloatEqual(this._rate, t) && (this.transposer.rate = this._rate), this._rate > 1 ? this._outputBuffer != this.transposer.outputBuffer && (this.stretch.inputBuffer = this._inputBuffer, this.stretch.outputBuffer = this._intermediateBuffer, this.transposer.inputBuffer = this._intermediateBuffer, this.transposer.outputBuffer = this._outputBuffer) : this._outputBuffer != this.stretch.outputBuffer && (this.transposer.inputBuffer = this._inputBuffer, this.transposer.outputBuffer = this._intermediateBuffer, this.stretch.inputBuffer = this._intermediateBuffer, this.stretch.outputBuffer = this._outputBuffer);
  }
  process() {
    this._rate > 1 ? (this.stretch.process(), this.transposer.process()) : (this.transposer.process(), this.stretch.process());
  }
}
class WebAudioBufferSource {
  constructor(e) {
    this.buffer = e, this._position = 0;
  }
  get dualChannel() {
    return this.buffer.numberOfChannels > 1;
  }
  get position() {
    return this._position;
  }
  set position(e) {
    this._position = e;
  }
  extract(e, t = 0, r = 0) {
    this.position = r;
    let a = this.buffer.getChannelData(0), s = this.dualChannel ? this.buffer.getChannelData(1) : this.buffer.getChannelData(0), u = 0;
    for (; u < t; u++)
      e[u * 2] = a[u + r], e[u * 2 + 1] = s[u + r];
    return Math.min(t, a.length - r);
  }
}
const getWebAudioNode = function(i2, e, t = noop, r = 4096) {
  const a = i2.createScriptProcessor(r, 2, 2), s = new Float32Array(r * 2);
  return a.onaudioprocess = (u) => {
    let l = u.outputBuffer.getChannelData(0), c = u.outputBuffer.getChannelData(1), d = e.extract(s, r);
    t(e.sourcePosition), d === 0 && e.onEnd();
    let f = 0;
    for (; f < d; f++)
      l[f] = s[f * 2], c[f] = s[f * 2 + 1];
  }, a;
}, pad = function(i2, e, t) {
  return t = t || "0", i2 = i2 + "", i2.length >= e ? i2 : new Array(e - i2.length + 1).join(t) + i2;
}, minsSecs = function(i2) {
  const e = Math.floor(i2 / 60), t = i2 - e * 60;
  return `${e}:${pad(parseInt(t), 2)}`;
}, onUpdate = function(i2) {
  const e = this.timePlayed, t = this.sampleRate;
  if (this.sourcePosition = i2, this.timePlayed = i2 / t, e !== this.timePlayed) {
    const r = new CustomEvent("play", {
      detail: {
        timePlayed: this.timePlayed,
        formattedTimePlayed: this.formattedTimePlayed,
        percentagePlayed: this.percentagePlayed
      }
    });
    this._node.dispatchEvent(r);
  }
};
class PitchShifter {
  constructor(e, t, r, a = noop) {
    this._soundtouch = new SoundTouch();
    const s = new WebAudioBufferSource(t);
    this.timePlayed = 0, this.sourcePosition = 0, this._filter = new SimpleFilter(s, this._soundtouch, a), this._node = getWebAudioNode(e, this._filter, (u) => onUpdate.call(this, u), r), this.tempo = 1, this.rate = 1, this.duration = t.duration, this.sampleRate = e.sampleRate, this.listeners = [];
  }
  get formattedDuration() {
    return minsSecs(this.duration);
  }
  get formattedTimePlayed() {
    return minsSecs(this.timePlayed);
  }
  get percentagePlayed() {
    return 100 * this._filter.sourcePosition / (this.duration * this.sampleRate);
  }
  set percentagePlayed(e) {
    this._filter.sourcePosition = parseInt(e * this.duration * this.sampleRate), this.sourcePosition = this._filter.sourcePosition, this.timePlayed = this.sourcePosition / this.sampleRate;
  }
  get node() {
    return this._node;
  }
  set pitch(e) {
    this._soundtouch.pitch = e;
  }
  set pitchSemitones(e) {
    this._soundtouch.pitchSemitones = e;
  }
  set rate(e) {
    this._soundtouch.rate = e;
  }
  set tempo(e) {
    this._soundtouch.tempo = e;
  }
  connect(e) {
    this._node.connect(e);
  }
  disconnect() {
    this._node.disconnect();
  }
  on(e, t) {
    this.listeners.push({
      name: e,
      cb: t
    }), this._node.addEventListener(e, (r) => t(r.detail));
  }
  off(e = null) {
    let t = this.listeners;
    e && (t = t.filter((r) => r.name === e)), t.forEach((r) => {
      this._node.removeEventListener(r.name, (a) => r.cb(a.detail));
    });
  }
}
const soundtouch = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AbstractFifoSamplePipe,
  PitchShifter,
  RateTransposer,
  SimpleFilter,
  SoundTouch,
  Stretch,
  WebAudioBufferSource,
  getWebAudioNode
}, Symbol.toStringTag, { value: "Module" })), require$$5$1 = /* @__PURE__ */ getAugmentedNamespace(soundtouch);
var audio, hasRequiredAudio;
function requireAudio() {
  if (hasRequiredAudio) return audio;
  hasRequiredAudio = 1;
  const i2 = requireClip(), e = requireMaterial(), { isBrowser: t } = requireLib$5(), { nodeRequire: r } = requireUtils(), a = requireAudio$1();
  r("ffmpeg-probe");
  let s;
  t && (s = require$$5$1.PitchShifter);
  const u = 1024;
  class l extends i2 {
    constructor(d) {
      d = typeof d == "string" ? { path: d } : d, super({ type: "audio", audio: true, ...d }), this.conf.active === false && (this.audio = false), this.active = this.audio;
    }
    createDisplay() {
      this.display = null;
    }
    get default() {
      var d;
      const f = super.default;
      return {
        startTime: f.startTime,
        endTime: this.loop ? f.endTime : void 0,
        duration: this.loop || (d = this.material) == null ? void 0 : d.getDuration()
      };
    }
    annotate() {
      super.annotate(), this.material && (this.material.duration = this.duration);
    }
    updateMaterialTime() {
      this.material.parseTimeConf(this.conf);
    }
    disable() {
      this.audio = false;
    }
    enable() {
      this.audio = true;
    }
    mute(d) {
      this._muted = d;
    }
    resetMute() {
      this._muted = false;
    }
    set audio(d) {
      this.conf.audio = !!d, this.conf.audio ? super.enable() : super.disable(), this.conf.audio || this.pause();
    }
    get sampleRate() {
      return this.creator().getConf("audioSampleRate");
    }
    get audio() {
      return !!this.conf.audio && !this.muted;
    }
    get loop() {
      return !!this.conf.loop;
    }
    set loop(d) {
      this.conf.loop = !!d;
    }
    get pitch() {
      return Number(this.conf.pitch) || 1;
    }
    set pitch(d) {
      this.conf.pitch = Number(d) || 1;
    }
    get speed() {
      return this.material.speed;
    }
    set speed(d) {
      this.conf.speed = d, this.material.setSpeed(d);
    }
    get volume() {
      return isNaN(this.conf.volume) ? 1 : Math.max(Number(this.conf.volume), 0);
    }
    set volume(d) {
      this.conf.volume = d;
    }
    get fadeIn() {
      return isNaN(this.conf.fadeIn) ? 0 : Number(this.conf.fadeIn);
    }
    set fadeIn(d) {
      this.conf.fadeIn = d;
    }
    get fadeOut() {
      return isNaN(this.conf.fadeOut) ? 0 : Number(this.conf.fadeOut);
    }
    set fadeOut(d) {
      this.conf.fadeOut = d;
    }
    async preProcessing(d) {
      this.material && this.material.destroy(), this.material = new e(this.conf), this.material.duration = this.duration, this.audioBuffer = await a.getBuffer(
        this.material.path,
        this.creator().uuid,
        this.sampleRate,
        -1,
        d
      ), this.material.length = this.audioBuffer.duration;
    }
    pause() {
      !t || !this.playing || (this.fading = false, this.playing = false, this.sourceNode.disconnect());
    }
    /**
     *
     * @param time 素材的seek后已经计算过speed和loop的真实时间
     */
    async play(d) {
      !t || this.playing || !this.sourceNode || (this.sourceNode.percentagePlayed = d / this.material.length, this.sourceNode.tempo = this.speed, this.sourceNode.pitch = this.pitch, this.sourceNode.connect(this.gainNode), await this.ctx.resume(), this.playing = true);
    }
    initAudioCtx() {
      this.ctx || (this.ctx = new AudioContext({ sampleRate: this.sampleRate })), this.gainNode || (this.gainNode = this.ctx.createGain(), this.gainNode.connect(this.ctx.destination)), this.sourceNode || (this.sourceNode = new s(this.ctx, this.audioBuffer, u));
    }
    async destroyAudioCtx() {
      this.ctx && (await this.ctx.close(), this.ctx = null, this.gainNode = null, this.sourceNode = null);
    }
    async drawing(d = 0, f = 0) {
      if (!t) return false;
      const p = d / 1e3;
      let m = await super.drawing(d, f);
      if (m && f > 0 && this.mute(p < this.absStartTime || p > this.absEndTime), !m || !this.audio)
        return this.pause(), await this.destroyAudioCtx(), false;
      this.initAudioCtx();
      const y = p - this.absStartTime, { time: x, loops: g } = this._materialTime(p, true);
      if (this.currentTime = x, f)
        if (this.currentTime < this.fadeIn) {
          const _ = this.volume * (this.currentTime / this.fadeIn);
          this.fade(_, this.volume, this.fadeIn - this.currentTime, d);
        } else if (this.endTime > y && this.endTime - y < this.fadeOut) {
          const _ = this.endTime - y, T = this.volume * (_ / this.fadeOut);
          this.fade(T, 0, _, d);
        } else
          this.gainNode.gain.value = this.volume;
      if (g > 0 && this.loops != g)
        return this.loops = g, this.pause();
      if (!f) return this.pause();
      this.creator().burning || this.play(this.currentTime);
    }
    fade(d, f, p, m) {
      this.fading > m || (this.gainNode.gain.value = d, this.gainNode.gain.linearRampToValueAtTime(f, this.ctx.currentTime + p), this.fading = m + p * 1e3 >> 0);
    }
    addInput(d) {
      d.addInput(this.material.path);
      let f = ["-vn"];
      const p = this.material.getSliceOpts(!this.loop);
      p && (f = f.concat(p)), d.addInputOptions(f);
    }
    toFilterCommand({ input: d, output: f }) {
      const p = this.toLoopFilter(), m = this.toDelayFilter(), y = this.toSpeedFilter(), x = this.toVolumeFilter(), g = this.toFadeInFilter(), _ = this.toFadeOutFilter();
      return `[${d}]aformat=sample_rates=${this.sampleRate},${m}${p}${y}${x}${g}${_}[${f}]`;
    }
    toLoopFilter() {
      let { pitch: d = 1, loop: f } = this;
      const p = this.material.getEndOffset(true) - this.material.getStartOffset(), m = this.sampleRate;
      return `,asetrate=${m * d},aresample=${m},aloop=${f ? "-1" : "0"}:size=${p * m}`;
    }
    toDelayFilter() {
      let { speed: d = 1, pitch: f = 1 } = this;
      d /= f;
      const p = this.absStartTime * d * 1e3 >> 0;
      return `adelay=${p}|${p}`;
    }
    // toPitchFilter() {
    //   let { pitch = 1 } = this;
    //   if (pitch === 1) return '';
    //   let setRate = '';
    //   const r = 44100 * pitch;
    //   if (!this.loop) setRate = `,asetrate=${r.toFixed(2)}`;
    //   return `${setRate},aresample=44100`;
    // }
    toSpeedFilter() {
      let { speed: d = 1, pitch: f = 1 } = this;
      return d /= f, d === 1 ? "" : `,atempo=${d}`;
    }
    toVolumeFilter() {
      let { volume: d = -1 } = this;
      return d === -1 ? "" : (this.audio || (d = 0), `,volume=${d}`);
    }
    toFadeInFilter() {
      const { fadeIn: d = -1, absStartTime: f = 0 } = this;
      return d <= 0 ? "" : `,afade=t=in:st=${f}:d=${d}`;
    }
    toFadeOutFilter() {
      const { fadeOut: d = -1 } = this;
      return d <= 0 ? "" : `,afade=t=out:st=${Math.max(0, this.absEndTime - d)}:d=${d}`;
    }
    destroy() {
      var d;
      super.destroy(), (d = this.material) == null || d.destroy(), this.audioBuffer = null, this.destroyAudioCtx();
    }
  }
  return audio = l, audio;
}
var leftPad_1, hasRequiredLeftPad;
function requireLeftPad() {
  if (hasRequiredLeftPad) return leftPad_1;
  hasRequiredLeftPad = 1, leftPad_1 = e;
  var i2 = [
    "",
    " ",
    "  ",
    "   ",
    "    ",
    "     ",
    "      ",
    "       ",
    "        ",
    "         "
  ];
  function e(t, r, a) {
    if (t = t + "", r = r - t.length, r <= 0) return t;
    if (!a && a !== 0 && (a = " "), a = a + "", a === " " && r < 10) return i2[r] + t;
    for (var s = ""; r & 1 && (s += a), r >>= 1, r; )
      a += a;
    return s + t;
  }
  return leftPad_1;
}
var fs_1, hasRequiredFs;
function requireFs() {
  if (hasRequiredFs) return fs_1;
  hasRequiredFs = 1;
  const { nodeRequire: i2 } = requireUtils(), e = i2("rmfr"), t = i2("fs-extra"), r = require$$1$1, a = requireLeftPad();
  return fs_1 = {
    format: "raw",
    /**
     * Ensures that the directory exists. If the directory structure does not exist, it is created.
     * @public
     */
    ensureDir(s, u = false) {
      u && (s = r.dirname(s)), t.ensureDir(s);
    },
    exists(s) {
      return t.existsSync(s);
    },
    /**
     * removal of files and directories
     * @async
     * @public
     */
    async rmDir(s) {
      await e(s);
    },
    setCacheFormat(s) {
      this.format = s === "raw" ? s : "ff";
    },
    /**
     * Move files from one place to another
     * @param {object} conf - processing configuration
     * @param {string} conf.dir - File directory
     * @param {string} conf.from - Original file name
     * @param {string} conf.to - Target file name
     * @async
     * @public
     */
    async moveFile({ dir: s, from: u, to: l }) {
      const c = this.getFilePath({ dir: s, name: u, prefix: false }), d = this.getFilePath({ dir: s, name: l, prefix: true });
      await t.move(c, d, { overwrite: true });
    },
    /**
     * Write files synchronously
     * @param {object} conf - processing configuration
     * @param {string} conf.dir - File directory
     * @param {string} conf.name - File directory
     * @param {string} conf.buffer - Original file name
     * @public
     */
    writeFileSync({ dir: s, name: u, data: l }) {
      const c = this.getFilePath({ dir: s, name: u, prefix: true });
      t.writeFileSync(c, l);
    },
    /**
     * The FS.readFileSync method is an inbuilt application programming interface
     * of fs module which is used to read the file and return its content.
     * @param {object} conf - processing configuration
     * @param {string} conf.dir - File directory
     * @param {string} conf.name - File directory
     * @return {buffer} This method returns the content of the file.
     * @public
     */
    readFileSync({ dir: s, name: u }) {
      const l = this.getFilePath({ dir: s, name: u, prefix: false });
      return t.readFileSync(l);
    },
    /**
     * Write files asynchronously
     * @param {object} conf - processing configuration
     * @param {string} conf.dir - File directory
     * @param {string} conf.name - File directory
     * @param {string} conf.buffer - Original file name
     * @async
     * @public
     */
    async writeFileAsync({ dir: s, name: u, buffer: l }) {
      const c = this.getFilePath({ dir: s, name: u, prefix: false });
      return await t.outputFile(c, l);
    },
    /**
     * Get file extensions with JavaScript
     * @param {string} filename - input file
     * @return {string} - the file extensions
     * @public
     */
    getExt(s) {
      return /[^.]+$/.exec(s);
    },
    getFilePath({ dir: s, name: u, prefix: l = false }) {
      return l ? r.join(s, `${a(u, 12, "0")}.${this.format}`) : r.join(s, `${u}.${this.format}`);
    },
    getCacheFilePath(s) {
      return r.join(s, `%012d.${this.format}`);
    },
    /**
     * Check if it is a font file
     * @param {string} font - input file
     * @public
     */
    isFont(s) {
      return /.*\.(ttf|otf|svg|woff|woff2|eot)$/gi.test(s);
    }
  }, fs_1;
}
var canvas, hasRequiredCanvas;
function requireCanvas() {
  if (hasRequiredCanvas) return canvas;
  hasRequiredCanvas = 1;
  const i2 = requireUtils();
  requireFs();
  const { isBrowser: e } = requireLib$5(), { createCanvas: t, createImageData: r, registerFont: a } = requireLib$2();
  return canvas = {
    canvas: null,
    /**
     * Get a unique canvas instance
     * @param {number} width - canvas width
     * @param {number} height - canvas height
     * @return {Canvas} a unique canvas instance
     * @public
     */
    getCanvas({ width: s, height: u }) {
      return this.canvas || (this.canvas = t(s, u)), this.canvas.width = s, this.canvas.height = u, this.canvas;
    },
    /**
     * Utility function to get buffer
     * @param {string} type - picture format type
     * @param {Canvas} canvas - Container canvas
     * @param {number} quality - picture quality
     * @return {buffer} The returned buffer value
     * @public
     */
    toBuffer({ type: s, canvas: u, quality: l = 70 }) {
      l = l >> 0, l = Math.min(l, 100);
      let c = 10 - 0.1 * l;
      c = c >> 0;
      let d, f;
      switch (s) {
        case "png":
        case "gif":
          d = u.toBuffer("image/png", {
            compressionLevel: c,
            filters: u.PNG_FILTER_NONE
          });
          break;
        case "jpg":
        case "jpeg":
          d = u.toBuffer("image/jpeg", { quality: l / 100 });
          break;
        case "canvas":
          f = this.getContext(u), d = f.getImageData(0, 0, u.width, u.height).data;
          break;
        default:
          d = u.toBuffer("raw");
          break;
      }
      return d;
    },
    /**
     * Draw buffer or array data onto the canvas object
     * @param {number} width - canvas width
     * @param {number} height - canvas height
     * @param {array|buffer} data - buffer or array data
     * @return {Canvas} a unique canvas instance
     * @public
     */
    draw({ width: s, height: u, data: l }) {
      const c = this.getCanvas({ width: s, height: u }), d = c.getContext("2d"), f = r(new Uint8ClampedArray(l), s, u);
      return d.putImageData(f, 0, 0), c;
    },
    /**
     * Set fonts and register new font files
     * @param {string} font - text font file path
     * @param {function} setFontFunc - Callback hook for element setting font
     * @public
     */
    setFont(s, u) {
      const l = "f" + i2.toHash(s);
      i2.storage[l] || (e || a(s, { family: l }), i2.storage[l] = true), u(l);
    },
    fillRect({ canvas: s, color: u }) {
      const l = s.getContext("2d");
      l.fillStyle = u, l.fillRect(0, 0, s.width, s.height);
    },
    getContext(s) {
      return s.getContext("2d");
    }
  }, canvas;
}
var cons, hasRequiredCons;
function requireCons() {
  if (hasRequiredCons) return cons;
  hasRequiredCons = 1, requireUtils();
  const i2 = requireClip();
  requireAudio();
  const e = requireCanvas();
  requireUtils();
  const { Sprite: t, Texture: r, Container: a, WebGLRenderer: s, CanvasRenderer: u, createCanvas: l } = requireLib$2();
  class c extends i2 {
    get audio() {
      return !this.conf.mute;
    }
    set audio(f) {
      this.conf.mute = !f, this.mute(!f);
    }
    mute(f) {
      this.allNodes.map((p) => p.mute && p.mute(f));
    }
    resetMute() {
      this.mute(!this.audio);
    }
    /**
     * Create display object
     * @private
     */
    createDisplay() {
      this.display = new a(), this.display.sortableChildren = true;
    }
    updateDisplay() {
      this.display.sortDirty = true;
    }
    addDisplayChild(f) {
      f.locked || f.parent === this.display && this.display.children.includes(f) || this.display.addChild(f);
    }
    // removeDisplayChild(childDisplay) {
    //   this.display.removeChild(childDisplay);
    // }
    get previewRenderer() {
      if (this.pvRenderer) return this.pvRenderer;
      const f = this.rootConf("width"), p = this.rootConf("height");
      return this.rootConf("useGL") ? this.pvRenderer = new s({ width: f, height: p }) : this.pvRenderer = new u({ width: f, height: p }), this.pvRenderer;
    }
    async getDisplay(f, p) {
      const m = await this.getPreview(f, { ...p, format: "canvas" });
      if (!m) throw new Error("null");
      return new t(r.fromCanvas(m));
    }
    async getPreview(f, { width: p, height: m, format: y = "jpeg" } = {}) {
      var x;
      const [g, _] = [this.rootConf("width"), this.rootConf("height")], T = new a();
      if (T.sortableChildren = true, this.bgColor)
        try {
          const w = l(g, _);
          e.fillRect({ canvas: w, color: this.bgColor });
          const A = new t(r.fromCanvas(w));
          T.addChildAt(A, 0);
        } catch {
          return null;
        }
      const E = [], b = async (w, A, S = null) => {
        let F = A, M = null;
        if (w && w.onTime(f, false, "show")) {
          if (w.type === "filter") {
            const U = w.addFilterTo(A);
            U.enabled = true, U.setTime(f - w.absStartTime, w.duration), M = U;
          } else if (w.getDisplay) {
            F = await w.getDisplay(f, { timing: "abs" }), F.zIndex = w.zIndex, w.display.chroma && (F.chroma = w.display.chroma);
            const { matrix: U, alpha: B } = w.display.colorMatrix;
            if (U && B && F.setColorMatrix(U, B), T.addChild(F), w.conf.asMask) {
              const q = F;
              S || (S = A), S.mask = q, q.renderable = false, q.isMask = true, q.binaryMask = !!w.conf.binaryMask, q.reverseMask = !!w.conf.reverseMask, F = null;
            }
            w.type === "cover" && E.push(F);
          }
        }
        if (F && w.type !== "scene" && w.children)
          for (const U of w.children)
            await b(U, F, M);
      };
      try {
        for (const w of this.children)
          await b(w, T);
        E.sort((w, A) => w.zIndex - A.zIndex).map((w) => {
          for (const A of [...T.children])
            A === w || A.zIndex > w.zIndex || A.isMask || A.parent !== w && w.addChild(A);
        });
      } catch {
        return null;
      }
      (x = T == null ? void 0 : T.texture) != null && x.baseTexture && T.texture.baseTexture.update(), this.previewRenderer.render(T), T.destroy(true);
      const C = { x: 0, y: 0, w: g, h: _ };
      return this.subImage(this.previewRenderer.view, C, { width: p, height: m, format: y });
    }
    destroy() {
      this.pvRenderer && this.pvRenderer.destroy(true, true), this.pvRenderer = null, super.destroy();
    }
  }
  return cons = c, cons;
}
var queue, hasRequiredQueue;
function requireQueue() {
  if (hasRequiredQueue) return queue;
  hasRequiredQueue = 1;
  class i2 {
    constructor() {
      this.queue = [], this.pendingPromise = false;
    }
    enqueue(t) {
      return new Promise((r, a) => {
        this.queue.push({
          promise: t,
          resolve: r,
          reject: a
        }), this.dequeue();
      });
    }
    dequeue() {
      if (this.pendingPromise) return false;
      const t = this.queue.shift();
      if (!t) return false;
      try {
        this.pendingPromise = true, t.promise().then((r) => {
          this.pendingPromise = false, t.resolve(r), this.dequeue();
        }).catch((r) => {
          this.pendingPromise = false, t.reject(r), this.dequeue();
        });
      } catch (r) {
        this.pendingPromise = false, t.reject(r), this.dequeue();
      }
      return true;
    }
    destroy() {
      this.pendingPromise = true, this.queue = null;
    }
  }
  return queue = i2, queue;
}
var video$2, hasRequiredVideo$2;
function requireVideo$2() {
  if (hasRequiredVideo$2) return video$2;
  hasRequiredVideo$2 = 1;
  const i2 = requireQueue(), { genUuid: e } = requireUtils(), { isBrowser: t } = requireLib$5(), { isUA: r } = requireUtils(), a = "default", s = "preview", u = { [a]: [], [s]: [] };
  window && (window.MIRAP_VPOOL = u);
  const l = new i2(), c = 300, d = 2;
  class f {
    constructor(m, y, x = null) {
      if (this.loaded = false, this.uses = {}, this.cid = y, this.id = e(), m instanceof f && (m.loaded ? this.cloneVideo(m) : m = m.url), !this.loaded && typeof m == "string" && (this.$video = this.createVideo(m), this.url = m), !this.url)
        throw new Error(`VideoHolder.create with src error: ${m}`);
      this.assignTo(x);
    }
    connectGainNode() {
      const m = new AudioContext(), y = m.createMediaElementSource(this.$video);
      this.gainNode = m.createGain(), y.connect(this.gainNode), this.gainNode.connect(m.destination);
    }
    setVolume(m) {
      r("chrome") ? (this.gainNode || this.connectGainNode(), this.gainNode.gain.value = m) : this.$video.volume = Math.min(1, m);
    }
    assignTo(m) {
      m && (this.userId = m, this.uses[m] || (this.uses[m] = 0), this.uses[m]++, this.createBy || (this.createBy = m));
    }
    cloneVideo(m) {
      this.url = m.url, this.info = m.info, this.$video = m.$video.cloneNode(false), this.loaded = true, this._debugShow(this.$video);
    }
    createVideo(m) {
      if (!t) return { src: m };
      const y = document.createElement("video");
      return y.playsinline = true, y.crossOrigin = "Anonymous", y.src = m, y.id = this.id, y.width = c, y.height = c, this._debugShow(y), y;
    }
    _debugShow(m) {
      const y = document.getElementById("mira-player-debug-container");
      y && (m.controls = "controls", m.style = "background:#000", y.appendChild(m));
    }
    release() {
      this.userId = null;
    }
    getInfo() {
      return new Promise((m, y) => {
        if (this.loaded) return this.info ? m(this.info) : y();
        if (this.metaCb = (x) => {
          if (this.loaded = true, !this.$video) return y();
          const { duration: g, videoWidth: _, videoHeight: T } = this.$video;
          this.info = { width: _, height: T, duration: g }, m(this.info);
        }, this.errorCb = (x) => {
          this.loaded = true, y();
        }, this.$video.readyState > 0)
          return this.metaCb();
        this.$video.addEventListener("loadedmetadata", this.metaCb), this.$video.addEventListener("error", this.errorCb), this.timeout && clearTimeout(this.timeout), this.timeout = setTimeout(() => {
          this.loaded || y();
        }, 6e4);
      });
    }
    destroy() {
      this.$video && (this.metaCb && this.$video.removeEventListener("loadedmetadata", this.metaCb), this.errorCb && this.$video.removeEventListener("error", this.errorCb), this.metaCb = null, this.errorCb = null, this.$video.src = "", this.$video.srcObject = null, this.$video.remove()), this.timeout && clearTimeout(this.timeout), this.$video = null, this.userId = null;
    }
    static release(m) {
      for (const [y, x] of Object.entries(u))
        u[y] = x.filter((g) => g.cid !== m ? true : (g.destroy(), false));
    }
    static async grantPlay(m) {
      await Promise.all(u[a].map(async (y) => {
        if (y.cid !== m) return;
        const x = y.$video, g = x.muted;
        return x.muted = true, await x.play(), new Promise((_) => {
          setTimeout(() => {
            x.pause(), x.muted = g, setTimeout(() => _(), 1);
          }, 1);
        });
      }));
    }
    static get(m, y, x) {
      return new Promise((g, _) => {
        l.enqueue(async () => {
          try {
            g(await this._get_(m, y, x));
          } catch (T) {
            _(T);
          }
        });
      });
    }
    static _get_(m, y, x) {
      return new Promise((g, _) => {
        const T = x.endsWith("preview") ? s : a, E = u[T].filter((C) => C.url === m && C.cid === y);
        let b = E.filter((C) => C.userId === x)[0];
        if (b) return g(b);
        if (b = E.filter((C) => !C.userId)[0], b)
          return b.assignTo(x), g(b);
        if (T === s && E.length >= d)
          return _("pool is busy");
        b = new f(E[0] || m, y, x), u[T].push(b), g(b);
      });
    }
  }
  return video$2 = f, video$2;
}
var track, hasRequiredTrack;
function requireTrack() {
  if (hasRequiredTrack) return track;
  hasRequiredTrack = 1;
  const i2 = requireClip();
  class e extends i2 {
    constructor(r = {}) {
      super({ type: "track", ...r });
    }
    get isTrack() {
      return true;
    }
    addChild(r, a = null) {
      super.addChild(r, a), this.refreshSibling();
    }
    removeChild(r) {
      super.removeChild(r), this.refreshSibling();
    }
    refreshSibling() {
      for (let r = 0; r < this.children.length; r++) {
        if (r == 0) {
          this.children[r].prevSibling = null;
          continue;
        }
        const a = this.children[r - 1];
        this.children[r].prevSibling = a, a.nextSibling = this.children[r], this.children[r].nextSibling = null;
      }
    }
    createDisplay() {
    }
    annotate() {
      const r = this.children[this.children.length - 1];
      this.lastChildEndTime = r ? r.endTime : 0;
    }
    get absStartTime() {
      return 0;
    }
    get absEndTime() {
      return this.endTime;
    }
    get startTime() {
      return 0;
    }
    get duration() {
      return this.endTime - this.startTime;
    }
    get endTime() {
      return this.lastChildEndTime;
    }
  }
  return track = e, track;
}
var spine, hasRequiredSpine;
function requireSpine() {
  if (hasRequiredSpine) return spine;
  hasRequiredSpine = 1;
  const i2 = requireTrack();
  class e extends i2 {
    constructor(r = {}) {
      super({ type: "spine", ...r });
    }
  }
  return spine = e, spine;
}
var logger, hasRequiredLogger;
function requireLogger() {
  if (hasRequiredLogger) return logger;
  hasRequiredLogger = 1;
  const { nodeRequire: i2 } = requireUtils(), e = i2("colors"), t = requireUtils(), r = "[FF]";
  return logger = {
    /**
     * Whether to open the print switch
     */
    enable: false,
    hooks: {},
    /**
     * Print information to the command line
     * @public
     */
    info(a) {
      a = typeof a == "object" ? a : { msg: a };
      let { pos: s, msg: u = "" } = a;
      s = s ? `${s} ` : "";
      const l = `${r} ${s}${u}`;
      this.enable && console.log(e ? e.green(l) : l), this.hooks.info && this.hooks.info(l);
    },
    /**
     * Print information to the command line
     * @public
     */
    log(a) {
      a = typeof a == "object" ? a : { msg: a };
      let { pos: s, msg: u = "" } = a;
      s = s ? `${s} ` : "";
      const l = `${r} ${s}${u}`;
      this.enable && console.log(e ? e.blue(l) : l), this.hooks.log && this.hooks.log(l);
    },
    /**
     * Print error message to the command line
     * @public
     */
    error(a) {
      a = typeof a == "object" ? a : { error: a };
      let { pos: s, error: u = "", msg: l = "" } = a;
      s = s ? `${s} ` : "", u = t.getErrStack(u);
      const c = `${r} ${s}${l}${u}`;
      console.error(e ? e.red(c) : c), this.hooks.error && this.hooks.error(c);
    },
    /**
     * Add callback hook
     * @public
     */
    addCallback(a, s) {
      this.hooks[a] = s;
    }
  }, logger;
}
var _arrayEach, hasRequired_arrayEach;
function require_arrayEach() {
  if (hasRequired_arrayEach) return _arrayEach;
  hasRequired_arrayEach = 1;
  function i2(e, t) {
    for (var r = -1, a = e == null ? 0 : e.length; ++r < a && t(e[r], r, e) !== false; )
      ;
    return e;
  }
  return _arrayEach = i2, _arrayEach;
}
var _createBaseFor, hasRequired_createBaseFor;
function require_createBaseFor() {
  if (hasRequired_createBaseFor) return _createBaseFor;
  hasRequired_createBaseFor = 1;
  function i2(e) {
    return function(t, r, a) {
      for (var s = -1, u = Object(t), l = a(t), c = l.length; c--; ) {
        var d = l[e ? c : ++s];
        if (r(u[d], d, u) === false)
          break;
      }
      return t;
    };
  }
  return _createBaseFor = i2, _createBaseFor;
}
var _baseFor, hasRequired_baseFor;
function require_baseFor() {
  if (hasRequired_baseFor) return _baseFor;
  hasRequired_baseFor = 1;
  var i2 = require_createBaseFor(), e = i2();
  return _baseFor = e, _baseFor;
}
var _baseTimes, hasRequired_baseTimes;
function require_baseTimes() {
  if (hasRequired_baseTimes) return _baseTimes;
  hasRequired_baseTimes = 1;
  function i2(e, t) {
    for (var r = -1, a = Array(e); ++r < e; )
      a[r] = t(r);
    return a;
  }
  return _baseTimes = i2, _baseTimes;
}
var _baseIsArguments, hasRequired_baseIsArguments;
function require_baseIsArguments() {
  if (hasRequired_baseIsArguments) return _baseIsArguments;
  hasRequired_baseIsArguments = 1;
  var i2 = require_baseGetTag(), e = requireIsObjectLike(), t = "[object Arguments]";
  function r(a) {
    return e(a) && i2(a) == t;
  }
  return _baseIsArguments = r, _baseIsArguments;
}
var isArguments_1, hasRequiredIsArguments;
function requireIsArguments() {
  if (hasRequiredIsArguments) return isArguments_1;
  hasRequiredIsArguments = 1;
  var i2 = require_baseIsArguments(), e = requireIsObjectLike(), t = Object.prototype, r = t.hasOwnProperty, a = t.propertyIsEnumerable, s = i2(/* @__PURE__ */ function() {
    return arguments;
  }()) ? i2 : function(u) {
    return e(u) && r.call(u, "callee") && !a.call(u, "callee");
  };
  return isArguments_1 = s, isArguments_1;
}
var isArray_1, hasRequiredIsArray;
function requireIsArray() {
  if (hasRequiredIsArray) return isArray_1;
  hasRequiredIsArray = 1;
  var i2 = Array.isArray;
  return isArray_1 = i2, isArray_1;
}
var isBuffer = { exports: {} }, stubFalse_1, hasRequiredStubFalse;
function requireStubFalse() {
  if (hasRequiredStubFalse) return stubFalse_1;
  hasRequiredStubFalse = 1;
  function i2() {
    return false;
  }
  return stubFalse_1 = i2, stubFalse_1;
}
isBuffer.exports;
var hasRequiredIsBuffer;
function requireIsBuffer() {
  return hasRequiredIsBuffer || (hasRequiredIsBuffer = 1, function(i2, e) {
    var t = require_root(), r = requireStubFalse(), a = e && !e.nodeType && e, s = a && true && i2 && !i2.nodeType && i2, u = s && s.exports === a, l = u ? t.Buffer : void 0, c = l ? l.isBuffer : void 0, d = c || r;
    i2.exports = d;
  }(isBuffer, isBuffer.exports)), isBuffer.exports;
}
var _isIndex, hasRequired_isIndex;
function require_isIndex() {
  if (hasRequired_isIndex) return _isIndex;
  hasRequired_isIndex = 1;
  var i2 = 9007199254740991, e = /^(?:0|[1-9]\d*)$/;
  function t(r, a) {
    var s = typeof r;
    return a = a ?? i2, !!a && (s == "number" || s != "symbol" && e.test(r)) && r > -1 && r % 1 == 0 && r < a;
  }
  return _isIndex = t, _isIndex;
}
var isLength_1, hasRequiredIsLength;
function requireIsLength() {
  if (hasRequiredIsLength) return isLength_1;
  hasRequiredIsLength = 1;
  var i2 = 9007199254740991;
  function e(t) {
    return typeof t == "number" && t > -1 && t % 1 == 0 && t <= i2;
  }
  return isLength_1 = e, isLength_1;
}
var _baseIsTypedArray, hasRequired_baseIsTypedArray;
function require_baseIsTypedArray() {
  if (hasRequired_baseIsTypedArray) return _baseIsTypedArray;
  hasRequired_baseIsTypedArray = 1;
  var i2 = require_baseGetTag(), e = requireIsLength(), t = requireIsObjectLike(), r = "[object Arguments]", a = "[object Array]", s = "[object Boolean]", u = "[object Date]", l = "[object Error]", c = "[object Function]", d = "[object Map]", f = "[object Number]", p = "[object Object]", m = "[object RegExp]", y = "[object Set]", x = "[object String]", g = "[object WeakMap]", _ = "[object ArrayBuffer]", T = "[object DataView]", E = "[object Float32Array]", b = "[object Float64Array]", C = "[object Int8Array]", w = "[object Int16Array]", A = "[object Int32Array]", S = "[object Uint8Array]", F = "[object Uint8ClampedArray]", M = "[object Uint16Array]", U = "[object Uint32Array]", B = {};
  B[E] = B[b] = B[C] = B[w] = B[A] = B[S] = B[F] = B[M] = B[U] = true, B[r] = B[a] = B[_] = B[s] = B[T] = B[u] = B[l] = B[c] = B[d] = B[f] = B[p] = B[m] = B[y] = B[x] = B[g] = false;
  function q(z) {
    return t(z) && e(z.length) && !!B[i2(z)];
  }
  return _baseIsTypedArray = q, _baseIsTypedArray;
}
var _baseUnary, hasRequired_baseUnary;
function require_baseUnary() {
  if (hasRequired_baseUnary) return _baseUnary;
  hasRequired_baseUnary = 1;
  function i2(e) {
    return function(t) {
      return e(t);
    };
  }
  return _baseUnary = i2, _baseUnary;
}
var _nodeUtil = { exports: {} };
_nodeUtil.exports;
var hasRequired_nodeUtil;
function require_nodeUtil() {
  return hasRequired_nodeUtil || (hasRequired_nodeUtil = 1, function(i2, e) {
    var t = require_freeGlobal(), r = e && !e.nodeType && e, a = r && true && i2 && !i2.nodeType && i2, s = a && a.exports === r, u = s && t.process, l = function() {
      try {
        var c = a && a.require && a.require("util").types;
        return c || u && u.binding && u.binding("util");
      } catch {
      }
    }();
    i2.exports = l;
  }(_nodeUtil, _nodeUtil.exports)), _nodeUtil.exports;
}
var isTypedArray_1, hasRequiredIsTypedArray;
function requireIsTypedArray() {
  if (hasRequiredIsTypedArray) return isTypedArray_1;
  hasRequiredIsTypedArray = 1;
  var i2 = require_baseIsTypedArray(), e = require_baseUnary(), t = require_nodeUtil(), r = t && t.isTypedArray, a = r ? e(r) : i2;
  return isTypedArray_1 = a, isTypedArray_1;
}
var _arrayLikeKeys, hasRequired_arrayLikeKeys;
function require_arrayLikeKeys() {
  if (hasRequired_arrayLikeKeys) return _arrayLikeKeys;
  hasRequired_arrayLikeKeys = 1;
  var i2 = require_baseTimes(), e = requireIsArguments(), t = requireIsArray(), r = requireIsBuffer(), a = require_isIndex(), s = requireIsTypedArray(), u = Object.prototype, l = u.hasOwnProperty;
  function c(d, f) {
    var p = t(d), m = !p && e(d), y = !p && !m && r(d), x = !p && !m && !y && s(d), g = p || m || y || x, _ = g ? i2(d.length, String) : [], T = _.length;
    for (var E in d)
      (f || l.call(d, E)) && !(g && // Safari 9 has enumerable `arguments.length` in strict mode.
      (E == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
      y && (E == "offset" || E == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
      x && (E == "buffer" || E == "byteLength" || E == "byteOffset") || // Skip index properties.
      a(E, T))) && _.push(E);
    return _;
  }
  return _arrayLikeKeys = c, _arrayLikeKeys;
}
var _isPrototype, hasRequired_isPrototype;
function require_isPrototype() {
  if (hasRequired_isPrototype) return _isPrototype;
  hasRequired_isPrototype = 1;
  var i2 = Object.prototype;
  function e(t) {
    var r = t && t.constructor, a = typeof r == "function" && r.prototype || i2;
    return t === a;
  }
  return _isPrototype = e, _isPrototype;
}
var _overArg, hasRequired_overArg;
function require_overArg() {
  if (hasRequired_overArg) return _overArg;
  hasRequired_overArg = 1;
  function i2(e, t) {
    return function(r) {
      return e(t(r));
    };
  }
  return _overArg = i2, _overArg;
}
var _nativeKeys, hasRequired_nativeKeys;
function require_nativeKeys() {
  if (hasRequired_nativeKeys) return _nativeKeys;
  hasRequired_nativeKeys = 1;
  var i2 = require_overArg(), e = i2(Object.keys, Object);
  return _nativeKeys = e, _nativeKeys;
}
var _baseKeys, hasRequired_baseKeys;
function require_baseKeys() {
  if (hasRequired_baseKeys) return _baseKeys;
  hasRequired_baseKeys = 1;
  var i2 = require_isPrototype(), e = require_nativeKeys(), t = Object.prototype, r = t.hasOwnProperty;
  function a(s) {
    if (!i2(s))
      return e(s);
    var u = [];
    for (var l in Object(s))
      r.call(s, l) && l != "constructor" && u.push(l);
    return u;
  }
  return _baseKeys = a, _baseKeys;
}
var isObject_1, hasRequiredIsObject;
function requireIsObject() {
  if (hasRequiredIsObject) return isObject_1;
  hasRequiredIsObject = 1;
  function i2(e) {
    var t = typeof e;
    return e != null && (t == "object" || t == "function");
  }
  return isObject_1 = i2, isObject_1;
}
var isFunction_1, hasRequiredIsFunction;
function requireIsFunction() {
  if (hasRequiredIsFunction) return isFunction_1;
  hasRequiredIsFunction = 1;
  var i2 = require_baseGetTag(), e = requireIsObject(), t = "[object AsyncFunction]", r = "[object Function]", a = "[object GeneratorFunction]", s = "[object Proxy]";
  function u(l) {
    if (!e(l))
      return false;
    var c = i2(l);
    return c == r || c == a || c == t || c == s;
  }
  return isFunction_1 = u, isFunction_1;
}
var isArrayLike_1, hasRequiredIsArrayLike;
function requireIsArrayLike() {
  if (hasRequiredIsArrayLike) return isArrayLike_1;
  hasRequiredIsArrayLike = 1;
  var i2 = requireIsFunction(), e = requireIsLength();
  function t(r) {
    return r != null && e(r.length) && !i2(r);
  }
  return isArrayLike_1 = t, isArrayLike_1;
}
var keys_1, hasRequiredKeys;
function requireKeys() {
  if (hasRequiredKeys) return keys_1;
  hasRequiredKeys = 1;
  var i2 = require_arrayLikeKeys(), e = require_baseKeys(), t = requireIsArrayLike();
  function r(a) {
    return t(a) ? i2(a) : e(a);
  }
  return keys_1 = r, keys_1;
}
var _baseForOwn, hasRequired_baseForOwn;
function require_baseForOwn() {
  if (hasRequired_baseForOwn) return _baseForOwn;
  hasRequired_baseForOwn = 1;
  var i2 = require_baseFor(), e = requireKeys();
  function t(r, a) {
    return r && i2(r, a, e);
  }
  return _baseForOwn = t, _baseForOwn;
}
var _createBaseEach, hasRequired_createBaseEach;
function require_createBaseEach() {
  if (hasRequired_createBaseEach) return _createBaseEach;
  hasRequired_createBaseEach = 1;
  var i2 = requireIsArrayLike();
  function e(t, r) {
    return function(a, s) {
      if (a == null)
        return a;
      if (!i2(a))
        return t(a, s);
      for (var u = a.length, l = r ? u : -1, c = Object(a); (r ? l-- : ++l < u) && s(c[l], l, c) !== false; )
        ;
      return a;
    };
  }
  return _createBaseEach = e, _createBaseEach;
}
var _baseEach, hasRequired_baseEach;
function require_baseEach() {
  if (hasRequired_baseEach) return _baseEach;
  hasRequired_baseEach = 1;
  var i2 = require_baseForOwn(), e = require_createBaseEach(), t = e(i2);
  return _baseEach = t, _baseEach;
}
var _castFunction, hasRequired_castFunction;
function require_castFunction() {
  if (hasRequired_castFunction) return _castFunction;
  hasRequired_castFunction = 1;
  var i2 = requireIdentity();
  function e(t) {
    return typeof t == "function" ? t : i2;
  }
  return _castFunction = e, _castFunction;
}
var forEach_1, hasRequiredForEach;
function requireForEach() {
  if (hasRequiredForEach) return forEach_1;
  hasRequiredForEach = 1;
  var i2 = require_arrayEach(), e = require_baseEach(), t = require_castFunction(), r = requireIsArray();
  function a(s, u) {
    var l = r(s) ? i2 : e;
    return l(s, t(u));
  }
  return forEach_1 = a, forEach_1;
}
var gl_1, hasRequiredGl;
function requireGl() {
  if (hasRequiredGl) return gl_1;
  hasRequiredGl = 1;
  const i2 = requireNdarray(), e = requireUtils(), { gl: t } = requireLib$2(), r = {
    byteArray: null,
    cache: {},
    getContext(a) {
      const s = a.uuid;
      return r.cache[s] || (r.cache[s] = t(a.width, a.height)), r.cache[s];
    },
    release(a) {
      delete r.cache[a];
    },
    getPixelsByteArray({ gl: a, width: s, height: u, flip: l, bgr: c }) {
      const d = new Uint8Array(s * u * 4);
      if (a.readPixels(0, 0, s, u, a.RGBA, a.UNSIGNED_BYTE, d), !l) return d;
      const f = c ? [2, 1, 0, 3] : [0, 1, 2, 3], p = new Uint8Array(s * u * 4);
      for (let m = 0; m < u; m++)
        for (let y = 0; y < s; y++) {
          const x = y, g = u - m - 1;
          for (let _ = 0; _ < 4; _++) {
            const T = 4 * (g * s + x) + f[_], E = 4 * (m * s + x) + _;
            p[T] = d[E];
          }
        }
      return p;
    },
    enableBlendMode(a) {
      a.blendEquation(a.FUNC_ADD), a.blendFunc(a.SRC_ALPHA, a.ONE_MINUS_SRC_ALPHA), a.enable(a.BLEND);
    },
    /**
     * Get the pixel data of the image
     * https://github.com/stackgl/gl-texture2d/issues/16
     * @public
     */
    async getPixels({ type: a, data: s, width: u, height: l }) {
      if (a === "raw")
        return i2(s, [u, l, 4], [4, u * 4, 1]);
      {
        const { pixels: c } = await e.getPixels(s, `image/${a}`);
        return c;
      }
    }
  };
  return gl_1 = r, gl_1;
}
var timeline, hasRequiredTimeline;
function requireTimeline() {
  if (hasRequiredTimeline) return timeline;
  hasRequiredTimeline = 1, requireForEach(), requireSpine();
  const i2 = requireLogger();
  class e {
    constructor(r) {
      this.creator = r, this.fps = r.getConf("fps"), this.frame = 0, this.frameInFloat = 0, this.duration = 0, this.framesNum = 0;
    }
    update() {
      this.duration = this.creator.duration, this.framesNum = Math.round(this.duration * this.fps);
    }
    annotate() {
      this.creator.annotate(), i2.info({ pos: "Timeline", msg: `annotate creator duration ${this.duration}` }), this.creator.allNodes.map((r) => {
        i2.info({
          pos: "Timeline",
          msg: `annotate ${r.id.padEnd(10, " ")}: time:[${r.absStartTime.toFixed(2).padStart(6, " ")}, ${r.absEndTime.toFixed(2).padStart(6, " ")})  zIndex:${r.zIndex.toFixed(0).padStart(8, " ")}`
        });
      });
    }
    isOver() {
      return this.creator.timer * 1e-3 > this.duration;
    }
    /**
     * update the next frameData
     * @param {Number} deltaTimeMs
     * @public
     */
    nextFrame(r) {
      if (r === void 0 && (r = 1e3 / this.fps), r <= 0) return this.pause();
      const { fps: a } = this;
      if (!this.isOver()) {
        const s = r * a / 1e3;
        return this.frameInFloat += s, this.frame = this.frameInFloat >> 0, this.creator.timeUpdate(r);
      }
    }
    pause() {
      return this.creator.timeUpdate(0);
    }
    async jumpTo(r) {
      const { fps: a } = this;
      return this.frameInFloat = r * a / 1e3, this.frame = this.frameInFloat >> 0, await this.creator.timeUpdate(0, r);
    }
    setFps(r) {
      this.fps = r;
    }
    destroy() {
      this.creator = null;
    }
  }
  return timeline = e, timeline;
}
var renderer, hasRequiredRenderer;
function requireRenderer() {
  if (hasRequiredRenderer) return renderer;
  hasRequiredRenderer = 1;
  const { nodeRequire: i2, awaitMap: e } = requireUtils(), t = i2("../utils/fs"), r = i2("../utils/perf"), a = i2("../core/synthesis"), s = i2("../utils/stream"), u = i2("../utils/opencv");
  requireLib$2(), requireForEach(), requireGl(), requireLogger();
  const l = requireCanvas(), c = requireTimeline(), d = requireBase(), { isBrowser: f } = requireLib$5();
  requireMaterial();
  const p = requireVideo$2();
  class m extends d {
    constructor({ creator: x }) {
      super({ type: "renderer" }), this.stop = false, this.parent = x, this.mPLAYER = null;
    }
    async jumpTo(x) {
      const g = this.playRate;
      this.emit({ type: "seeking", time: x });
      const _ = async () => {
        await this.timeline.jumpTo(x), this.renderFrame();
        const T = this.parent.currentTime;
        this.emit({ type: "seeked", currentTime: T }), this.emit({ type: "timeupdate", currentTime: T, total: Math.floor(this.timeline.duration * 1e3) });
      };
      return this.playing ? new Promise((T) => {
        this.once("pause", async (E) => {
          await _(), g > 0 && this.play(g), T();
        }), this.pause();
      }) : await _();
    }
    async play(x = 1) {
      if (this.playRate = x, this.playing) return;
      const g = this.getCreator();
      this.played || (this.emit({ type: "play" }), this.played = true, await p.grantPlay(g.uuid)), this.resetTimer(), this.emit({ type: "playing", currentTime: this._tweenr }), this.playing = true;
      const _ = 40;
      let T = 0;
      const E = async () => {
        if (!g) return;
        let b = this.mainDelay(), C = this.parent.currentTime;
        b !== 0 && (T += b, b = b * 0.2 + T * 0.01 >> 0, b = Math.min(_, b)), this.renderFrame();
        const w = Math.floor(this.timeline.duration * 1e3);
        this.timeline.isOver() && (C = w, this.pause(), await this.timeline.pause()), this.emit({ type: "timeupdate", currentTime: C, total: w }), this.playRate > 0 ? (await this.timeline.nextFrame(Math.max(1, _ - b) * x), window.requestAnimationFrame(E)) : (this.playing = false, this.timeline.isOver() ? this.emit({ type: "ended" }) : (await this.timeline.pause(), this.emit({ type: "pause", currentTime: C })));
      };
      E();
    }
    async pause() {
      this.playRate = 0;
    }
    /**
     * Start rendering
     * @async
     * @public
     */
    async start(x = true) {
      f || r.start(), this.emit({ type: "start" });
      try {
        await this.preProcessing();
      } catch (T) {
        if (this.stop) return;
        throw f ? this.emit({ type: "error", error: T }) : this.emitError({ error: T, pos: "preProcessing" }), T;
      }
      if (this.stop) return;
      this.createTimeline();
      try {
        await this.prepareMaterial();
      } catch (T) {
        if (this.stop) return;
        throw f ? this.emit({ type: "error", error: T }) : this.emitError({ error: T, pos: "prepareMaterial" }), T;
      }
      !f && x && (this.configCache(), this.createStream(), this.createSynthesis());
      const g = this.getCreator(), _ = this.rootConf();
      this.emit({
        type: "loadedmetadata",
        duration: g.duration,
        width: _.getVal("width"),
        height: _.getVal("height")
      }), !this.stop && (this.playRate = 0, this.renderFrame(), g.canplay = true, this.emit({ type: "canplay" }));
    }
    /**
     * Confirm that there must be a cache folder
     * @private
     */
    configCache() {
      const x = this.rootConf(), g = x.getVal("cacheFormat"), _ = x.getVal("detailedCacheDir");
      t.ensureDir(_), t.setCacheFormat(g);
    }
    resetTimer() {
      this._timer = Date.now(), this._tweenr = this.parent.currentTime;
    }
    mainDelay() {
      const x = this.getCreator();
      return (!this.mPLAYER || !this.mPLAYER.playing) && (this.mPLAYER = this.player(x.mVIDEOS), this.mPLAYER && this.resetTimer()), this.mPLAYER ? this.mPLAYER.delay() * 1e3 >> 0 : this.timerDelay();
    }
    timerDelay() {
      const x = Date.now() - this._timer;
      return this.parent.currentTime - this._tweenr - x;
    }
    player(x) {
      for (let g = 0; g < x.length; g++)
        if (x[g].playing) return x[g];
    }
    /**
     * Init & probe materials in advance
     * @private
     */
    async preProcessing() {
      const x = this.getCreator(), g = x.allNodes;
      let _ = 0, T = g.length;
      this.emit({ type: "preloading", loaded: _, total: T, id: "creator" });
      for (const E of g) {
        if (!f && !E.active && !E.children.length) {
          console.log("preProcessing", E.id, E.conf, E.active);
          continue;
        }
        let b = 0;
        for (; ; ) {
          if (this.stop) return;
          try {
            await E.preProcessing((C) => {
              this.emit({ type: "preloading", loaded: _ + C, total: T, id: E.id });
            }), _ += 1;
            break;
          } catch (C) {
            if (++b > (E.retry || 1))
              throw console.error(`preprocess error: ${E.id}
`, C), `preprocess ${E.type}[id=${E.id}] fail, tried ${b}:
` + E.conf.src;
          } finally {
            this.emit({ type: "preloading", loaded: _, total: T, id: E.id });
          }
        }
      }
      x.allNodes.map((E) => {
        !f && !E.active && !E.children.length || E.annotate();
      });
    }
    /**
     * Prepare processing materials in advance
     * @private
     */
    async prepareMaterial() {
      const x = this.getCreator().allNodes;
      let g = 0, _ = x.length;
      this.emit({ type: "prepareMaterial", prepared: g, total: _, id: "creator" });
      for (const T of x) {
        if (this.stop) return;
        !f && !T.active || (await T.prepareMaterial(), g += 1, this.emit({ type: "prepareMaterial", prepared: g, total: _, id: T.id }));
      }
    }
    /**
     * Create a stream pipeline for data transmission
     * @private
     */
    createStream() {
      const x = this.rootConf(), g = x.getVal("highWaterMark"), _ = x.getVal("parallel"), T = new s({ size: g, parallel: _ });
      T.addPullFunc(this.nodeRenderFrame.bind(this)), T.on("error", (E) => this.emitError({ error: E, pos: "FFStream" })), this.stream = T;
    }
    /**
     * Create a timeline to manage animation
     * @private
     */
    createTimeline() {
      this.timeline = new c(this.getCreator()), this.timeline.annotate();
    }
    async nodeRenderFrame() {
      const x = await this.renderFrame();
      return await this.timeline.nextFrame(), x;
    }
    /**
     * Render a single frame, They are normal clips and transition animation clips.
     * @private
     */
    async renderFrame() {
      return f && this.playRate <= 0 && await this.timeline.pause(), this.snapshotToBuffer();
    }
    /**
     * Take a screenshot of node-canvas and convert it to buffer.
     * @private
     */
    snapshotToBuffer() {
      const x = this.rootConf(), g = this.getCreator();
      if (this.timeline.isOver() || g.render(), f) return;
      const _ = x.getVal("cacheFormat"), T = x.getVal("cacheQuality"), E = g.app.view;
      return l.toBuffer({ type: _, canvas: E, quality: T });
    }
    /**
     * synthesis Video Function
     * @private
     */
    async createSynthesis() {
      const { stream: x, timeline: g } = this, _ = this.rootConf(), T = this.getCreator();
      _.setVal("bgColor", T.bgColor);
      const E = T.allNodes.filter((S) => ["audio", "speech"].includes(S.type)), b = T.allNodes.filter((S) => S.type === "video"), C = new a(_), { start: w, end: A } = T.outputTime;
      C.setDuration(A - w), T.audioOnly ? E.length || C.addNullAudio() : (C.addStream(x), C.addVideos(b)), C.addAudios(E), this.bubble(C), C.on("synthesis-complete", (S) => {
        r.end();
        const F = r.getInfo();
        S = { ...S, useage: F }, this.emit("complete", S), console.log("Render time:", x.fillTime), console.log(`Video Download/Read time: ${u.dltimer} + ${u.timer} = ${u.timer + u.dltimer}`);
      }), await T.timeUpdate(0, Math.floor(w * 1e3)), C.start(), this.synthesis = C;
    }
    /**
     * Get parent creator
     * @private
     */
    getCreator() {
      return this.parent;
    }
    /**
     * Delete the cache intermediate folder
     * @private
     */
    removeCacheFiles() {
      if (this.rootConf("debug") || f || this.getCreator().conf.pathId) return;
      const x = this.rootConf("detailedCacheDir");
      t.rmDir(x);
    }
    destroy() {
      this.stream && this.stream.destroy(), this.timeline && this.timeline.destroy(), this.synthesis && this.synthesis.destroy(), this.removeCacheFiles(), this.removeAllListeners(), super.destroy(), this.stop = true, this.parent = null, this.stream = null, this.timeline = null, this.synthesis = null, this.mPLAYER = null;
    }
  }
  return renderer = m, renderer;
}
var render, hasRequiredRender;
function requireRender() {
  if (hasRequiredRender) return render;
  hasRequiredRender = 1;
  const i2 = requireCanvas(), e = requireQueue(), { WebGLRenderer: t, CanvasRenderer: r, createCanvas: a } = requireLib$2(), s = {
    cache: {},
    async queuedGetView(u, l, c, { type: d, format: f }) {
      return new Promise(async (p, m) => {
        const y = s.cache[c.uuid][u];
        await y.queue.enqueue(async () => {
          if (y.render.render(l), y.render.view.rgbReverse = true, f === "canvas") {
            const x = a(c.width, c.height);
            x.getContext("2d").drawImage(y.render.view, 0, 0, c.width, c.height), p(x);
          }
          p(i2.toBuffer({ type: d, canvas: y.render.view }));
        });
      });
    },
    async getView(u, l, c, d) {
      if (!s.cache[c.uuid] || !s.cache[c.uuid][u]) {
        const f = { width: c.width, height: c.height }, p = c.getConf("useGL") ? new t(f) : new r(f);
        s.cache[c.uuid] = {
          [u]: {
            render: p,
            queue: new e()
          }
        };
      }
      return await s.queuedGetView(u, l, c, d);
    },
    release(u) {
      s.cache[u] && Object.values(s.cache[u]).forEach((l) => {
        var c;
        (c = l == null ? void 0 : l.render) == null || c.destroy();
      }), delete s.cache[u];
    }
  };
  return render = s, render;
}
var creator, hasRequiredCreator;
function requireCreator() {
  if (hasRequiredCreator) return creator;
  hasRequiredCreator = 1;
  const { isBrowser: i2 } = requireLib$5(), e = require$$1$1, t = requireConf(), r = requirePool$1(), a = requireCons(), s = requireUtils(), u = requireVideo$2(), l = requireXhr(), c = requireAudio(), d = requireSpine(), f = requireLogger(), p = requireRenderer(), { Application: m, Loader: y, settings: x, destroyAndCleanAllCache: g, createCanvas: _ } = requireLib$2(), { nodeRequire: T, genUuid: E } = requireUtils(), b = T("../utils/opencv"), C = T("../utils/ffmpeg"), w = requireGl(), A = requireRender(), S = requireAudio$1(), F = 4096;
  class M extends a {
    constructor(B = {}) {
      super({ type: "creator", ...B }), this.canplay = false, this.visible = true, this.maxzIndex = 0, this.inCenter = false, this._conf = new t(B), this.loader = new y(), this.switchLog(this.getConf("log")), this.timer = 10, this._timer = 0, this.frameCallbacks = [], this.mVIDEOS = [], this.analyser = new S.Analyser(F), this.createApp(), this.createRenderer(), this.addAudio(this.getConf("audio")), this.getConf("opencv") === false && (b.enable = false), i2 || f.info({ pos: "OpenCV", msg: `enable: ${b.enable} available: ${b.available()}` });
    }
    updateDisplay() {
      this.allNodes.filter((B) => {
        B.updateDisplay && B.updateDisplay();
      }), super.updateDisplay();
    }
    get uuid() {
      return this.conf.refId;
    }
    get absStartTime() {
      return 0;
    }
    get playing() {
      return this.renderer.playing;
    }
    /**
     * Create webgl scene display object
     * @private
     */
    createApp() {
      this.resetSize();
      const B = this.getConf("width"), q = this.getConf("height"), z = this.getConf("render"), D = this.getConf("clarity"), X = this.getConf("antialias"), k = true, I = `${this.type}_${z}`;
      x.PRECISION_FRAGMENT = `${D}p`;
      const P = this.getConf("canvas");
      if (i2 && !P) throw new Error("Browser rendering need canvas!");
      this.setConf("useGL", k);
      const G = {
        useGL: k,
        antialias: X,
        view: P,
        // 烧制的时候，可能需要视频直接烧制加速，所以要透明
        backgroundColor: 0,
        transparent: !i2
      }, W = r.get(I, () => new m(B, q, G));
      W.renderer.resize(B, q), this.display = W.stage, this.display.sortableChildren = true, this.app = W, this.width = B, this.height = q;
    }
    get bgColor() {
      return this.app.renderer._backgroundColorString;
    }
    async resize(B, q) {
      if (!(!B || !q || isNaN(B) || isNaN(q) || B === this.getConf("width") && q === this.getConf("height"))) {
        this.width = B, this.height = q, this.setConf("width", B), this.setConf("height", q), this.conf.width = B, this.conf.height = q, this.app.renderer.resize(B, q);
        for (const z of this.allNodes)
          z.display && (z.resizeBackground && z.resizeBackground(), z.updateAnimations && z.updateAnimations(), z.updateAttr && z.updateAttr(), z.fitSize && await z.fitSize(), z.fitTexture && await z.fitTexture());
        this.render(), this.emit("resize");
      }
    }
    /**
     * Create Renderer instance - Core classes for rendering animations and videos.
     * @private
     */
    createRenderer() {
      this.renderer = new p({ creator: this });
    }
    /**
     * Create output path, only used when using FFCreatorCenter.
     * @public
     */
    generateOutput() {
      const B = this.getConf("ext"), q = this.getConf("outputDir");
      return q && this.setOutput(e.join(q, `${E()}.${B}`)), this;
    }
    /**
     * Get FFmpeg command line.
     * @return {function} FFmpeg command line
     * @public
     */
    getFFmpeg() {
      return C.getFFmpeg();
    }
    /**
     * Set as the first frame cover page image
     * @param {string} face - the cover face image path
     * @public
     */
    setCover(B) {
      this.setConf("cover", B);
    }
    /**
     * Set the fps of the composite video.
     * @param {number} fps - the fps of the composite video
     * @public
     */
    setFps(B) {
      this.setConf("fps", B);
    }
    /**
     * Set the total duration of the composite video.
     * @param {number} duration - the total duration
     * @public
     */
    setDuration(B) {
      this.setConf("duration", B);
    }
    /**
     * Set configuration.
     * @param {string} key - the config key
     * @param {any} val - the config val
     * @public
     */
    setConf(B, q) {
      this._conf.setVal(B, q);
    }
    /**
     * Get configuration.
     * @param {string} key - the config key
     * @return {any}  the config val
     * @public
     */
    getConf(B) {
      return this._conf.getVal(B);
    }
    /**
     * Add background sound.
     * @param {string|object|FFAudio} args - the audio config
     * @public
     */
    addAudio(B) {
      B && (typeof B == "string" && (B = { path: B }), !(B instanceof c) && B.loop === void 0 && (B.loop = true), super.addAudio(B));
    }
    /**
     * Set the stage size of the scene
     * @param {number} width - stage width
     * @param {number} height - stage height
     * @public
     */
    resetSize(B, q) {
      B || (B = this.getConf("width"), q = this.getConf("height")), this.setConf("width", s.courtship(B)), this.setConf("height", s.courtship(q));
    }
    /**
     * Set the video output path
     * @param {string} output - the video output path
     * @public
     */
    setOutput(B) {
      this.setConf("output", e.normalize(B));
    }
    /**
     * Get the video output path
     * @return {string} output - the video output path
     * @public
     */
    getFile() {
      return this.getConf("output");
    }
    refresh() {
      this.canplay && this.jumpTo(this.currentTime);
    }
    /**
     * Render the scene of the inkpaint app
     * @public
     */
    render() {
      try {
        this.app.render();
      } catch (B) {
        console.log("App render error", B);
      }
    }
    /**
     * Set the video output path
     * @param {string} output - the video output path
     * @public
     */
    output(B) {
      this.setOutput(B);
    }
    /**
     * Open logger switch
     * @public
     */
    openLog() {
      f.enable = true;
    }
    /**
     * Close logger switch
     * @public
     */
    closeLog() {
      f.enable = false;
    }
    switchLog(B) {
      B ? this.openLog() : this.closeLog();
    }
    /**
     * Hook handler function
     * @public
     */
    setInputOptions(B) {
      this.setConf("inputOptions", B);
    }
    setOutOptions(B) {
      this.setConf("outputOptions", B);
    }
    async prepare(B = 0) {
      await this.start(25, false);
      const q = this.toJson();
      if (q.pathId = this.rootConf("pathId"), !B || B * 3 > this.duration) return q;
      const z = Math.round(this.duration / B), D = Math.round(this.duration / z), X = [], k = JSON.stringify(q);
      for (let P = 0; P < z; P++) {
        const G = JSON.parse(k);
        G.mute = true, G.start = P * D >> 0, P + 1 < z && (G.end = (P + 1) * D >> 0), X.push(G);
      }
      const I = JSON.parse(k);
      return I.ext = "m4a", { videos: X, audio: I };
    }
    /**
     * Start video processing
     * @public
     */
    async start(B = 25, q = true) {
      await s.sleep(B), !this.destroyed && (this.addRenderEvent(), this.initSpine(), this.initzIndex(), await this.renderer.start(q));
    }
    initSpine() {
      let B = this.children.filter((q) => (q == null ? void 0 : q.type) === "spine");
      if (B.length > 1) throw new Error("Num of Spine must only one!");
      if (B.length === 0) {
        if (this.children.filter((z) => (z == null ? void 0 : z.type) === "track").length > 0) throw new Error("Track should not exists when Spine absence!");
        B = new d(), B.parent = this;
        const q = [B];
        this.children.map((z) => {
          z.type === "video" && !z.conf.start ? B.addChild(z) : q.push(z);
        }), this.children = q;
      }
    }
    initzIndex() {
      let B = 0;
      const q = (z) => {
        z.children.map((D) => {
          D.zIndex = D.basezIndex + B++, this.maxzIndex = Math.max(D.zIndex, this.maxzIndex), q(D);
        });
      };
      q(this);
    }
    time(B) {
      return Number(B);
    }
    /**
     * Start video play, must called by user CLICK event in the first time
     * @public
     */
    async play(B = 1) {
      if (!this.burning) {
        if (!this.canplay) throw new Error("player not ready");
        this.playbackRate = B, this.renderer.play(B);
      }
    }
    /**
     * Pause video play
     * @public
     */
    async pause() {
      if (!this.burning) {
        if (!this.canplay) throw new Error("player not ready");
        return this.renderer.pause();
      }
    }
    async jumpTo(B) {
      if (this.burning) return;
      if (!this.canplay) throw new Error("player not ready");
      const q = Number(B);
      if (isNaN(q) || q < 0) throw new Error("jump to invalid time", B);
      this.renderer.jumpTo(Math.min(q, this.duration * 1e3 - 50 >> 0));
    }
    /**
     * Register to Renderer listen for events
     * @private
     */
    addRenderEvent() {
      this.bubble(this.renderer);
      const B = async () => {
        await s.sleep(20), this.destroy();
      };
      this.renderer.on("error", B), this.renderer.on("complete", B);
    }
    /**
     * Add callback hook
     * @param {function} callback - callback function
     * @public
     */
    addFrameCallback(B) {
      !B || this.frameCallbacks.includes(B) || (this.frameCallbacks.push(B), this.frameCallbacks.sort((q, z) => q.zIndex - z.zIndex));
    }
    /**
     * Remove callback hook
     * @param {function} callback - callback function
     * @public
     */
    removeFrameCallback(B) {
      if (!B) return;
      const q = this.frameCallbacks.indexOf(B);
      q > -1 && this.frameCallbacks.splice(q, 1);
    }
    get audioBufferSize() {
      return Math.round(this.getConf("audioSampleRate") / this.getConf("fps"));
    }
    /**
     * 把所有audio frame根据不同chanel合并起来
     */
    mergeAudioFrame() {
      const B = [];
      for (const q of this.frameCallbacks) {
        if (typeof q.getAudioFrame != "function") continue;
        const z = q.getAudioFrame(this.timer, this.audioBufferSize);
        if (z && z.length > 0)
          for (const D in z) {
            if (!B[D]) {
              B[D] = z[D];
              continue;
            }
            for (let X = 0; X < this.audioBufferSize; X++)
              B[D][X] += z[D][X] || 0;
          }
      }
      this.audioFrame = B;
    }
    /**
     * Time update function
     * @param {number} delta - delta time (ms)
     * @param {number} timeInMs - Jump to time (ms)
     * @public
     */
    async timeUpdate(B = 0, q = -1) {
      if (B > 0 && !this.canplay) return;
      const z = q >= 0 ? q : this.timer + B, D = B > 0 ? this.timer : z;
      return this.timer = z, this.mergeAudioFrame(), this.analyser.process(this.audioFrame), Promise.all(this.frameCallbacks.map((X) => {
        if (typeof X.drawing == "function")
          return X.drawing(D, B);
      }));
    }
    get audioData() {
      return this.analyser.duration = this.duration, this.analyser.currentTime = this.timer / 1e3, this.analyser;
    }
    get duration() {
      return Number(this.getConf("duration"));
    }
    get currentTime() {
      return this.timer;
    }
    /**
     * Destroy the App class created by InkPaint
     * @private
     */
    destroyApp() {
      const B = this.getConf("pool"), q = this.getConf("render");
      B ? (this.app.destroyChildren(true), r.put(`${this.type}_${q}`, this.app)) : this.app.destroy(true, true), this.app = null;
    }
    annotate() {
      if (this.burning) return;
      const B = this.children.filter((D) => D.type === "spine")[0];
      B.annotate();
      let q = B.duration;
      this.allNodes.filter((D) => !D.isVirtual && !D.flexibleDuration).map((D) => q = Math.max(q, D.absEndTime));
      let z = false;
      q !== this.duration && (z = true, this.setDuration(q)), this.allNodes.map((D) => {
        D.annotate(), this.maxzIndex = Math.max(D.zIndex, this.maxzIndex);
      }), this.renderer.timeline.duration !== this.duration && this.renderer.timeline.update(), this.updateDisplay(), z && this.canplay && this.emit({
        type: "loadedmetadata",
        duration: this.duration,
        width: this.getConf("width"),
        height: this.getConf("height")
      }), this.emit({
        type: "timeupdate",
        currentTime: this.currentTime,
        total: Math.floor(this.duration * 1e3)
      });
    }
    get outputTime() {
      let B = this.getConf("start") || 0, q = this.getConf("end") || this.duration;
      return { start: B, end: q };
    }
    get audioOnly() {
      return `${this.getConf("ext")}`.toLowerCase() === "m4a";
    }
    snapshot(B = {}) {
      this.burning || (this.burning = true);
      const { width: q, height: z } = this;
      this.render();
      const D = _(q, z), X = D.getContext("2d");
      if (X.drawImage(this.app.view, 0, 0, q, z), B.next) {
        const k = 1e3 / this.getConf("fps"), I = this.currentTime + k;
        I > this.duration * 1e3 ? (B.next = null, this.burning = false) : B.next = this.timeUpdate(k, I);
      }
      return ((B == null ? void 0 : B.format) || "jpeg").toLowerCase() === "raw" ? new Promise((k) => {
        setTimeout(() => {
          k(X.getImageData(0, 0, q, z));
        }, 0);
      }) : new Promise((k) => {
        const I = B.format.toLowerCase() === "png" ? "png" : "jpeg";
        D.toBlob((P) => k(P), `image/${I}`, B.quality || 0.8);
      });
    }
    toMiraML(B = true, q = 2) {
      this.XML_INDENT = q;
      const z = this.toJson(B), D = ['version="1.1"'];
      for (const X of ["author", "name", "description"])
        z[X] && (D.push(`${X}="${z[X]}"`), delete z[X]);
      return `<miraml ${D.join(" ")}>
${this.xml(z, q)}</miraml>`;
    }
    xml(B, q, z = null) {
      const D = z || B.type;
      if (!D || !B) return "";
      const X = q + this.XML_INDENT, k = [], I = B.children && Array.isArray(B.children) ? B.children.map((V) => this.xml(V, X)) : [];
      B.type === "text" && B.text && (I.push(`${" ".repeat(X)}<content>${B.text}</content>
`), delete B.text, delete B.content);
      for (let [V, K] of Object.entries(B))
        ["type", "children"].includes(V) || (Array.isArray(K) ? (K = K.map((J) => typeof J != "object" ? J : (I.push(this.xml(J, X, V)), null)).filter((J) => J !== null), K.length > 0 && k.push(`${V}="${JSON.stringify(K)}"`)) : typeof K == "object" ? I.push(this.xml(K, X, V)) : K != null && k.push(`${V}="${K}"`));
      const P = " ".repeat(q), G = `${k.length ? " " : ""}${k.join(" ")}`, W = I.join("");
      return W ? `${P}<${D}${G}>
${W}${P}</${D}>
` : `${P}<${D}${G}></${D}>
`;
    }
    toJson(B = false) {
      const q = super.toJson(B);
      return q.type = "canvas", B || (q.duration = this.duration), delete q.canvas, delete q.value, delete q.cacheDir, delete q.outputDir, delete q.log, B && (delete q.library, delete q.materials), q;
    }
    async destroy() {
      !this.renderer && !this.display || this.destroyed || (this.destroyed = true, this.canplay = false, await this.timeUpdate(0), this.loader.destroy(), this.renderer.destroy(), this.destroyApp(), super.destroy(), u.release(this.uuid), l.cancel(this.uuid), w.release(this.uuid), A.release(this.uuid), this.mVIDEOS = [], this.frameCallbacks = [], this._conf = null, this.conf = null, this.loader = null, this.display = null, this.renderer = null, this.inCenter = false, this.emit("emptied"), f.info({ pos: "Creator", msg: "destroyed!!" }));
    }
    /**
     * Set the installation path of the current server ffmpeg.
     * @param {string} path - installation path of the current server ffmpeg
     * @public
     */
    static setFFmpegPath(B) {
      C.setFFmpegPath(B);
    }
    /**
     * Set the installation path of the current server ffprobe.
     * @param {string} path - installation path of the current server ffprobe
     * @public
     */
    static setFFprobePath(B) {
      C.setFFprobePath(B);
    }
  }
  return creator = M, creator;
}
var pool = {}, twiddle = {}, hasRequiredTwiddle;
function requireTwiddle() {
  if (hasRequiredTwiddle) return twiddle;
  hasRequiredTwiddle = 1;
  var i2 = 32;
  twiddle.INT_BITS = i2, twiddle.INT_MAX = 2147483647, twiddle.INT_MIN = -1 << i2 - 1, twiddle.sign = function(r) {
    return (r > 0) - (r < 0);
  }, twiddle.abs = function(r) {
    var a = r >> i2 - 1;
    return (r ^ a) - a;
  }, twiddle.min = function(r, a) {
    return a ^ (r ^ a) & -(r < a);
  }, twiddle.max = function(r, a) {
    return r ^ (r ^ a) & -(r < a);
  }, twiddle.isPow2 = function(r) {
    return !(r & r - 1) && !!r;
  }, twiddle.log2 = function(r) {
    var a, s;
    return a = (r > 65535) << 4, r >>>= a, s = (r > 255) << 3, r >>>= s, a |= s, s = (r > 15) << 2, r >>>= s, a |= s, s = (r > 3) << 1, r >>>= s, a |= s, a | r >> 1;
  }, twiddle.log10 = function(r) {
    return r >= 1e9 ? 9 : r >= 1e8 ? 8 : r >= 1e7 ? 7 : r >= 1e6 ? 6 : r >= 1e5 ? 5 : r >= 1e4 ? 4 : r >= 1e3 ? 3 : r >= 100 ? 2 : r >= 10 ? 1 : 0;
  }, twiddle.popCount = function(r) {
    return r = r - (r >>> 1 & 1431655765), r = (r & 858993459) + (r >>> 2 & 858993459), (r + (r >>> 4) & 252645135) * 16843009 >>> 24;
  };
  function e(r) {
    var a = 32;
    return r &= -r, r && a--, r & 65535 && (a -= 16), r & 16711935 && (a -= 8), r & 252645135 && (a -= 4), r & 858993459 && (a -= 2), r & 1431655765 && (a -= 1), a;
  }
  twiddle.countTrailingZeros = e, twiddle.nextPow2 = function(r) {
    return r += r === 0, --r, r |= r >>> 1, r |= r >>> 2, r |= r >>> 4, r |= r >>> 8, r |= r >>> 16, r + 1;
  }, twiddle.prevPow2 = function(r) {
    return r |= r >>> 1, r |= r >>> 2, r |= r >>> 4, r |= r >>> 8, r |= r >>> 16, r - (r >>> 1);
  }, twiddle.parity = function(r) {
    return r ^= r >>> 16, r ^= r >>> 8, r ^= r >>> 4, r &= 15, 27030 >>> r & 1;
  };
  var t = new Array(256);
  return function(r) {
    for (var a = 0; a < 256; ++a) {
      var s = a, u = a, l = 7;
      for (s >>>= 1; s; s >>>= 1)
        u <<= 1, u |= s & 1, --l;
      r[a] = u << l & 255;
    }
  }(t), twiddle.reverse = function(r) {
    return t[r & 255] << 24 | t[r >>> 8 & 255] << 16 | t[r >>> 16 & 255] << 8 | t[r >>> 24 & 255];
  }, twiddle.interleave2 = function(r, a) {
    return r &= 65535, r = (r | r << 8) & 16711935, r = (r | r << 4) & 252645135, r = (r | r << 2) & 858993459, r = (r | r << 1) & 1431655765, a &= 65535, a = (a | a << 8) & 16711935, a = (a | a << 4) & 252645135, a = (a | a << 2) & 858993459, a = (a | a << 1) & 1431655765, r | a << 1;
  }, twiddle.deinterleave2 = function(r, a) {
    return r = r >>> a & 1431655765, r = (r | r >>> 1) & 858993459, r = (r | r >>> 2) & 252645135, r = (r | r >>> 4) & 16711935, r = (r | r >>> 16) & 65535, r << 16 >> 16;
  }, twiddle.interleave3 = function(r, a, s) {
    return r &= 1023, r = (r | r << 16) & 4278190335, r = (r | r << 8) & 251719695, r = (r | r << 4) & 3272356035, r = (r | r << 2) & 1227133513, a &= 1023, a = (a | a << 16) & 4278190335, a = (a | a << 8) & 251719695, a = (a | a << 4) & 3272356035, a = (a | a << 2) & 1227133513, r |= a << 1, s &= 1023, s = (s | s << 16) & 4278190335, s = (s | s << 8) & 251719695, s = (s | s << 4) & 3272356035, s = (s | s << 2) & 1227133513, r | s << 2;
  }, twiddle.deinterleave3 = function(r, a) {
    return r = r >>> a & 1227133513, r = (r | r >>> 2) & 3272356035, r = (r | r >>> 4) & 251719695, r = (r | r >>> 8) & 4278190335, r = (r | r >>> 16) & 1023, r << 22 >> 22;
  }, twiddle.nextCombination = function(r) {
    var a = r | r - 1;
    return a + 1 | (~a & -~a) - 1 >>> e(r) + 1;
  }, twiddle;
}
var dup, hasRequiredDup;
function requireDup() {
  if (hasRequiredDup) return dup;
  hasRequiredDup = 1;
  function i2(r, a, s) {
    var u = r[s] | 0;
    if (u <= 0)
      return [];
    var l = new Array(u), c;
    if (s === r.length - 1)
      for (c = 0; c < u; ++c)
        l[c] = a;
    else
      for (c = 0; c < u; ++c)
        l[c] = i2(r, a, s + 1);
    return l;
  }
  function e(r, a) {
    var s, u;
    for (s = new Array(r), u = 0; u < r; ++u)
      s[u] = a;
    return s;
  }
  function t(r, a) {
    switch (typeof a > "u" && (a = 0), typeof r) {
      case "number":
        if (r > 0)
          return e(r | 0, a);
        break;
      case "object":
        if (typeof r.length == "number")
          return i2(r, a, 0);
        break;
    }
    return [];
  }
  return dup = t, dup;
}
var hasRequiredPool;
function requirePool() {
  if (hasRequiredPool) return pool;
  hasRequiredPool = 1;
  var i2 = requireTwiddle(), e = requireDup(), t = requireBuffer$1().Buffer;
  window.__TYPEDARRAY_POOL || (window.__TYPEDARRAY_POOL = {
    UINT8: e([32, 0]),
    UINT16: e([32, 0]),
    UINT32: e([32, 0]),
    BIGUINT64: e([32, 0]),
    INT8: e([32, 0]),
    INT16: e([32, 0]),
    INT32: e([32, 0]),
    BIGINT64: e([32, 0]),
    FLOAT: e([32, 0]),
    DOUBLE: e([32, 0]),
    DATA: e([32, 0]),
    UINT8C: e([32, 0]),
    BUFFER: e([32, 0])
  });
  var r = typeof Uint8ClampedArray < "u", a = typeof BigUint64Array < "u", s = typeof BigInt64Array < "u", u = window.__TYPEDARRAY_POOL;
  u.UINT8C || (u.UINT8C = e([32, 0])), u.BIGUINT64 || (u.BIGUINT64 = e([32, 0])), u.BIGINT64 || (u.BIGINT64 = e([32, 0])), u.BUFFER || (u.BUFFER = e([32, 0]));
  var l = u.DATA, c = u.BUFFER;
  pool.free = function(M) {
    if (t.isBuffer(M))
      c[i2.log2(M.length)].push(M);
    else {
      if (Object.prototype.toString.call(M) !== "[object ArrayBuffer]" && (M = M.buffer), !M)
        return;
      var U = M.length || M.byteLength, B = i2.log2(U) | 0;
      l[B].push(M);
    }
  };
  function d(M) {
    if (M) {
      var U = M.length || M.byteLength, B = i2.log2(U);
      l[B].push(M);
    }
  }
  function f(M) {
    d(M.buffer);
  }
  pool.freeUint8 = pool.freeUint16 = pool.freeUint32 = pool.freeBigUint64 = pool.freeInt8 = pool.freeInt16 = pool.freeInt32 = pool.freeBigInt64 = pool.freeFloat32 = pool.freeFloat = pool.freeFloat64 = pool.freeDouble = pool.freeUint8Clamped = pool.freeDataView = f, pool.freeArrayBuffer = d, pool.freeBuffer = function(M) {
    c[i2.log2(M.length)].push(M);
  }, pool.malloc = function(M, U) {
    if (U === void 0 || U === "arraybuffer")
      return p(M);
    switch (U) {
      case "uint8":
        return m(M);
      case "uint16":
        return y(M);
      case "uint32":
        return x(M);
      case "int8":
        return g(M);
      case "int16":
        return _(M);
      case "int32":
        return T(M);
      case "float":
      case "float32":
        return E(M);
      case "double":
      case "float64":
        return b(M);
      case "uint8_clamped":
        return C(M);
      case "bigint64":
        return A(M);
      case "biguint64":
        return w(M);
      case "buffer":
        return F(M);
      case "data":
      case "dataview":
        return S(M);
      default:
        return null;
    }
    return null;
  };
  function p(U) {
    var U = i2.nextPow2(U), B = i2.log2(U), q = l[B];
    return q.length > 0 ? q.pop() : new ArrayBuffer(U);
  }
  pool.mallocArrayBuffer = p;
  function m(M) {
    return new Uint8Array(p(M), 0, M);
  }
  pool.mallocUint8 = m;
  function y(M) {
    return new Uint16Array(p(2 * M), 0, M);
  }
  pool.mallocUint16 = y;
  function x(M) {
    return new Uint32Array(p(4 * M), 0, M);
  }
  pool.mallocUint32 = x;
  function g(M) {
    return new Int8Array(p(M), 0, M);
  }
  pool.mallocInt8 = g;
  function _(M) {
    return new Int16Array(p(2 * M), 0, M);
  }
  pool.mallocInt16 = _;
  function T(M) {
    return new Int32Array(p(4 * M), 0, M);
  }
  pool.mallocInt32 = T;
  function E(M) {
    return new Float32Array(p(4 * M), 0, M);
  }
  pool.mallocFloat32 = pool.mallocFloat = E;
  function b(M) {
    return new Float64Array(p(8 * M), 0, M);
  }
  pool.mallocFloat64 = pool.mallocDouble = b;
  function C(M) {
    return r ? new Uint8ClampedArray(p(M), 0, M) : m(M);
  }
  pool.mallocUint8Clamped = C;
  function w(M) {
    return a ? new BigUint64Array(p(8 * M), 0, M) : null;
  }
  pool.mallocBigUint64 = w;
  function A(M) {
    return s ? new BigInt64Array(p(8 * M), 0, M) : null;
  }
  pool.mallocBigInt64 = A;
  function S(M) {
    return new DataView(p(M), 0, M);
  }
  pool.mallocDataView = S;
  function F(M) {
    M = i2.nextPow2(M);
    var U = i2.log2(M), B = c[U];
    return B.length > 0 ? B.pop() : new t(M);
  }
  return pool.mallocBuffer = F, pool.clearCache = function() {
    for (var M = 0; M < 32; ++M)
      u.UINT8[M].length = 0, u.UINT16[M].length = 0, u.UINT32[M].length = 0, u.INT8[M].length = 0, u.INT16[M].length = 0, u.INT32[M].length = 0, u.FLOAT[M].length = 0, u.DOUBLE[M].length = 0, u.BIGUINT64[M].length = 0, u.BIGINT64[M].length = 0, u.UINT8C[M].length = 0, l[M].length = 0, c[M].length = 0;
  }, pool;
}
var ndarrayOps = {}, hasRequiredNdarrayOps;
function requireNdarrayOps() {
  return hasRequiredNdarrayOps || (hasRequiredNdarrayOps = 1, function(i2) {
    var e = requireCompiler(), t = {
      body: "",
      args: [],
      thisVars: [],
      localVars: []
    };
    function r(m) {
      if (!m)
        return t;
      for (var y = 0; y < m.args.length; ++y) {
        var x = m.args[y];
        y === 0 ? m.args[y] = { name: x, lvalue: true, rvalue: !!m.rvalue, count: m.count || 1 } : m.args[y] = { name: x, lvalue: false, rvalue: true, count: 1 };
      }
      return m.thisVars || (m.thisVars = []), m.localVars || (m.localVars = []), m;
    }
    function a(m) {
      return e({
        args: m.args,
        pre: r(m.pre),
        body: r(m.body),
        post: r(m.proc),
        funcName: m.funcName
      });
    }
    function s(m) {
      for (var y = [], x = 0; x < m.args.length; ++x)
        y.push("a" + x);
      var g = new Function("P", [
        "return function ",
        m.funcName,
        "_ndarrayops(",
        y.join(","),
        ") {P(",
        y.join(","),
        ");return a0}"
      ].join(""));
      return g(a(m));
    }
    var u = {
      add: "+",
      sub: "-",
      mul: "*",
      div: "/",
      mod: "%",
      band: "&",
      bor: "|",
      bxor: "^",
      lshift: "<<",
      rshift: ">>",
      rrshift: ">>>"
    };
    (function() {
      for (var m in u) {
        var y = u[m];
        i2[m] = s({
          args: ["array", "array", "array"],
          body: {
            args: ["a", "b", "c"],
            body: "a=b" + y + "c"
          },
          funcName: m
        }), i2[m + "eq"] = s({
          args: ["array", "array"],
          body: {
            args: ["a", "b"],
            body: "a" + y + "=b"
          },
          rvalue: true,
          funcName: m + "eq"
        }), i2[m + "s"] = s({
          args: ["array", "array", "scalar"],
          body: {
            args: ["a", "b", "s"],
            body: "a=b" + y + "s"
          },
          funcName: m + "s"
        }), i2[m + "seq"] = s({
          args: ["array", "scalar"],
          body: {
            args: ["a", "s"],
            body: "a" + y + "=s"
          },
          rvalue: true,
          funcName: m + "seq"
        });
      }
    })();
    var l = {
      not: "!",
      bnot: "~",
      neg: "-",
      recip: "1.0/"
    };
    (function() {
      for (var m in l) {
        var y = l[m];
        i2[m] = s({
          args: ["array", "array"],
          body: {
            args: ["a", "b"],
            body: "a=" + y + "b"
          },
          funcName: m
        }), i2[m + "eq"] = s({
          args: ["array"],
          body: {
            args: ["a"],
            body: "a=" + y + "a"
          },
          rvalue: true,
          count: 2,
          funcName: m + "eq"
        });
      }
    })();
    var c = {
      and: "&&",
      or: "||",
      eq: "===",
      neq: "!==",
      lt: "<",
      gt: ">",
      leq: "<=",
      geq: ">="
    };
    (function() {
      for (var m in c) {
        var y = c[m];
        i2[m] = s({
          args: ["array", "array", "array"],
          body: {
            args: ["a", "b", "c"],
            body: "a=b" + y + "c"
          },
          funcName: m
        }), i2[m + "s"] = s({
          args: ["array", "array", "scalar"],
          body: {
            args: ["a", "b", "s"],
            body: "a=b" + y + "s"
          },
          funcName: m + "s"
        }), i2[m + "eq"] = s({
          args: ["array", "array"],
          body: {
            args: ["a", "b"],
            body: "a=a" + y + "b"
          },
          rvalue: true,
          count: 2,
          funcName: m + "eq"
        }), i2[m + "seq"] = s({
          args: ["array", "scalar"],
          body: {
            args: ["a", "s"],
            body: "a=a" + y + "s"
          },
          rvalue: true,
          count: 2,
          funcName: m + "seq"
        });
      }
    })();
    var d = [
      "abs",
      "acos",
      "asin",
      "atan",
      "ceil",
      "cos",
      "exp",
      "floor",
      "log",
      "round",
      "sin",
      "sqrt",
      "tan"
    ];
    (function() {
      for (var m = 0; m < d.length; ++m) {
        var y = d[m];
        i2[y] = s({
          args: ["array", "array"],
          pre: { args: [], body: "this_f=Math." + y, thisVars: ["this_f"] },
          body: { args: ["a", "b"], body: "a=this_f(b)", thisVars: ["this_f"] },
          funcName: y
        }), i2[y + "eq"] = s({
          args: ["array"],
          pre: { args: [], body: "this_f=Math." + y, thisVars: ["this_f"] },
          body: { args: ["a"], body: "a=this_f(a)", thisVars: ["this_f"] },
          rvalue: true,
          count: 2,
          funcName: y + "eq"
        });
      }
    })();
    var f = [
      "max",
      "min",
      "atan2",
      "pow"
    ];
    (function() {
      for (var m = 0; m < f.length; ++m) {
        var y = f[m];
        i2[y] = s({
          args: ["array", "array", "array"],
          pre: { args: [], body: "this_f=Math." + y, thisVars: ["this_f"] },
          body: { args: ["a", "b", "c"], body: "a=this_f(b,c)", thisVars: ["this_f"] },
          funcName: y
        }), i2[y + "s"] = s({
          args: ["array", "array", "scalar"],
          pre: { args: [], body: "this_f=Math." + y, thisVars: ["this_f"] },
          body: { args: ["a", "b", "c"], body: "a=this_f(b,c)", thisVars: ["this_f"] },
          funcName: y + "s"
        }), i2[y + "eq"] = s({
          args: ["array", "array"],
          pre: { args: [], body: "this_f=Math." + y, thisVars: ["this_f"] },
          body: { args: ["a", "b"], body: "a=this_f(a,b)", thisVars: ["this_f"] },
          rvalue: true,
          count: 2,
          funcName: y + "eq"
        }), i2[y + "seq"] = s({
          args: ["array", "scalar"],
          pre: { args: [], body: "this_f=Math." + y, thisVars: ["this_f"] },
          body: { args: ["a", "b"], body: "a=this_f(a,b)", thisVars: ["this_f"] },
          rvalue: true,
          count: 2,
          funcName: y + "seq"
        });
      }
    })();
    var p = [
      "atan2",
      "pow"
    ];
    (function() {
      for (var m = 0; m < p.length; ++m) {
        var y = p[m];
        i2[y + "op"] = s({
          args: ["array", "array", "array"],
          pre: { args: [], body: "this_f=Math." + y, thisVars: ["this_f"] },
          body: { args: ["a", "b", "c"], body: "a=this_f(c,b)", thisVars: ["this_f"] },
          funcName: y + "op"
        }), i2[y + "ops"] = s({
          args: ["array", "array", "scalar"],
          pre: { args: [], body: "this_f=Math." + y, thisVars: ["this_f"] },
          body: { args: ["a", "b", "c"], body: "a=this_f(c,b)", thisVars: ["this_f"] },
          funcName: y + "ops"
        }), i2[y + "opeq"] = s({
          args: ["array", "array"],
          pre: { args: [], body: "this_f=Math." + y, thisVars: ["this_f"] },
          body: { args: ["a", "b"], body: "a=this_f(b,a)", thisVars: ["this_f"] },
          rvalue: true,
          count: 2,
          funcName: y + "opeq"
        }), i2[y + "opseq"] = s({
          args: ["array", "scalar"],
          pre: { args: [], body: "this_f=Math." + y, thisVars: ["this_f"] },
          body: { args: ["a", "b"], body: "a=this_f(b,a)", thisVars: ["this_f"] },
          rvalue: true,
          count: 2,
          funcName: y + "opseq"
        });
      }
    })(), i2.any = e({
      args: ["array"],
      pre: t,
      body: { args: [{ name: "a", lvalue: false, rvalue: true, count: 1 }], body: "if(a){return true}", localVars: [], thisVars: [] },
      post: { args: [], localVars: [], thisVars: [], body: "return false" },
      funcName: "any"
    }), i2.all = e({
      args: ["array"],
      pre: t,
      body: { args: [{ name: "x", lvalue: false, rvalue: true, count: 1 }], body: "if(!x){return false}", localVars: [], thisVars: [] },
      post: { args: [], localVars: [], thisVars: [], body: "return true" },
      funcName: "all"
    }), i2.sum = e({
      args: ["array"],
      pre: { args: [], localVars: [], thisVars: ["this_s"], body: "this_s=0" },
      body: { args: [{ name: "a", lvalue: false, rvalue: true, count: 1 }], body: "this_s+=a", localVars: [], thisVars: ["this_s"] },
      post: { args: [], localVars: [], thisVars: ["this_s"], body: "return this_s" },
      funcName: "sum"
    }), i2.prod = e({
      args: ["array"],
      pre: { args: [], localVars: [], thisVars: ["this_s"], body: "this_s=1" },
      body: { args: [{ name: "a", lvalue: false, rvalue: true, count: 1 }], body: "this_s*=a", localVars: [], thisVars: ["this_s"] },
      post: { args: [], localVars: [], thisVars: ["this_s"], body: "return this_s" },
      funcName: "prod"
    }), i2.norm2squared = e({
      args: ["array"],
      pre: { args: [], localVars: [], thisVars: ["this_s"], body: "this_s=0" },
      body: { args: [{ name: "a", lvalue: false, rvalue: true, count: 2 }], body: "this_s+=a*a", localVars: [], thisVars: ["this_s"] },
      post: { args: [], localVars: [], thisVars: ["this_s"], body: "return this_s" },
      funcName: "norm2squared"
    }), i2.norm2 = e({
      args: ["array"],
      pre: { args: [], localVars: [], thisVars: ["this_s"], body: "this_s=0" },
      body: { args: [{ name: "a", lvalue: false, rvalue: true, count: 2 }], body: "this_s+=a*a", localVars: [], thisVars: ["this_s"] },
      post: { args: [], localVars: [], thisVars: ["this_s"], body: "return Math.sqrt(this_s)" },
      funcName: "norm2"
    }), i2.norminf = e({
      args: ["array"],
      pre: { args: [], localVars: [], thisVars: ["this_s"], body: "this_s=0" },
      body: { args: [{ name: "a", lvalue: false, rvalue: true, count: 4 }], body: "if(-a>this_s){this_s=-a}else if(a>this_s){this_s=a}", localVars: [], thisVars: ["this_s"] },
      post: { args: [], localVars: [], thisVars: ["this_s"], body: "return this_s" },
      funcName: "norminf"
    }), i2.norm1 = e({
      args: ["array"],
      pre: { args: [], localVars: [], thisVars: ["this_s"], body: "this_s=0" },
      body: { args: [{ name: "a", lvalue: false, rvalue: true, count: 3 }], body: "this_s+=a<0?-a:a", localVars: [], thisVars: ["this_s"] },
      post: { args: [], localVars: [], thisVars: ["this_s"], body: "return this_s" },
      funcName: "norm1"
    }), i2.sup = e({
      args: ["array"],
      pre: {
        body: "this_h=-Infinity",
        args: [],
        thisVars: ["this_h"],
        localVars: []
      },
      body: {
        body: "if(_inline_1_arg0_>this_h)this_h=_inline_1_arg0_",
        args: [{ name: "_inline_1_arg0_", lvalue: false, rvalue: true, count: 2 }],
        thisVars: ["this_h"],
        localVars: []
      },
      post: {
        body: "return this_h",
        args: [],
        thisVars: ["this_h"],
        localVars: []
      }
    }), i2.inf = e({
      args: ["array"],
      pre: {
        body: "this_h=Infinity",
        args: [],
        thisVars: ["this_h"],
        localVars: []
      },
      body: {
        body: "if(_inline_1_arg0_<this_h)this_h=_inline_1_arg0_",
        args: [{ name: "_inline_1_arg0_", lvalue: false, rvalue: true, count: 2 }],
        thisVars: ["this_h"],
        localVars: []
      },
      post: {
        body: "return this_h",
        args: [],
        thisVars: ["this_h"],
        localVars: []
      }
    }), i2.argmin = e({
      args: ["index", "array", "shape"],
      pre: {
        body: "{this_v=Infinity;this_i=_inline_0_arg2_.slice(0)}",
        args: [
          { name: "_inline_0_arg0_", lvalue: false, rvalue: false, count: 0 },
          { name: "_inline_0_arg1_", lvalue: false, rvalue: false, count: 0 },
          { name: "_inline_0_arg2_", lvalue: false, rvalue: true, count: 1 }
        ],
        thisVars: ["this_i", "this_v"],
        localVars: []
      },
      body: {
        body: "{if(_inline_1_arg1_<this_v){this_v=_inline_1_arg1_;for(var _inline_1_k=0;_inline_1_k<_inline_1_arg0_.length;++_inline_1_k){this_i[_inline_1_k]=_inline_1_arg0_[_inline_1_k]}}}",
        args: [
          { name: "_inline_1_arg0_", lvalue: false, rvalue: true, count: 2 },
          { name: "_inline_1_arg1_", lvalue: false, rvalue: true, count: 2 }
        ],
        thisVars: ["this_i", "this_v"],
        localVars: ["_inline_1_k"]
      },
      post: {
        body: "{return this_i}",
        args: [],
        thisVars: ["this_i"],
        localVars: []
      }
    }), i2.argmax = e({
      args: ["index", "array", "shape"],
      pre: {
        body: "{this_v=-Infinity;this_i=_inline_0_arg2_.slice(0)}",
        args: [
          { name: "_inline_0_arg0_", lvalue: false, rvalue: false, count: 0 },
          { name: "_inline_0_arg1_", lvalue: false, rvalue: false, count: 0 },
          { name: "_inline_0_arg2_", lvalue: false, rvalue: true, count: 1 }
        ],
        thisVars: ["this_i", "this_v"],
        localVars: []
      },
      body: {
        body: "{if(_inline_1_arg1_>this_v){this_v=_inline_1_arg1_;for(var _inline_1_k=0;_inline_1_k<_inline_1_arg0_.length;++_inline_1_k){this_i[_inline_1_k]=_inline_1_arg0_[_inline_1_k]}}}",
        args: [
          { name: "_inline_1_arg0_", lvalue: false, rvalue: true, count: 2 },
          { name: "_inline_1_arg1_", lvalue: false, rvalue: true, count: 2 }
        ],
        thisVars: ["this_i", "this_v"],
        localVars: ["_inline_1_k"]
      },
      post: {
        body: "{return this_i}",
        args: [],
        thisVars: ["this_i"],
        localVars: []
      }
    }), i2.random = s({
      args: ["array"],
      pre: { args: [], body: "this_f=Math.random", thisVars: ["this_f"] },
      body: { args: ["a"], body: "a=this_f()", thisVars: ["this_f"] },
      funcName: "random"
    }), i2.assign = s({
      args: ["array", "array"],
      body: { args: ["a", "b"], body: "a=b" },
      funcName: "assign"
    }), i2.assigns = s({
      args: ["array", "scalar"],
      body: { args: ["a", "b"], body: "a=b" },
      funcName: "assigns"
    }), i2.equals = e({
      args: ["array", "array"],
      pre: t,
      body: {
        args: [
          { name: "x", lvalue: false, rvalue: true, count: 1 },
          { name: "y", lvalue: false, rvalue: true, count: 1 }
        ],
        body: "if(x!==y){return false}",
        localVars: [],
        thisVars: []
      },
      post: { args: [], localVars: [], thisVars: [], body: "return true" },
      funcName: "equals"
    });
  }(ndarrayOps)), ndarrayOps;
}
var buffer, hasRequiredBuffer;
function requireBuffer() {
  if (hasRequiredBuffer) return buffer;
  hasRequiredBuffer = 1;
  var i2 = requirePool(), e = requireNdarrayOps(), t = requireNdarray(), r = [
    "uint8",
    "uint8_clamped",
    "uint16",
    "uint32",
    "int8",
    "int16",
    "int32",
    "float32"
  ];
  function a(f, p, m, y, x) {
    this.gl = f, this.type = p, this.handle = m, this.length = y, this.usage = x;
  }
  var s = a.prototype;
  s.bind = function() {
    this.gl.bindBuffer(this.type, this.handle);
  }, s.unbind = function() {
    this.gl.bindBuffer(this.type, null);
  }, s.dispose = function() {
    this.gl.deleteBuffer(this.handle);
  };
  function u(f, p, m, y, x, g) {
    var _ = x.length * x.BYTES_PER_ELEMENT;
    if (g < 0)
      return f.bufferData(p, x, y), _;
    if (_ + g > m)
      throw new Error("gl-buffer: If resizing buffer, must not specify offset");
    return f.bufferSubData(p, g, x), m;
  }
  function l(f, p) {
    for (var m = i2.malloc(f.length, p), y = f.length, x = 0; x < y; ++x)
      m[x] = f[x];
    return m;
  }
  function c(f, p) {
    for (var m = 1, y = p.length - 1; y >= 0; --y) {
      if (p[y] !== m)
        return false;
      m *= f[y];
    }
    return true;
  }
  s.update = function(f, p) {
    if (typeof p != "number" && (p = -1), this.bind(), typeof f == "object" && typeof f.shape < "u") {
      var m = f.dtype;
      if (r.indexOf(m) < 0 && (m = "float32"), this.type === this.gl.ELEMENT_ARRAY_BUFFER) {
        var y = gl.getExtension("OES_element_index_uint");
        y && m !== "uint16" ? m = "uint32" : m = "uint16";
      }
      if (m === f.dtype && c(f.shape, f.stride))
        f.offset === 0 && f.data.length === f.shape[0] ? this.length = u(this.gl, this.type, this.length, this.usage, f.data, p) : this.length = u(this.gl, this.type, this.length, this.usage, f.data.subarray(f.offset, f.shape[0]), p);
      else {
        var x = i2.malloc(f.size, m), g = t(x, f.shape);
        e.assign(g, f), p < 0 ? this.length = u(this.gl, this.type, this.length, this.usage, x, p) : this.length = u(this.gl, this.type, this.length, this.usage, x.subarray(0, f.size), p), i2.free(x);
      }
    } else if (Array.isArray(f)) {
      var _;
      this.type === this.gl.ELEMENT_ARRAY_BUFFER ? _ = l(f, "uint16") : _ = l(f, "float32"), p < 0 ? this.length = u(this.gl, this.type, this.length, this.usage, _, p) : this.length = u(this.gl, this.type, this.length, this.usage, _.subarray(0, f.length), p), i2.free(_);
    } else if (typeof f == "object" && typeof f.length == "number")
      this.length = u(this.gl, this.type, this.length, this.usage, f, p);
    else if (typeof f == "number" || f === void 0) {
      if (p >= 0)
        throw new Error("gl-buffer: Cannot specify offset when resizing buffer");
      f = f | 0, f <= 0 && (f = 1), this.gl.bufferData(this.type, f | 0, this.usage), this.length = f;
    } else
      throw new Error("gl-buffer: Invalid data type");
  };
  function d(f, p, m, y) {
    if (m = m || f.ARRAY_BUFFER, y = y || f.DYNAMIC_DRAW, m !== f.ARRAY_BUFFER && m !== f.ELEMENT_ARRAY_BUFFER)
      throw new Error("gl-buffer: Invalid type for webgl buffer, must be either gl.ARRAY_BUFFER or gl.ELEMENT_ARRAY_BUFFER");
    if (y !== f.DYNAMIC_DRAW && y !== f.STATIC_DRAW && y !== f.STREAM_DRAW)
      throw new Error("gl-buffer: Invalid usage for buffer, must be either gl.DYNAMIC_DRAW, gl.STATIC_DRAW or gl.STREAM_DRAW");
    var x = f.createBuffer(), g = new a(f, m, x, 0, y);
    return g.update(p), g;
  }
  return buffer = d, buffer;
}
var texture, hasRequiredTexture;
function requireTexture() {
  if (hasRequiredTexture) return texture;
  hasRequiredTexture = 1;
  var i2 = requireNdarray(), e = requireNdarrayOps(), t = requirePool();
  texture = E;
  var r = null, a = null, s = null;
  function u(b) {
    r = [
      b.LINEAR,
      b.NEAREST_MIPMAP_LINEAR,
      b.LINEAR_MIPMAP_NEAREST,
      b.LINEAR_MIPMAP_NEAREST
    ], a = [
      b.NEAREST,
      b.LINEAR,
      b.NEAREST_MIPMAP_NEAREST,
      b.NEAREST_MIPMAP_LINEAR,
      b.LINEAR_MIPMAP_NEAREST,
      b.LINEAR_MIPMAP_LINEAR
    ], s = [
      b.REPEAT,
      b.CLAMP_TO_EDGE,
      b.MIRRORED_REPEAT
    ];
  }
  function l(b) {
    return typeof HTMLCanvasElement < "u" && b instanceof HTMLCanvasElement || typeof HTMLImageElement < "u" && b instanceof HTMLImageElement || typeof HTMLVideoElement < "u" && b instanceof HTMLVideoElement || typeof ImageData < "u" && b instanceof ImageData;
  }
  var c = function(b, C) {
    e.muls(b, C, 255);
  };
  function d(b, C, w) {
    var A = b.gl, S = A.getParameter(A.MAX_TEXTURE_SIZE);
    if (C < 0 || C > S || w < 0 || w > S)
      throw new Error("gl-texture2d: Invalid texture size");
    return b._shape = [C, w], b.bind(), A.texImage2D(A.TEXTURE_2D, 0, b.format, C, w, 0, b.format, b.type, null), b._mipLevels = [0], b;
  }
  function f(b, C, w, A, S, F) {
    this.gl = b, this.handle = C, this.format = S, this.type = F, this._shape = [w, A], this._mipLevels = [0], this._magFilter = b.NEAREST, this._minFilter = b.NEAREST, this._wrapS = b.CLAMP_TO_EDGE, this._wrapT = b.CLAMP_TO_EDGE, this._anisoSamples = 1;
    var M = this, U = [this._wrapS, this._wrapT];
    Object.defineProperties(U, [
      {
        get: function() {
          return M._wrapS;
        },
        set: function(q) {
          return M.wrapS = q;
        }
      },
      {
        get: function() {
          return M._wrapT;
        },
        set: function(q) {
          return M.wrapT = q;
        }
      }
    ]), this._wrapVector = U;
    var B = [this._shape[0], this._shape[1]];
    Object.defineProperties(B, [
      {
        get: function() {
          return M._shape[0];
        },
        set: function(q) {
          return M.width = q;
        }
      },
      {
        get: function() {
          return M._shape[1];
        },
        set: function(q) {
          return M.height = q;
        }
      }
    ]), this._shapeVector = B;
  }
  var p = f.prototype;
  Object.defineProperties(p, {
    minFilter: {
      get: function() {
        return this._minFilter;
      },
      set: function(b) {
        this.bind();
        var C = this.gl;
        if (this.type === C.FLOAT && r.indexOf(b) >= 0 && (C.getExtension("OES_texture_float_linear") || (b = C.NEAREST)), a.indexOf(b) < 0)
          throw new Error("gl-texture2d: Unknown filter mode " + b);
        return C.texParameteri(C.TEXTURE_2D, C.TEXTURE_MIN_FILTER, b), this._minFilter = b;
      }
    },
    magFilter: {
      get: function() {
        return this._magFilter;
      },
      set: function(b) {
        this.bind();
        var C = this.gl;
        if (this.type === C.FLOAT && r.indexOf(b) >= 0 && (C.getExtension("OES_texture_float_linear") || (b = C.NEAREST)), a.indexOf(b) < 0)
          throw new Error("gl-texture2d: Unknown filter mode " + b);
        return C.texParameteri(C.TEXTURE_2D, C.TEXTURE_MAG_FILTER, b), this._magFilter = b;
      }
    },
    mipSamples: {
      get: function() {
        return this._anisoSamples;
      },
      set: function(b) {
        var C = this._anisoSamples;
        if (this._anisoSamples = Math.max(b, 1) | 0, C !== this._anisoSamples) {
          var w = this.gl.getExtension("EXT_texture_filter_anisotropic");
          w && this.gl.texParameterf(this.gl.TEXTURE_2D, w.TEXTURE_MAX_ANISOTROPY_EXT, this._anisoSamples);
        }
        return this._anisoSamples;
      }
    },
    wrapS: {
      get: function() {
        return this._wrapS;
      },
      set: function(b) {
        if (this.bind(), s.indexOf(b) < 0)
          throw new Error("gl-texture2d: Unknown wrap mode " + b);
        return this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, b), this._wrapS = b;
      }
    },
    wrapT: {
      get: function() {
        return this._wrapT;
      },
      set: function(b) {
        if (this.bind(), s.indexOf(b) < 0)
          throw new Error("gl-texture2d: Unknown wrap mode " + b);
        return this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, b), this._wrapT = b;
      }
    },
    wrap: {
      get: function() {
        return this._wrapVector;
      },
      set: function(b) {
        if (Array.isArray(b) || (b = [b, b]), b.length !== 2)
          throw new Error("gl-texture2d: Must specify wrap mode for rows and columns");
        for (var C = 0; C < 2; ++C)
          if (s.indexOf(b[C]) < 0)
            throw new Error("gl-texture2d: Unknown wrap mode " + b);
        this._wrapS = b[0], this._wrapT = b[1];
        var w = this.gl;
        return this.bind(), w.texParameteri(w.TEXTURE_2D, w.TEXTURE_WRAP_S, this._wrapS), w.texParameteri(w.TEXTURE_2D, w.TEXTURE_WRAP_T, this._wrapT), b;
      }
    },
    shape: {
      get: function() {
        return this._shapeVector;
      },
      set: function(b) {
        if (!Array.isArray(b))
          b = [b | 0, b | 0];
        else if (b.length !== 2)
          throw new Error("gl-texture2d: Invalid texture shape");
        return d(this, b[0] | 0, b[1] | 0), [b[0] | 0, b[1] | 0];
      }
    },
    width: {
      get: function() {
        return this._shape[0];
      },
      set: function(b) {
        return b = b | 0, d(this, b, this._shape[1]), b;
      }
    },
    height: {
      get: function() {
        return this._shape[1];
      },
      set: function(b) {
        return b = b | 0, d(this, this._shape[0], b), b;
      }
    }
  }), p.bind = function(b) {
    var C = this.gl;
    return b !== void 0 && C.activeTexture(C.TEXTURE0 + (b | 0)), C.bindTexture(C.TEXTURE_2D, this.handle), b !== void 0 ? b | 0 : C.getParameter(C.ACTIVE_TEXTURE) - C.TEXTURE0;
  }, p.dispose = function() {
    this.gl.deleteTexture(this.handle);
  }, p.generateMipmap = function() {
    this.bind(), this.gl.generateMipmap(this.gl.TEXTURE_2D);
    for (var b = Math.min(this._shape[0], this._shape[1]), C = 0; b > 0; ++C, b >>>= 1)
      this._mipLevels.indexOf(C) < 0 && this._mipLevels.push(C);
  }, p.setPixels = function(b, C, w, A) {
    var S = this.gl;
    this.bind(), Array.isArray(C) ? (A = w, w = C[1] | 0, C = C[0] | 0) : (C = C || 0, w = w || 0), A = A || 0;
    var F = l(b) ? b : b.raw;
    if (F) {
      var M = this._mipLevels.indexOf(A) < 0;
      M ? (S.texImage2D(S.TEXTURE_2D, 0, this.format, this.format, this.type, F), this._mipLevels.push(A)) : S.texSubImage2D(S.TEXTURE_2D, A, C, w, this.format, this.type, F);
    } else if (b.shape && b.stride && b.data) {
      if (b.shape.length < 2 || C + b.shape[1] > this._shape[1] >>> A || w + b.shape[0] > this._shape[0] >>> A || C < 0 || w < 0)
        throw new Error("gl-texture2d: Texture dimensions are out of bounds");
      y(S, C, w, A, this.format, this.type, this._mipLevels, b);
    } else
      throw new Error("gl-texture2d: Unsupported data type");
  };
  function m(b, C) {
    return b.length === 3 ? C[2] === 1 && C[1] === b[0] * b[2] && C[0] === b[2] : C[0] === 1 && C[1] === b[0];
  }
  function y(b, C, w, A, S, F, M, U) {
    var B = U.dtype, q = U.shape.slice();
    if (q.length < 2 || q.length > 3)
      throw new Error("gl-texture2d: Invalid ndarray, must be 2d or 3d");
    var z = 0, D = 0, X = m(q, U.stride.slice());
    if (B === "float32" ? z = b.FLOAT : B === "float64" ? (z = b.FLOAT, X = false, B = "float32") : B === "uint8" ? z = b.UNSIGNED_BYTE : (z = b.UNSIGNED_BYTE, X = false, B = "uint8"), q.length === 2)
      D = b.LUMINANCE, q = [q[0], q[1], 1], U = i2(U.data, q, [U.stride[0], U.stride[1], 1], U.offset);
    else if (q.length === 3) {
      if (q[2] === 1)
        D = b.ALPHA;
      else if (q[2] === 2)
        D = b.LUMINANCE_ALPHA;
      else if (q[2] === 3)
        D = b.RGB;
      else if (q[2] === 4)
        D = b.RGBA;
      else
        throw new Error("gl-texture2d: Invalid shape for pixel coords");
      q[2];
    } else
      throw new Error("gl-texture2d: Invalid shape for texture");
    if ((D === b.LUMINANCE || D === b.ALPHA) && (S === b.LUMINANCE || S === b.ALPHA) && (D = S), D !== S)
      throw new Error("gl-texture2d: Incompatible texture format for setPixels");
    var k = U.size, I = M.indexOf(A) < 0;
    if (I && M.push(A), z === F && X)
      U.offset === 0 && U.data.length === k ? I ? b.texImage2D(b.TEXTURE_2D, A, S, q[0], q[1], 0, S, F, U.data) : b.texSubImage2D(b.TEXTURE_2D, A, C, w, q[0], q[1], S, F, U.data) : I ? b.texImage2D(b.TEXTURE_2D, A, S, q[0], q[1], 0, S, F, U.data.subarray(U.offset, U.offset + k)) : b.texSubImage2D(b.TEXTURE_2D, A, C, w, q[0], q[1], S, F, U.data.subarray(U.offset, U.offset + k));
    else {
      var P;
      F === b.FLOAT ? P = t.mallocFloat32(k) : P = t.mallocUint8(k);
      var G = i2(P, q, [q[2], q[2] * q[0], 1]);
      z === b.FLOAT && F === b.UNSIGNED_BYTE ? c(G, U) : e.assign(G, U), I ? b.texImage2D(b.TEXTURE_2D, A, S, q[0], q[1], 0, S, F, P.subarray(0, k)) : b.texSubImage2D(b.TEXTURE_2D, A, C, w, q[0], q[1], S, F, P.subarray(0, k)), F === b.FLOAT ? t.freeFloat32(P) : t.freeUint8(P);
    }
  }
  function x(b) {
    var C = b.createTexture();
    return b.bindTexture(b.TEXTURE_2D, C), b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MIN_FILTER, b.NEAREST), b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MAG_FILTER, b.NEAREST), b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_S, b.CLAMP_TO_EDGE), b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_T, b.CLAMP_TO_EDGE), C;
  }
  function g(b, C, w, A, S) {
    var F = b.getParameter(b.MAX_TEXTURE_SIZE);
    if (C < 0 || C > F || w < 0 || w > F)
      throw new Error("gl-texture2d: Invalid texture shape");
    if (S === b.FLOAT && !b.getExtension("OES_texture_float"))
      throw new Error("gl-texture2d: Floating point textures not supported on this platform");
    var M = x(b);
    return b.texImage2D(b.TEXTURE_2D, 0, A, C, w, 0, A, S, null), new f(b, M, C, w, A, S);
  }
  function _(b, C, w, A, S, F) {
    var M = x(b);
    return b.texImage2D(b.TEXTURE_2D, 0, S, S, F, C), new f(b, M, w, A, S, F);
  }
  function T(b, C) {
    var w = C.dtype, A = C.shape.slice(), S = b.getParameter(b.MAX_TEXTURE_SIZE);
    if (A[0] < 0 || A[0] > S || A[1] < 0 || A[1] > S)
      throw new Error("gl-texture2d: Invalid texture size");
    var F = m(A, C.stride.slice()), M = 0;
    w === "float32" ? M = b.FLOAT : w === "float64" ? (M = b.FLOAT, F = false, w = "float32") : w === "uint8" ? M = b.UNSIGNED_BYTE : (M = b.UNSIGNED_BYTE, F = false, w = "uint8");
    var U = 0;
    if (A.length === 2)
      U = b.LUMINANCE, A = [A[0], A[1], 1], C = i2(C.data, A, [C.stride[0], C.stride[1], 1], C.offset);
    else if (A.length === 3)
      if (A[2] === 1)
        U = b.ALPHA;
      else if (A[2] === 2)
        U = b.LUMINANCE_ALPHA;
      else if (A[2] === 3)
        U = b.RGB;
      else if (A[2] === 4)
        U = b.RGBA;
      else
        throw new Error("gl-texture2d: Invalid shape for pixel coords");
    else
      throw new Error("gl-texture2d: Invalid shape for texture");
    M === b.FLOAT && !b.getExtension("OES_texture_float") && (M = b.UNSIGNED_BYTE, F = false);
    var B, q, z = C.size;
    if (F)
      C.offset === 0 && C.data.length === z ? B = C.data : B = C.data.subarray(C.offset, C.offset + z);
    else {
      var D = [A[2], A[2] * A[0], 1];
      q = t.malloc(z, w);
      var X = i2(q, A, D, 0);
      (w === "float32" || w === "float64") && M === b.UNSIGNED_BYTE ? c(X, C) : e.assign(X, C), B = q.subarray(0, z);
    }
    var k = x(b);
    return b.texImage2D(b.TEXTURE_2D, 0, U, A[0], A[1], 0, U, M, B), F || t.free(q), new f(b, k, A[0], A[1], U, M);
  }
  function E(b) {
    if (arguments.length <= 1)
      throw new Error("gl-texture2d: Missing arguments for texture2d constructor");
    if (r || u(b), typeof arguments[1] == "number")
      return g(b, arguments[1], arguments[2], arguments[3] || b.RGBA, arguments[4] || b.UNSIGNED_BYTE);
    if (Array.isArray(arguments[1]))
      return g(b, arguments[1][0] | 0, arguments[1][1] | 0, arguments[2] || b.RGBA, arguments[3] || b.UNSIGNED_BYTE);
    if (typeof arguments[1] == "object") {
      var C = arguments[1], w = l(C) ? C : C.raw;
      if (w)
        return _(b, w, C.width | 0, C.height | 0, arguments[2] || b.RGBA, arguments[3] || b.UNSIGNED_BYTE);
      if (C.shape && C.data && C.stride)
        return T(b, C);
    }
    throw new Error("gl-texture2d: Invalid arguments for texture2d constructor");
  }
  return texture;
}
var _baseRandom, hasRequired_baseRandom;
function require_baseRandom() {
  if (hasRequired_baseRandom) return _baseRandom;
  hasRequired_baseRandom = 1;
  var i2 = Math.floor, e = Math.random;
  function t(r, a) {
    return r + i2(e() * (a - r + 1));
  }
  return _baseRandom = t, _baseRandom;
}
var _arraySample, hasRequired_arraySample;
function require_arraySample() {
  if (hasRequired_arraySample) return _arraySample;
  hasRequired_arraySample = 1;
  var i2 = require_baseRandom();
  function e(t) {
    var r = t.length;
    return r ? t[i2(0, r - 1)] : void 0;
  }
  return _arraySample = e, _arraySample;
}
var _arrayMap, hasRequired_arrayMap;
function require_arrayMap() {
  if (hasRequired_arrayMap) return _arrayMap;
  hasRequired_arrayMap = 1;
  function i2(e, t) {
    for (var r = -1, a = e == null ? 0 : e.length, s = Array(a); ++r < a; )
      s[r] = t(e[r], r, e);
    return s;
  }
  return _arrayMap = i2, _arrayMap;
}
var _baseValues, hasRequired_baseValues;
function require_baseValues() {
  if (hasRequired_baseValues) return _baseValues;
  hasRequired_baseValues = 1;
  var i2 = require_arrayMap();
  function e(t, r) {
    return i2(r, function(a) {
      return t[a];
    });
  }
  return _baseValues = e, _baseValues;
}
var values_1, hasRequiredValues;
function requireValues() {
  if (hasRequiredValues) return values_1;
  hasRequiredValues = 1;
  var i2 = require_baseValues(), e = requireKeys();
  function t(r) {
    return r == null ? [] : i2(r, e(r));
  }
  return values_1 = t, values_1;
}
var _baseSample, hasRequired_baseSample;
function require_baseSample() {
  if (hasRequired_baseSample) return _baseSample;
  hasRequired_baseSample = 1;
  var i2 = require_arraySample(), e = requireValues();
  function t(r) {
    return i2(e(r));
  }
  return _baseSample = t, _baseSample;
}
var sample_1, hasRequiredSample;
function requireSample() {
  if (hasRequiredSample) return sample_1;
  hasRequiredSample = 1;
  var i2 = require_arraySample(), e = require_baseSample(), t = requireIsArray();
  function r(a) {
    var s = t(a) ? i2 : e;
    return s(a);
  }
  return sample_1 = r, sample_1;
}
var glTransitions, hasRequiredGlTransitions;
function requireGlTransitions() {
  return hasRequiredGlTransitions || (hasRequiredGlTransitions = 1, glTransitions = [{ name: "Bounce", paramsTypes: { shadow_colour: "vec4", shadow_height: "float", bounces: "float" }, defaultParams: { shadow_colour: [0, 0, 0, 0.6], shadow_height: 0.075, bounces: 3 }, glsl: `// Author: Adrian Purser
// License: MIT

uniform vec4 shadow_colour; // = vec4(0.,0.,0.,.6)
uniform float shadow_height; // = 0.075
uniform float bounces; // = 3.0

const float PI = 3.14159265358;

vec4 transition (vec2 uv) {
  float time = progress;
  float stime = sin(time * PI / 2.);
  float phase = time * PI * bounces;
  float y = (abs(cos(phase))) * (1.0 - stime);
  float d = uv.y - y;
  return mix(
    mix(
      getToColor(uv),
      shadow_colour,
      step(d, shadow_height) * (1. - mix(
        ((d / shadow_height) * shadow_colour.a) + (1.0 - shadow_colour.a),
        1.0,
        smoothstep(0.95, 1., progress) // fade-out the shadow at the end
      ))
    ),
    getFromColor(vec2(uv.x, uv.y + (1.0 - y))),
    step(d, 0.0)
  );
}
`, author: "Adrian Purser", license: "MIT", createdAt: "Fri, 10 Nov 2017 17:01:45 +0000", updatedAt: "Sat, 11 Nov 2017 08:50:40 +0100" }, { name: "BowTieHorizontal", paramsTypes: {}, defaultParams: {}, glsl: `// Author: huynx
// License: MIT

vec2 bottom_left = vec2(0.0, 1.0);
vec2 bottom_right = vec2(1.0, 1.0);
vec2 top_left = vec2(0.0, 0.0);
vec2 top_right = vec2(1.0, 0.0);
vec2 center = vec2(0.5, 0.5);

float check(vec2 p1, vec2 p2, vec2 p3)
{
  return (p1.x - p3.x) * (p2.y - p3.y) - (p2.x - p3.x) * (p1.y - p3.y);
}

bool PointInTriangle (vec2 pt, vec2 p1, vec2 p2, vec2 p3)
{
    bool b1, b2, b3;
    b1 = check(pt, p1, p2) < 0.0;
    b2 = check(pt, p2, p3) < 0.0;
    b3 = check(pt, p3, p1) < 0.0;
    return ((b1 == b2) && (b2 == b3));
}

bool in_left_triangle(vec2 p){
  vec2 vertex1, vertex2, vertex3;
  vertex1 = vec2(progress, 0.5);
  vertex2 = vec2(0.0, 0.5-progress);
  vertex3 = vec2(0.0, 0.5+progress);
  if (PointInTriangle(p, vertex1, vertex2, vertex3))
  {
    return true;
  }
  return false;
}

bool in_right_triangle(vec2 p){
  vec2 vertex1, vertex2, vertex3;
  vertex1 = vec2(1.0-progress, 0.5);
  vertex2 = vec2(1.0, 0.5-progress);
  vertex3 = vec2(1.0, 0.5+progress);
  if (PointInTriangle(p, vertex1, vertex2, vertex3))
  {
    return true;
  }
  return false;
}

float blur_edge(vec2 bot1, vec2 bot2, vec2 top, vec2 testPt)
{
  vec2 lineDir = bot1 - top;
  vec2 perpDir = vec2(lineDir.y, -lineDir.x);
  vec2 dirToPt1 = bot1 - testPt;
  float dist1 = abs(dot(normalize(perpDir), dirToPt1));
  
  lineDir = bot2 - top;
  perpDir = vec2(lineDir.y, -lineDir.x);
  dirToPt1 = bot2 - testPt;
  float min_dist = min(abs(dot(normalize(perpDir), dirToPt1)), dist1);
  
  if (min_dist < 0.005) {
    return min_dist / 0.005;
  }
  else  {
    return 1.0;
  };
}


vec4 transition (vec2 uv) {
  if (in_left_triangle(uv))
  {
    if (progress < 0.1)
    {
      return getFromColor(uv);
    }
    if (uv.x < 0.5)
    {
      vec2 vertex1 = vec2(progress, 0.5);
      vec2 vertex2 = vec2(0.0, 0.5-progress);
      vec2 vertex3 = vec2(0.0, 0.5+progress);
      return mix(
        getFromColor(uv),
        getToColor(uv),
        blur_edge(vertex2, vertex3, vertex1, uv)
      );
    }
    else
    {
      if (progress > 0.0)
      {
        return getToColor(uv);
      }
      else
      {
        return getFromColor(uv);
      }
    }    
  }
  else if (in_right_triangle(uv))
  {
    if (uv.x >= 0.5)
    {
      vec2 vertex1 = vec2(1.0-progress, 0.5);
      vec2 vertex2 = vec2(1.0, 0.5-progress);
      vec2 vertex3 = vec2(1.0, 0.5+progress);
      return mix(
        getFromColor(uv),
        getToColor(uv),
        blur_edge(vertex2, vertex3, vertex1, uv)
      );  
    }
    else
    {
      return getFromColor(uv);
    }
  }
  else {
    return getFromColor(uv);
  }
}`, author: "huynx", license: "MIT", createdAt: "Sat, 24 Mar 2018 12:54:26 +0100", updatedAt: "Sat, 24 Mar 2018 12:54:26 +0100" }, { name: "BowTieVertical", paramsTypes: {}, defaultParams: {}, glsl: `// Author: huynx\r
// License: MIT\r
\r
float check(vec2 p1, vec2 p2, vec2 p3)\r
{\r
  return (p1.x - p3.x) * (p2.y - p3.y) - (p2.x - p3.x) * (p1.y - p3.y);\r
}\r
\r
bool PointInTriangle (vec2 pt, vec2 p1, vec2 p2, vec2 p3)\r
{\r
    bool b1, b2, b3;\r
    b1 = check(pt, p1, p2) < 0.0;\r
    b2 = check(pt, p2, p3) < 0.0;\r
    b3 = check(pt, p3, p1) < 0.0;\r
    return ((b1 == b2) && (b2 == b3));\r
}\r
\r
bool in_top_triangle(vec2 p){\r
  vec2 vertex1, vertex2, vertex3;\r
  vertex1 = vec2(0.5, progress);\r
  vertex2 = vec2(0.5-progress, 0.0);\r
  vertex3 = vec2(0.5+progress, 0.0);\r
  if (PointInTriangle(p, vertex1, vertex2, vertex3))\r
  {\r
    return true;\r
  }\r
  return false;\r
}\r
\r
bool in_bottom_triangle(vec2 p){\r
  vec2 vertex1, vertex2, vertex3;\r
  vertex1 = vec2(0.5, 1.0 - progress);\r
  vertex2 = vec2(0.5-progress, 1.0);\r
  vertex3 = vec2(0.5+progress, 1.0);\r
  if (PointInTriangle(p, vertex1, vertex2, vertex3))\r
  {\r
    return true;\r
  }\r
  return false;\r
}\r
\r
float blur_edge(vec2 bot1, vec2 bot2, vec2 top, vec2 testPt)\r
{\r
  vec2 lineDir = bot1 - top;\r
  vec2 perpDir = vec2(lineDir.y, -lineDir.x);\r
  vec2 dirToPt1 = bot1 - testPt;\r
  float dist1 = abs(dot(normalize(perpDir), dirToPt1));\r
  \r
  lineDir = bot2 - top;\r
  perpDir = vec2(lineDir.y, -lineDir.x);\r
  dirToPt1 = bot2 - testPt;\r
  float min_dist = min(abs(dot(normalize(perpDir), dirToPt1)), dist1);\r
  \r
  if (min_dist < 0.005) {\r
    return min_dist / 0.005;\r
  }\r
  else  {\r
    return 1.0;\r
  };\r
}\r
\r
\r
vec4 transition (vec2 uv) {\r
  if (in_top_triangle(uv))\r
  {\r
    if (progress < 0.1)\r
    {\r
      return getFromColor(uv);\r
    }\r
    if (uv.y < 0.5)\r
    {\r
      vec2 vertex1 = vec2(0.5, progress);\r
      vec2 vertex2 = vec2(0.5-progress, 0.0);\r
      vec2 vertex3 = vec2(0.5+progress, 0.0);\r
      return mix(\r
        getFromColor(uv),\r
        getToColor(uv),\r
        blur_edge(vertex2, vertex3, vertex1, uv)\r
      );\r
    }\r
    else\r
    {\r
      if (progress > 0.0)\r
      {\r
        return getToColor(uv);\r
      }\r
      else\r
      {\r
        return getFromColor(uv);\r
      }\r
    }    \r
  }\r
  else if (in_bottom_triangle(uv))\r
  {\r
    if (uv.y >= 0.5)\r
    {\r
      vec2 vertex1 = vec2(0.5, 1.0-progress);\r
      vec2 vertex2 = vec2(0.5-progress, 1.0);\r
      vec2 vertex3 = vec2(0.5+progress, 1.0);\r
      return mix(\r
        getFromColor(uv),\r
        getToColor(uv),\r
        blur_edge(vertex2, vertex3, vertex1, uv)\r
      );  \r
    }\r
    else\r
    {\r
      return getFromColor(uv);\r
    }\r
  }\r
  else {\r
    return getFromColor(uv);\r
  }\r
}`, author: "huynx", license: "MIT", createdAt: "Tue, 27 Mar 2018 10:07:54 +0700", updatedAt: "Tue, 27 Mar 2018 10:07:54 +0700" }, { name: "ButterflyWaveScrawler", paramsTypes: { amplitude: "float", waves: "float", colorSeparation: "float" }, defaultParams: { amplitude: 1, waves: 30, colorSeparation: 0.3 }, glsl: `// Author: mandubian
// License: MIT
uniform float amplitude; // = 1.0
uniform float waves; // = 30.0
uniform float colorSeparation; // = 0.3
float PI = 3.14159265358979323846264;
float compute(vec2 p, float progress, vec2 center) {
vec2 o = p*sin(progress * amplitude)-center;
// horizontal vector
vec2 h = vec2(1., 0.);
// butterfly polar function (don't ask me why this one :))
float theta = acos(dot(o, h)) * waves;
return (exp(cos(theta)) - 2.*cos(4.*theta) + pow(sin((2.*theta - PI) / 24.), 5.)) / 10.;
}
vec4 transition(vec2 uv) {
  vec2 p = uv.xy / vec2(1.0).xy;
  float inv = 1. - progress;
  vec2 dir = p - vec2(.5);
  float dist = length(dir);
  float disp = compute(p, progress, vec2(0.5, 0.5)) ;
  vec4 texTo = getToColor(p + inv*disp);
  vec4 texFrom = vec4(
  getFromColor(p + progress*disp*(1.0 - colorSeparation)).r,
  getFromColor(p + progress*disp).g,
  getFromColor(p + progress*disp*(1.0 + colorSeparation)).b,
  1.0);
  return texTo*progress + texFrom*inv;
}
`, author: "mandubian", license: "MIT", createdAt: "Thu, 1 Jun 2017 11:47:17 +0200", updatedAt: "Thu, 1 Jun 2017 11:47:17 +0200" }, { name: "CircleCrop", paramsTypes: { bgcolor: "vec4" }, defaultParams: { bgcolor: [0, 0, 0, 1] }, glsl: `// License: MIT
// Author: fkuteken
// ported by gre from https://gist.github.com/fkuteken/f63e3009c1143950dee9063c3b83fb88

uniform vec4 bgcolor; // = vec4(0.0, 0.0, 0.0, 1.0)

vec2 ratio2 = vec2(1.0, 1.0 / ratio);
float s = pow(2.0 * abs(progress - 0.5), 3.0);

vec4 transition(vec2 p) {
  float dist = length((vec2(p) - 0.5) * ratio2);
  return mix(
    progress < 0.5 ? getFromColor(p) : getToColor(p), // branching is ok here as we statically depend on progress uniform (branching won't change over pixels)
    bgcolor,
    step(s, dist)
  );
}
`, license: "MIT", author: "fkuteken", createdAt: "Mon, 12 Jun 2017 12:52:34 +0800", updatedAt: "Mon, 12 Jun 2017 12:52:34 +0800" }, { name: "ColourDistance", paramsTypes: { power: "float" }, defaultParams: { power: 5 }, glsl: `// License: MIT
// Author: P-Seebauer
// ported by gre from https://gist.github.com/P-Seebauer/2a5fa2f77c883dd661f9

uniform float power; // = 5.0

vec4 transition(vec2 p) {
  vec4 fTex = getFromColor(p);
  vec4 tTex = getToColor(p);
  float m = step(distance(fTex, tTex), progress);
  return mix(
    mix(fTex, tTex, m),
    tTex,
    pow(progress, power)
  );
}
`, license: "MIT", author: "P-Seebauer", createdAt: "Mon, 12 Jun 2017 12:57:42 +0800", updatedAt: "Mon, 12 Jun 2017 12:57:42 +0800" }, { name: "CrazyParametricFun", paramsTypes: { a: "float", b: "float", amplitude: "float", smoothness: "float" }, defaultParams: { a: 4, b: 1, amplitude: 120, smoothness: 0.1 }, glsl: `// Author: mandubian
// License: MIT

uniform float a; // = 4
uniform float b; // = 1
uniform float amplitude; // = 120
uniform float smoothness; // = 0.1

vec4 transition(vec2 uv) {
  vec2 p = uv.xy / vec2(1.0).xy;
  vec2 dir = p - vec2(.5);
  float dist = length(dir);
  float x = (a - b) * cos(progress) + b * cos(progress * ((a / b) - 1.) );
  float y = (a - b) * sin(progress) - b * sin(progress * ((a / b) - 1.));
  vec2 offset = dir * vec2(sin(progress  * dist * amplitude * x), sin(progress * dist * amplitude * y)) / smoothness;
  return mix(getFromColor(p + offset), getToColor(p), smoothstep(0.2, 1.0, progress));
}
`, author: "mandubian", license: "MIT", createdAt: "Thu, 1 Jun 2017 13:03:12 +0200", updatedAt: "Thu, 1 Jun 2017 13:03:12 +0200" }, { name: "CrossZoom", paramsTypes: { strength: "float" }, defaultParams: { strength: 0.4 }, glsl: `// License: MIT
// Author: rectalogic
// ported by gre from https://gist.github.com/rectalogic/b86b90161503a0023231

// Converted from https://github.com/rectalogic/rendermix-basic-effects/blob/master/assets/com/rendermix/CrossZoom/CrossZoom.frag
// Which is based on https://github.com/evanw/glfx.js/blob/master/src/filters/blur/zoomblur.js
// With additional easing functions from https://github.com/rectalogic/rendermix-basic-effects/blob/master/assets/com/rendermix/Easing/Easing.glsllib

uniform float strength; // = 0.4

const float PI = 3.141592653589793;

float Linear_ease(in float begin, in float change, in float duration, in float time) {
    return change * time / duration + begin;
}

float Exponential_easeInOut(in float begin, in float change, in float duration, in float time) {
    if (time == 0.0)
        return begin;
    else if (time == duration)
        return begin + change;
    time = time / (duration / 2.0);
    if (time < 1.0)
        return change / 2.0 * pow(2.0, 10.0 * (time - 1.0)) + begin;
    return change / 2.0 * (-pow(2.0, -10.0 * (time - 1.0)) + 2.0) + begin;
}

float Sinusoidal_easeInOut(in float begin, in float change, in float duration, in float time) {
    return -change / 2.0 * (cos(PI * time / duration) - 1.0) + begin;
}

float rand (vec2 co) {
  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

vec3 crossFade(in vec2 uv, in float dissolve) {
    return mix(getFromColor(uv).rgb, getToColor(uv).rgb, dissolve);
}

vec4 transition(vec2 uv) {
    vec2 texCoord = uv.xy / vec2(1.0).xy;

    // Linear interpolate center across center half of the image
    vec2 center = vec2(Linear_ease(0.25, 0.5, 1.0, progress), 0.5);
    float dissolve = Exponential_easeInOut(0.0, 1.0, 1.0, progress);

    // Mirrored sinusoidal loop. 0->strength then strength->0
    float strength = Sinusoidal_easeInOut(0.0, strength, 0.5, progress);

    vec3 color = vec3(0.0);
    float total = 0.0;
    vec2 toCenter = center - texCoord;

    /* randomize the lookup values to hide the fixed number of samples */
    float offset = rand(uv);

    for (float t = 0.0; t <= 40.0; t++) {
        float percent = (t + offset) / 40.0;
        float weight = 4.0 * (percent - percent * percent);
        color += crossFade(texCoord + toCenter * percent * strength, dissolve) * weight;
        total += weight;
    }
    return vec4(color / total, 1.0);
}
`, license: "MIT", author: "rectalogic", createdAt: "Mon, 12 Jun 2017 12:33:07 +0800", updatedAt: "Mon, 12 Jun 2017 12:33:07 +0800" }, { name: "Directional", paramsTypes: { direction: "vec2" }, defaultParams: { direction: [0, 1] }, glsl: `// Author: Gaëtan Renaudeau
// License: MIT

uniform vec2 direction; // = vec2(0.0, 1.0)

vec4 transition (vec2 uv) {
  vec2 p = uv + progress * sign(direction);
  vec2 f = fract(p);
  return mix(
    getToColor(f),
    getFromColor(f),
    step(0.0, p.y) * step(p.y, 1.0) * step(0.0, p.x) * step(p.x, 1.0)
  );
}
`, author: "Gaëtan Renaudeau", license: "MIT", createdAt: "Thu, 19 Apr 2018 12:20:29 +0200", updatedAt: "Thu, 19 Apr 2018 12:20:29 +0200" }, { name: "DoomScreenTransition", paramsTypes: { bars: "int", amplitude: "float", noise: "float", frequency: "float", dripScale: "float" }, defaultParams: { bars: 30, amplitude: 2, noise: 0.1, frequency: 0.5, dripScale: 0.5 }, glsl: `// Author: Zeh Fernando
// License: MIT


// Transition parameters --------

// Number of total bars/columns
uniform int bars; // = 30

// Multiplier for speed ratio. 0 = no variation when going down, higher = some elements go much faster
uniform float amplitude; // = 2

// Further variations in speed. 0 = no noise, 1 = super noisy (ignore frequency)
uniform float noise; // = 0.1

// Speed variation horizontally. the bigger the value, the shorter the waves
uniform float frequency; // = 0.5

// How much the bars seem to "run" from the middle of the screen first (sticking to the sides). 0 = no drip, 1 = curved drip
uniform float dripScale; // = 0.5


// The code proper --------

float rand(int num) {
  return fract(mod(float(num) * 67123.313, 12.0) * sin(float(num) * 10.3) * cos(float(num)));
}

float wave(int num) {
  float fn = float(num) * frequency * 0.1 * float(bars);
  return cos(fn * 0.5) * cos(fn * 0.13) * sin((fn+10.0) * 0.3) / 2.0 + 0.5;
}

float drip(int num) {
  return sin(float(num) / float(bars - 1) * 3.141592) * dripScale;
}

float pos(int num) {
  return (noise == 0.0 ? wave(num) : mix(wave(num), rand(num), noise)) + (dripScale == 0.0 ? 0.0 : drip(num));
}

vec4 transition(vec2 uv) {
  int bar = int(uv.x * (float(bars)));
  float scale = 1.0 + pos(bar) * amplitude;
  float phase = progress * scale;
  float posY = uv.y / vec2(1.0).y;
  vec2 p;
  vec4 c;
  if (phase + posY < 1.0) {
    p = vec2(uv.x, uv.y + mix(0.0, vec2(1.0).y, phase)) / vec2(1.0).xy;
    c = getFromColor(p);
  } else {
    p = uv.xy / vec2(1.0).xy;
    c = getToColor(p);
  }

  // Finally, apply the color
  return c;
}
`, author: "Zeh Fernando", license: "MIT", createdAt: "Tue, 30 May 2017 09:39:09 -0700", updatedAt: "Tue, 30 May 2017 09:39:09 -0700" }, { name: "Dreamy", paramsTypes: {}, defaultParams: {}, glsl: `// Author: mikolalysenko
// License: MIT

vec2 offset(float progress, float x, float theta) {
  float phase = progress*progress + progress + theta;
  float shifty = 0.03*progress*cos(10.0*(progress+x));
  return vec2(0, shifty);
}
vec4 transition(vec2 p) {
  return mix(getFromColor(p + offset(progress, p.x, 0.0)), getToColor(p + offset(1.0-progress, p.x, 3.14)), progress);
}
`, author: "mikolalysenko", license: "MIT", createdAt: "Mon, 12 Jun 2017 12:27:38 +0800", updatedAt: "Mon, 12 Jun 2017 12:27:38 +0800" }, { name: "DreamyZoom", paramsTypes: { rotation: "float", scale: "float" }, defaultParams: { rotation: 6, scale: 1.2 }, glsl: `// Author: Zeh Fernando
// License: MIT

// Definitions --------
#define DEG2RAD 0.03926990816987241548078304229099 // 1/180*PI


// Transition parameters --------

// In degrees
uniform float rotation; // = 6

// Multiplier
uniform float scale; // = 1.2


// The code proper --------

vec4 transition(vec2 uv) {
  // Massage parameters
  float phase = progress < 0.5 ? progress * 2.0 : (progress - 0.5) * 2.0;
  float angleOffset = progress < 0.5 ? mix(0.0, rotation * DEG2RAD, phase) : mix(-rotation * DEG2RAD, 0.0, phase);
  float newScale = progress < 0.5 ? mix(1.0, scale, phase) : mix(scale, 1.0, phase);
  
  vec2 center = vec2(0, 0);

  // Calculate the source point
  vec2 assumedCenter = vec2(0.5, 0.5);
  vec2 p = (uv.xy - vec2(0.5, 0.5)) / newScale * vec2(ratio, 1.0);

  // This can probably be optimized (with distance())
  float angle = atan(p.y, p.x) + angleOffset;
  float dist = distance(center, p);
  p.x = cos(angle) * dist / ratio + 0.5;
  p.y = sin(angle) * dist + 0.5;
  vec4 c = progress < 0.5 ? getFromColor(p) : getToColor(p);

  // Finally, apply the color
  return c + (progress < 0.5 ? mix(0.0, 1.0, phase) : mix(1.0, 0.0, phase));
}
`, author: "Zeh Fernando", license: "MIT", createdAt: "Tue, 30 May 2017 10:44:06 -0700", updatedAt: "Tue, 30 May 2017 10:44:06 -0700" }, { name: "GlitchDisplace", paramsTypes: {}, defaultParams: {}, glsl: `// Author: Matt DesLauriers
// License: MIT

highp float random(vec2 co)
{
    highp float a = 12.9898;
    highp float b = 78.233;
    highp float c = 43758.5453;
    highp float dt= dot(co.xy ,vec2(a,b));
    highp float sn= mod(dt,3.14);
    return fract(sin(sn) * c);
}
float voronoi( in vec2 x ) {
    vec2 p = floor( x );
    vec2 f = fract( x );
    float res = 8.0;
    for( float j=-1.; j<=1.; j++ )
    for( float i=-1.; i<=1.; i++ ) {
        vec2  b = vec2( i, j );
        vec2  r = b - f + random( p + b );
        float d = dot( r, r );
        res = min( res, d );
    }
    return sqrt( res );
}

vec2 displace(vec4 tex, vec2 texCoord, float dotDepth, float textureDepth, float strength) {
    float b = voronoi(.003 * texCoord + 2.0);
    float g = voronoi(0.2 * texCoord);
    float r = voronoi(texCoord - 1.0);
    vec4 dt = tex * 1.0;
    vec4 dis = dt * dotDepth + 1.0 - tex * textureDepth;

    dis.x = dis.x - 1.0 + textureDepth*dotDepth;
    dis.y = dis.y - 1.0 + textureDepth*dotDepth;
    dis.x *= strength;
    dis.y *= strength;
    vec2 res_uv = texCoord ;
    res_uv.x = res_uv.x + dis.x - 0.0;
    res_uv.y = res_uv.y + dis.y;
    return res_uv;
}

float ease1(float t) {
  return t == 0.0 || t == 1.0
    ? t
    : t < 0.5
      ? +0.5 * pow(2.0, (20.0 * t) - 10.0)
      : -0.5 * pow(2.0, 10.0 - (t * 20.0)) + 1.0;
}
float ease2(float t) {
  return t == 1.0 ? t : 1.0 - pow(2.0, -10.0 * t);
}



vec4 transition(vec2 uv) {
  vec2 p = uv.xy / vec2(1.0).xy;
  vec4 color1 = getFromColor(p);
  vec4 color2 = getToColor(p);
  vec2 disp = displace(color1, p, 0.33, 0.7, 1.0-ease1(progress));
  vec2 disp2 = displace(color2, p, 0.33, 0.5, ease2(progress));
  vec4 dColor1 = getToColor(disp);
  vec4 dColor2 = getFromColor(disp2);
  float val = ease1(progress);
  vec3 gray = vec3(dot(min(dColor2, dColor1).rgb, vec3(0.299, 0.587, 0.114)));
  dColor2 = vec4(gray, 1.0);
  dColor2 *= 2.0;
  color1 = mix(color1, dColor2, smoothstep(0.0, 0.5, progress));
  color2 = mix(color2, dColor1, smoothstep(1.0, 0.5, progress));
  return mix(color1, color2, val);
  //gl_FragColor = mix(gl_FragColor, dColor, smoothstep(0.0, 0.5, progress));
  
   //gl_FragColor = mix(texture2D(from, p), texture2D(to, p), progress);
}
`, author: "Matt DesLauriers", license: "MIT", createdAt: "Tue, 30 May 2017 14:53:04 -0400", updatedAt: "Tue, 30 May 2017 14:53:04 -0400" }, { name: "GlitchMemories", paramsTypes: {}, defaultParams: {}, glsl: `// author: Gunnar Roth
// based on work from natewave
// license: MIT
vec4 transition(vec2 p) {
  vec2 block = floor(p.xy / vec2(16));
  vec2 uv_noise = block / vec2(64);
  uv_noise += floor(vec2(progress) * vec2(1200.0, 3500.0)) / vec2(64);
  vec2 dist = progress > 0.0 ? (fract(uv_noise) - 0.5) * 0.3 *(1.0 -progress) : vec2(0.0);
  vec2 red = p + dist * 0.2;
  vec2 green = p + dist * .3;
  vec2 blue = p + dist * .5;

  return vec4(mix(getFromColor(red), getToColor(red), progress).r,mix(getFromColor(green), getToColor(green), progress).g,mix(getFromColor(blue), getToColor(blue), progress).b,1.0);
}

`, author: "Gunnar Roth", license: "MIT", createdAt: "Wed, 21 Feb 2018 00:52:15 +0100", updatedAt: "Wed, 21 Feb 2018 19:32:02 +0100" }, { name: "GridFlip", paramsTypes: { size: "ivec2", pause: "float", dividerWidth: "float", bgcolor: "vec4", randomness: "float" }, defaultParams: { size: [4, 4], pause: 0.1, dividerWidth: 0.05, bgcolor: [0, 0, 0, 1], randomness: 0.1 }, glsl: `// License: MIT
// Author: TimDonselaar
// ported by gre from https://gist.github.com/TimDonselaar/9bcd1c4b5934ba60087bdb55c2ea92e5

uniform ivec2 size; // = ivec2(4)
uniform float pause; // = 0.1
uniform float dividerWidth; // = 0.05
uniform vec4 bgcolor; // = vec4(0.0, 0.0, 0.0, 1.0)
uniform float randomness; // = 0.1
 
float rand (vec2 co) {
  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

float getDelta(vec2 p) {
  vec2 rectanglePos = floor(vec2(size) * p);
  vec2 rectangleSize = vec2(1.0 / vec2(size).x, 1.0 / vec2(size).y);
  float top = rectangleSize.y * (rectanglePos.y + 1.0);
  float bottom = rectangleSize.y * rectanglePos.y;
  float left = rectangleSize.x * rectanglePos.x;
  float right = rectangleSize.x * (rectanglePos.x + 1.0);
  float minX = min(abs(p.x - left), abs(p.x - right));
  float minY = min(abs(p.y - top), abs(p.y - bottom));
  return min(minX, minY);
}

float getDividerSize() {
  vec2 rectangleSize = vec2(1.0 / vec2(size).x, 1.0 / vec2(size).y);
  return min(rectangleSize.x, rectangleSize.y) * dividerWidth;
}

vec4 transition(vec2 p) {
  if(progress < pause) {
    float currentProg = progress / pause;
    float a = 1.0;
    if(getDelta(p) < getDividerSize()) {
      a = 1.0 - currentProg;
    }
    return mix(bgcolor, getFromColor(p), a);
  }
  else if(progress < 1.0 - pause){
    if(getDelta(p) < getDividerSize()) {
      return bgcolor;
    } else {
      float currentProg = (progress - pause) / (1.0 - pause * 2.0);
      vec2 q = p;
      vec2 rectanglePos = floor(vec2(size) * q);
      
      float r = rand(rectanglePos) - randomness;
      float cp = smoothstep(0.0, 1.0 - r, currentProg);
    
      float rectangleSize = 1.0 / vec2(size).x;
      float delta = rectanglePos.x * rectangleSize;
      float offset = rectangleSize / 2.0 + delta;
      
      p.x = (p.x - offset)/abs(cp - 0.5)*0.5 + offset;
      vec4 a = getFromColor(p);
      vec4 b = getToColor(p);
      
      float s = step(abs(vec2(size).x * (q.x - delta) - 0.5), abs(cp - 0.5));
      return mix(bgcolor, mix(b, a, step(cp, 0.5)), s);
    }
  }
  else {
    float currentProg = (progress - 1.0 + pause) / pause;
    float a = 1.0;
    if(getDelta(p) < getDividerSize()) {
      a = currentProg;
    }
    return mix(bgcolor, getToColor(p), a);
  }
}
`, license: "MIT", author: "TimDonselaar", createdAt: "Mon, 12 Jun 2017 11:32:51 +0800", updatedAt: "Mon, 12 Jun 2017 11:32:51 +0800" }, { name: "InvertedPageCurl", paramsTypes: {}, defaultParams: {}, glsl: `// author: Hewlett-Packard
// license: BSD 3 Clause
// Adapted by Sergey Kosarevsky from:
// http://rectalogic.github.io/webvfx/examples_2transition-shader-pagecurl_8html-example.html

/*
Copyright (c) 2010 Hewlett-Packard Development Company, L.P. All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

   * Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
   * Redistributions in binary form must reproduce the above
     copyright notice, this list of conditions and the following disclaimer
     in the documentation and/or other materials provided with the
     distribution.
   * Neither the name of Hewlett-Packard nor the names of its
     contributors may be used to endorse or promote products derived from
     this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
in vec2 texCoord;
*/

const float MIN_AMOUNT = -0.16;
const float MAX_AMOUNT = 1.5;
float amount = progress * (MAX_AMOUNT - MIN_AMOUNT) + MIN_AMOUNT;

const float PI = 3.141592653589793;

const float scale = 512.0;
const float sharpness = 3.0;

float cylinderCenter = amount;
// 360 degrees * amount
float cylinderAngle = 2.0 * PI * amount;

const float cylinderRadius = 1.0 / PI / 2.0;

vec3 hitPoint(float hitAngle, float yc, vec3 point, mat3 rrotation)
{
        float hitPoint = hitAngle / (2.0 * PI);
        point.y = hitPoint;
        return rrotation * point;
}

vec4 antiAlias(vec4 color1, vec4 color2, float distanc)
{
        distanc *= scale;
        if (distanc < 0.0) return color2;
        if (distanc > 2.0) return color1;
        float dd = pow(1.0 - distanc / 2.0, sharpness);
        return ((color2 - color1) * dd) + color1;
}

float distanceToEdge(vec3 point)
{
        float dx = abs(point.x > 0.5 ? 1.0 - point.x : point.x);
        float dy = abs(point.y > 0.5 ? 1.0 - point.y : point.y);
        if (point.x < 0.0) dx = -point.x;
        if (point.x > 1.0) dx = point.x - 1.0;
        if (point.y < 0.0) dy = -point.y;
        if (point.y > 1.0) dy = point.y - 1.0;
        if ((point.x < 0.0 || point.x > 1.0) && (point.y < 0.0 || point.y > 1.0)) return sqrt(dx * dx + dy * dy);
        return min(dx, dy);
}

vec4 seeThrough(float yc, vec2 p, mat3 rotation, mat3 rrotation)
{
        float hitAngle = PI - (acos(yc / cylinderRadius) - cylinderAngle);
        vec3 point = hitPoint(hitAngle, yc, rotation * vec3(p, 1.0), rrotation);
        if (yc <= 0.0 && (point.x < 0.0 || point.y < 0.0 || point.x > 1.0 || point.y > 1.0))
        {
            return getToColor(p);
        }

        if (yc > 0.0) return getFromColor(p);

        vec4 color = getFromColor(point.xy);
        vec4 tcolor = vec4(0.0);

        return antiAlias(color, tcolor, distanceToEdge(point));
}

vec4 seeThroughWithShadow(float yc, vec2 p, vec3 point, mat3 rotation, mat3 rrotation)
{
        float shadow = distanceToEdge(point) * 30.0;
        shadow = (1.0 - shadow) / 3.0;

        if (shadow < 0.0) shadow = 0.0; else shadow *= amount;

        vec4 shadowColor = seeThrough(yc, p, rotation, rrotation);
        shadowColor.r -= shadow;
        shadowColor.g -= shadow;
        shadowColor.b -= shadow;

        return shadowColor;
}

vec4 backside(float yc, vec3 point)
{
        vec4 color = getFromColor(point.xy);
        float gray = (color.r + color.b + color.g) / 15.0;
        gray += (8.0 / 10.0) * (pow(1.0 - abs(yc / cylinderRadius), 2.0 / 10.0) / 2.0 + (5.0 / 10.0));
        color.rgb = vec3(gray);
        return color;
}

vec4 behindSurface(vec2 p, float yc, vec3 point, mat3 rrotation)
{
        float shado = (1.0 - ((-cylinderRadius - yc) / amount * 7.0)) / 6.0;
        shado *= 1.0 - abs(point.x - 0.5);

        yc = (-cylinderRadius - cylinderRadius - yc);

        float hitAngle = (acos(yc / cylinderRadius) + cylinderAngle) - PI;
        point = hitPoint(hitAngle, yc, point, rrotation);

        if (yc < 0.0 && point.x >= 0.0 && point.y >= 0.0 && point.x <= 1.0 && point.y <= 1.0 && (hitAngle < PI || amount > 0.5))
        {
                shado = 1.0 - (sqrt(pow(point.x - 0.5, 2.0) + pow(point.y - 0.5, 2.0)) / (71.0 / 100.0));
                shado *= pow(-yc / cylinderRadius, 3.0);
                shado *= 0.5;
        }
        else
        {
                shado = 0.0;
        }
        return vec4(getToColor(p).rgb - shado, 1.0);
}

vec4 transition(vec2 p) {

  const float angle = 100.0 * PI / 180.0;
        float c = cos(-angle);
        float s = sin(-angle);

        mat3 rotation = mat3( c, s, 0,
                                                                -s, c, 0,
                                                                -0.801, 0.8900, 1
                                                                );
        c = cos(angle);
        s = sin(angle);

        mat3 rrotation = mat3(	c, s, 0,
                                                                        -s, c, 0,
                                                                        0.98500, 0.985, 1
                                                                );

        vec3 point = rotation * vec3(p, 1.0);

        float yc = point.y - cylinderCenter;

        if (yc < -cylinderRadius)
        {
                // Behind surface
                return behindSurface(p,yc, point, rrotation);
        }

        if (yc > cylinderRadius)
        {
                // Flat surface
                return getFromColor(p);
        }

        float hitAngle = (acos(yc / cylinderRadius) + cylinderAngle) - PI;

        float hitAngleMod = mod(hitAngle, 2.0 * PI);
        if ((hitAngleMod > PI && amount < 0.5) || (hitAngleMod > PI/2.0 && amount < 0.0))
        {
                return seeThrough(yc, p, rotation, rrotation);
        }

        point = hitPoint(hitAngle, yc, point, rrotation);

        if (point.x < 0.0 || point.y < 0.0 || point.x > 1.0 || point.y > 1.0)
        {
                return seeThroughWithShadow(yc, p, point, rotation, rrotation);
        }

        vec4 color = backside(yc, point);

        vec4 otherColor;
        if (yc < 0.0)
        {
                float shado = 1.0 - (sqrt(pow(point.x - 0.5, 2.0) + pow(point.y - 0.5, 2.0)) / 0.71);
                shado *= pow(-yc / cylinderRadius, 3.0);
                shado *= 0.5;
                otherColor = vec4(0.0, 0.0, 0.0, shado);
        }
        else
        {
                otherColor = getFromColor(p);
        }

        color = antiAlias(color, otherColor, cylinderRadius - abs(yc));

        vec4 cl = seeThroughWithShadow(yc, p, point, rotation, rrotation);
        float dist = distanceToEdge(point);

        return antiAlias(color, cl, dist);
}
`, author: "Hewlett-Packard", license: "BSD 3 Clause", createdAt: "Wed, 21 Feb 2018 01:13:49 +0100", updatedAt: "Wed, 21 Feb 2018 16:00:02 +0100" }, { name: "LinearBlur", paramsTypes: { intensity: "float" }, defaultParams: { intensity: 0.1 }, glsl: `// author: gre
// license: MIT
uniform float intensity; // = 0.1
const int passes = 6;

vec4 transition(vec2 uv) {
    vec4 c1 = vec4(0.0);
    vec4 c2 = vec4(0.0);

    float disp = intensity*(0.5-distance(0.5, progress));
    for (int xi=0; xi<passes; xi++)
    {
        float x = float(xi) / float(passes) - 0.5;
        for (int yi=0; yi<passes; yi++)
        {
            float y = float(yi) / float(passes) - 0.5;
            vec2 v = vec2(x,y);
            float d = disp;
            c1 += getFromColor( uv + d*v);
            c2 += getToColor( uv + d*v);
        }
    }
    c1 /= float(passes*passes);
    c2 /= float(passes*passes);
    return mix(c1, c2, progress);
}
`, author: "gre", license: "MIT", createdAt: "Fri, 23 Feb 2018 15:18:22 +0100", updatedAt: "Fri, 23 Feb 2018 15:18:22 +0100" }, { name: "Mosaic", paramsTypes: { endx: "int", endy: "int" }, defaultParams: { endx: 2, endy: -1 }, glsl: `// License: MIT
// Author: Xaychru
// ported by gre from https://gist.github.com/Xaychru/130bb7b7affedbda9df5

#define PI 3.14159265358979323
#define POW2(X) X*X
#define POW3(X) X*X*X
uniform int endx; // = 2
uniform int endy; // = -1

float Rand(vec2 v) {
  return fract(sin(dot(v.xy ,vec2(12.9898,78.233))) * 43758.5453);
}
vec2 Rotate(vec2 v, float a) {
  mat2 rm = mat2(cos(a), -sin(a),
                 sin(a), cos(a));
  return rm*v;
}
float CosInterpolation(float x) {
  return -cos(x*PI)/2.+.5;
}
vec4 transition(vec2 uv) {
  vec2 p = uv.xy / vec2(1.0).xy - .5;
  vec2 rp = p;
  float rpr = (progress*2.-1.);
  float z = -(rpr*rpr*2.) + 3.;
  float az = abs(z);
  rp *= az;
  rp += mix(vec2(.5, .5), vec2(float(endx) + .5, float(endy) + .5), POW2(CosInterpolation(progress)));
  vec2 mrp = mod(rp, 1.);
  vec2 crp = rp;
  bool onEnd = int(floor(crp.x))==endx&&int(floor(crp.y))==endy;
  if(!onEnd) {
    float ang = float(int(Rand(floor(crp))*4.))*.5*PI;
    mrp = vec2(.5) + Rotate(mrp-vec2(.5), ang);
  }
  if(onEnd || Rand(floor(crp))>.5) {
    return getToColor(mrp);
  } else {
    return getFromColor(mrp);
  }
}
`, license: "MIT", author: "Xaychru", createdAt: "Mon, 12 Jun 2017 10:26:51 +0800", updatedAt: "Mon, 12 Jun 2017 10:26:51 +0800" }, { name: "PolkaDotsCurtain", paramsTypes: { dots: "float", center: "vec2" }, defaultParams: { dots: 20, center: [0, 0] }, glsl: `// author: bobylito
// license: MIT
const float SQRT_2 = 1.414213562373;
uniform float dots;// = 20.0;
uniform vec2 center;// = vec2(0, 0);

vec4 transition(vec2 uv) {
  bool nextImage = distance(fract(uv * dots), vec2(0.5, 0.5)) < ( progress / distance(uv, center));
  return nextImage ? getToColor(uv) : getFromColor(uv);
}
`, author: "bobylito", license: "MIT", createdAt: "Tue, 20 Feb 2018 23:41:45 +0100", updatedAt: "Tue, 20 Feb 2018 23:41:45 +0100" }, { name: "Radial", paramsTypes: { smoothness: "float" }, defaultParams: { smoothness: 1 }, glsl: `// License: MIT
// Author: Xaychru
// ported by gre from https://gist.github.com/Xaychru/ce1d48f0ce00bb379750

uniform float smoothness; // = 1.0

const float PI = 3.141592653589;

vec4 transition(vec2 p) {
  vec2 rp = p*2.-1.;
  return mix(
    getToColor(p),
    getFromColor(p),
    smoothstep(0., smoothness, atan(rp.y,rp.x) - (progress-.5) * PI * 2.5)
  );
}
`, license: "MIT", author: "Xaychru", createdAt: "Mon, 12 Jun 2017 10:36:24 +0800", updatedAt: "Mon, 12 Jun 2017 10:36:24 +0800" }, { name: "SimpleZoom", paramsTypes: { zoom_quickness: "float" }, defaultParams: { zoom_quickness: 0.8 }, glsl: `// Author: 0gust1
// License: MIT

uniform float zoom_quickness; // = 0.8
float nQuick = clamp(zoom_quickness,0.2,1.0);

vec2 zoom(vec2 uv, float amount) {
  return 0.5 + ((uv - 0.5) * (1.0-amount));	
}

vec4 transition (vec2 uv) {
  return mix(
    getFromColor(zoom(uv, smoothstep(0.0, nQuick, progress))),
    getToColor(uv),
   smoothstep(nQuick-0.2, 1.0, progress)
  );
}`, author: "0gust1", license: "MIT", createdAt: "Tue, 6 Mar 2018 00:43:47 +0100", updatedAt: "Tue, 6 Mar 2018 00:43:47 +0100" }, { name: "StereoViewer", paramsTypes: { zoom: "float", corner_radius: "float" }, defaultParams: { zoom: 0.88, corner_radius: 0.22 }, glsl: `// Tunable parameters
// How much to zoom (out) for the effect ~ 0.5 - 1.0
uniform float zoom; // = 0.88
// Corner radius as a fraction of the image height
uniform float corner_radius;  // = 0.22

// author: Ted Schundler
// license: BSD 2 Clause
// Free for use and modification by anyone with credit

// Copyright (c) 2016, Theodore K Schundler
// All rights reserved.

// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

// 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.

// 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

///////////////////////////////////////////////////////////////////////////////
// Stereo Viewer Toy Transition                                              //
//                                                                           //
// Inspired by ViewMaster / Image3D image viewer devices.                    //
// This effect is similar to what you see when you press the device's lever. //
// There is a quick zoom in / out to make the transition 'valid' for GLSL.io //
///////////////////////////////////////////////////////////////////////////////

const vec4 black = vec4(0.0, 0.0, 0.0, 1.0);
const vec2 c00 = vec2(0.0, 0.0); // the four corner points
const vec2 c01 = vec2(0.0, 1.0);
const vec2 c11 = vec2(1.0, 1.0);
const vec2 c10 = vec2(1.0, 0.0);

// Check if a point is within a given corner
bool in_corner(vec2 p, vec2 corner, vec2 radius) {
  // determine the direction we want to be filled
  vec2 axis = (c11 - corner) - corner;

  // warp the point so we are always testing the bottom left point with the
  // circle centered on the origin
  p = p - (corner + axis * radius);
  p *= axis / radius;
  return (p.x > 0.0 && p.y > -1.0) || (p.y > 0.0 && p.x > -1.0) || dot(p, p) < 1.0;
}

// Check all four corners
// return a float for v2 for anti-aliasing?
bool test_rounded_mask(vec2 p, vec2 corner_size) {
  return
      in_corner(p, c00, corner_size) &&
      in_corner(p, c01, corner_size) &&
      in_corner(p, c10, corner_size) &&
      in_corner(p, c11, corner_size);
}

// Screen blend mode - https://en.wikipedia.org/wiki/Blend_modes
// This more closely approximates what you see than linear blending
vec4 screen(vec4 a, vec4 b) {
  return 1.0 - (1.0 - a) * (1.0 -b);
}

// Given RGBA, find a value that when screened with itself
// will yield the original value.
vec4 unscreen(vec4 c) {
  return 1.0 - sqrt(1.0 - c);
}

// Grab a pixel, only if it isn't masked out by the rounded corners
vec4 sample_with_corners_from(vec2 p, vec2 corner_size) {
  p = (p - 0.5) / zoom + 0.5;
  if (!test_rounded_mask(p, corner_size)) {
    return black;
  }
  return unscreen(getFromColor(p));
}

vec4 sample_with_corners_to(vec2 p, vec2 corner_size) {
  p = (p - 0.5) / zoom + 0.5;
  if (!test_rounded_mask(p, corner_size)) {
    return black;
  }
  return unscreen(getToColor(p));
}

// special sampling used when zooming - extra zoom parameter and don't unscreen
vec4 simple_sample_with_corners_from(vec2 p, vec2 corner_size, float zoom_amt) {
  p = (p - 0.5) / (1.0 - zoom_amt + zoom * zoom_amt) + 0.5;
  if (!test_rounded_mask(p, corner_size)) {
    return black;
  }
  return getFromColor(p);
}

vec4 simple_sample_with_corners_to(vec2 p, vec2 corner_size, float zoom_amt) {
  p = (p - 0.5) / (1.0 - zoom_amt + zoom * zoom_amt) + 0.5;
  if (!test_rounded_mask(p, corner_size)) {
    return black;
  }
  return getToColor(p);
}

// Basic 2D affine transform matrix helpers
// These really shouldn't be used in a fragment shader - I should work out the
// the math for a translate & rotate function as a pair of dot products instead

mat3 rotate2d(float angle, float ratio) {
  float s = sin(angle);
  float c = cos(angle);
  return mat3(
    c, s ,0.0,
    -s, c, 0.0,
    0.0, 0.0, 1.0);
}

mat3 translate2d(float x, float y) {
  return mat3(
    1.0, 0.0, 0,
    0.0, 1.0, 0,
    -x, -y, 1.0);
}

mat3 scale2d(float x, float y) {
  return mat3(
    x, 0.0, 0,
    0.0, y, 0,
    0, 0, 1.0);
}

// Split an image and rotate one up and one down along off screen pivot points
vec4 get_cross_rotated(vec3 p3, float angle, vec2 corner_size, float ratio) {
  angle = angle * angle; // easing
  angle /= 2.4; // works out to be a good number of radians

  mat3 center_and_scale = translate2d(-0.5, -0.5) * scale2d(1.0, ratio);
  mat3 unscale_and_uncenter = scale2d(1.0, 1.0/ratio) * translate2d(0.5,0.5);
  mat3 slide_left = translate2d(-2.0,0.0);
  mat3 slide_right = translate2d(2.0,0.0);
  mat3 rotate = rotate2d(angle, ratio);

  mat3 op_a = center_and_scale * slide_right * rotate * slide_left * unscale_and_uncenter;
  mat3 op_b = center_and_scale * slide_left * rotate * slide_right * unscale_and_uncenter;

  vec4 a = sample_with_corners_from((op_a * p3).xy, corner_size);
  vec4 b = sample_with_corners_from((op_b * p3).xy, corner_size);

  return screen(a, b);
}

// Image stays put, but this time move two masks
vec4 get_cross_masked(vec3 p3, float angle, vec2 corner_size, float ratio) {
  angle = 1.0 - angle;
  angle = angle * angle; // easing
  angle /= 2.4;

  vec4 img;

  mat3 center_and_scale = translate2d(-0.5, -0.5) * scale2d(1.0, ratio);
  mat3 unscale_and_uncenter = scale2d(1.0 / zoom, 1.0 / (zoom * ratio)) * translate2d(0.5,0.5);
  mat3 slide_left = translate2d(-2.0,0.0);
  mat3 slide_right = translate2d(2.0,0.0);
  mat3 rotate = rotate2d(angle, ratio);

  mat3 op_a = center_and_scale * slide_right * rotate * slide_left * unscale_and_uncenter;
  mat3 op_b = center_and_scale * slide_left * rotate * slide_right * unscale_and_uncenter;

  bool mask_a = test_rounded_mask((op_a * p3).xy, corner_size);
  bool mask_b = test_rounded_mask((op_b * p3).xy, corner_size);

  if (mask_a || mask_b) {
    img = sample_with_corners_to(p3.xy, corner_size);
    return screen(mask_a ? img : black, mask_b ? img : black);
  } else {
    return black;
  }
}

vec4 transition(vec2 uv) {
  float a;
  vec2 p=uv.xy/vec2(1.0).xy;
  vec3 p3 = vec3(p.xy, 1.0); // for 2D matrix transforms

  // corner is warped to represent to size after mapping to 1.0, 1.0
  vec2 corner_size = vec2(corner_radius / ratio, corner_radius);

  if (progress <= 0.0) {
    // 0.0: start with the base frame always
    return getFromColor(p);
  } else if (progress < 0.1) {
    // 0.0-0.1: zoom out and add rounded corners
    a = progress / 0.1;
    return  simple_sample_with_corners_from(p, corner_size * a, a);
  } else if (progress < 0.48) {
    // 0.1-0.48: Split original image apart
    a = (progress - 0.1)/0.38;
    return get_cross_rotated(p3, a, corner_size, ratio);
  } else if (progress < 0.9) {
    // 0.48-0.52: black
    // 0.52 - 0.9: unmask new image
    return get_cross_masked(p3, (progress - 0.52)/0.38, corner_size, ratio);
  } else if (progress < 1.0) {
    // zoom out and add rounded corners
    a = (1.0 - progress) / 0.1;
    return simple_sample_with_corners_to(p, corner_size * a, a);
  } else {
    // 1.0 end with base frame
    return getToColor(p);
  }
}
`, author: "Ted Schundler", license: "BSD 2 Clause", createdAt: "Tue, 20 Feb 2018 23:20:29 +0100", updatedAt: "Wed, 21 Feb 2018 15:42:00 +0100" }, { name: "Swirl", paramsTypes: {}, defaultParams: {}, glsl: `// License: MIT
// Author: Sergey Kosarevsky
// ( http://www.linderdaum.com )
// ported by gre from https://gist.github.com/corporateshark/cacfedb8cca0f5ce3f7c

vec4 transition(vec2 UV)
{
	float Radius = 1.0;

	float T = progress;

	UV -= vec2( 0.5, 0.5 );

	float Dist = length(UV);

	if ( Dist < Radius )
	{
		float Percent = (Radius - Dist) / Radius;
		float A = ( T <= 0.5 ) ? mix( 0.0, 1.0, T/0.5 ) : mix( 1.0, 0.0, (T-0.5)/0.5 );
		float Theta = Percent * Percent * A * 8.0 * 3.14159;
		float S = sin( Theta );
		float C = cos( Theta );
		UV = vec2( dot(UV, vec2(C, -S)), dot(UV, vec2(S, C)) );
	}
	UV += vec2( 0.5, 0.5 );

	vec4 C0 = getFromColor(UV);
	vec4 C1 = getToColor(UV);

	return mix( C0, C1, T );
}
`, license: "MIT", author: "Sergey Kosarevsky", createdAt: "Mon, 12 Jun 2017 12:38:27 +0800", updatedAt: "Mon, 12 Jun 2017 12:38:27 +0800" }, { name: "WaterDrop", paramsTypes: { amplitude: "float", speed: "float" }, defaultParams: { amplitude: 30, speed: 30 }, glsl: `// author: Paweł Płóciennik
// license: MIT
uniform float amplitude; // = 30
uniform float speed; // = 30

vec4 transition(vec2 p) {
  vec2 dir = p - vec2(.5);
  float dist = length(dir);

  if (dist > progress) {
    return mix(getFromColor( p), getToColor( p), progress);
  } else {
    vec2 offset = dir * sin(dist * amplitude - progress * speed);
    return mix(getFromColor( p + offset), getToColor( p), progress);
  }
}
`, author: "Paweł Płóciennik", license: "MIT", createdAt: "Wed, 21 Feb 2018 19:37:15 +0100", updatedAt: "Wed, 21 Feb 2018 19:37:15 +0100" }, { name: "ZoomInCircles", paramsTypes: {}, defaultParams: {}, glsl: `// License: MIT
// Author: dycm8009
// ported by gre from https://gist.github.com/dycm8009/948e99b1800e81ad909a

vec2 zoom(vec2 uv, float amount) {
  return 0.5 + ((uv - 0.5) * amount);	
}

vec2 ratio2 = vec2(1.0, 1.0 / ratio);

vec4 transition(vec2 uv) {
  // TODO: some timing are hardcoded but should be one or many parameters
  // TODO: should also be able to configure how much circles
  // TODO: if() branching should be avoided when possible, prefer use of step() & other functions
  vec2 r = 2.0 * ((vec2(uv.xy) - 0.5) * ratio2);
  float pro = progress / 0.8;
  float z = pro * 0.2;
  float t = 0.0;
  if (pro > 1.0) {
    z = 0.2 + (pro - 1.0) * 5.;
    t = clamp((progress - 0.8) / 0.07, 0.0, 1.0);
  }
  if (length(r) < 0.5+z) {
    // uv = zoom(uv, 0.9 - 0.1 * pro);
  }
  else if (length(r) < 0.8+z*1.5) {
    uv = zoom(uv, 1.0 - 0.15 * pro);
    t = t * 0.5;
  }
  else if (length(r) < 1.2+z*2.5) {
    uv = zoom(uv, 1.0 - 0.2 * pro);
    t = t * 0.2;
  }
  else {
    uv = zoom(uv, 1.0 - 0.25 * pro);
  }
  return mix(getFromColor(uv), getToColor(uv), t);
}
`, license: "MIT", author: "dycm8009", createdAt: "Mon, 12 Jun 2017 11:24:34 +0800", updatedAt: "Mon, 12 Jun 2017 11:24:34 +0800" }, { name: "angular", paramsTypes: { startingAngle: "float" }, defaultParams: { startingAngle: 90 }, glsl: `// Author: Fernando Kuteken
// License: MIT

#define PI 3.141592653589

uniform float startingAngle; // = 90;

vec4 transition (vec2 uv) {
  
  float offset = startingAngle * PI / 180.0;
  float angle = atan(uv.y - 0.5, uv.x - 0.5) + offset;
  float normalizedAngle = (angle + PI) / (2.0 * PI);
  
  normalizedAngle = normalizedAngle - floor(normalizedAngle);

  return mix(
    getFromColor(uv),
    getToColor(uv),
    step(normalizedAngle, progress)
    );
}
`, author: "Fernando Kuteken", license: "MIT", createdAt: "Tue, 30 May 2017 14:26:44 +0200", updatedAt: "Tue, 30 May 2017 14:26:44 +0200" }, { name: "burn", paramsTypes: { color: "vec3" }, defaultParams: { color: [0.9, 0.4, 0.2] }, glsl: `// author: gre
// License: MIT
uniform vec3 color /* = vec3(0.9, 0.4, 0.2) */;
vec4 transition (vec2 uv) {
  return mix(
    getFromColor(uv) + vec4(progress*color, 1.0),
    getToColor(uv) + vec4((1.0-progress)*color, 1.0),
    progress
  );
}
`, author: "gre", license: "MIT", createdAt: "Tue, 30 May 2017 14:26:44 +0200", updatedAt: "Tue, 30 May 2017 14:26:44 +0200" }, { name: "cannabisleaf", paramsTypes: {}, defaultParams: {}, glsl: `// Author: @Flexi23
// License: MIT

// inspired by http://www.wolframalpha.com/input/?i=cannabis+curve

vec4 transition (vec2 uv) {
  if(progress == 0.0){
    return getFromColor(uv);
  }
  vec2 leaf_uv = (uv - vec2(0.5))/10./pow(progress,3.5);
	leaf_uv.y += 0.35;
	float r = 0.18;
	float o = atan(leaf_uv.y, leaf_uv.x);
  return mix(getFromColor(uv), getToColor(uv), 1.-step(1. - length(leaf_uv)+r*(1.+sin(o))*(1.+0.9 * cos(8.*o))*(1.+0.1*cos(24.*o))*(0.9+0.05*cos(200.*o)), 1.));
}
`, author: "@Flexi23", license: "MIT", createdAt: "Thu, 1 Jun 2017 15:58:58 +0200", updatedAt: "Thu, 1 Jun 2017 15:58:58 +0200" }, { name: "circle", paramsTypes: { center: "vec2", backColor: "vec3" }, defaultParams: { center: [0.5, 0.5], backColor: [0.1, 0.1, 0.1] }, glsl: `// Author: Fernando Kuteken
// License: MIT

uniform vec2 center; // = vec2(0.5, 0.5);
uniform vec3 backColor; // = vec3(0.1, 0.1, 0.1);

vec4 transition (vec2 uv) {
  
  float distance = length(uv - center);
  float radius = sqrt(8.0) * abs(progress - 0.5);
  
  if (distance > radius) {
    return vec4(backColor, 1.0);
  }
  else {
    if (progress < 0.5) return getFromColor(uv);
    else return getToColor(uv);
  }
}
`, author: "Fernando Kuteken", license: "MIT", createdAt: "Tue, 30 May 2017 14:26:44 +0200", updatedAt: "Tue, 30 May 2017 14:26:44 +0200" }, { name: "circleopen", paramsTypes: { smoothness: "float", opening: "bool" }, defaultParams: { smoothness: 0.3, opening: true }, glsl: `// author: gre
// License: MIT
uniform float smoothness; // = 0.3
uniform bool opening; // = true

const vec2 center = vec2(0.5, 0.5);
const float SQRT_2 = 1.414213562373;

vec4 transition (vec2 uv) {
  float x = opening ? progress : 1.-progress;
  float m = smoothstep(-smoothness, 0.0, SQRT_2*distance(center, uv) - x*(1.+smoothness));
  return mix(getFromColor(uv), getToColor(uv), opening ? 1.-m : m);
}
`, author: "gre", license: "MIT", createdAt: "Tue, 30 May 2017 14:26:44 +0200", updatedAt: "Tue, 30 May 2017 14:26:44 +0200" }, { name: "colorphase", paramsTypes: { fromStep: "vec4", toStep: "vec4" }, defaultParams: { fromStep: [0, 0.2, 0.4, 0], toStep: [0.6, 0.8, 1, 1] }, glsl: `// Author: gre
// License: MIT

// Usage: fromStep and toStep must be in [0.0, 1.0] range 
// and all(fromStep) must be < all(toStep)

uniform vec4 fromStep; // = vec4(0.0, 0.2, 0.4, 0.0)
uniform vec4 toStep; // = vec4(0.6, 0.8, 1.0, 1.0)

vec4 transition (vec2 uv) {
  vec4 a = getFromColor(uv);
  vec4 b = getToColor(uv);
  return mix(a, b, smoothstep(fromStep, toStep, vec4(progress)));
}
`, author: "gre", license: "MIT", createdAt: "Tue, 30 May 2017 14:26:44 +0200", updatedAt: "Tue, 30 May 2017 14:26:44 +0200" }, { name: "crosshatch", paramsTypes: { center: "vec2", threshold: "float", fadeEdge: "float" }, defaultParams: { center: [0.5, 0.5], threshold: 3, fadeEdge: 0.1 }, glsl: `// License: MIT
// Author: pthrasher
// adapted by gre from https://gist.github.com/pthrasher/04fd9a7de4012cbb03f6

uniform vec2 center; // = vec2(0.5)
uniform float threshold; // = 3.0
uniform float fadeEdge; // = 0.1

float rand(vec2 co) {
  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}
vec4 transition(vec2 p) {
  float dist = distance(center, p) / threshold;
  float r = progress - min(rand(vec2(p.y, 0.0)), rand(vec2(0.0, p.x)));
  return mix(getFromColor(p), getToColor(p), mix(0.0, mix(step(dist, r), 1.0, smoothstep(1.0-fadeEdge, 1.0, progress)), smoothstep(0.0, fadeEdge, progress)));    
}
`, license: "MIT", author: "pthrasher", createdAt: "Mon, 12 Jun 2017 10:02:12 +0800", updatedAt: "Mon, 12 Jun 2017 10:02:12 +0800" }, { name: "crosswarp", paramsTypes: {}, defaultParams: {}, glsl: `// Author: Eke Péter <peterekepeter@gmail.com>
// License: MIT
vec4 transition(vec2 p) {
  float x = progress;
  x=smoothstep(.0,1.0,(x*2.0+p.x-1.0));
  return mix(getFromColor((p-.5)*(1.-x)+.5), getToColor((p-.5)*x+.5), x);
}
`, author: "Eke Péter <peterekepeter@gmail.com>", license: "MIT", createdAt: "Tue, 30 May 2017 14:26:44 +0200", updatedAt: "Tue, 30 May 2017 14:26:44 +0200" }, { name: "cube", paramsTypes: { persp: "float", unzoom: "float", reflection: "float", floating: "float" }, defaultParams: { persp: 0.7, unzoom: 0.3, reflection: 0.4, floating: 3 }, glsl: `// Author: gre
// License: MIT
uniform float persp; // = 0.7
uniform float unzoom; // = 0.3
uniform float reflection; // = 0.4
uniform float floating; // = 3.0

vec2 project (vec2 p) {
  return p * vec2(1.0, -1.2) + vec2(0.0, -floating/100.);
}

bool inBounds (vec2 p) {
  return all(lessThan(vec2(0.0), p)) && all(lessThan(p, vec2(1.0)));
}

vec4 bgColor (vec2 p, vec2 pfr, vec2 pto) {
  vec4 c = vec4(0.0, 0.0, 0.0, 1.0);
  pfr = project(pfr);
  // FIXME avoid branching might help perf!
  if (inBounds(pfr)) {
    c += mix(vec4(0.0), getFromColor(pfr), reflection * mix(1.0, 0.0, pfr.y));
  }
  pto = project(pto);
  if (inBounds(pto)) {
    c += mix(vec4(0.0), getToColor(pto), reflection * mix(1.0, 0.0, pto.y));
  }
  return c;
}

// p : the position
// persp : the perspective in [ 0, 1 ]
// center : the xcenter in [0, 1] \\ 0.5 excluded
vec2 xskew (vec2 p, float persp, float center) {
  float x = mix(p.x, 1.0-p.x, center);
  return (
    (
      vec2( x, (p.y - 0.5*(1.0-persp) * x) / (1.0+(persp-1.0)*x) )
      - vec2(0.5-distance(center, 0.5), 0.0)
    )
    * vec2(0.5 / distance(center, 0.5) * (center<0.5 ? 1.0 : -1.0), 1.0)
    + vec2(center<0.5 ? 0.0 : 1.0, 0.0)
  );
}

vec4 transition(vec2 op) {
  float uz = unzoom * 2.0*(0.5-distance(0.5, progress));
  vec2 p = -uz*0.5+(1.0+uz) * op;
  vec2 fromP = xskew(
    (p - vec2(progress, 0.0)) / vec2(1.0-progress, 1.0),
    1.0-mix(progress, 0.0, persp),
    0.0
  );
  vec2 toP = xskew(
    p / vec2(progress, 1.0),
    mix(pow(progress, 2.0), 1.0, persp),
    1.0
  );
  // FIXME avoid branching might help perf!
  if (inBounds(fromP)) {
    return getFromColor(fromP);
  }
  else if (inBounds(toP)) {
    return getToColor(toP);
  }
  return bgColor(op, fromP, toP);
}
`, author: "gre", license: "MIT", createdAt: "Tue, 30 May 2017 14:26:44 +0200", updatedAt: "Tue, 30 May 2017 14:26:44 +0200" }, { name: "directionalwarp", paramsTypes: { direction: "vec2" }, defaultParams: { direction: [-1, 1] }, glsl: `// Author: pschroen
// License: MIT

uniform vec2 direction; // = vec2(-1.0, 1.0)

const float smoothness = 0.5;
const vec2 center = vec2(0.5, 0.5);

vec4 transition (vec2 uv) {
  vec2 v = normalize(direction);
  v /= abs(v.x) + abs(v.y);
  float d = v.x * center.x + v.y * center.y;
  float m = 1.0 - smoothstep(-smoothness, 0.0, v.x * uv.x + v.y * uv.y - (d - 0.5 + progress * (1.0 + smoothness)));
  return mix(getFromColor((uv - 0.5) * (1.0 - m) + 0.5), getToColor((uv - 0.5) * m + 0.5), m);
}
`, author: "pschroen", license: "MIT", createdAt: "Wed, 13 Dec 2017 12:08:49 -0500", updatedAt: "Wed, 13 Dec 2017 12:08:49 -0500" }, { name: "directionalwipe", paramsTypes: { direction: "vec2", smoothness: "float" }, defaultParams: { direction: [1, -1], smoothness: 0.5 }, glsl: `// Author: gre
// License: MIT

uniform vec2 direction; // = vec2(1.0, -1.0)
uniform float smoothness; // = 0.5
 
const vec2 center = vec2(0.5, 0.5);
 
vec4 transition (vec2 uv) {
  vec2 v = normalize(direction);
  v /= abs(v.x)+abs(v.y);
  float d = v.x * center.x + v.y * center.y;
  float m =
    (1.0-step(progress, 0.0)) * // there is something wrong with our formula that makes m not equals 0.0 with progress is 0.0
    (1.0 - smoothstep(-smoothness, 0.0, v.x * uv.x + v.y * uv.y - (d-0.5+progress*(1.+smoothness))));
  return mix(getFromColor(uv), getToColor(uv), m);
}
`, author: "gre", license: "MIT", createdAt: "Tue, 30 May 2017 14:26:44 +0200", updatedAt: "Tue, 30 May 2017 14:26:44 +0200" }, { name: "displacement", paramsTypes: { displacementMap: "sampler2D", strength: "float" }, defaultParams: { displacementMap: null, strength: 0.5 }, glsl: `// Author: Travis Fischer
// License: MIT
//
// Adapted from a Codrops article by Robin Delaporte
// https://tympanus.net/Development/DistortionHoverEffect

uniform sampler2D displacementMap;

uniform float strength; // = 0.5

vec4 transition (vec2 uv) {
  float displacement = texture2D(displacementMap, uv).r * strength;

  vec2 uvFrom = vec2(uv.x + progress * displacement, uv.y);
  vec2 uvTo = vec2(uv.x - (1.0 - progress) * displacement, uv.y);

  return mix(
    getFromColor(uvFrom),
    getToColor(uvTo),
    progress
  );
}
`, author: "Travis Fischer", license: "MIT", createdAt: "Tue, 10 Apr 2018 23:03:38 -0400", updatedAt: "Tue, 10 Apr 2018 23:03:38 -0400" }, { name: "doorway", paramsTypes: { reflection: "float", perspective: "float", depth: "float" }, defaultParams: { reflection: 0.4, perspective: 0.4, depth: 3 }, glsl: `// author: gre
// License: MIT 
uniform float reflection; // = 0.4
uniform float perspective; // = 0.4
uniform float depth; // = 3

const vec4 black = vec4(0.0, 0.0, 0.0, 1.0);
const vec2 boundMin = vec2(0.0, 0.0);
const vec2 boundMax = vec2(1.0, 1.0);

bool inBounds (vec2 p) {
  return all(lessThan(boundMin, p)) && all(lessThan(p, boundMax));
}

vec2 project (vec2 p) {
  return p * vec2(1.0, -1.2) + vec2(0.0, -0.02);
}

vec4 bgColor (vec2 p, vec2 pto) {
  vec4 c = black;
  pto = project(pto);
  if (inBounds(pto)) {
    c += mix(black, getToColor(pto), reflection * mix(1.0, 0.0, pto.y));
  }
  return c;
}


vec4 transition (vec2 p) {
  vec2 pfr = vec2(-1.), pto = vec2(-1.);
  float middleSlit = 2.0 * abs(p.x-0.5) - progress;
  if (middleSlit > 0.0) {
    pfr = p + (p.x > 0.5 ? -1.0 : 1.0) * vec2(0.5*progress, 0.0);
    float d = 1.0/(1.0+perspective*progress*(1.0-middleSlit));
    pfr.y -= d/2.;
    pfr.y *= d;
    pfr.y += d/2.;
  }
  float size = mix(1.0, depth, 1.-progress);
  pto = (p + vec2(-0.5, -0.5)) * vec2(size, size) + vec2(0.5, 0.5);
  if (inBounds(pfr)) {
    return getFromColor(pfr);
  }
  else if (inBounds(pto)) {
    return getToColor(pto);
  }
  else {
    return bgColor(p, pto);
  }
}
`, author: "gre", license: "MIT", createdAt: "Tue, 30 May 2017 14:26:44 +0200", updatedAt: "Tue, 30 May 2017 14:26:44 +0200" }, { name: "fade", paramsTypes: {}, defaultParams: {}, glsl: `// author: gre
// license: MIT

vec4 transition (vec2 uv) {
  return mix(
    getFromColor(uv),
    getToColor(uv),
    progress
  );
}
`, author: "gre", license: "MIT", createdAt: "Tue, 30 May 2017 14:26:44 +0200", updatedAt: "Tue, 30 May 2017 14:26:44 +0200" }, { name: "fadecolor", paramsTypes: { color: "vec3", colorPhase: "float" }, defaultParams: { color: [0, 0, 0], colorPhase: 0.4 }, glsl: `// author: gre
// License: MIT
uniform vec3 color;// = vec3(0.0)
uniform float colorPhase/* = 0.4 */; // if 0.0, there is no black phase, if 0.9, the black phase is very important
vec4 transition (vec2 uv) {
  return mix(
    mix(vec4(color, 1.0), getFromColor(uv), smoothstep(1.0-colorPhase, 0.0, progress)),
    mix(vec4(color, 1.0), getToColor(uv), smoothstep(    colorPhase, 1.0, progress)),
    progress);
}
`, author: "gre", license: "MIT", createdAt: "Tue, 30 May 2017 14:26:44 +0200", updatedAt: "Tue, 30 May 2017 14:26:44 +0200" }, { name: "fadegrayscale", paramsTypes: { intensity: "float" }, defaultParams: { intensity: 0.3 }, glsl: `// Author: gre
// License: MIT

uniform float intensity; // = 0.3; // if 0.0, the image directly turn grayscale, if 0.9, the grayscale transition phase is very important
 
vec3 grayscale (vec3 color) {
  return vec3(0.2126*color.r + 0.7152*color.g + 0.0722*color.b);
}
 
vec4 transition (vec2 uv) {
  vec4 fc = getFromColor(uv);
  vec4 tc = getToColor(uv);
  return mix(
    mix(vec4(grayscale(fc.rgb), 1.0), fc, smoothstep(1.0-intensity, 0.0, progress)),
    mix(vec4(grayscale(tc.rgb), 1.0), tc, smoothstep(    intensity, 1.0, progress)),
    progress);
}
`, author: "gre", license: "MIT", createdAt: "Tue, 30 May 2017 14:26:44 +0200", updatedAt: "Tue, 30 May 2017 14:26:44 +0200" }, { name: "flyeye", paramsTypes: { size: "float", zoom: "float", colorSeparation: "float" }, defaultParams: { size: 0.04, zoom: 50, colorSeparation: 0.3 }, glsl: `// Author: gre
// License: MIT
uniform float size; // = 0.04
uniform float zoom; // = 50.0
uniform float colorSeparation; // = 0.3

vec4 transition(vec2 p) {
  float inv = 1. - progress;
  vec2 disp = size*vec2(cos(zoom*p.x), sin(zoom*p.y));
  vec4 texTo = getToColor(p + inv*disp);
  vec4 texFrom = vec4(
    getFromColor(p + progress*disp*(1.0 - colorSeparation)).r,
    getFromColor(p + progress*disp).g,
    getFromColor(p + progress*disp*(1.0 + colorSeparation)).b,
    1.0);
  return texTo*progress + texFrom*inv;
}
`, author: "gre", license: "MIT", createdAt: "Tue, 30 May 2017 14:26:44 +0200", updatedAt: "Tue, 30 May 2017 14:26:44 +0200" }, { name: "heart", paramsTypes: {}, defaultParams: {}, glsl: `// Author: gre
// License: MIT

float inHeart (vec2 p, vec2 center, float size) {
  if (size==0.0) return 0.0;
  vec2 o = (p-center)/(1.6*size);
  float a = o.x*o.x+o.y*o.y-0.3;
  return step(a*a*a, o.x*o.x*o.y*o.y*o.y);
}
vec4 transition (vec2 uv) {
  return mix(
    getFromColor(uv),
    getToColor(uv),
    inHeart(uv, vec2(0.5, 0.4), progress)
  );
}
`, author: "gre", license: "MIT", createdAt: "Tue, 30 May 2017 14:26:44 +0200", updatedAt: "Tue, 30 May 2017 14:26:44 +0200" }, { name: "hexagonalize", paramsTypes: { steps: "int", horizontalHexagons: "float" }, defaultParams: { steps: 50, horizontalHexagons: 20 }, glsl: `// Author: Fernando Kuteken
// License: MIT
// Hexagonal math from: http://www.redblobgames.com/grids/hexagons/

uniform int steps; // = 50;
uniform float horizontalHexagons; //= 20;

struct Hexagon {
  float q;
  float r;
  float s;
};

Hexagon createHexagon(float q, float r){
  Hexagon hex;
  hex.q = q;
  hex.r = r;
  hex.s = -q - r;
  return hex;
}

Hexagon roundHexagon(Hexagon hex){
  
  float q = floor(hex.q + 0.5);
  float r = floor(hex.r + 0.5);
  float s = floor(hex.s + 0.5);

  float deltaQ = abs(q - hex.q);
  float deltaR = abs(r - hex.r);
  float deltaS = abs(s - hex.s);

  if (deltaQ > deltaR && deltaQ > deltaS)
    q = -r - s;
  else if (deltaR > deltaS)
    r = -q - s;
  else
    s = -q - r;

  return createHexagon(q, r);
}

Hexagon hexagonFromPoint(vec2 point, float size) {
  
  point.y /= ratio;
  point = (point - 0.5) / size;
  
  float q = (sqrt(3.0) / 3.0) * point.x + (-1.0 / 3.0) * point.y;
  float r = 0.0 * point.x + 2.0 / 3.0 * point.y;

  Hexagon hex = createHexagon(q, r);
  return roundHexagon(hex);
  
}

vec2 pointFromHexagon(Hexagon hex, float size) {
  
  float x = (sqrt(3.0) * hex.q + (sqrt(3.0) / 2.0) * hex.r) * size + 0.5;
  float y = (0.0 * hex.q + (3.0 / 2.0) * hex.r) * size + 0.5;
  
  return vec2(x, y * ratio);
}

vec4 transition (vec2 uv) {
  
  float dist = 2.0 * min(progress, 1.0 - progress);
  dist = steps > 0 ? ceil(dist * float(steps)) / float(steps) : dist;
  
  float size = (sqrt(3.0) / 3.0) * dist / horizontalHexagons;
  
  vec2 point = dist > 0.0 ? pointFromHexagon(hexagonFromPoint(uv, size), size) : uv;

  return mix(getFromColor(point), getToColor(point), progress);
  
}
`, author: "Fernando Kuteken", license: "MIT", createdAt: "Tue, 30 May 2017 21:55:47 -0300", updatedAt: "Tue, 30 May 2017 21:55:47 -0300" }, { name: "kaleidoscope", paramsTypes: { speed: "float", angle: "float", power: "float" }, defaultParams: { speed: 1, angle: 1, power: 1.5 }, glsl: `// Author: nwoeanhinnogaehr
// License: MIT

uniform float speed; // = 1.0;
uniform float angle; // = 1.0;
uniform float power; // = 1.5;

vec4 transition(vec2 uv) {
  vec2 p = uv.xy / vec2(1.0).xy;
  vec2 q = p;
  float t = pow(progress, power)*speed;
  p = p -0.5;
  for (int i = 0; i < 7; i++) {
    p = vec2(sin(t)*p.x + cos(t)*p.y, sin(t)*p.y - cos(t)*p.x);
    t += angle;
    p = abs(mod(p, 2.0) - 1.0);
  }
  abs(mod(p, 1.0));
  return mix(
    mix(getFromColor(q), getToColor(q), progress),
    mix(getFromColor(p), getToColor(p), progress), 1.0 - 2.0*abs(progress - 0.5));
}
`, author: "nwoeanhinnogaehr", license: "MIT", createdAt: "Wed, 31 May 2017 21:48:26 -0400", updatedAt: "Wed, 31 May 2017 21:48:26 -0400" }, { name: "luma", paramsTypes: { luma: "sampler2D" }, defaultParams: { luma: null }, glsl: `// Author: gre
// License: MIT

uniform sampler2D luma;

vec4 transition(vec2 uv) {
  return mix(
    getToColor(uv),
    getFromColor(uv),
    step(progress, texture2D(luma, uv).r)
  );
}
`, author: "gre", license: "MIT", createdAt: "Tue, 30 May 2017 14:26:44 +0200", updatedAt: "Tue, 30 May 2017 14:26:44 +0200" }, { name: "luminance_melt", paramsTypes: { direction: "bool", l_threshold: "float", above: "bool" }, defaultParams: { direction: true, l_threshold: 0.8, above: false }, glsl: `// Author: 0gust1
// License: MIT
//My own first transition — based on crosshatch code (from pthrasher), using  simplex noise formula (copied and pasted)
//-> cooler with high contrasted images (isolated dark subject on light background f.e.)
//TODO : try to rebase it on DoomTransition (from zeh)?
//optimizations :
//luminance (see http://stackoverflow.com/questions/596216/formula-to-determine-brightness-of-rgb-color#answer-596241)
// Y = (R+R+B+G+G+G)/6
//or Y = (R+R+R+B+G+G+G+G)>>3 


//direction of movement :  0 : up, 1, down
uniform bool direction; // = 1 
//luminance threshold
uniform float l_threshold; // = 0.8 
//does the movement takes effect above or below luminance threshold ?
uniform bool above; // = false 


//Random function borrowed from everywhere
float rand(vec2 co){
  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}


// Simplex noise :
// Description : Array and textureless GLSL 2D simplex noise function.
//      Author : Ian McEwan, Ashima Arts.
//  Maintainer : ijm
//     Lastmod : 20110822 (ijm)
//     License : MIT  
//               2011 Ashima Arts. All rights reserved.
//               Distributed under the MIT License. See LICENSE file.
//               https://github.com/ashima/webgl-noise
// 

vec3 mod289(vec3 x) {
  return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec2 mod289(vec2 x) {
  return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec3 permute(vec3 x) {
  return mod289(((x*34.0)+1.0)*x);
}

float snoise(vec2 v)
  {
  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0
                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)
                     -0.577350269189626,  // -1.0 + 2.0 * C.x
                      0.024390243902439); // 1.0 / 41.0
// First corner
  vec2 i  = floor(v + dot(v, C.yy) );
  vec2 x0 = v -   i + dot(i, C.xx);

// Other corners
  vec2 i1;
  //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0
  //i1.y = 1.0 - i1.x;
  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
  // x0 = x0 - 0.0 + 0.0 * C.xx ;
  // x1 = x0 - i1 + 1.0 * C.xx ;
  // x2 = x0 - 1.0 + 2.0 * C.xx ;
  vec4 x12 = x0.xyxy + C.xxzz;
  x12.xy -= i1;

// Permutations
  i = mod289(i); // Avoid truncation effects in permutation
  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))
		+ i.x + vec3(0.0, i1.x, 1.0 ));

  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);
  m = m*m ;
  m = m*m ;

// Gradients: 41 points uniformly over a line, mapped onto a diamond.
// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)

  vec3 x = 2.0 * fract(p * C.www) - 1.0;
  vec3 h = abs(x) - 0.5;
  vec3 ox = floor(x + 0.5);
  vec3 a0 = x - ox;

// Normalise gradients implicitly by scaling m
// Approximation of: m *= inversesqrt( a0*a0 + h*h );
  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );

// Compute final noise value at P
  vec3 g;
  g.x  = a0.x  * x0.x  + h.x  * x0.y;
  g.yz = a0.yz * x12.xz + h.yz * x12.yw;
  return 130.0 * dot(m, g);
}

// Simplex noise -- end

float luminance(vec4 color){
  //(0.299*R + 0.587*G + 0.114*B)
  return color.r*0.299+color.g*0.587+color.b*0.114;
}

vec2 center = vec2(1.0, direction);

vec4 transition(vec2 uv) {
  vec2 p = uv.xy / vec2(1.0).xy;
  if (progress == 0.0) {
    return getFromColor(p);
  } else if (progress == 1.0) {
    return getToColor(p);
  } else {
    float x = progress;
    float dist = distance(center, p)- progress*exp(snoise(vec2(p.x, 0.0)));
    float r = x - rand(vec2(p.x, 0.1));
    float m;
    if(above){
     m = dist <= r && luminance(getFromColor(p))>l_threshold ? 1.0 : (progress*progress*progress);
    }
    else{
     m = dist <= r && luminance(getFromColor(p))<l_threshold ? 1.0 : (progress*progress*progress);  
    }
    return mix(getFromColor(p), getToColor(p), m);    
  }
}
`, author: "0gust1", license: "MIT", createdAt: "Wed, 24 Jan 2018 19:02:32 +0100", updatedAt: "Wed, 24 Jan 2018 19:02:32 +0100" }, { name: "morph", paramsTypes: { strength: "float" }, defaultParams: { strength: 0.1 }, glsl: `// Author: paniq
// License: MIT
uniform float strength; // = 0.1

vec4 transition(vec2 p) {
  vec4 ca = getFromColor(p);
  vec4 cb = getToColor(p);
  
  vec2 oa = (((ca.rg+ca.b)*0.5)*2.0-1.0);
  vec2 ob = (((cb.rg+cb.b)*0.5)*2.0-1.0);
  vec2 oc = mix(oa,ob,0.5)*strength;
  
  float w0 = progress;
  float w1 = 1.0-w0;
  return mix(getFromColor(p+oc*w0), getToColor(p-oc*w1), progress);
}
`, author: "paniq", license: "MIT", createdAt: "Thu, 10 Aug 2017 00:27:36 +0200", updatedAt: "Thu, 10 Aug 2017 00:32:01 +0200" }, { name: "multiply_blend", paramsTypes: {}, defaultParams: {}, glsl: `// Author: Fernando Kuteken
// License: MIT

vec4 blend(vec4 a, vec4 b) {
  return a * b;
}

vec4 transition (vec2 uv) {
  
  vec4 blended = blend(getFromColor(uv), getToColor(uv));
  
  if (progress < 0.5)
    return mix(getFromColor(uv), blended, 2.0 * progress);
  else
    return mix(blended, getToColor(uv), 2.0 * progress - 1.0);
}

`, author: "Fernando Kuteken", license: "MIT", createdAt: "Tue, 30 May 2017 14:26:44 +0200", updatedAt: "Tue, 30 May 2017 14:26:44 +0200" }, { name: "perlin", paramsTypes: { scale: "float", smoothness: "float", seed: "float" }, defaultParams: { scale: 4, smoothness: 0.01, seed: 12.9898 }, glsl: `// Author: Rich Harris
// License: MIT

#ifdef GL_ES
precision mediump float;
#endif

uniform float scale; // = 4.0
uniform float smoothness; // = 0.01

uniform float seed; // = 12.9898

// http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/
float random(vec2 co)
{
    highp float a = seed;
    highp float b = 78.233;
    highp float c = 43758.5453;
    highp float dt= dot(co.xy ,vec2(a,b));
    highp float sn= mod(dt,3.14);
    return fract(sin(sn) * c);
}

// 2D Noise based on Morgan McGuire @morgan3d
// https://www.shadertoy.com/view/4dS3Wd
float noise (in vec2 st) {
    vec2 i = floor(st);
    vec2 f = fract(st);

    // Four corners in 2D of a tile
    float a = random(i);
    float b = random(i + vec2(1.0, 0.0));
    float c = random(i + vec2(0.0, 1.0));
    float d = random(i + vec2(1.0, 1.0));

    // Smooth Interpolation

    // Cubic Hermine Curve.  Same as SmoothStep()
    vec2 u = f*f*(3.0-2.0*f);
    // u = smoothstep(0.,1.,f);

    // Mix 4 coorners porcentages
    return mix(a, b, u.x) +
            (c - a)* u.y * (1.0 - u.x) +
            (d - b) * u.x * u.y;
}

vec4 transition (vec2 uv) {
  vec4 from = getFromColor(uv);
  vec4 to = getToColor(uv);
  float n = noise(uv * scale);
  
  float p = mix(-smoothness, 1.0 + smoothness, progress);
  float lower = p - smoothness;
  float higher = p + smoothness;
  
  float q = smoothstep(lower, higher, n);
  
  return mix(
    from,
    to,
    1.0 - q
  );
}
`, author: "Rich Harris", license: "MIT", createdAt: "Tue, 23 Jan 2018 21:35:10 -0500", updatedAt: "Wed, 24 Jan 2018 07:35:04 -0500" }, { name: "pinwheel", paramsTypes: { speed: "float" }, defaultParams: { speed: 2 }, glsl: `// Author: Mr Speaker
// License: MIT

uniform float speed; // = 2.0;

vec4 transition(vec2 uv) {
  
  vec2 p = uv.xy / vec2(1.0).xy;
  
  float circPos = atan(p.y - 0.5, p.x - 0.5) + progress * speed;
  float modPos = mod(circPos, 3.1415 / 4.);
  float signed = sign(progress - modPos);
  
  return mix(getToColor(p), getFromColor(p), step(signed, 0.5));
  
}
`, author: "Mr Speaker", license: "MIT", createdAt: "Tue, 30 May 2017 09:04:31 -0400", updatedAt: "Tue, 30 May 2017 09:04:31 -0400" }, { name: "pixelize", paramsTypes: { squaresMin: "ivec2", steps: "int" }, defaultParams: { squaresMin: [20, 20], steps: 50 }, glsl: `// Author: gre
// License: MIT
// forked from https://gist.github.com/benraziel/c528607361d90a072e98

uniform ivec2 squaresMin/* = ivec2(20) */; // minimum number of squares (when the effect is at its higher level)
uniform int steps /* = 50 */; // zero disable the stepping

float d = min(progress, 1.0 - progress);
float dist = steps>0 ? ceil(d * float(steps)) / float(steps) : d;
vec2 squareSize = 2.0 * dist / vec2(squaresMin);

vec4 transition(vec2 uv) {
  vec2 p = dist>0.0 ? (floor(uv / squareSize) + 0.5) * squareSize : uv;
  return mix(getFromColor(p), getToColor(p), progress);
}
`, author: "gre", license: "MIT", createdAt: "Tue, 30 May 2017 14:26:44 +0200", updatedAt: "Wed, 31 May 2017 10:58:26 +0200" }, { name: "polar_function", paramsTypes: { segments: "int" }, defaultParams: { segments: 5 }, glsl: `// Author: Fernando Kuteken
// License: MIT

#define PI 3.14159265359

uniform int segments; // = 5;

vec4 transition (vec2 uv) {
  
  float angle = atan(uv.y - 0.5, uv.x - 0.5) - 0.5 * PI;
  float normalized = (angle + 1.5 * PI) * (2.0 * PI);
  
  float radius = (cos(float(segments) * angle) + 4.0) / 4.0;
  float difference = length(uv - vec2(0.5, 0.5));
  
  if (difference > radius * progress)
    return getFromColor(uv);
  else
    return getToColor(uv);
}
`, author: "Fernando Kuteken", license: "MIT", createdAt: "Tue, 30 May 2017 14:26:44 +0200", updatedAt: "Tue, 30 May 2017 14:26:44 +0200" }, { name: "randomsquares", paramsTypes: { size: "ivec2", smoothness: "float" }, defaultParams: { size: [10, 10], smoothness: 0.5 }, glsl: `// Author: gre
// License: MIT

uniform ivec2 size; // = ivec2(10, 10)
uniform float smoothness; // = 0.5
 
float rand (vec2 co) {
  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

vec4 transition(vec2 p) {
  float r = rand(floor(vec2(size) * p));
  float m = smoothstep(0.0, -smoothness, r - (progress * (1.0 + smoothness)));
  return mix(getFromColor(p), getToColor(p), m);
}
`, author: "gre", license: "MIT", createdAt: "Tue, 30 May 2017 14:26:44 +0200", updatedAt: "Tue, 30 May 2017 14:26:44 +0200" }, { name: "ripple", paramsTypes: { amplitude: "float", speed: "float" }, defaultParams: { amplitude: 100, speed: 50 }, glsl: `// Author: gre
// License: MIT
uniform float amplitude; // = 100.0
uniform float speed; // = 50.0

vec4 transition (vec2 uv) {
  vec2 dir = uv - vec2(.5);
  float dist = length(dir);
  vec2 offset = dir * (sin(progress * dist * amplitude - progress * speed) + .5) / 30.;
  return mix(
    getFromColor(uv + offset),
    getToColor(uv),
    smoothstep(0.2, 1.0, progress)
  );
}
`, author: "gre", license: "MIT", createdAt: "Tue, 30 May 2017 15:15:27 +0200", updatedAt: "Tue, 30 May 2017 15:15:27 +0200" }, { name: "rotate_scale_fade", paramsTypes: { center: "vec2", rotations: "float", scale: "float", backColor: "vec4" }, defaultParams: { center: [0.5, 0.5], rotations: 1, scale: 8, backColor: [0.15, 0.15, 0.15, 1] }, glsl: `// Author: Fernando Kuteken
// License: MIT

#define PI 3.14159265359

uniform vec2 center; // = vec2(0.5, 0.5);
uniform float rotations; // = 1;
uniform float scale; // = 8;
uniform vec4 backColor; // = vec4(0.15, 0.15, 0.15, 1.0);

vec4 transition (vec2 uv) {
  
  vec2 difference = uv - center;
  vec2 dir = normalize(difference);
  float dist = length(difference);
  
  float angle = 2.0 * PI * rotations * progress;
  
  float c = cos(angle);
  float s = sin(angle);
  
  float currentScale = mix(scale, 1.0, 2.0 * abs(progress - 0.5));
  
  vec2 rotatedDir = vec2(dir.x  * c - dir.y * s, dir.x * s + dir.y * c);
  vec2 rotatedUv = center + rotatedDir * dist / currentScale;
  
  if (rotatedUv.x < 0.0 || rotatedUv.x > 1.0 ||
      rotatedUv.y < 0.0 || rotatedUv.y > 1.0)
    return backColor;
    
  return mix(getFromColor(rotatedUv), getToColor(rotatedUv), progress);
}
`, author: "Fernando Kuteken", license: "MIT", createdAt: "Tue, 30 May 2017 14:26:44 +0200", updatedAt: "Tue, 30 May 2017 14:26:44 +0200" }, { name: "squareswire", paramsTypes: { squares: "ivec2", direction: "vec2", smoothness: "float" }, defaultParams: { squares: [10, 10], direction: [1, -0.5], smoothness: 1.6 }, glsl: `// Author: gre
// License: MIT
 
uniform ivec2 squares;// = ivec2(10,10)
uniform vec2 direction;// = vec2(1.0, -0.5)
uniform float smoothness; // = 1.6

const vec2 center = vec2(0.5, 0.5);
vec4 transition (vec2 p) {
  vec2 v = normalize(direction);
  v /= abs(v.x)+abs(v.y);
  float d = v.x * center.x + v.y * center.y;
  float offset = smoothness;
  float pr = smoothstep(-offset, 0.0, v.x * p.x + v.y * p.y - (d-0.5+progress*(1.+offset)));
  vec2 squarep = fract(p*vec2(squares));
  vec2 squaremin = vec2(pr/2.0);
  vec2 squaremax = vec2(1.0 - pr/2.0);
  float a = (1.0 - step(progress, 0.0)) * step(squaremin.x, squarep.x) * step(squaremin.y, squarep.y) * step(squarep.x, squaremax.x) * step(squarep.y, squaremax.y);
  return mix(getFromColor(p), getToColor(p), a);
}
`, author: "gre", license: "MIT", createdAt: "Tue, 30 May 2017 14:26:44 +0200", updatedAt: "Tue, 30 May 2017 14:26:44 +0200" }, { name: "squeeze", paramsTypes: { colorSeparation: "float" }, defaultParams: { colorSeparation: 0.04 }, glsl: `// Author: gre
// License: MIT
 
uniform float colorSeparation; // = 0.04
 
vec4 transition (vec2 uv) {
  float y = 0.5 + (uv.y-0.5) / (1.0-progress);
  if (y < 0.0 || y > 1.0) {
     return getToColor(uv);
  }
  else {
    vec2 fp = vec2(uv.x, y);
    vec2 off = progress * vec2(0.0, colorSeparation);
    vec4 c = getFromColor(fp);
    vec4 cn = getFromColor(fp - off);
    vec4 cp = getFromColor(fp + off);
    return vec4(cn.r, c.g, cp.b, c.a);
  }
}
`, author: "gre", license: "MIT", createdAt: "Tue, 30 May 2017 14:26:44 +0200", updatedAt: "Tue, 30 May 2017 14:26:44 +0200" }, { name: "swap", paramsTypes: { reflection: "float", perspective: "float", depth: "float" }, defaultParams: { reflection: 0.4, perspective: 0.2, depth: 3 }, glsl: `// Author: gre
// License: MIT
// General parameters
uniform float reflection; // = 0.4
uniform float perspective; // = 0.2
uniform float depth; // = 3.0
 
const vec4 black = vec4(0.0, 0.0, 0.0, 1.0);
const vec2 boundMin = vec2(0.0, 0.0);
const vec2 boundMax = vec2(1.0, 1.0);
 
bool inBounds (vec2 p) {
  return all(lessThan(boundMin, p)) && all(lessThan(p, boundMax));
}
 
vec2 project (vec2 p) {
  return p * vec2(1.0, -1.2) + vec2(0.0, -0.02);
}
 
vec4 bgColor (vec2 p, vec2 pfr, vec2 pto) {
  vec4 c = black;
  pfr = project(pfr);
  if (inBounds(pfr)) {
    c += mix(black, getFromColor(pfr), reflection * mix(1.0, 0.0, pfr.y));
  }
  pto = project(pto);
  if (inBounds(pto)) {
    c += mix(black, getToColor(pto), reflection * mix(1.0, 0.0, pto.y));
  }
  return c;
}
 
vec4 transition(vec2 p) {
  vec2 pfr, pto = vec2(-1.);
 
  float size = mix(1.0, depth, progress);
  float persp = perspective * progress;
  pfr = (p + vec2(-0.0, -0.5)) * vec2(size/(1.0-perspective*progress), size/(1.0-size*persp*p.x)) + vec2(0.0, 0.5);
 
  size = mix(1.0, depth, 1.-progress);
  persp = perspective * (1.-progress);
  pto = (p + vec2(-1.0, -0.5)) * vec2(size/(1.0-perspective*(1.0-progress)), size/(1.0-size*persp*(0.5-p.x))) + vec2(1.0, 0.5);

  if (progress < 0.5) {
    if (inBounds(pfr)) {
      return getFromColor(pfr);
    }
    if (inBounds(pto)) {
      return getToColor(pto);
    }  
  }
  if (inBounds(pto)) {
    return getToColor(pto);
  }
  if (inBounds(pfr)) {
    return getFromColor(pfr);
  }
  return bgColor(p, pfr, pto);
}
`, author: "gre", license: "MIT", createdAt: "Tue, 30 May 2017 14:26:44 +0200", updatedAt: "Sun, 18 Feb 2018 17:45:50 +0100" }, { name: "undulatingBurnOut", paramsTypes: { smoothness: "float", center: "vec2", color: "vec3" }, defaultParams: { smoothness: 0.03, center: [0.5, 0.5], color: [0, 0, 0] }, glsl: `// License: MIT
// Author: pthrasher
// adapted by gre from https://gist.github.com/pthrasher/8e6226b215548ba12734

uniform float smoothness; // = 0.03
uniform vec2 center; // = vec2(0.5)
uniform vec3 color; // = vec3(0.0)

const float M_PI = 3.14159265358979323846;

float quadraticInOut(float t) {
  float p = 2.0 * t * t;
  return t < 0.5 ? p : -p + (4.0 * t) - 1.0;
}

float getGradient(float r, float dist) {
  float d = r - dist;
  return mix(
    smoothstep(-smoothness, 0.0, r - dist * (1.0 + smoothness)),
    -1.0 - step(0.005, d),
    step(-0.005, d) * step(d, 0.01)
  );
}

float getWave(vec2 p){
  vec2 _p = p - center; // offset from center
  float rads = atan(_p.y, _p.x);
  float degs = degrees(rads) + 180.0;
  vec2 range = vec2(0.0, M_PI * 30.0);
  vec2 domain = vec2(0.0, 360.0);
  float ratio = (M_PI * 30.0) / 360.0;
  degs = degs * ratio;
  float x = progress;
  float magnitude = mix(0.02, 0.09, smoothstep(0.0, 1.0, x));
  float offset = mix(40.0, 30.0, smoothstep(0.0, 1.0, x));
  float ease_degs = quadraticInOut(sin(degs));
  float deg_wave_pos = (ease_degs * magnitude) * sin(x * offset);
  return x + deg_wave_pos;
}

vec4 transition(vec2 p) {
  float dist = distance(center, p);
  float m = getGradient(getWave(p), dist);
  vec4 cfrom = getFromColor(p);
  vec4 cto = getToColor(p);
  return mix(mix(cfrom, cto, m), mix(cfrom, vec4(color, 1.0), 0.75), step(m, -2.0));
}
`, license: "MIT", author: "pthrasher", createdAt: "Mon, 12 Jun 2017 10:23:37 +0800", updatedAt: "Mon, 12 Jun 2017 10:23:37 +0800" }, { name: "wind", paramsTypes: { size: "float" }, defaultParams: { size: 0.2 }, glsl: `// Author: gre
// License: MIT

// Custom parameters
uniform float size; // = 0.2

float rand (vec2 co) {
  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

vec4 transition (vec2 uv) {
  float r = rand(vec2(0, uv.y));
  float m = smoothstep(0.0, -size, uv.x*(1.0-size) + size*r - (progress * (1.0 + size)));
  return mix(
    getFromColor(uv),
    getToColor(uv),
    m
  );
}
`, author: "gre", license: "MIT", createdAt: "Tue, 30 May 2017 14:26:44 +0200", updatedAt: "Tue, 30 May 2017 14:26:44 +0200" }, { name: "windowblinds", paramsTypes: {}, defaultParams: {}, glsl: `// Author: Fabien Benetou
// License: MIT

vec4 transition (vec2 uv) {
  float t = progress;
  
  if (mod(floor(uv.y*100.*progress),2.)==0.)
    t*=2.-.5;
  
  return mix(
    getFromColor(uv),
    getToColor(uv),
    mix(t, progress, smoothstep(0.8, 1.0, progress))
  );
}
`, author: "Fabien Benetou", license: "MIT", createdAt: "Wed, 31 May 2017 14:11:48 +0200", updatedAt: "Wed, 31 May 2017 14:11:48 +0200" }, { name: "windowslice", paramsTypes: { count: "float", smoothness: "float" }, defaultParams: { count: 10, smoothness: 0.5 }, glsl: `// Author: gre
// License: MIT

uniform float count; // = 10.0
uniform float smoothness; // = 0.5

vec4 transition (vec2 p) {
  float pr = smoothstep(-smoothness, 0.0, p.x - progress * (1.0 + smoothness));
  float s = step(pr, fract(count * p.x));
  return mix(getFromColor(p), getToColor(p), s);
}
`, author: "gre", license: "MIT", createdAt: "Wed, 28 Mar 2018 17:23:26 +0200", updatedAt: "Wed, 28 Mar 2018 17:23:26 +0200" }, { name: "wipeDown", paramsTypes: {}, defaultParams: {}, glsl: `// Author: Jake Nelson
// License: MIT

vec4 transition(vec2 uv) {
  vec2 p=uv.xy/vec2(1.0).xy;
  vec4 a=getFromColor(p);
  vec4 b=getToColor(p);
  return mix(a, b, step(1.0-p.y,progress));
}
`, author: "Jake Nelson", license: "MIT", createdAt: "Wed, 1 Nov 2017 15:26:01 -0500", updatedAt: "Thu, 2 Nov 2017 18:39:26 -0500" }, { name: "wipeLeft", paramsTypes: {}, defaultParams: {}, glsl: `// Author: Jake Nelson
// License: MIT

vec4 transition(vec2 uv) {
  vec2 p=uv.xy/vec2(1.0).xy;
  vec4 a=getFromColor(p);
  vec4 b=getToColor(p);
  return mix(a, b, step(1.0-p.x,progress));
}
`, author: "Jake Nelson", license: "MIT", createdAt: "Wed, 1 Nov 2017 15:26:28 -0500", updatedAt: "Fri, 3 Nov 2017 18:03:50 +0100" }, { name: "wipeRight", paramsTypes: {}, defaultParams: {}, glsl: `// Author: Jake Nelson
// License: MIT

vec4 transition(vec2 uv) {
  vec2 p=uv.xy/vec2(1.0).xy;
  vec4 a=getFromColor(p);
  vec4 b=getToColor(p);
  return mix(a, b, step(0.0+p.x,progress));
}
`, author: "Jake Nelson", license: "MIT", createdAt: "Wed, 1 Nov 2017 15:27:02 -0500", updatedAt: "Thu, 2 Nov 2017 18:40:22 -0500" }, { name: "wipeUp", paramsTypes: {}, defaultParams: {}, glsl: `// Author: Jake Nelson
// License: MIT

vec4 transition(vec2 uv) {
  vec2 p=uv.xy/vec2(1.0).xy;
  vec4 a=getFromColor(p);
  vec4 b=getToColor(p);
  return mix(a, b, step(0.0+p.y,progress));
}
`, author: "Jake Nelson", license: "MIT", createdAt: "Wed, 1 Nov 2017 15:24:36 -0500", updatedAt: "Thu, 2 Nov 2017 18:37:42 -0500" }]), glTransitions;
}
var cube, hasRequiredCube;
function requireCube() {
  return hasRequiredCube || (hasRequiredCube = 1, cube = {
    name: "Cube",
    paramsTypes: {
      persp: "float",
      unzoom: "float",
      reflection: "float",
      floating: "float",
      bgcolor: "vec4"
    },
    defaultParams: {
      persp: 0.7,
      unzoom: 0.3,
      reflection: 0.4,
      floating: 3,
      bgcolor: [0, 0, 0, 1]
    },
    glsl: `
// Author: gre
// License: MIT
uniform float persp; // = 0.7
uniform float unzoom; // = 0.3
uniform float reflection; // = 0.4
uniform float floating; // = 3.0
uniform vec4 bgcolor; // = vec4(0.0, 0.0, 0.0, 1.0)

vec2 project (vec2 p) {
  return p * vec2(1.0, -1.2) + vec2(0.0, -floating/100.);
}

bool inBounds (vec2 p) {
  return all(lessThan(vec2(0.0), p)) && all(lessThan(p, vec2(1.0)));
}

vec4 bgColor (vec2 p, vec2 pfr, vec2 pto) {
  vec4 c = bgcolor;
  pfr = project(pfr);
  // FIXME avoid branching might help perf!
  if (inBounds(pfr)) {
    c += mix(vec4(0.0), getFromColor(pfr), reflection * mix(1.0, 0.0, pfr.y));
  }
  pto = project(pto);
  if (inBounds(pto)) {
    c += mix(vec4(0.0), getToColor(pto), reflection * mix(1.0, 0.0, pto.y));
  }
  return c;
}

// p : the position
// persp : the perspective in [ 0, 1 ]
// center : the xcenter in [0, 1]  0.5 excluded
vec2 xskew (vec2 p, float persp, float center) {
  float x = mix(p.x, 1.0-p.x, center);
  return (
    (
      vec2( x, (p.y - 0.5*(1.0-persp) * x) / (1.0+(persp-1.0)*x) )
      - vec2(0.5-distance(center, 0.5), 0.0)
    )
    * vec2(0.5 / distance(center, 0.5) * (center<0.5 ? 1.0 : -1.0), 1.0)
    + vec2(center<0.5 ? 0.0 : 1.0, 0.0)
  );
}

vec4 transition(vec2 op) {
  float uz = unzoom * 2.0*(0.5-distance(0.5, progress));
  vec2 p = -uz*0.5+(1.0+uz) * op;
  vec2 fromP = xskew(
    (p - vec2(progress, 0.0)) / vec2(1.0-progress, 1.0),
    1.0-mix(progress, 0.0, persp),
    0.0
  );
  vec2 toP = xskew(
    p / vec2(progress, 1.0),
    mix(pow(progress, 2.0), 1.0, persp),
    1.0
  );
  // FIXME avoid branching might help perf!
  if (inBounds(fromP)) {
    return getFromColor(fromP);
  }
  else if (inBounds(toP)) {
    return getToColor(toP);
  }
  return bgColor(op, fromP, toP);
}
`
  }), cube;
}
var fat, hasRequiredFat;
function requireFat() {
  return hasRequiredFat || (hasRequiredFat = 1, fat = {
    name: "Fat",
    paramsTypes: {},
    defaultParams: {},
    glsl: `
  const float PI = 3.1415927;

  float getDis(float dis){
    dis = pow(dis,0.65);
    return 1.*dis;
  }

  vec4 transition (vec2 uv) {
    vec2 center=vec2(.5);
    vec2 dv=center-uv;
    float k = (3./2.);
    float r = .16;
    float dis=length(dv);
    float sinFactor=((sin(progress*k*PI)-1.)+1.)*r;

    vec2 dv1=normalize(dv);
    vec2 offsets=dv1*sinFactor*getDis(dis);
    vec2 uv2=offsets+uv;
    vec2 uv3=offsets*1.2+uv;

    vec4 c=getToColor(uv);
    vec4 a=getToColor(uv2);
    vec4 b=getFromColor(uv3);

    if(progress<=.0) return getFromColor(uv);
    return mix(b,mix(a,c,progress), progress);
  }
`
  }), fat;
}
var lens, hasRequiredLens;
function requireLens() {
  return hasRequiredLens || (hasRequiredLens = 1, lens = {
    name: "Lens",
    paramsTypes: {},
    defaultParams: {},
    glsl: `
  #define GRID_SIZE 20.
  const float PI = acos(-1.);

  float screenIn(in vec2 uv) {
    float x = 1. - step(0.5, abs(uv.x-0.5));
    float y = 1. - step(0.5, abs(uv.y-0.5));
    float result = x * y;
    return result;
  }
  mat2 rotate(in float r) { float c=cos(r),s=sin(r); return mat2(c,-s,s,c); }
  float hash(in float v) { return fract(sin(v)*43237.5324); }
  float hash(in vec2 v) { return fract(sin(dot(v, vec2(12.9898, 78.233)))*43237.5324); }

  vec4 transitionFrame(float ratio, in vec2 st) {
    vec2 uv = st;
    uv *= rotate(PI/6.);

    uv.y *= GRID_SIZE;
    vec2 id = vec2(0.);
    id.y = floor(uv.y);
    uv.x *= GRID_SIZE*hash(id.y);
    id.x = id.y + floor(uv.x);

    float angle = sign(hash(id.x)*2.-1.);
    float offset = hash(id.x + id.y)+1.414;

    vec2 uv1 = st;
    vec2 uv2 = st + vec2(angle * offset * ratio, 0.)*rotate(-PI/6.);

    return screenIn(uv2)<1. ? getToColor(uv1) : getFromColor(uv2);
  }

  vec4 transition (vec2 uv) {
    vec2 iResolution = vec2(1.0);
    float iTime = progress*PI/2.0;
    float ratio = smoothstep(0., 1., sin(iTime));
    vec4 video = transitionFrame(ratio, uv);
    vec3 col = video.rgb;
    return vec4(col,1.0);
  }
`,
    author: "https://www.shadertoy.com/view/wdcSzl"
  }), lens;
}
var slice, hasRequiredSlice;
function requireSlice() {
  return hasRequiredSlice || (hasRequiredSlice = 1, slice = {
    name: "Slice",
    paramsTypes: {},
    defaultParams: {},
    glsl: `
  float NUM = 18.0;
  float PI = 3.1415927;
  vec2 direction = vec2(1.0, .0);

  float normalSine(float value) {
    return (sin(value) + 1.0) / 2.0;
  }

  float rand(float n){
    float num = 100.;
    float y = floor(n * num);
    y/=num;
    return fract(sin(y) * 43758.5453123);
  }

  float checker(vec2 uv) {
    float div = 2.0;
    float fy = floor(uv.x * NUM);
    float odd = fy - (div * floor(fy/div));
    return sign(odd);
  }

  vec4 transition (vec2 uv) {
    float iTime = (progress - .5)*PI;
    vec2 iResolution =vec2(1.0);

    float factor = 1.0 - ( 2.0 * checker(uv));
    vec2 offsetDirection = direction * factor;
    vec2 offset = offsetDirection * normalSine(iTime);
    vec2 wrapped = fract(uv + offset);
    
    vec4 fromColor = getFromColor(wrapped);
    vec4 toColor = getToColor(wrapped);
    return mix(fromColor,toColor,progress);
  }
`
  }), slice;
}
var shake, hasRequiredShake;
function requireShake() {
  return hasRequiredShake || (hasRequiredShake = 1, shake = {
    name: "Shake",
    paramsTypes: {},
    defaultParams: {},
    glsl: `
  const float PI = 3.1415927;
  float random2d(vec2 n) { 
    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);
  }
  
  float randomRange (in vec2 seed, in float min, in float max) {
    return min + random2d(seed) * (max - min);
  }
  
  float insideRange(float v, float bottom, float top) {
    return step(bottom, v) - step(top, v);
  }
  
  float getSpeed(float progress){
    return pow(progress, 4.);
  }
  
  float AMT = 0.2; //0 - 1 glitch amount
  float SPEED = 0.6; //0 - 1 speed
     
  vec4 transition (vec2 p) {
    float iTime = progress*PI;
    vec2 iResolution =vec2(1.0);
    
    float time = floor(iTime * SPEED * 60.0);  
    vec2 uv = p.xy / iResolution.xy;
    vec3 outCol = getToColor(uv).rgb;
    
    float maxOffset = AMT/2.0;
    for (float i = 0.0; i < 10.0 * .45; i += 1.0) {
      float sliceY = random2d(vec2(time , 2345.0 + float(i)));
      float sliceH = random2d(vec2(time , 9035.0 + float(i))) * 0.25;
      float hOffset = randomRange(vec2(time , 9625.0 + float(i)), -maxOffset, maxOffset);
      vec2 uvOff = uv;
      uvOff.x += hOffset;
      if (insideRange(uv.y, sliceY, fract(sliceY+sliceH)) == 1.0 ){
        outCol = getToColor(uvOff).rgb;
      }
    }
  
    float maxColOffset = AMT/6.0;
    float rnd = random2d(vec2(time , 9545.0));
    vec2 colOffset = vec2(randomRange(vec2(time, 9545.0),-maxColOffset,maxColOffset), randomRange(vec2(time , 7205.0),-maxColOffset,maxColOffset));
    if (rnd < 0.33){
      outCol.r = getToColor(uv + colOffset).r;
      
    }else if (rnd < 0.66){
      outCol.g = getToColor(uv + colOffset).g;
    } else{
      outCol.b = getToColor(uv + colOffset).b;  
    }
    
    vec4 fromColor = getFromColor(p);
    vec4 toColor = vec4(outCol,1.0);
    
    if(progress>=1.) return getToColor(p);
    return mix(fromColor,toColor,getSpeed(progress));
  }
`
  }), shake;
}
var stretch, hasRequiredStretch;
function requireStretch() {
  return hasRequiredStretch || (hasRequiredStretch = 1, stretch = {
    name: "Stretch",
    paramsTypes: {},
    defaultParams: {},
    glsl: `
  const float PI = 3.1415927;
  float quarticInOut(float t) {
    return t < 0.5? +8.0 * pow(t, 4.0): -8.0 * pow(t - 1.0, 4.0) + 1.0;
  }

  float hash(float n) { 
    return fract(sin(n) * 1e4); 
  }
  float hash(vec2 p) { 
    return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x)))); 
  }
    
  float hnoise(vec2 x) {
    vec2 i = floor(x);
    vec2 f = fract(x);
    float a = hash(i);
    float b = hash(i + vec2(1.0, 0.0));
    float c = hash(i + vec2(0.0, 1.0));
    float d = hash(i + vec2(1.0, 1.0));
    vec2 u = f * f * (3.0 - 2.0 * f);
    return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
  }
    
  vec4 transition (vec2 uv) {
    vec2 newUv = (uv - vec2(0.5)) + vec2(0.5);
    float hn = hnoise(newUv.xy  / 10.0); 
    vec2 d = vec2(0.,normalize(vec2(0.5,0.5) - newUv.xy).y);
    float time = quarticInOut(progress);
    vec2 uv1 = newUv + d * time / 5.0 * (1.0 + hn / 2.0);
    vec2 uv2 = newUv - d * (1.0 - time) / 5.0 * (1.0 + hn / 2.0);

    return mix(getFromColor(uv1), getToColor(uv2), time);
  }
`
  }), stretch;
}
var backoff, hasRequiredBackoff;
function requireBackoff() {
  return hasRequiredBackoff || (hasRequiredBackoff = 1, backoff = {
    name: "BackOff",
    paramsTypes: {},
    defaultParams: {},
    glsl: `
  float superstep(float a, float x){
    float v = smoothstep(a-0.1,a,x);
    return pow(v, 1.2);
  }

  vec4 transition (vec2 uv) {
    vec2 p=uv.xy/vec2(1.0).xy;
    vec4 a=getFromColor(p);
    vec4 b=getToColor(p);

    if(uv.x<=.5&&uv.y<=.5){
      return mix(a, b, superstep(1.0-p.y,progress));
    }else if(uv.x<=1.&&uv.y<=.5){
      return mix(a, b, superstep(0.0+p.x,progress));
    }else if(uv.x>=.5&&uv.y>=.5){
      return mix(a, b, superstep(0.0+p.y,progress));
    }else{
      return mix(a, b, superstep(1.0-p.x,progress));
    }
  }
`
  }), backoff;
}
var fluidly, hasRequiredFluidly;
function requireFluidly() {
  return hasRequiredFluidly || (hasRequiredFluidly = 1, fluidly = {
    name: "Fluidly",
    paramsTypes: {},
    defaultParams: {},
    glsl: `
  #define PI 3.14159265359
  vec2 accel = vec2(0.01);

  vec2 mirror(vec2 v) {
    vec2 m = mod(v, 2.0);
    return mix(m, 2.0 - m, step(1.0, m));
  }

  float tri(float p) {
    return mix(p, 1.0 - p, step(0.5, p))*2.0;
  }

  vec4 transition (vec2 uv) {
    vec2 iResolution = vec2(1.0);
    float iTime = progress;

    vec2 vuv1 = uv - 0.5;
    vuv1 *= vec2(1.,iResolution.y/iResolution.x);
    vuv1 += 0.5;

    float p = pow(min(cos(PI * (mod(iTime,2.)-1.) / 2.), 1. - abs(mod(iTime,2.) - 1.)  ), 1. );
    float delayValue = p*7. - uv.y*2. + uv.x - 2.0 ;
    delayValue = clamp(delayValue,0.,1.);

    vec2 acc = vec2(0.5,2.);
    vec2 translateValue = p + delayValue * acc;
    vec2 translateValue1 = vec2(-0.5,1.)* translateValue;
    vec2 translateValue2 = vec2(-0.5,1.) * (translateValue - 1.0 - acc);

    vec2 w = sin( sin(iTime)*vec2(0,0.3) + uv*vec2(0,4.)) * vec2(0, 0.5);
    vec2 xy = w*(tri(p)*0.5 + tri(delayValue)*0.5);

    vec2 uv1 = vuv1 + translateValue1 + xy;
    vec2 uv2 = vuv1 + translateValue2 + xy;

    vec4 t0 = getFromColor(mirror(uv1));
    vec4 t1 = getToColor(mirror(uv2));
    return mix(t0, t1, delayValue);
  }
`,
    author: "https://www.shadertoy.com/view/wsjGWW"
  }), fluidly;
}
var oblique, hasRequiredOblique;
function requireOblique() {
  return hasRequiredOblique || (hasRequiredOblique = 1, oblique = {
    name: "Oblique",
    paramsTypes: { bgcolor: "vec4" },
    defaultParams: { bgcolor: [0, 0, 0, 1] },
    glsl: `
  const float PI = 3.1415927;
  const float seed = 265.5;
  const float rotAngle = PI/4.;
  const float sliceCount = 10.0;

  float random (in vec2 st) { 
    return fract(sin(dot(st.xy,vec2(12.9798,78.323)))*43758.5453234);
  }

  mat2 rot2m(float a){
    float s = sin(a);
    float c = cos(a);
    return mat2(c, -s, s, c);
  }

  float slices(in vec2 p, float count){
    p *= rot2m(rotAngle);
    float x = p.x * count;
    float v = random( vec2(floor(x)) + seed * count * 0.5 );
    return v;
  }

  float randomSlices(in vec2 p){
      float s1 = 1.0, s2 = 0.0;
      for(float i = 1.0; i < sliceCount; ++i){
          float t = slices(p, 2.0 * i);
          
          s1 = min(s1, t);
          s2 = max(s2, t);
      }
      return (s1 + s2) * 0.5;
  }

  vec4 pic(float v, vec2 uv, vec2 sp){
      float m1 = (v + 1.0);
      m1 = 1.0 / pow(m1, 0.25);
      
      float m2 = (2.0 - v);
      m2 = 1.0 / pow(m2, 0.25);
      
      vec2 uv1 = (uv - sp) * m1 + sp;
      vec2 uv2 = (uv - sp) * m2 + sp;
      
      vec4 colA = getFromColor( fract(uv1) );
      vec4 colB = getToColor( fract(uv2) );
      
      return mix(colA, colB, v);
  }

  vec4 transition (vec2 uv) {
      float iTime = progress*PI;
      vec2 iResolution =vec2(1.0);
      float v = randomSlices(uv);
      
      float b = smoothstep(0.0, v, sin(iTime * 0.7));
      vec2 sp = vec2(v, random(vec2(v) ) ) * 0.5;
      
      return pic(b, uv, sp );
  }
`,
    author: "https://www.shadertoy.com/view/ltVSzd"
  }), oblique;
}
var windows4, hasRequiredWindows4;
function requireWindows4() {
  return hasRequiredWindows4 || (hasRequiredWindows4 = 1, windows4 = {
    name: "Windows4",
    paramsTypes: {},
    defaultParams: {},
    glsl: `
  #define PI 3.141592653589793

  float superstep(float a, float x){
    float v = smoothstep(a-0.1,a,x);
    return pow(v, 1.2);
  }
  
  float quarticInOut(float t) {
    return t < 0.5
      ? +8.0 * pow(t, 4.0)
      : -8.0 * pow(t - 1.0, 4.0) + 1.0;
  }
  
  float backOut(float t) {
    float f = t < 0.5
      ? 2.0 * t
      : 1.0 - (2.0 * t - 1.0);
  
    float g = pow(f, 3.0) - f * sin(f * PI);
  
    return t < 0.5
      ? 0.5 * g
      : 0.5 * (1.0 - g) + 0.5;
  }
  
  vec4 getColor(vec2 uv, vec2 direction){
    vec2 p = uv + quarticInOut(progress) * sign(direction);
    vec2 f = fract(p);
    
    return mix(
      getToColor(f),
      getFromColor(f),
      step(0.0, p.y) * step(p.y, 1.0) * step(0.0, p.x) * step(p.x, 1.0)
    );
  }
  
  vec4 transition (vec2 uv) {
    if(uv.x<=.5&&uv.y<=.5){
      return getColor(uv, vec2(0., 1.));
    }else if(uv.x<=1.&&uv.y<=.5){
      return getColor(uv, vec2(-1., 0.));
    }else if(uv.x>=.5&&uv.y>=.5){
      return getColor(uv, vec2(0., -1.));
    }else{
      return getColor(uv, vec2(1., 0.));
    }
  }
`
  }), windows4;
}
var tetrapod, hasRequiredTetrapod;
function requireTetrapod() {
  return hasRequiredTetrapod || (hasRequiredTetrapod = 1, tetrapod = {
    name: "Tetrapod",
    paramsTypes: {},
    defaultParams: {},
    glsl: `
  #define PI 3.141592653589793
  const float divisions=20.;
  
  float sfract(float time){
    if(time>=1.) return 1.;
    return fract(time);
  }
  
  vec4 transition (vec2 uv) {
    float iTime = progress;
    vec2 iResolution =vec2(1.0);
    vec2 st = uv;
      
    float t = sfract(iTime)*3.-1.;
    vec2 f_st = fract(st*divisions);
    vec2 i_st = floor(st*divisions);
    f_st -= 0.5;
    t = (1.-t+(i_st.x/divisions) - (1.-i_st.y/divisions));
    float fx = smoothstep(t-.2, t+.3, 1.-abs(f_st.x+f_st.y));
    float fy = smoothstep(t-.2, t+.3, 1.-abs((f_st.x)-(f_st.y)));
    float a = fx*fy;
      
    vec4 toColor = getToColor(st)*a;
    vec4 fromColor = getFromColor(uv);
    fromColor.a = 1.-iTime;
      
    if(progress>=1.) return getToColor(uv);
    return mix(fromColor, toColor , progress*progress);
  }
`
  }), tetrapod;
}
var colorful, hasRequiredColorful;
function requireColorful() {
  return hasRequiredColorful || (hasRequiredColorful = 1, colorful = {
    name: "Colorful",
    paramsTypes: {},
    defaultParams: {},
    glsl: `
  #define HALF_PI 1.57079632679
  vec4 colors[6];
  vec2 center = vec2(0.5, 0.5);

  float aasin(float t){
    float nt = t;
    if(nt<=.0) nt = 0.;
    if(nt>=1.) nt = 1.;
    return asin(nt)/HALF_PI;
  }

  vec4 getRgb(float r, float g, float b){
    float v255 = 255.0;
    return vec4(r/v255, g/v255, b/v255, 1.);
  }

  vec2 resetSize(vec2 size){
    vec2 nsize = size;
    if(ratio>1.){
      nsize.y = size.y / ratio;
    }else{
      nsize.x = size.x * ratio;
    }

    return nsize;
  }

  vec4 transition (vec2 uv) {
    colors[0]= getRgb(255., 212., 50.);
    colors[1]= getRgb(252., 92., 102.);
    colors[2]= getRgb(70., 170., 240.);
    colors[3]= getRgb(57., 105., 214.);
    colors[4]= getRgb(137., 84., 208.);
    colors[5]= getToColor(uv);

    float num = 6.0;
    float delay = .3;
    vec2 iResolution = vec2(1.0);
    float tha = progress *(1. + (num-1.) * delay);

    vec2 centerPx = iResolution.xy * center;
    vec2 ncenterPx = resetSize(centerPx);
    vec2 nuv = resetSize(uv);
    vec2 dis = nuv - ncenterPx;
    float dist = length(dis) / length(ncenterPx);

    vec4 color = getFromColor(uv);
    for(int i = 0; i < 6; i+=1) {
      float mixRatio = smoothstep(dist-0.015, dist, aasin(tha-delay*float(i)));
        color = mix(color, colors[i], mixRatio);
    }

    if(progress<=0.) return getFromColor(uv);
    return color;
  }
`
  }), colorful;
}
var moveleft, hasRequiredMoveleft;
function requireMoveleft() {
  return hasRequiredMoveleft || (hasRequiredMoveleft = 1, moveleft = {
    name: "MoveLeft",
    paramsTypes: {},
    defaultParams: {},
    glsl: `
  #define PI 3.141592653589793
  #define HALF_PI 1.5707963267948966
    
  float pows(float p){
    return pow(p, 1.6);
  }
  
  float quarticInOut(float t) {
    return t < 0.5
      ? +8.0 * pow(t, 4.0)
      : -8.0 * pow(t - 1.0, 4.0) + 1.0;
  }
  
  float backIn(float t) {
    return pow(t, 3.0) - t * sin(t * PI);
  }
  
  vec4 blurToColor(vec2 uv, float blurSize){
    float invAspect = 1.;
    vec4 col = vec4(0.);
    for(float index = 0.; index < 30.; index++){
      vec2 bl = vec2((index/9. - 0.5) * blurSize * invAspect, 0.);
      vec2 newuv = uv + bl;
      col += getToColor(newuv);
    }
    col = col / 30.;
    return col;
  }
  
  vec4 transition (vec2 uv) {
    vec2 iResolution =vec2(1.0);
    vec2 pos = uv;
    float d = quarticInOut(1.-progress);
    pos.x = uv.x + d;
    //pos.y = zoomIn(uv.y, progress);
    //pos.x = zoomOut(pos.x, progress);
  
    vec4 result;
    vec4 col1 = getFromColor(uv);
    vec4 col2 = blurToColor(pos, .2*d);
  
    result = col2;
    if(uv.x> 1.0 - d){
      result = col1;
    }
    if(pos.x<0.){
      result = col1;
    }
    if(progress>=1.0){
      return getToColor(uv);
    }
  
    return result;
  }
`
  }), moveleft;
}
var sunflower, hasRequiredSunflower;
function requireSunflower() {
  return hasRequiredSunflower || (hasRequiredSunflower = 1, sunflower = {
    name: "Sunflower",
    paramsTypes: {},
    defaultParams: {},
    glsl: `
  const float PI = 3.1415927;
  const float NUM = 8.;

  float getStep(vec2 p, float speed){
    float circPos = atan(p.y - 0.5, p.x - 0.5) + progress * speed;
    float modPos = mod(circPos, PI / NUM);
    float signed = sign(progress - modPos);
    return smoothstep(signed-.2,signed, 0.5);
  }

  vec4 transition(vec2 uv) {
    vec2 p = uv.xy / vec2(1.0).xy;
    vec2 center = vec2(.5);
    float len = length(p-center);
    for(float i=0.;i<=1.;i+=1./20.){
      vec4 color = mix(getToColor(p), getFromColor(p), getStep(p, (1.-i)*6.));
      if(len<i) return color;
    }
  }
`
  }), sunflower;
}
var zoomright, hasRequiredZoomright;
function requireZoomright() {
  return hasRequiredZoomright || (hasRequiredZoomright = 1, zoomright = {
    name: "ZoomRight",
    paramsTypes: {},
    defaultParams: {},
    glsl: `
  const float PI = 3.1415927;

  float triangle(float x) {
    return 1.0 - abs(fract(x) - 0.5) * 2.0;
  }
  float smootherstep(float x) {
    return x * x * x * (x * (x * 6.0 - 15.0) + 10.0);
  }

  float endPosition(float radius, float offset, float rollPosition) {
    float rollLength = radius * 3.141592 / 2.0;
    float onRoll = min(offset + 1.0 - rollPosition, rollLength);
    return rollPosition + radius * sin(onRoll / radius);
  }

  float findRollPosition(float radius, float offset) {
    float lower = 1.0 - radius;
    float upper = 1.0;

    float mid = 0.0;
    for(int i = 0; i < 16; i++) {
      mid = (upper + lower) / 2.0;
      float position = endPosition(radius, offset, mid);
      if(position > 1.0) {
        upper = mid;
      } else {
        lower = mid;
      }
    }
    return mid;
  }

  vec4 transition (vec2 uv) {
      float iTime = progress*PI;
      vec2 iResolution =vec2(1.0);
      vec2 p = uv;
      
      float t = iTime / 5.0;
      float offset = smootherstep(triangle(t));

      float radius = 0.3;
      float flatLength = 1.0 - radius;
      float rollLength = radius * 3.141592 / 2.0;
      float fullLength = flatLength + rollLength;

      offset *= fullLength;
      float rollPosition = findRollPosition(radius, offset);
      float shadow;
      if(p.x < rollPosition) {
          uv.x -= offset;
          shadow = 1.0;
      } else {
          float a = asin((p.x - rollPosition) / radius);
          uv.x = a * radius - offset + rollPosition;
          uv.y = (p.y - 0.5) / (0.4 * cos(a) + 0.6) + 0.5;
          shadow = 0.5 * cos(a) + 0.5;
      }
      
      vec4 fromColor = getFromColor(uv);
      fromColor *= step(-uv.x, 0.0);
      fromColor *= step(-uv.y, 0.0);
      fromColor *= step(uv.y, 1.0);
      fromColor *= shadow;
      
      vec4 result = fromColor;
      vec4 toColor = getToColor(p);
      
      if(result.a<0.3) result = toColor;
      if(progress>1.) return toColor;
      return result;
  }
`,
    author: "https://www.shadertoy.com/view/wssczB",
    createdAt: "Mon, 12 Jun 2020 12:52:34 +0800",
    updatedAt: "Mon, 12 Jun 2020 12:52:34 +0800"
  }), zoomright;
}
var waterwave, hasRequiredWaterwave;
function requireWaterwave() {
  return hasRequiredWaterwave || (hasRequiredWaterwave = 1, waterwave = {
    name: "WaterWave",
    paramsTypes: {},
    defaultParams: {},
    glsl: `
  #define PIS 3.1415926

  vec3 mod289(vec3 x) {
    return x - floor(x * (1.0 / 289.0)) * 289.0;
  }
  vec4 mod289(vec4 x) {
    return x - floor(x * (1.0 / 289.0)) * 289.0;
  }
  vec4 permute(vec4 x) {
    return mod289(((x*34.0)+1.0)*x);
  }
  vec4 taylorInvSqrt(vec4 r){
    return 1.79284291400159 - 0.85373472095314 * r;
  }

  float snoise(vec3 v) {
    const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
    const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);

    vec3 i  = floor(v + dot(v, C.yyy) );
    vec3 x0 =   v - i + dot(i, C.xxx) ;

    vec3 g = step(x0.yzx, x0.xyz);
    vec3 l = 1.0 - g;
    vec3 i1 = min( g.xyz, l.zxy );
    vec3 i2 = max( g.xyz, l.zxy );

    vec3 x1 = x0 - i1 + C.xxx;
    vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y
    vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y

    i = mod289(i);
    vec4 p = permute( permute( permute(
        i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
      + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))
      + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));

    // Gradients: 7x7 points over a square, mapped onto an octahedron.
    // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)
    float n_ = 0.142857142857; // 1.0/7.0
    vec3  ns = n_ * D.wyz - D.xzx;

    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)
    vec4 x_ = floor(j * ns.z);
    vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)

    vec4 x = x_ *ns.x + ns.yyyy;
    vec4 y = y_ *ns.x + ns.yyyy;
    vec4 h = 1.0 - abs(x) - abs(y);

    vec4 b0 = vec4( x.xy, y.xy );
    vec4 b1 = vec4( x.zw, y.zw );

    vec4 s0 = floor(b0)*2.0 + 1.0;
    vec4 s1 = floor(b1)*2.0 + 1.0;
    vec4 sh = -step(h, vec4(0.0));

    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;

    vec3 p0 = vec3(a0.xy,h.x);
    vec3 p1 = vec3(a0.zw,h.y);
    vec3 p2 = vec3(a1.xy,h.z);
    vec3 p3 = vec3(a1.zw,h.w);

    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
    p0 *= norm.x;
    p1 *= norm.y;
    p2 *= norm.z;
    p3 *= norm.w;

    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
    m = m * m;
    return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );
  }

  vec3 curlNoise( vec3 p ){
    const float e = 0.1;
    float  n1 = snoise(vec3(p.x, p.y + e, p.z));
    float  n2 = snoise(vec3(p.x, p.y - e, p.z));
    float  n3 = snoise(vec3(p.x, p.y, p.z + e));
    float  n4 = snoise(vec3(p.x, p.y, p.z - e));
    float  n5 = snoise(vec3(p.x + e, p.y, p.z));
    float  n6 = snoise(vec3(p.x - e, p.y, p.z));

    float x = n2 - n1 - n4 + n3;
    float y = n4 - n3 - n6 + n5;
    float z = n6 - n5 - n2 + n1;

    const float divisor = 1.0 / ( 2.0 * e );
    return normalize( vec3( x , y , z ) * divisor );
  }

  vec4 transition (vec2 uv) {
    float iTime = progress * PIS/2.0;
    float f = sin(iTime) ;
    vec3 curl = curlNoise(vec3(uv,1.) *5. + iTime) / 1.;

    vec4 t0 = getFromColor(vec2(uv.x,uv.y + f * (curl.x) ) );
    vec4 t1 = getToColor(vec2(uv.x,uv.y + (1.-f) * (curl.x) ));
  
    uv.x += curl.x;
    return mix(t0,t1,f);
  }
`,
    author: "https://www.shadertoy.com/view/tdj3W3"
  }), waterwave;
}
var radiation, hasRequiredRadiation;
function requireRadiation() {
  return hasRequiredRadiation || (hasRequiredRadiation = 1, radiation = {
    name: "Radiation",
    paramsTypes: {},
    defaultParams: {},
    glsl: `
  #define MPI 3.14159265
  float cprogress;
  float randomSeed;
  float PHI = 1.61803398874989484820459; 
      
  float LinearTween(float t, float start, float end){
    return t * start + (1. - t) * end;
  }
      
  float quadraticEaseIn(float t, float start, float end){
    return LinearTween(t * t, start, end);
  }
      
  vec4 radialWiggle(vec2 uv){
      vec2 center = vec2(0.5,0.5);
      vec2 toUV = uv - center;
      float distanceFromCenter = length(toUV);
      vec2  normToUV = toUV / distanceFromCenter;
      float angle = (cos(MPI/2.0*cprogress) + MPI) / (0.2 * MPI);
      float offset1 = getFromColor(vec2(angle, fract(cprogress/3. + distanceFromCenter/5. + randomSeed))).x * 3.0 - 1.0;
      float offset2 = offset1 * 2.0 * min(0.3, (1.-cprogress)) * distanceFromCenter;
      offset1 = offset1 * 2.0 * min(0.3, cprogress) * distanceFromCenter;
      
      vec4 c1 = getToColor(fract(center + normToUV * (distanceFromCenter + offset1)));
      vec4 c2 = getFromColor(fract(center + normToUV * (distanceFromCenter + offset2)));
      return mix(c1, c2, cprogress);
  }
      
  vec4 transition (vec2 uv) {
    vec2 iResolution = vec2(1.0);
    randomSeed = MPI ;
    cprogress  = quadraticEaseIn(progress, 0.0, 1.0);
    return radialWiggle(uv);
  }
`
  }), radiation;
}
var quicksand, hasRequiredQuicksand;
function requireQuicksand() {
  return hasRequiredQuicksand || (hasRequiredQuicksand = 1, quicksand = {
    name: "Quicksand",
    paramsTypes: {},
    defaultParams: {},
    glsl: `
  #define M_PI 3.1415926535897932384626433832795

  vec4 transition (vec2 uv) {
    vec4 color1 = getFromColor(uv+(getToColor(uv).rb)*progress);
    return mix(color1, getToColor(uv), progress);
  }
`
  }), quicksand;
}
var magnifier, hasRequiredMagnifier;
function requireMagnifier() {
  return hasRequiredMagnifier || (hasRequiredMagnifier = 1, magnifier = {
    name: "Magnifier",
    paramsTypes: {},
    defaultParams: {},
    glsl: `
  const float PI = 3.1415927;
  const float radius = .3;
  const float width = .35;

  float quarticIn(float t) {
      return pow(t, 4.0);
  }

  float parabola( float x, float k ) {
    return pow( 4. * x * ( 1. - x ), k );
  }

  vec4 transition (vec2 uv) {
    vec2 cuv = (uv - vec2(0.5)) + vec2(0.5);
    vec2 start = vec2(0.5,0.5);
    vec2 aspect = vec2(1.);
    float dt = parabola(progress, 1.);
    float time = quarticIn(progress);
    vec4 bg = getFromColor(fract(cuv+time*0.04));
    float prog = progress*0.66 + bg.g * 0.04;
    float circ = 1. - smoothstep(-width, 0.0, radius * distance(start*aspect, cuv*aspect) - prog*(1.+width));
    float intpl = pow(abs(circ), 1.);

    vec4 t1 = getFromColor((cuv - 0.5) * (1.0 - intpl) + 0.5 ) ;
    vec4 t2 = getToColor((cuv - 0.5) * intpl + 0.5 );
    return mix( t1, t2, intpl );
  }
`
  }), magnifier;
}
var fastswitch, hasRequiredFastswitch;
function requireFastswitch() {
  return hasRequiredFastswitch || (hasRequiredFastswitch = 1, fastswitch = {
    name: "FastSwitch",
    paramsTypes: {},
    defaultParams: {},
    glsl: `
  #define PIS 3.141592653589793

  float sineInOut(float t) {
    return -0.5 * (cos(PIS * t) - 1.0);
  }

  vec4 transition (vec2 uv) {
    vec2 iResolution = vec2(1.0);
    float iTime = progress;

    vec4 _currentImage;
    vec4 _nextImage;
    float dispFactor = sineInOut(iTime * 1.);

    float intensity = 0.3;

    vec4 orig1 = getFromColor(uv);
    vec4 orig2 = getToColor(uv);
    _currentImage = getFromColor(vec2(uv.x, uv.y + dispFactor * (orig2.r * intensity)));
    _nextImage = getToColor(vec2(uv.x, uv.y + (1.0 - dispFactor) * (orig1.r * intensity)));

    vec4 finalTexture = mix(_currentImage, _nextImage, dispFactor);

    return finalTexture;
  }
`
  }), fastswitch;
}
var hangaround, hasRequiredHangaround;
function requireHangaround() {
  return hasRequiredHangaround || (hasRequiredHangaround = 1, hangaround = {
    name: "HangAround",
    paramsTypes: {},
    defaultParams: {},
    glsl: `
  vec2 direction = vec2(-1.0, 0.0);
  const float PI = 3.1415927;

  float backIn(float t) {
    return pow(t, 3.0) - t * sin(t * PI);
  }

  float backOut(float t) {
    float f = 1.0 - t;
    return 1.0 - (pow(f, 3.0) - f * sin(f * PI));
  }

  vec4 transition(vec2 uv) {
    for(float i=0.;i<=1.1;i+=1./40.){
      float d = .3;
      float k = 1./d;
      float ds = i*(1.-d)/10.;
      float time = k*(progress-ds);
      time = clamp(time,0.,1.);
      //time = pow(time, .7);
      time = backOut(time);

      vec2 p = uv + time * sign(direction);
      vec2 f = fract(p);
      vec4 color = mix(
        getToColor(f),
        getFromColor(f),
        step(0.0, p.x) * step(p.y, 1.0) * step(0.0, p.x) * step(p.x, 1.0)
      );

      if((1.-uv.y)<=i) return color;
    }
  }
`
  }), hangaround;
}
var circlecrop, hasRequiredCirclecrop;
function requireCirclecrop() {
  return hasRequiredCirclecrop || (hasRequiredCirclecrop = 1, circlecrop = {
    name: "CircleCrop",
    paramsTypes: { bgcolor: "vec4" },
    defaultParams: { bgcolor: [0, 0, 0, 1] },
    glsl: `
  uniform vec4 bgcolor; // = vec4(0.0, 0.0, 0.0, 1.0)

  vec2 ratio2 = vec2(1.0, 1.0 / ratio);
  float s = pow(2.0 * abs(progress - 0.5), 3.0);

  vec4 transition(vec2 p) {
    float dist = length((vec2(p) - 0.5) * ratio2);

    return mix(
      progress < 0.5 ? getFromColor(p) : getToColor(p),
      bgcolor,
      smoothstep(s, s+0.01, dist)
    );
  }
`
  }), circlecrop;
}
var windowshades, hasRequiredWindowshades;
function requireWindowshades() {
  return hasRequiredWindowshades || (hasRequiredWindowshades = 1, windowshades = {
    name: "WindowShades",
    paramsTypes: {},
    defaultParams: {},
    glsl: `
  float getSpeed(float t, float speed){
    float d = 0.7*speed;
    float k = 1./(1.-d);
    float b = -1./(1.-d)*d;
    float y = k*t+b; 
    y = clamp(y, 0., 1.);
    return y*y;
  }

  vec4 transition (vec2 uv) {
    vec2 iResolution = vec2(1.0);
    float t = progress;
      
    vec4 result = getToColor(uv);
    vec4 result2 = getToColor(uv);
    vec2 translate = vec2(uv.x,uv.y);
        
    float div = 2.0;
    float num = 20.0;
    float fy = floor(uv.y * num);
    float odd = fy - (div * floor(fy/div));
    float speed = (fy/num);
      
    if( odd == 0.0){
      translate.x = translate.x - getSpeed(t, speed);    
      result = getFromColor(translate);
      if(translate.x<0.0){
        result.rgb = result2.rgb;
      }
    }else{
      translate.x = translate.x + getSpeed(t, speed);    
      result = getFromColor(translate);
      if(translate.x>1.0){
        result.rgb = result2.rgb;
      }
    }
    
    return result;
  }
`
  }), windowshades;
}
var tricolorcircle, hasRequiredTricolorcircle;
function requireTricolorcircle() {
  return hasRequiredTricolorcircle || (hasRequiredTricolorcircle = 1, tricolorcircle = {
    name: "TricolorCircle",
    paramsTypes: {},
    defaultParams: {},
    glsl: `
  #define D120 2.09439510239
  #define D240 4.18879020479
      
  bool inEllipse(vec3 circle, vec2 point){
    float a,b;
    if(ratio>1.){
      a = circle.z; 
      b = circle.z*ratio;
    }else{
      a = circle.z / ratio; 
      b = circle.z;
    }
    float aa = a*a;
    float bb = b*b;
    float xx = pow(point.x-circle.x, 2.0);
    float yy = pow(point.y-circle.y, 2.0);
    
    if(xx/aa + yy/bb <= 1.0)
      return true; 
    return false;
  }
      
  vec4 transition (vec2 uv) {
    vec2 iResolution = vec2(1.0);
    vec2 po = uv.xy;
    vec2 sc = vec2(0.5);   
    float r = progress;       //Radius
    float d = 0.3;            //Distance
    float a = progress * 4.0; //Angle progress

    vec3 rC = vec3(sc.x + d * sin(a),         sc.y + d * cos(a),      r);
    vec3 gC = vec3(sc.x + d * sin(a + D120),  sc.y + d * cos(a + D120),   r);
    vec3 bC = vec3(sc.x + d * sin(a + D240),  sc.y + d * cos(a + D240),   r);

    vec4 col1 = getFromColor(uv);
    vec4 col0 = getToColor(uv);

    if(!inEllipse(rC, po))
      col0.r = col1.r;
    if(!inEllipse(gC, po))
      col0.g = col1.g;
    if(!inEllipse(bC, po))
      col0.b = col1.b;
      
    if(progress>=1.0) return col0;
    return col0;
  }
`,
    author: "https://www.shadertoy.com/view/WdsyRX"
  }), tricolorcircle;
}
var shader, hasRequiredShader;
function requireShader() {
  if (hasRequiredShader) return shader;
  hasRequiredShader = 1;
  const i2 = requireSample(), e = requireForEach(), t = requireGlTransitions(), r = requireCube(), a = requireFat(), s = requireLens(), u = requireSlice(), l = requireShake(), c = requireStretch(), d = requireBackoff(), f = requireFluidly(), p = requireOblique(), m = requireWindows4(), y = requireTetrapod(), x = requireColorful(), g = requireMoveleft(), _ = requireSunflower(), T = requireZoomright(), E = requireWaterwave(), b = requireRadiation(), C = requireQuicksand(), w = requireMagnifier(), A = requireFastswitch(), S = requireHangaround(), F = requireCirclecrop(), M = requireWindowshades(), U = requireTricolorcircle(), B = [
    r,
    a,
    s,
    l,
    u,
    c,
    f,
    d,
    p,
    g,
    m,
    x,
    w,
    y,
    _,
    T,
    b,
    E,
    S,
    A,
    M,
    F,
    U,
    C
  ];
  return shader = {
    /**
     * Get the shader source code by name
     * @param {string} name - shader name
     * @return {string} shader source
     * @public
     */
    getShaderByName(q) {
      let z = this.getFromArr(q, B);
      return z || (z = this.getFromArr(q, t)), !z && q.toLowerCase() == "random" && (z = this.getRandomShader()), z || (z = this.getFromArr("fade", t)), z;
    },
    getFromArr(q, z) {
      let D;
      return e(z, (X) => {
        X.name.toLowerCase() == q.toLowerCase() && (D = X);
      }), D;
    },
    getRandomShader() {
      return i2(t);
    }
  }, shader;
}
var transition, hasRequiredTransition;
function requireTransition() {
  if (hasRequiredTransition) return transition;
  hasRequiredTransition = 1, requireBuffer();
  const i2 = requireTexture(), e = requireClip(), t = requireGl(), r = requireShader(), { createCanvas: a, createImageData: s, Texture: u, Sprite: l, RenderTexture: c } = requireLib$2();
  requireCanvas();
  const { isBrowser: d } = requireLib$5(), f = requireMd5(), p = requireRender();
  class m extends e {
    constructor(x) {
      super({ type: "trans", duration: 1, ...x }), this.key = this.conf.key;
    }
    get name() {
      return this.conf.name;
    }
    get uuid() {
      return f(`${this.key}-${JSON.stringify(this.params)}`).substring(0, 16);
    }
    set fit(x) {
      this.conf.fit = !!x;
    }
    get fit() {
      return !!this.conf.fit;
    }
    createDisplay() {
      this.display = new l(u.fromCanvas(a(1, 1)));
    }
    refresh(x) {
      var g, _;
      if (!this.parent)
        this.prevSibling = null, this.nextSibling = null;
      else if (this.parent.type !== "spine") {
        const A = this.prevRefId && this.prevRefId != this.refId ? this.root().getByRefId(this.prevRefId) : null;
        A && (this.prevSibling = A, this.prevSibling.nextSibling = this);
        const S = this.nextRefId && this.nextRefId != this.refId ? this.root().getByRefId(this.nextRefId) : null;
        S && S != this.prevSibling && (this.nextSibling = S, this.nextSibling.prevSibling = this);
      }
      if (!this.display) return;
      let T, E;
      this.conf.fit && (T = (g = this.prevSibling) != null && g.display ? this.prevSibling.display.getBounds() : null, E = (_ = this.nextSibling) != null && _.display ? this.nextSibling.display.getBounds() : null);
      const b = T || E;
      T && E && b.enlarge(E);
      const [C, w] = [this.rootConf("width"), this.rootConf("height")];
      this.display.width = b ? b.width : C, this.display.height = b ? b.height : w, this.display.x = b ? b.left : 0, this.display.y = b ? b.top : 0, this.filter.params = this.conf.params || {}, this.filter.offset = [
        -(C * 0.5 - (this.display.x + this.display.width * 0.5)) / C,
        (w * 0.5 - (this.display.y + this.display.height * 0.5)) / w
      ];
    }
    async preProcessing() {
      const x = this.rootConf("width"), g = this.rootConf("height");
      this.createTransitionFilter(this.key), this.render = this.creator().app.renderer, this.filter.ratio = x / g, this.prevTexture = c.create(x, g), this.nextTexture = c.create(x, g), this.filter.prev = new l(this.prevTexture), this.filter.next = new l(this.nextTexture);
    }
    async prepareMaterial() {
      this.refresh();
    }
    createTransitionFilter(x) {
      const g = r.getShaderByName(x);
      this.filter = this.display.setTransition(g);
    }
    annotate() {
      var x, g;
      this._duration = this.duration, this._absStartTime = this.absStartTime, this._absEndTime = this._absStartTime + this._duration, this.addTimelineCallback(), this.onTime = (_) => {
        const T = _ >= this._absStartTime && _ < this._absEndTime;
        return T ? this.show() : this.hide(), T;
      }, this.zIndex = Math.max(((x = this.prevSibling) == null ? void 0 : x.zIndex) || 0, ((g = this.nextSibling) == null ? void 0 : g.zIndex) || 0) + 1, this.display && (this.display.zIndex = this.zIndex);
    }
    get prevRefId() {
      return this.conf.prevRefId;
    }
    set prevRefId(x) {
      this.conf.prevRefId = x;
    }
    get nextRefId() {
      return this.conf.nextRefId;
    }
    set nextRefId(x) {
      this.conf.nextRefId = x;
    }
    get default() {
      var x;
      return {
        startTime: ((x = this.prevSibling) == null ? void 0 : x.endTime) || 0,
        duration: 1
      };
    }
    get duration() {
      let x = this.time(this.conf.duration);
      return isNaN(x) ? this.time(this.default.duration) : x;
    }
    get startTime() {
      return this.prevSibling ? Math.max(0, this.relativeEndTime - this.duration * 0.5 || 0) : super.startTime;
    }
    get endTime() {
      return this.prevSibling ? Math.max(0, this.relativeEndTime || 0) : super.startTime;
    }
    get relativeEndTime() {
      var x;
      return ((x = this.prevSibling) == null ? void 0 : x.absEndTime) - this.parent.absStartTime;
    }
    async drawing(x = 0, g = 0) {
      if (!this.display) return false;
      const _ = x * 1e-3;
      return this.onTime(_) ? (this.prevSibling && this.prevSibling.display && this.render.render(this.prevSibling.display, this.prevTexture), this.nextSibling && this.nextSibling.display && this.render.render(this.nextSibling.display, this.nextTexture), this.filter.updateProgress((_ - this._absStartTime) / this._duration), true) : false;
    }
    async getDisplay(x, g) {
      const _ = await this.getPreview(x, { ...g, format: "canvas" });
      if (!_) throw new Error("null");
      return new l(u.fromCanvas(_));
    }
    async getPreview(x, g) {
      var _, T;
      const E = await ((_ = this.prevSibling) == null ? void 0 : _.getDisplay(x, { timing: "abs" })), b = await ((T = this.nextSibling) == null ? void 0 : T.getDisplay(x, { timing: "abs" })), C = await this._render({ prevDisplay: E, nextDisplay: b, time: x }), { width: w, height: A } = this, S = a(w, A), F = S.getContext("2d");
      C && F.putImageData(C, 0, 0);
      const M = { x: 0, y: 0, w, h: A };
      return this.subImage(S, M, g);
    }
    async getSnapshotBuffer(x) {
      var g;
      if (!x) return;
      (g = x == null ? void 0 : x.texture) != null && g.baseTexture && x.texture.baseTexture.update();
      const _ = d ? "canvas" : "raw";
      return await p.getView("trans", x, this.creator(), { type: _ });
    }
    /**
     * Rendering function
     * @private
     */
    async _render({ prevDisplay: x, nextDisplay: g, time: _ }) {
      const T = (_ - this._absStartTime) / this._duration, E = "raw", { gl: b, transition: C, params: w } = this, A = b.drawingBufferWidth, S = b.drawingBufferHeight, F = await this.getSnapshotBuffer(x) || new Int16Array(A * S * 4), M = await this.getSnapshotBuffer(g) || new Int16Array(A * S * 4);
      b.clear(b.COLOR_BUFFER_BIT);
      const U = await t.getPixels({ type: E, data: F, width: A, height: S }), B = await t.getPixels({ type: E, data: M, width: A, height: S }), q = i2(b, U);
      q.minFilter = b.LINEAR, q.magFilter = b.LINEAR;
      const z = i2(b, B);
      z.minFilter = b.LINEAR, z.magFilter = b.LINEAR, C.draw(T, q, z, A, S, w), q.dispose(), z.dispose();
      const D = t.getPixelsByteArray({ gl: b, width: A, height: S, flip: true });
      return s(new Uint8ClampedArray(D.buffer), A, S);
    }
    destroy() {
      var x, g, _, T, E, b;
      (x = this.buffer) == null || x.dispose(), (g = this.transition) == null || g.dispose(), this.gl = null, this.source = null, this.buffer = null, this.transition = null, this.prevTexture = null, this.nextTexture = null, (T = (_ = this.filter) == null ? void 0 : _.prev) == null || T.destroy(), (b = (E = this.filter) == null ? void 0 : E.next) == null || b.destroy(), this.filter = null, this.render = null, super.destroy();
    }
  }
  return transition = m, transition;
}
var dist = {}, hasRequiredDist;
function requireDist() {
  if (hasRequiredDist) return dist;
  hasRequiredDist = 1, Object.defineProperty(dist, "__esModule", { value: true });
  function i2(D, X, k, I) {
    return k * (D /= I) * D + X;
  }
  dist.easeInQuad = i2;
  function e(D, X, k, I) {
    return -k * (D /= I) * (D - 2) + X;
  }
  dist.easeOutQuad = e;
  function t(D, X, k, I) {
    return (D /= I / 2) < 1 ? k / 2 * D * D + X : -k / 2 * (--D * (D - 2) - 1) + X;
  }
  dist.easeInOutQuad = t;
  function r(D, X, k, I) {
    return k * (D /= I) * D * D + X;
  }
  dist.easeInCubic = r;
  function a(D, X, k, I) {
    return k * ((D = D / I - 1) * D * D + 1) + X;
  }
  dist.easeOutCubic = a;
  function s(D, X, k, I) {
    return (D /= I / 2) < 1 ? k / 2 * D * D * D + X : k / 2 * ((D -= 2) * D * D + 2) + X;
  }
  dist.easeInOutCubic = s;
  function u(D, X, k, I) {
    return k * (D /= I) * D * D * D + X;
  }
  dist.easeInQuart = u;
  function l(D, X, k, I) {
    return -k * ((D = D / I - 1) * D * D * D - 1) + X;
  }
  dist.easeOutQuart = l;
  function c(D, X, k, I) {
    return (D /= I / 2) < 1 ? k / 2 * D * D * D * D + X : -k / 2 * ((D -= 2) * D * D * D - 2) + X;
  }
  dist.easeInOutQuart = c;
  function d(D, X, k, I) {
    return k * (D /= I) * D * D * D * D + X;
  }
  dist.easeInQuint = d;
  function f(D, X, k, I) {
    return k * ((D = D / I - 1) * D * D * D * D + 1) + X;
  }
  dist.easeOutQuint = f;
  function p(D, X, k, I) {
    return (D /= I / 2) < 1 ? k / 2 * D * D * D * D * D + X : k / 2 * ((D -= 2) * D * D * D * D + 2) + X;
  }
  dist.easeInOutQuint = p;
  function m(D, X, k, I) {
    return -k * Math.cos(D / I * (Math.PI / 2)) + k + X;
  }
  dist.easeInSine = m;
  function y(D, X, k, I) {
    return k * Math.sin(D / I * (Math.PI / 2)) + X;
  }
  dist.easeOutSine = y;
  function x(D, X, k, I) {
    return -k / 2 * (Math.cos(Math.PI * D / I) - 1) + X;
  }
  dist.easeInOutSine = x;
  function g(D, X, k, I) {
    return D === 0 ? X : k * Math.pow(2, 10 * (D / I - 1)) + X;
  }
  dist.easeInExpo = g;
  function _(D, X, k, I) {
    return D === I ? X + k : k * (-Math.pow(2, -10 * D / I) + 1) + X;
  }
  dist.easeOutExpo = _;
  function T(D, X, k, I) {
    return D === 0 ? X : D === I ? X + k : (D /= I / 2) < 1 ? k / 2 * Math.pow(2, 10 * (D - 1)) + X : k / 2 * (-Math.pow(2, -10 * --D) + 2) + X;
  }
  dist.easeInOutExpo = T;
  function E(D, X, k, I) {
    return -k * (Math.sqrt(1 - (D /= I) * D) - 1) + X;
  }
  dist.easeInCirc = E;
  function b(D, X, k, I) {
    return k * Math.sqrt(1 - (D = D / I - 1) * D) + X;
  }
  dist.easeOutCirc = b;
  function C(D, X, k, I) {
    return (D /= I / 2) < 1 ? -k / 2 * (Math.sqrt(1 - D * D) - 1) + X : k / 2 * (Math.sqrt(1 - (D -= 2) * D) + 1) + X;
  }
  dist.easeInOutCirc = C;
  function w(D, X, k, I) {
    var P = 1.70158, G = 0, W = k;
    return D === 0 ? X : (D /= I) === 1 ? X + k : (G || (G = I * 0.3), W < Math.abs(k) ? (W = k, P = G / 4) : P = G / (2 * Math.PI) * Math.asin(k / W), -(W * Math.pow(2, 10 * (D -= 1)) * Math.sin((D * I - P) * (2 * Math.PI) / G)) + X);
  }
  dist.easeInElastic = w;
  function A(D, X, k, I) {
    var P = 1.70158, G = 0, W = k;
    return D === 0 ? X : (D /= I) === 1 ? X + k : (G || (G = I * 0.3), W < Math.abs(k) ? (W = k, P = G / 4) : P = G / (2 * Math.PI) * Math.asin(k / W), W * Math.pow(2, -10 * D) * Math.sin((D * I - P) * (2 * Math.PI) / G) + k + X);
  }
  dist.easeOutElastic = A;
  function S(D, X, k, I) {
    var P = 1.70158, G = 0, W = k;
    return D === 0 ? X : (D /= I / 2) === 2 ? X + k : (G || (G = I * (0.3 * 1.5)), W < Math.abs(k) ? (W = k, P = G / 4) : P = G / (2 * Math.PI) * Math.asin(k / W), D < 1 ? -0.5 * (W * Math.pow(2, 10 * (D -= 1)) * Math.sin((D * I - P) * (2 * Math.PI) / G)) + X : W * Math.pow(2, -10 * (D -= 1)) * Math.sin((D * I - P) * (2 * Math.PI) / G) * 0.5 + k + X);
  }
  dist.easeInOutElastic = S;
  function F(D, X, k, I, P) {
    return P === void 0 && (P = 1.70158), k * (D /= I) * D * ((P + 1) * D - P) + X;
  }
  dist.easeInBack = F;
  function M(D, X, k, I, P) {
    return P === void 0 && (P = 1.70158), k * ((D = D / I - 1) * D * ((P + 1) * D + P) + 1) + X;
  }
  dist.easeOutBack = M;
  function U(D, X, k, I, P) {
    return P === void 0 && (P = 1.70158), (D /= I / 2) < 1 ? k / 2 * (D * D * (((P *= 1.525) + 1) * D - P)) + X : k / 2 * ((D -= 2) * D * (((P *= 1.525) + 1) * D + P) + 2) + X;
  }
  dist.easeInOutBack = U;
  function B(D, X, k, I) {
    return k - q(I - D, 0, k, I) + X;
  }
  dist.easeInBounce = B;
  function q(D, X, k, I) {
    return (D /= I) < 1 / 2.75 ? k * (7.5625 * D * D) + X : D < 2 / 2.75 ? k * (7.5625 * (D -= 1.5 / 2.75) * D + 0.75) + X : D < 2.5 / 2.75 ? k * (7.5625 * (D -= 2.25 / 2.75) * D + 0.9375) + X : k * (7.5625 * (D -= 2.625 / 2.75) * D + 0.984375) + X;
  }
  dist.easeOutBounce = q;
  function z(D, X, k, I) {
    return D < I / 2 ? B(D * 2, 0, k, I) * 0.5 + X : q(D * 2 - I, 0, k, I) * 0.5 + k * 0.5 + X;
  }
  return dist.easeInOutBounce = z, dist;
}
var keyFrame, hasRequiredKeyFrame;
function requireKeyFrame() {
  if (hasRequiredKeyFrame) return keyFrame;
  hasRequiredKeyFrame = 1;
  const i2 = requireDist();
  class e {
    constructor({ startTime: a, endTime: s, from: u, to: l, key: c, func: d }) {
      this.startTime = a !== void 0 ? a : 0, this.endTime = s, this.from = u !== void 0 ? u : l, this.to = l, this.key = c, this.func = d && i2[d] || this.default;
    }
    default(a, s, u, l) {
      return s + u * (a / l);
    }
    get(a, s) {
      const u = (this.endTime - this.startTime) / s;
      return this.func((a - this.startTime / s) * 1e3, this.from, this.to - this.from, u * 1e3);
    }
  }
  class t {
    constructor(a) {
      this.conf = a, this.keyFrames = {}, this.parse();
    }
    /**
     *
     * @param key 需要关键帧动画变化的key
     * @param value 关键帧动画的值, 例如x为300
     * @param index 关键帧的index
     * @param time 关键帧的时间
     * @param func 关键帧动画func的名字
     * @returns {KeyFrame}
     */
    keyFrame(a, s, u, l, c) {
      var d;
      const f = this.conf[u - 1] && this.conf[u - 1][a], p = { startTime: (d = this.conf[u - 1]) == null ? void 0 : d.time, endTime: l, to: s, key: a, from: f, func: c };
      return new e(p);
    }
    parse() {
      return this.conf.sort((a, s) => a.time - s.time).map((a, s) => {
        Object.entries(a).forEach((u) => {
          const [l, c] = u;
          if (l === "time" || l === "innerHTML") return;
          const d = this.keyFrame(l, c, s, a.time, a.easing);
          this.keyFrames[l] || (this.keyFrames[l] = []), this.keyFrames[l].push(d);
        });
      });
    }
    update(a) {
      this.conf = a, this.parse();
    }
    renderAttr(a, s) {
      const u = {}, l = s.speed || 1;
      for (let [c, d] of Object.entries(this.keyFrames)) {
        let f;
        for (const p of d)
          if (a >= p.startTime / l && a <= p.endTime / l) {
            f = p.get(a, l);
            break;
          }
        if (f === void 0 && d.length > 0 && (a < d[0].startTime / l ? f = d[0].from : f = d[d.length - 1].to), f !== void 0) {
          const { relative: p, key: m, value: y } = s.toAbs(c, f);
          if (u[m] !== void 0 && p) continue;
          u[m] = y;
        }
      }
      return u;
    }
  }
  return keyFrame = t, keyFrame;
}
var node, hasRequiredNode;
function requireNode() {
  if (hasRequiredNode) return node;
  hasRequiredNode = 1;
  const FFClip = requireClip(), { BLEND_MODES } = requireLib$2(), KeyFrames = requireKeyFrame(), _FFNode = class ____FFNode extends FFClip {
    /**
     * FFNode constructor
     *
     * @constructor
     * @param {object} conf - FFNode related configuration items
     * @param {number} conf.x - x coordinate of FFNode
     * @param {number} conf.y - y coordinate of FFNode
     * @param {number} conf.scale - scale of FFNode
     * @param {number} conf.rotate - rotation of FFNode
     * @param {number} conf.opacity - opacity of FFNode
     * @param {object} conf.keyframes - keyframes of FFNode
     */
    constructor(i2 = {}) {
      super({ type: "node", ...i2 }), this.preload = !!i2.preload, this.setScale(this.confAttr.scale || 1), this.updateAttr(), i2.width && (this.conf.width = this.vu(i2.width)), i2.height && (this.conf.height = this.vu(i2.height)), i2.keyframes && (this.keyFrame = new KeyFrames(i2.keyframes));
    }
    updateMaterialTime() {
    }
    get confAttr() {
      const i2 = { ...this.conf };
      return i2.width = this.px(i2.width), i2.height = this.px(i2.height), i2.x = this.px(i2.x), i2.y = this.px(i2.y), i2.scale = this.initScale || 1, i2.rotation = i2.rotation !== void 0 ? Number(i2.rotation) : 0, i2.opacity = i2.opacity !== void 0 ? Number(i2.opacity) : 1, i2.speed = i2.speed !== void 0 ? Number(i2.speed) : 1, i2;
    }
    set audio(i2) {
    }
    get audio() {
      return false;
    }
    get blend() {
      return this.conf.blend || "NORMAL";
    }
    keyFrameAttr(i2, e) {
      return this.keyFrame.renderAttr(i2, e);
    }
    parseAudioMotion() {
      if (!this.confAttr.amotion) return;
      const attr = {};
      this.creator().audioData;
      const aMotion = { ...this.confAttr.amotion };
      for (let [key, value] of Object.entries(aMotion)) {
        const results = value.match(new RegExp("(?<={)(.*?)(?=})", "g"));
        if (results) {
          for (const i2 of results)
            value = value.replace(`{${i2}}`, `audioData['${i2}']`);
          attr[key] = eval(value);
        }
      }
      return attr;
    }
    /**
     * 用于将conf中d-开头的相对值转为绝对值
     * @param key
     * @param newValue
     * @param _attr 作为相对基准的attr
     * @returns {{value: number, key: string, relative: boolean}}
     */
    toAbs(i2, e, t = null) {
      let r = t && t[i2] !== void 0 ? t[i2] : this.confAttr[i2], a, s = false;
      if (i2.includes("d-")) {
        i2 = i2.replace("d-", "");
        let u = t && t[i2] !== void 0 ? t[i2] : this.confAttr[i2];
        s = true, ____FFNode.D_LIST.includes(i2) ? a = u * e : a = u + e;
      } else
        ____FFNode.D_LIST.includes(i2) ? a = r * e : a = e;
      return { relative: s, key: i2, value: a };
    }
    async drawing(i2, e) {
      var t;
      const r = await super.drawing(i2, e), a = {};
      if (r && this.keyFrame) {
        const s = i2 / 1e3 - this.absStartTime, u = this.keyFrameAttr(s, this);
        Object.assign(a, u);
      }
      if (r && (t = this.confAttr) != null && t.amotion) {
        const s = this.parseAudioMotion();
        for (const [u, l] of Object.entries(s)) {
          const { relative: c, key: d, value: f } = this.toAbs(u, l, a);
          a[d] !== void 0 && c || (a[d] = f);
        }
      }
      return Object.keys(a).length > 0 ? (this.display && this.display.attr(a), this.animationAttr = a) : this.animationAttr = null, r;
    }
    refresh() {
      this.updateAttr();
    }
    updateAttr() {
      const { x: i2 = 0, y: e = 0, rotate: t = 0, opacity: r = 1, anchor: a = 0.5, blend: s, flipX: u = false, flipY: l = false } = this.confAttr;
      this.setXY(i2, e), this.setRotate(t), this.setAnchor(a), this.addBlend(s), this.setChromaKey(), this.setColor(), this.setOpacity(r), this.setFlip({ flipX: u, flipY: l });
    }
    show() {
      super.show();
    }
    hide() {
      super.hide();
    }
    /**
     * Set display object registration center
     * @param {number} anchor
     * @public
     */
    setAnchor(i2, e) {
      var t;
      (t = this.display) != null && t.anchor && (Array.isArray(i2) && (e = i2[1], i2 = i2[0]), e = e === void 0 ? i2 : e, this.display.anchor.set(i2, e), i2 == 0.5 && e == 0.5 ? delete this.conf.anchor : this.conf.anchor = [i2, e]);
    }
    /**
     * Set display object scale
     * @param {number} scale
     * @public
     */
    setScale(i2 = 1) {
      isNaN(i2) || !this.display || (this.scale = i2, this.display.scale.set(i2, i2), this.initScale = this.display.scale.x);
    }
    /**
     * Set display object rotation
     * @param {number} rotation
     * @public
     */
    setRotate(i2 = 0) {
      isNaN(i2) || !this.display || (Math.abs(i2) < 1e-4 && (i2 = 0), this.display.rotation = i2, i2 === 0 ? delete this.conf.rotate : this.conf.rotate = i2);
    }
    /**
     * Set the duration of node in the scene
     * @param {number} duration
     * @public
     */
    setDuration(i2) {
      this.duration = i2;
    }
    /**
     * Set display object x,y position
     * @param {number} x - x position
     * @param {number} y - y position
     * @public
     */
    setXY(i2 = 0, e = 0) {
      this.display && (this.display.x = this.px(i2), this.display.y = this.px(e), this.setConfRpx("x", this.display.x), this.setConfRpx("y", this.display.y));
    }
    set opacity(i2) {
      this.display && (this.display.alpha = i2, i2 === 1 ? delete this.conf.opacity : this.conf.opacity = i2);
    }
    get opacity() {
      return this.confAttr.opacity;
    }
    /**
     * Set display object width and height
     * @param {number} width - object width
     * @param {number} height - object height
     * @public
     */
    setWH(i2, e) {
      this.setSize(i2, e);
    }
    /**
     * Set display object width and height
     * @param {number} width - object width
     * @param {number} height - object height
     * @public
     */
    setSize(i2, e) {
      this.setConfRpx("width", i2), this.setConfRpx("height", e);
    }
    /**
     * Add blend filter
     * @param {boolean} blend - blend filter mode
     * @public
     */
    addBlend(i2 = "") {
      const e = BLEND_MODES[i2.toUpperCase()];
      e && (this.display.blendMode = e);
    }
    setOpacity(i2) {
      this.opacity = i2;
    }
    setFlip({ flipX: i2, flipY: e }) {
      var t;
      (t = this.display) == null || t.setFlip(i2, e);
    }
    setColor() {
      let i2 = this.confAttr.color;
      if (!Array.isArray(i2))
        if (i2 != null && i2.key) i2 = [i2];
        else {
          this.display && this.display.setColorMatrix(null);
          return;
        }
      const e = isNaN(this.confAttr.colorAlpha) ? 1 : Number(this.confAttr.colorAlpha);
      this.display.setColorMatrix(i2, Math.min(1, Math.max(e, 0)));
    }
    setChromaKey() {
      const { chromaKey: i2, chromaSimilarity: e, chromaSmoothness: t, chromaSaturation: r, chromaShadowness: a } = this;
      if (!i2 || !this.display) {
        this.display && (this.display.chroma = null);
        return;
      }
      this.display.chroma = {
        color: i2,
        similarity: e,
        smoothness: t,
        saturation: r,
        shadowness: a
      };
    }
    get chromaKey() {
      return this.confAttr.chromaKey;
    }
    get chromaSimilarity() {
      return this.confAttr.chromaSimilarity || 0.2;
    }
    get chromaSmoothness() {
      return this.confAttr.chromaSmoothness || 0.1;
    }
    get chromaSaturation() {
      return this.confAttr.chromaSaturation || 0.1;
    }
    get chromaShadowness() {
      return this.confAttr.chromaShadowness || 0.1;
    }
    get rotate() {
      return this.getRotation();
    }
    get rotation() {
      return this.getRotation();
    }
    get x() {
      return this.getX();
    }
    get y() {
      return this.getY();
    }
    get width() {
      return this.getWidth();
    }
    get height() {
      return this.getHeight();
    }
    get anchorX() {
      return this.getAnchor().x;
    }
    get anchorY() {
      return this.getAnchor().y;
    }
    getAnchor() {
      return this.display.anchor;
    }
    getRotation() {
      return this.display.rotation || 0;
    }
    /**
     * Get display object x position
     * @return {number} x
     * @public
     */
    getX() {
      return this.display.x;
    }
    /**
     * Get display object y position
     * @return {number} y
     * @public
     */
    getY() {
      return this.display.y;
    }
    getXY() {
      return [this.display.x, this.display.y];
    }
    /**
     * Get display object width and height
     * @return {array} [width, height]
     * @public
     */
    getWH() {
      const { width: i2 = 0, height: e = 0 } = this.confAttr;
      return i2 && e ? [i2, e] : [this.display.width, this.display.height];
    }
    getWidth() {
      return this.getWH()[0];
    }
    getHeight() {
      return this.getWH()[1];
    }
    getProp(i2) {
      return this.display[i2];
    }
    fitSize() {
      let { width: i2, height: e } = this.confAttr;
      this.display && this.display.attr({ width: i2, height: e });
    }
    fitTexture() {
    }
    /**
     * Destroy the component
     * @public
     */
    destroy() {
      super.destroy(), this.display = null, this.parent = null;
    }
  };
  hv(_FFNode, "D_LIST", ["scale", "opacity"]);
  let FFNode = _FFNode;
  return node = FFNode, node;
}
function _typeof(i2) {
  "@babel/helpers - typeof";
  return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof = function(e) {
    return typeof e;
  } : _typeof = function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, _typeof(i2);
}
function _classCallCheck(i2, e) {
  if (!(i2 instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
var mulTable = [512, 512, 456, 512, 328, 456, 335, 512, 405, 328, 271, 456, 388, 335, 292, 512, 454, 405, 364, 328, 298, 271, 496, 456, 420, 388, 360, 335, 312, 292, 273, 512, 482, 454, 428, 405, 383, 364, 345, 328, 312, 298, 284, 271, 259, 496, 475, 456, 437, 420, 404, 388, 374, 360, 347, 335, 323, 312, 302, 292, 282, 273, 265, 512, 497, 482, 468, 454, 441, 428, 417, 405, 394, 383, 373, 364, 354, 345, 337, 328, 320, 312, 305, 298, 291, 284, 278, 271, 265, 259, 507, 496, 485, 475, 465, 456, 446, 437, 428, 420, 412, 404, 396, 388, 381, 374, 367, 360, 354, 347, 341, 335, 329, 323, 318, 312, 307, 302, 297, 292, 287, 282, 278, 273, 269, 265, 261, 512, 505, 497, 489, 482, 475, 468, 461, 454, 447, 441, 435, 428, 422, 417, 411, 405, 399, 394, 389, 383, 378, 373, 368, 364, 359, 354, 350, 345, 341, 337, 332, 328, 324, 320, 316, 312, 309, 305, 301, 298, 294, 291, 287, 284, 281, 278, 274, 271, 268, 265, 262, 259, 257, 507, 501, 496, 491, 485, 480, 475, 470, 465, 460, 456, 451, 446, 442, 437, 433, 428, 424, 420, 416, 412, 408, 404, 400, 396, 392, 388, 385, 381, 377, 374, 370, 367, 363, 360, 357, 354, 350, 347, 344, 341, 338, 335, 332, 329, 326, 323, 320, 318, 315, 312, 310, 307, 304, 302, 299, 297, 294, 292, 289, 287, 285, 282, 280, 278, 275, 273, 271, 269, 267, 265, 263, 261, 259], shgTable = [9, 11, 12, 13, 13, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24];
function processImage(i2, e, t, r, a, s) {
  if (typeof i2 == "string" && (i2 = document.getElementById(i2)), !(!i2 || Object.prototype.toString.call(i2).slice(8, -1) === "HTMLImageElement" && !("naturalWidth" in i2))) {
    var u = a ? "offset" : "natural", l = i2[u + "Width"], c = i2[u + "Height"];
    if (Object.prototype.toString.call(i2).slice(8, -1) === "ImageBitmap" && (l = i2.width, c = i2.height), typeof e == "string" && (e = document.getElementById(e)), !(!e || !("getContext" in e))) {
      s || (e.style.width = l + "px", e.style.height = c + "px"), e.width = l, e.height = c;
      var d = e.getContext("2d");
      d.clearRect(0, 0, l, c), d.drawImage(i2, 0, 0, i2.naturalWidth, i2.naturalHeight, 0, 0, l, c), !(isNaN(t) || t < 1) && (r ? processCanvasRGBA(e, 0, 0, l, c, t) : processCanvasRGB(e, 0, 0, l, c, t));
    }
  }
}
function getImageDataFromCanvas(i2, e, t, r, a) {
  if (typeof i2 == "string" && (i2 = document.getElementById(i2)), !i2 || _typeof(i2) !== "object" || !("getContext" in i2))
    throw new TypeError("Expecting canvas with `getContext` method in processCanvasRGB(A) calls!");
  var s = i2.getContext("2d");
  try {
    return s.getImageData(e, t, r, a);
  } catch (u) {
    throw new Error("unable to access image data: " + u);
  }
}
function processCanvasRGBA(i2, e, t, r, a, s) {
  if (!(isNaN(s) || s < 1)) {
    s |= 0;
    var u = getImageDataFromCanvas(i2, e, t, r, a);
    u = processImageDataRGBA(u, e, t, r, a, s), i2.getContext("2d").putImageData(u, e, t);
  }
}
function processImageDataRGBA(i2, e, t, r, a, s) {
  for (var u = i2.data, l = 2 * s + 1, c = r - 1, d = a - 1, f = s + 1, p = f * (f + 1) / 2, m = new BlurStack(), y = m, x, g = 1; g < l; g++)
    y = y.next = new BlurStack(), g === f && (x = y);
  y.next = m;
  for (var _ = null, T = null, E = 0, b = 0, C = mulTable[s], w = shgTable[s], A = 0; A < a; A++) {
    y = m;
    for (var S = u[b], F = u[b + 1], M = u[b + 2], U = u[b + 3], B = 0; B < f; B++)
      y.r = S, y.g = F, y.b = M, y.a = U, y = y.next;
    for (var q = 0, z = 0, D = 0, X = 0, k = f * S, I = f * F, P = f * M, G = f * U, W = p * S, V = p * F, K = p * M, J = p * U, ae = 1; ae < f; ae++) {
      var re = b + ((c < ae ? c : ae) << 2), he = u[re], ge = u[re + 1], me = u[re + 2], Te = u[re + 3], _e = f - ae;
      W += (y.r = he) * _e, V += (y.g = ge) * _e, K += (y.b = me) * _e, J += (y.a = Te) * _e, q += he, z += ge, D += me, X += Te, y = y.next;
    }
    _ = m, T = x;
    for (var ye = 0; ye < r; ye++) {
      var Ae = J * C >>> w;
      if (u[b + 3] = Ae, Ae !== 0) {
        var ke = 255 / Ae;
        u[b] = (W * C >>> w) * ke, u[b + 1] = (V * C >>> w) * ke, u[b + 2] = (K * C >>> w) * ke;
      } else
        u[b] = u[b + 1] = u[b + 2] = 0;
      W -= k, V -= I, K -= P, J -= G, k -= _.r, I -= _.g, P -= _.b, G -= _.a;
      var Pe = ye + s + 1;
      Pe = E + (Pe < c ? Pe : c) << 2, q += _.r = u[Pe], z += _.g = u[Pe + 1], D += _.b = u[Pe + 2], X += _.a = u[Pe + 3], W += q, V += z, K += D, J += X, _ = _.next;
      var Ee = T, Oe = Ee.r, $e = Ee.g, gt = Ee.b, xt = Ee.a;
      k += Oe, I += $e, P += gt, G += xt, q -= Oe, z -= $e, D -= gt, X -= xt, T = T.next, b += 4;
    }
    E += r;
  }
  for (var vt = 0; vt < r; vt++) {
    b = vt << 2;
    var Xe = u[b], at = u[b + 1], ct = u[b + 2], Rt = u[b + 3], It = f * Xe, er = f * at, $ = f * ct, Y = f * Rt, ee = p * Xe, be = p * at, Se = p * ct, Ne = p * Rt;
    y = m;
    for (var je = 0; je < f; je++)
      y.r = Xe, y.g = at, y.b = ct, y.a = Rt, y = y.next;
    for (var pt = r, oe = 0, le = 0, Ue = 0, et = 0, lt = 1; lt <= s; lt++) {
      b = pt + vt << 2;
      var We = f - lt;
      ee += (y.r = Xe = u[b]) * We, be += (y.g = at = u[b + 1]) * We, Se += (y.b = ct = u[b + 2]) * We, Ne += (y.a = Rt = u[b + 3]) * We, et += Xe, oe += at, le += ct, Ue += Rt, y = y.next, lt < d && (pt += r);
    }
    b = vt, _ = m, T = x;
    for (var te = 0; te < a; te++) {
      var ne = b << 2;
      u[ne + 3] = Rt = Ne * C >>> w, Rt > 0 ? (Rt = 255 / Rt, u[ne] = (ee * C >>> w) * Rt, u[ne + 1] = (be * C >>> w) * Rt, u[ne + 2] = (Se * C >>> w) * Rt) : u[ne] = u[ne + 1] = u[ne + 2] = 0, ee -= It, be -= er, Se -= $, Ne -= Y, It -= _.r, er -= _.g, $ -= _.b, Y -= _.a, ne = vt + ((ne = te + f) < d ? ne : d) * r << 2, ee += et += _.r = u[ne], be += oe += _.g = u[ne + 1], Se += le += _.b = u[ne + 2], Ne += Ue += _.a = u[ne + 3], _ = _.next, It += Xe = T.r, er += at = T.g, $ += ct = T.b, Y += Rt = T.a, et -= Xe, oe -= at, le -= ct, Ue -= Rt, T = T.next, b += r;
    }
  }
  return i2;
}
function processCanvasRGB(i2, e, t, r, a, s) {
  if (!(isNaN(s) || s < 1)) {
    s |= 0;
    var u = getImageDataFromCanvas(i2, e, t, r, a);
    u = processImageDataRGB(u, e, t, r, a, s), i2.getContext("2d").putImageData(u, e, t);
  }
}
function processImageDataRGB(i2, e, t, r, a, s) {
  for (var u = i2.data, l = 2 * s + 1, c = r - 1, d = a - 1, f = s + 1, p = f * (f + 1) / 2, m = new BlurStack(), y = m, x, g = 1; g < l; g++)
    y = y.next = new BlurStack(), g === f && (x = y);
  y.next = m;
  for (var _ = null, T = null, E = mulTable[s], b = shgTable[s], C, w, A = 0, S = 0, F = 0; F < a; F++) {
    var M = u[S], U = u[S + 1], B = u[S + 2], q = f * M, z = f * U, D = f * B, X = p * M, k = p * U, I = p * B;
    y = m;
    for (var P = 0; P < f; P++)
      y.r = M, y.g = U, y.b = B, y = y.next;
    for (var G = 0, W = 0, V = 0, K = 1; K < f; K++)
      C = S + ((c < K ? c : K) << 2), X += (y.r = M = u[C]) * (w = f - K), k += (y.g = U = u[C + 1]) * w, I += (y.b = B = u[C + 2]) * w, G += M, W += U, V += B, y = y.next;
    _ = m, T = x;
    for (var J = 0; J < r; J++)
      u[S] = X * E >>> b, u[S + 1] = k * E >>> b, u[S + 2] = I * E >>> b, X -= q, k -= z, I -= D, q -= _.r, z -= _.g, D -= _.b, C = A + ((C = J + s + 1) < c ? C : c) << 2, G += _.r = u[C], W += _.g = u[C + 1], V += _.b = u[C + 2], X += G, k += W, I += V, _ = _.next, q += M = T.r, z += U = T.g, D += B = T.b, G -= M, W -= U, V -= B, T = T.next, S += 4;
    A += r;
  }
  for (var ae = 0; ae < r; ae++) {
    S = ae << 2;
    var re = u[S], he = u[S + 1], ge = u[S + 2], me = f * re, Te = f * he, _e = f * ge, ye = p * re, Ae = p * he, ke = p * ge;
    y = m;
    for (var Pe = 0; Pe < f; Pe++)
      y.r = re, y.g = he, y.b = ge, y = y.next;
    for (var Ee = 0, Oe = 0, $e = 0, gt = 1, xt = r; gt <= s; gt++)
      S = xt + ae << 2, ye += (y.r = re = u[S]) * (w = f - gt), Ae += (y.g = he = u[S + 1]) * w, ke += (y.b = ge = u[S + 2]) * w, Ee += re, Oe += he, $e += ge, y = y.next, gt < d && (xt += r);
    S = ae, _ = m, T = x;
    for (var vt = 0; vt < a; vt++)
      C = S << 2, u[C] = ye * E >>> b, u[C + 1] = Ae * E >>> b, u[C + 2] = ke * E >>> b, ye -= me, Ae -= Te, ke -= _e, me -= _.r, Te -= _.g, _e -= _.b, C = ae + ((C = vt + f) < d ? C : d) * r << 2, ye += Ee += _.r = u[C], Ae += Oe += _.g = u[C + 1], ke += $e += _.b = u[C + 2], _ = _.next, me += re = T.r, Te += he = T.g, _e += ge = T.b, Ee -= re, Oe -= he, $e -= ge, T = T.next, S += r;
  }
  return i2;
}
var BlurStack = (
  /**
   * Set properties.
   */
  function i() {
    _classCallCheck(this, i), this.r = 0, this.g = 0, this.b = 0, this.a = 0, this.next = null;
  }
);
const stackblurEs = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BlurStack,
  canvasRGB: processCanvasRGB,
  canvasRGBA: processCanvasRGBA,
  image: processImage,
  imageDataRGB: processImageDataRGB,
  imageDataRGBA: processImageDataRGBA
}, Symbol.toStringTag, { value: "Module" })), require$$5 = /* @__PURE__ */ getAugmentedNamespace(stackblurEs);
var color$1, hasRequiredColor;
function requireColor() {
  if (hasRequiredColor) return color$1;
  hasRequiredColor = 1;
  const { utils: i2 } = requireLib$2(), e = {
    HSL2RGB: (t, r, a) => {
      let s, u, l;
      if (r == 0)
        s = u = l = a;
      else {
        const c = (p, m, y) => (y < 0 && (y += 1), y > 1 && (y -= 1), y < 0.16666666666666666 ? p + (m - p) * 6 * y : y < 0.5 ? m : y < 0.6666666666666666 ? p + (m - p) * (0.6666666666666666 - y) * 6 : p);
        let d = a < 0.5 ? a * (1 + r) : a + r - a * r, f = 2 * a - d;
        s = c(f, d, t + 1 / 3), u = c(f, d, t), l = c(f, d, t - 1 / 3);
      }
      return [Math.round(s * 255), Math.round(u * 255), Math.round(l * 255)];
    },
    RGB2HSL: (t, r, a) => i2.rgb2hsl(t, r, a),
    STR2RGB: (t, r = null) => {
      let a, s, u;
      return t.length === 4 ? (a = "0x" + t[1] + t[1], s = "0x" + t[2] + t[2], u = "0x" + t[3] + t[3]) : t.length === 7 && (a = "0x" + t[1] + t[2], s = "0x" + t[3] + t[4], u = "0x" + t[5] + t[6]), isNaN(a) || isNaN(s) || isNaN(u) ? e.STR2RGB(r) : [Number(a), Number(s), Number(u)];
    },
    RGB2HEX: (t) => (t[0] << 16) + (t[1] << 8) + (t[2] | 0)
  };
  return color$1 = e, color$1;
}
var graphic, hasRequiredGraphic;
function requireGraphic() {
  if (hasRequiredGraphic) return graphic;
  hasRequiredGraphic = 1;
  const i2 = requireNode(), { isBrowser: e } = requireLib$5(), { canvasRGBA: t } = require$$5, { createCanvas: r, createImageData: a, Texture: s, Graphics: u, Sprite: l, RenderTexture: c, CanvasRenderer: d } = requireLib$2(), { STR2RGB: f, RGB2HEX: p } = requireColor();
  class m extends i2 {
    constructor(x = {}) {
      super({ type: "graph", ...x });
    }
    createDisplay() {
      this.graph = new u();
      const { shape: x, color: g = "#FFF", opacity: _ = 1 } = this.conf;
      this.graph.beginFill(p(f(g, "#FFF")), _), Array.isArray(x) ? x.map((T) => this.draw(T)) : this.draw(x), this.display = this.getSprite();
    }
    async getDisplay(x, g) {
      const _ = this.getSprite();
      if (_.copyFromProxy(this.display), this.animations) {
        const T = (g.timing === "rel" ? x + this.absStartTime : x) * 1e3 >> 0;
        this.animations.apply(_, T);
      }
      return _;
    }
    getSprite() {
      const x = Number(this.conf.blur), g = this.creator().app.renderer, _ = 2, T = this.graph.generateTexture(g, 0, _), E = T.baseTexture._glRenderTargets[0].frameBuffer.gl, [b, C] = [T.baseTexture.width * _, T.baseTexture.height * _], w = new Uint8Array(b * C * 4);
      E.readPixels(0, 0, b, C, E.RGBA, E.UNSIGNED_BYTE, w);
      const A = a(new Uint8ClampedArray(w), b, C);
      let S = r(b, C);
      if (S.getContext("2d").putImageData(A, 0, 0), x > 0) {
        const F = 2 * x, M = r(b + 2 * F, C + 2 * F), U = M.getContext("2d");
        e && (U.filter = `blur(${x}px)`), U.drawImage(S, F, F, b, C), e || t(M, 0, 0, b, C, x), S = M;
      }
      return new l(s.fromCanvas(S));
    }
    draw(x) {
      let g = null, _ = [];
      if (typeof x == "string")
        g = this[x];
      else if (typeof x == "object") {
        g = this[x.shape], _.push(x);
        const { color: T, opacity: E = this.conf.opacity || 1 } = x, b = f(T);
        isNaN(b[0]) || this.graph.beginFill(p(b), E);
      }
      g && typeof g == "function" && g.call(this, ..._);
    }
    rect(x) {
      let { x: g, y: _, width: T, height: E } = x || this.conf;
      x || (g = 0, _ = 0), this.graph.drawRect(this.px(g), this.px(_), this.px(T), this.px(E));
    }
    roundedrect(x) {
      let { x: g, y: _, width: T, height: E, radius: b } = x || this.conf;
      x || (g = 0, _ = 0), this.graph.drawRoundedRect(this.px(g), this.px(_), this.px(T), this.px(E), this.px(b));
    }
    circle(x) {
      let { x: g, y: _, radius: T } = x || this.conf;
      x || (g = 0, _ = 0), this.graph.drawCircle(this.px(g), this.px(_), this.px(T));
    }
    ellipse(x) {
      let { x: g, y: _, width: T, height: E } = x || this.conf;
      x || (g = 0, _ = 0), this.graph.drawEllipse(this.px(g), this.px(_), this.px(T), this.px(E));
    }
    polygon(x) {
      let { points: g } = x || this.conf;
      this.graph.drawPolygon(g);
    }
    star(x) {
      let { x: g, y: _, points: T, radius: E, innerRadius: b, rotation: C } = x || this.conf;
      x || (g = 0, _ = 0), this.graph.drawStar(this.px(g), this.px(_), T, this.px(E), this.px(b), C);
    }
    async drawing(x, g) {
      let _ = await super.drawing(x, g), { width: T, height: E } = this;
      return (this.display.width !== T || this.display.height !== E) && this.display.attr({ width: T, height: E }), _;
    }
  }
  return graphic = m, graphic;
}
var cover, hasRequiredCover;
function requireCover() {
  if (hasRequiredCover) return cover;
  hasRequiredCover = 1;
  const i2 = requireCons();
  requireCanvas();
  const { createCanvas: e, Sprite: t, Texture: r } = requireLib$2();
  class a extends i2 {
    constructor(u = {}) {
      super({ type: "cover", ...u });
    }
    get canvasEditNode() {
      return this.mask;
    }
    get audio() {
    }
    async getPreview(u, l) {
      return await super.getPreview(u, l);
    }
    createDisplay() {
      super.createDisplay(), this.bgCanvas = e(this.canvasWidth, this.canvasHeight), this.background && this.display.removeChild(this.background), this.background = new t(r.fromCanvas(this.bgCanvas)), this.display.addChild(this.background);
    }
    show() {
      super.show();
      const u = this.display.parent;
      for (const l of [...u.children])
        l === this.display || l.zIndex > this.zIndex || l.isMask || l.parent !== this.display && (this.display.addChild(l), l.locked = true);
    }
    hide() {
      const u = this.display.parent;
      super.hide();
      for (const l of [...this.display.children])
        l.locked && (u.addChild(l), l.locked = false);
    }
  }
  return cover = a, cover;
}
var image$1, hasRequiredImage$1;
function requireImage$1() {
  if (hasRequiredImage$1) return image$1;
  hasRequiredImage$1 = 1;
  const i2 = requireMaterial(), { canvasRGBA: e } = require$$5, { isBrowser: t } = requireLib$5(), { getRemote: r } = requireXhr(), { getPixels: a } = requireUtils(), { utils: s, createCanvas: u, createImageData: l } = requireLib$2();
  class c extends i2 {
    async init() {
      if (!this.path) return;
      let f = this.path;
      if (t && f.startsWith("http")) {
        const _ = await r(f, this.creator.uuid);
        f = URL.createObjectURL(_.data);
      }
      const { pixels: p } = await a(f);
      if (!p || !p.shape || p.shape.length < 3) return;
      let m = p.shape;
      m.length > 3 && (m = m.slice(m.length - 3));
      const y = this.info.width = m[0], x = this.info.height = m[1], g = new Uint8ClampedArray(p.data.buffer).slice(0, y * x * 4);
      this.imageData = l(g, y, x), this.canvas = this.initCanvas(y, x), this.canvasContext = this.canvas.getContext("2d"), this.drawCanvas(this.imageData, y, x);
    }
    drawCanvas(f, p, m, y = null) {
      if (y || (y = this.canvas), !y) return;
      const x = y.getContext("2d");
      let g = this.conf.blur && this.creator ? this.creator.px(this.conf.blur) : 0;
      return g > 0 && t && (x.filter = `blur(${g}px)`), x.drawImage(this.getImage(f), 0, 0, p, m), g > 0 && !t && e(y, 0, 0, p, m, g), y;
    }
    getImage(f) {
      if (f.constructor.name !== "ImageData") return f;
      const p = u(f.width, f.height);
      return p.getContext("2d").putImageData(f, 0, 0), p;
    }
    initCanvas(f, p) {
      return u(f, p);
    }
    clearCanvas() {
      this.canvasContext.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }
    getImageData(f) {
      const { width: p, height: m } = this.info;
      return (!this.tmpCanvas || !this.tmpCanvasContext) && (this.tmpCanvas = this.initCanvas(p, m), this.tmpCanvasContext = this.tmpCanvas.getContext("2d")), this.tmpCanvasContext.drawImage(f, 0, 0, p, m), this.tmpCanvasContext.getImageData(0, 0, p, m);
    }
    width() {
      return this.info.width || 0;
    }
    height() {
      return this.info.height || 0;
    }
    destroy() {
      super.destroy(), this.tmpCanvas && (this.tmpCanvas = null, this.tmpCanvasContext = null);
    }
  }
  return image$1 = c, image$1;
}
var text, hasRequiredText;
function requireText() {
  if (hasRequiredText) return text;
  hasRequiredText = 1;
  const i2 = requireNode(), e = requireIsArray(), t = requireCanvas(), r = requireQueue(), { ProxyObj: a, Text: s } = requireLib$2(), { isBrowser: u } = requireLib$5(), { nodeRequire: l } = requireUtils(), c = requireImage$1();
  requireColor();
  const d = l("fs-extra"), f = {}, p = { left: 0, center: 0.5, right: 1 }, m = { top: 0, center: 0.5, bottom: 1 };
  class y extends i2 {
    constructor(g = { text: "", style: { fontSize: 28 } }) {
      var _, T, E, b, C, w;
      !g.text && g.content && (g.text = g.content.innerHTML || `${g.content}`), super({ type: "text", ...g }), this.queue = new r(), this.setAlign(true);
      const A = ["fontSize", "letterSpacing", "lineHeight"];
      for (const S of A)
        g[S] && (this[S] = g[S]);
      (_ = g.stroke) != null && _.size && (this.conf.stroke.size = this.vu((T = g.stroke) == null ? void 0 : T.size, "1%")), (E = g.shadow) != null && E.blur && (this.conf.shadow.blur = this.vu((b = g.shadow) == null ? void 0 : b.blur, "1%")), (C = g.shadow) != null && C.offset && (this.conf.shadow.offset = this.vu((w = g.shadow) == null ? void 0 : w.offset, "1%")), this._selectionBgColor = "#CCC", this.editMode = false;
    }
    get confAttr() {
      const g = { ...super.confAttr };
      return g.fontSize = super.px(g.fontSize), g.padding = `${g.padding || "0%"}`, g.lineHeight = `${g.lineHeight || "150%"}`, g.letterSpacing = `${g.letterSpacing || "0%"}`, g;
    }
    get cursorIndex() {
      return this.display.cursor().ci;
    }
    set cursorIndex(g) {
      this.display.cursor(g);
    }
    get selectionBgColor() {
      return this._selectionBgColor;
    }
    set selectionBgColor(g) {
      this._selectionBgColor = g, this.display._style.selectionBgColor = g;
    }
    get material() {
      var g;
      return (g = this.speech) == null ? void 0 : g.material;
    }
    get volume() {
      var g;
      return (g = this.speech) == null ? void 0 : g.volume;
    }
    get buffer() {
      var g;
      return (g = this.speech) == null ? void 0 : g.buffer;
    }
    get speech() {
      const g = this.children.filter((_) => _.type === "speech");
      return g.length > 0 ? g[g.length - 1] : null;
    }
    get audio() {
      const g = this.speech;
      return g ? g.audio : false;
    }
    set audio(g) {
      const _ = this.speech;
      _ && (_.audio = g);
    }
    get wrap() {
      return !!this.confAttr.wrap;
    }
    set wrap(g) {
      this.conf.wrap = !!g;
    }
    get useFontFamily() {
      return this.cachedFontFamily || this.confAttr.fontFamily;
    }
    get fontFamily() {
      return this.confAttr.fontFamily;
    }
    set fontFamily(g) {
      this.conf.fontFamily = g;
    }
    get fontSize() {
      return this.confAttr.fontSize;
    }
    set fontSize(g) {
      this.conf.fontSize = super.vu(g, this.confAttr.fontSize);
    }
    get letterSpacing() {
      return this.px(this.confAttr.letterSpacing, false);
    }
    set letterSpacing(g) {
      this.conf.letterSpacing = this.vu(g, this.confAttr.letterSpacing);
    }
    get lineHeight() {
      return this.px(this.confAttr.lineHeight, false);
    }
    set lineHeight(g) {
      this.conf.lineHeight = this.vu(g, this.confAttr.lineHeight);
    }
    get align() {
      return this.confAttr.align || "center";
    }
    set align(g) {
      this.conf.align = g;
    }
    get valign() {
      return this.confAttr.valign || "center";
    }
    set valign(g) {
      this.conf.valign = g;
    }
    get color() {
      return this.confAttr.color || "#FFFFFF";
    }
    set color(g) {
      this.conf.color = g;
    }
    get backgroundColor() {
      return this.confAttr.backgroundColor;
    }
    set backgroundColor(g) {
      this.conf.backgroundColor = g;
    }
    get styleStroke() {
      var g, _;
      return {
        stroke: (g = this.confAttr.stroke) == null ? void 0 : g.color,
        strokeThickness: this.px((_ = this.confAttr.stroke) == null ? void 0 : _.size) || 0
      };
    }
    get stroke() {
      return this.confAttr.stroke;
    }
    set stroke(g) {
      this.conf.stroke = g;
    }
    get styleShadow() {
      var g, _, T, E, b, C, w;
      const A = ((g = this.confAttr.shadow) == null ? void 0 : g.angle) !== void 0 ? Number((_ = this.confAttr.shadow) == null ? void 0 : _.angle) : 45;
      return {
        dropShadow: this.confAttr.shadow && ((T = this.confAttr.shadow) == null ? void 0 : T.color),
        dropShadowColor: (E = this.confAttr.shadow) == null ? void 0 : E.color,
        dropShadowAlpha: Number((b = this.confAttr.shadow) == null ? void 0 : b.alpha) || 0,
        dropShadowBlur: this.px((C = this.confAttr.shadow) == null ? void 0 : C.blur) || 0,
        dropShadowDistance: this.px((w = this.confAttr.shadow) == null ? void 0 : w.offset) || 0,
        dropShadowAngle: A * (Math.PI / 180)
      };
    }
    get padding() {
      return this.px(this.confAttr.padding, false);
    }
    set padding(g) {
      this.conf.padding = this.vu(g, this.confAttr.padding);
    }
    get shadow() {
      return this.confAttr.shadow;
    }
    set shadow(g) {
      this.conf.shadow = g;
    }
    get text() {
      return this.confAttr.text;
    }
    set text(g) {
      this.conf.text = g, this.display.text = g, this.display.updateText(false);
    }
    toJson(g = false) {
      const _ = super.toJson(g);
      return g && (delete _.height, delete _.viewWidth, delete _.viewHeight, this.wrap || delete _.width), _;
    }
    px(g, _ = true) {
      if (typeof g == "string" && g.endsWith("%") && !isNaN(g.replace("%", ""))) {
        const T = this.fontSize * Number(g.replace("%", "")) * 0.01;
        return _ ? Math.round(T) : T;
      }
      return super.px(g);
    }
    vu(g, _) {
      if (typeof g == "string" && g.endsWith("%")) return g;
      const T = this.px(g);
      return typeof _ == "string" && _.endsWith("%") && !isNaN(T) ? `${Math.round(100 * (T / this.fontSize))}%` : super.vu(g, _);
    }
    /**
     * Functions for drawing images
     * @private
     */
    createDisplay() {
      let { text: g, fontSize: _ } = this;
      this.display = new s(), this.display.text = g;
    }
    async getDisplay(g, _) {
      const T = new s();
      if (T.copyFromProxy(this.display), this.animations) {
        const E = (_.timing === "rel" ? g + this.absStartTime : g) * 1e3 >> 0;
        this.animations.apply(T, E);
      }
      return T;
    }
    /**
     * load font file
     * @return {Promise}
     * @public
     */
    async preProcessing() {
      var g;
      if (this.confAttr.image && this.confAttr.image !== ((g = this.imageMat) == null ? void 0 : g.path) && (this.imageMat && this.material.destroy(), this.imageMat = new c({ src: this.confAttr.image }), await this.imageMat.init(), this.image = this.imageMat.canvas), u)
        await this.queuedFitSize("preProcessing");
      else {
        if (!this.useFontFamily || this.useFontFamily.startsWith("http") || !d.existsSync(this.useFontFamily))
          throw new Error(`Font not exists: ${this.useFontFamily}`);
        try {
          await this.setFont(this.useFontFamily);
        } catch {
          if (!this.useFontFamily.startsWith("http") && d.existsSync(this.useFontFamily))
            throw d.unlinkSync(this.useFontFamily), new Error(`Set font fail: ${this.useFontFamily}`);
        }
        this.updateStyle();
        const _ = this.display;
        this.display = new s(), this.display.substitute(_), this.setChromaKey(), this.setColor(), this.display.updateText(false), _.destroy();
      }
    }
    setColor() {
    }
    /**
     * Set text font file path
     * @param {string} font - text font file path
     * @public
     */
    async setFont(g) {
      return new Promise((_) => {
        t.setFont(g, (T) => {
          this.font = { font: g, fontFamily: T }, _();
        });
      });
    }
    /**
     * Set text style by object
     * @param {object} style - style by object
     * @public
     */
    setStyle(g) {
      g.image ? g.fillImage = g.image : g.color && (g.fill = g.color), e(g.padding) && (g.padding = g.padding[0]);
      for (const [_, T] of Object.entries(g))
        T === void 0 && delete g[_];
      this.display.updateStyle(g), this.display.updateText(false);
    }
    setWH(g, _) {
      let { width: T, height: E, fontSize: b } = this;
      T && E && g && _ && b && (g / T).toFixed(6) === (_ / E).toFixed(6) && this.setConfRpx("fontSize", b * (g / T)), super.setWH(g, _);
    }
    fitSize(g) {
      this.queuedFitSize(g);
    }
    queuedFitSize(g) {
      return this.queue.enqueue(async () => {
        var _;
        if (((_ = this.font) == null ? void 0 : _.fontFamily) != this.useFontFamily)
          if (f[this.useFontFamily])
            this.font = f[this.useFontFamily];
          else {
            await this.setFont(this.useFontFamily);
            const T = await new FontFace(this.font.fontFamily, `url("${this.font.font}")`).load();
            document.fonts.add(T), f[this.useFontFamily] = this.font, await document.fonts.ready;
          }
        this.updateStyle();
      });
    }
    updateStyle() {
      var g;
      const { fontSize: _, color: T, image: E, backgroundColor: b, wrap: C, align: w, lineHeight: A, styleStroke: S, styleShadow: F, letterSpacing: M, selectionBgColor: U, padding: B } = this, q = this.confAttr.width, z = (g = this.font) == null ? void 0 : g.fontFamily, D = {
        selectionBgColor: U,
        fontFamily: z,
        fontSize: _,
        color: T,
        image: E,
        backgroundColor: b,
        align: w,
        lineHeight: A,
        letterSpacing: M,
        padding: B,
        wordWrapWidth: q,
        wordWrap: C && q > 0,
        breakWords: true,
        lineJoin: "round",
        // 否则描边会有尖刺
        ...S,
        ...F
      };
      this.setStyle(D), this.setConfRpx("height", this.display.height), this.confAttr.width || this.setConfRpx("width", this.display.width), this.setAlign();
    }
    setAlign(g = false) {
      const { align: _, valign: T } = this, E = p[_] !== void 0 ? p[_] : 0.5, b = m[T] !== void 0 ? m[T] : 0.5;
      if (this.anchorX != E || this.anchorY != b) {
        if (!g) {
          let { x: C, y: w, width: A, height: S } = this;
          C += (E - this.anchorX) * A, w += (b - this.anchorY) * S, this.setXY(C, w);
        }
        this.setAnchor(E, b);
      }
    }
    selectStart(g) {
      const { dx: _, dy: T } = this.displayOffset;
      this.display.selectStart({ x: g.x - _, y: g.y - T });
    }
    selectEnd(g) {
      const { dx: _, dy: T } = this.displayOffset;
      this.display.selectEnd({ x: g.x - _, y: g.y - T }), this.creator().render();
    }
    selectMove({ x: g, y: _ }, T, E) {
      this.display.selectMove(g, _, T, E), this.creator().render();
    }
    selectClean() {
      this.display.selectStart({ x: 0, y: 0 }), this.display.selectEnd({ x: 0, y: 0 }), this.creator().render();
    }
    delete() {
      return this.display.delete();
    }
    selection() {
      return this.display.selectionText();
    }
    input(g) {
      return this.display.input(g);
    }
    cursor() {
      let { x: g, y: _, height: T } = this.display.cursor();
      const { dx: E, dy: b } = this.displayOffset;
      return { x: g + E, y: _ + b, height: T };
    }
    get displayOffset() {
      const { x: g, y: _ } = this.display.anchor, { width: T, height: E } = this, { width: b, height: C } = this.display;
      return { dx: (T - b) * g, dy: (E - C) * _ };
    }
    destroy() {
      this.display.text = "", super.destroy();
    }
  }
  return text = y, text;
}
var image, hasRequiredImage;
function requireImage() {
  if (hasRequiredImage) return image;
  hasRequiredImage = 1;
  const i2 = requireNode(), e = requireImage$1(), { Sprite: t, Texture: r, Rectangle: a, createCanvas: s } = requireLib$2(), { isBrowser: u } = requireLib$5();
  class l extends i2 {
    constructor(d = {}) {
      super({ type: "image", ...d });
    }
    get audio() {
    }
    get frame() {
      var d, f;
      if (this.conf.pframe) {
        const [p, m] = [this.material.width(), this.material.height()], [y, x, g, _] = [
          this.conf.pframe.x * p,
          this.conf.pframe.y * m,
          this.conf.pframe.w * p,
          this.conf.pframe.h * m
        ];
        return { x: y, y: x, w: g, h: _ };
      }
      return (d = this.conf.frame) != null && d.w && (f = this.conf.frame) != null && f.h ? { ...this.conf.frame } : null;
    }
    set frame(d) {
      const [f, p] = [this.material.width(), this.material.height()], [m, y, x, g] = [d.x / f, d.y / p, d.w / f, d.h / p];
      this.conf.pframe = { x: m, y, w: x, h: g };
    }
    setFrame(d, f, p, m) {
      typeof d == "object" && d.x !== void 0 ? this.frame = d : this.frame = { x: d, y: f, w: p, h: m };
    }
    getFrame() {
      if (this.frame) return this.frame;
      let [d, f, p, m] = [0, 0, this.material.width(), this.material.height()];
      const { "object-fit": y, "object-position": x } = this.conf;
      if (!y || y === "cover") {
        const [g, _] = this.getObjectPosition(), [T, E] = this.getWH(), b = Math.min(p / T, m / E), C = T * b, w = E * b;
        d += (p - C) * g, f += (m - w) * _, p = C, m = w;
      }
      return { x: d, y: f, w: p, h: m };
    }
    materialTime(d, f = false) {
      return { time: 0, loops: 0 };
    }
    async getFrameByTime(d) {
      return this.material.canvas;
    }
    async getDisplay(d, f) {
      const p = await this.getPreview(d, { ...f, format: "canvas", rawFrame: false });
      if (!p) throw new Error("get null canvas, will retry later");
      const m = new t(r.fromCanvas(p));
      return m.copyFromProxy(this.display), m;
    }
    async getPreview(d, { width: f, height: p, format: m = "jpeg", timing: y = "mat", rawFrame: x = false } = {}) {
      let g = d;
      (y === "abs" || y === "rel") && (g = this.materialTime(y === "rel" ? d + this.absStartTime : d, true).time);
      const _ = await this.getFrameByTime(g);
      if (!_) return null;
      let T = this.getFrame();
      x && (T = { x: 0, y: 0, w: this.material.width(), h: this.material.height() });
      const E = this.type === "video" ? "cover" : "contain";
      return this.subImage(_, T, { width: f, height: p, fit: E, format: m });
    }
    getObjectPosition() {
      let { "object-position": d } = this.conf;
      const { x: f, y: p } = this.getAnchor();
      (!Array.isArray(d) || d.length != 2) && (d = [f, p]);
      let [m, y] = d;
      return m = isNaN(Number(m)) ? f : Math.max(0, Math.min(1, Number(m))), y = isNaN(Number(y)) ? p : Math.max(0, Math.min(1, Number(y))), [m, y];
    }
    /**
     * Create Image Material
     * @param {*} conf
     * @returns {ImageMaterial}
     */
    createMaterial(d) {
      return new e(d);
    }
    updateMaterialTime() {
      this.material.parseTimeConf(this.conf);
    }
    /**
     * Create display object.
     * @private
     */
    createDisplay() {
      this.display = new t(r.fromCanvas(s(1, 1)));
    }
    annotate() {
      super.annotate(), this.material.duration = this.duration;
    }
    async prepareMaterial() {
      await super.prepareMaterial();
    }
    async preProcessing() {
      this.material && this.material.destroy(), this.material = this.createMaterial(this.conf), this.material.holderId = this.id, this.material.duration = this.duration, this.material.creator = this.root();
      const d = this.rootConf("fps");
      await this.material.init({ fps: d }), await this.fitSize(), this.display.texture.destroy(true), this.display.attr({ texture: r.fromCanvas(this.material.canvas) }), await this.fitTexture(), await this.setMotion();
    }
    async setMotion(d) {
      if (!this.conf.motion) {
        this.motionMask && this.motionFilter && (this.display.setMotion(null), this.motionFilter = null, this.motionMask = null);
        return;
      }
      this.motionMaterial && this.motionMaterial.destroy(), this.motionMaterial = this.createMaterial(this.conf.motion), await this.motionMaterial.init(), this.motionMask = new t(r.fromCanvas(this.motionMaterial.canvas)), this.motionFilter = this.display.setMotion(this.motionMask);
      const { width: f, height: p } = this.motionMaterial.info;
      this.motionMask.x = -f / 2, this.motionMask.y = -p / 2, this.motionMask.width = f, this.motionMask.height = p, this.display.addChild(this.motionMask);
    }
    fitSize() {
      let { width: d, height: f } = this.confAttr;
      const p = this.display;
      let m = this.material.width(), y = this.material.height();
      if (this.frame && (m = this.frame.w, y = this.frame.h), !m || !y) return;
      let x;
      if (!d || !f)
        d ? (x = d / m, f = x * y) : f ? (x = f / y, d = x * m) : (x = this.scale || 1, d = m * x, f = y * x);
      else {
        const g = this.conf["object-fit"];
        if (!g || g === "cover") x = Math.max(d / m, f / y);
        else if (g === "contain") x = Math.min(d / m, f / y);
        else if (g === "none") x = 1;
        else if (g === "scale-down") x = Math.min(1, Math.min(d / m, f / y));
        else if (g === "fill") return p.attr({ width: d, height: f });
        d = m * x, f = y * x;
      }
      p.attr({ width: d, height: f }), this.setScale(x);
    }
    fitTexture(d) {
      let { "object-fit": f } = this.conf;
      this.frame && this.setScale(this.scale);
      let { width: p, height: m } = this.confAttr;
      if (d = d || this.display, d.scale.x <= 0 || d.scale.y <= 0) return;
      d.texture.baseTexture.update();
      let y = this.material.width(), x = this.material.height(), g = 0, _ = 0;
      if (this.frame && (g = this.frame.x, _ = this.frame.y, y = this.frame.w, x = this.frame.h), p /= d.scale.x, m /= d.scale.y, !p || !m)
        return d.texture.frame = new a(g, _, y, x);
      const [T, E] = this.getObjectPosition();
      if (f === "fill")
        d.texture.frame = new a(g, _, y, x), d.width = p, d.height = m;
      else {
        const b = Math.min(p, y), C = Math.min(m, x);
        g += (y - b) * T, _ += (x - C) * E, d.texture.frame = new a(g, _, b, C);
      }
    }
    /**
     * Functions for drawing images
     * @private
     */
    draw({ display: d, texture: f, useCache: p = false }) {
      !f || u || (d = d || this.display, f.constructor.name === "ImageData" ? (d.texture.baseTexture.source = f, d.texture.baseTexture.update()) : f instanceof r ? (d.texture.destroy(true), d.texture = f, this.fitTexture(d)) : d.texture.updateSource(f, p));
    }
    /**
     * Delete historical texture Image
     * @private
     */
    deleteTexture(d) {
      this.parent && d.texture;
    }
    async drawing(d, f) {
      let p = await super.drawing(d, f);
      if (!p) return false;
      if (this.conf.motion && this.motionFilter) {
        const m = Math.pow(this.absEndTime - d * 1e-3, this.conf.motion.curve), [y, x] = [this.px(this.conf.motion.x) * m, this.px(this.conf.motion.y) * m];
        this.motionFilter.setScale(y, x);
      }
      return p;
    }
    destroy() {
      super.destroy(), this.material && this.material.destroy();
    }
  }
  return image = l, image;
}
var lodash$1 = { exports: {} };
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
var lodash = lodash$1.exports, hasRequiredLodash;
function requireLodash() {
  return hasRequiredLodash || (hasRequiredLodash = 1, function(i2, e) {
    (function() {
      var t, r = "4.17.21", a = 200, s = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", u = "Expected a function", l = "Invalid `variable` option passed into `_.template`", c = "__lodash_hash_undefined__", d = 500, f = "__lodash_placeholder__", p = 1, m = 2, y = 4, x = 1, g = 2, _ = 1, T = 2, E = 4, b = 8, C = 16, w = 32, A = 64, S = 128, F = 256, M = 512, U = 30, B = "...", q = 800, z = 16, D = 1, X = 2, k = 3, I = 1 / 0, P = 9007199254740991, G = 17976931348623157e292, W = NaN, V = 4294967295, K = V - 1, J = V >>> 1, ae = [
        ["ary", S],
        ["bind", _],
        ["bindKey", T],
        ["curry", b],
        ["curryRight", C],
        ["flip", M],
        ["partial", w],
        ["partialRight", A],
        ["rearg", F]
      ], re = "[object Arguments]", he = "[object Array]", ge = "[object AsyncFunction]", me = "[object Boolean]", Te = "[object Date]", _e = "[object DOMException]", ye = "[object Error]", Ae = "[object Function]", ke = "[object GeneratorFunction]", Pe = "[object Map]", Ee = "[object Number]", Oe = "[object Null]", $e = "[object Object]", gt = "[object Promise]", xt = "[object Proxy]", vt = "[object RegExp]", Xe = "[object Set]", at = "[object String]", ct = "[object Symbol]", Rt = "[object Undefined]", It = "[object WeakMap]", er = "[object WeakSet]", $ = "[object ArrayBuffer]", Y = "[object DataView]", ee = "[object Float32Array]", be = "[object Float64Array]", Se = "[object Int8Array]", Ne = "[object Int16Array]", je = "[object Int32Array]", pt = "[object Uint8Array]", oe = "[object Uint8ClampedArray]", le = "[object Uint16Array]", Ue = "[object Uint32Array]", et = /\b__p \+= '';/g, lt = /\b(__p \+=) '' \+/g, We = /(__e\(.*?\)|\b__t\)) \+\n'';/g, te = /&(?:amp|lt|gt|quot|#39);/g, ne = /[&<>"']/g, fe = RegExp(te.source), qe = RegExp(ne.source), Je = /<%-([\s\S]+?)%>/g, ht = /<%([\s\S]+?)%>/g, bt = /<%=([\s\S]+?)%>/g, kt = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, Ar = /^\w*$/, Sr = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, Vt = /[\\^$.*+?()[\]{}|]/g, jr = RegExp(Vt.source), tr = /^\s+/, _r = /\s/, wr = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, xr = /\{\n\/\* \[wrapped with (.+)\] \*/, Mr = /,? & /, Or = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g, hi = /[()=,{}\[\]\/\s]/, Rr = /\\(\\)?/g, ci = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g, Ri = /\w*$/, fi = /^[-+]0x[0-9a-f]+$/i, Ir = /^0b[01]+$/i, Zr = /^\[object .+?Constructor\]$/, Xi = /^0o[0-7]+$/i, Ai = /^(?:0|[1-9]\d*)$/, rs = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, Mi = /($^)/, Ja = /['\n\r\u2028\u2029\\]/g, Qr = "\\ud800-\\udfff", Za = "\\u0300-\\u036f", Vi = "\\ufe20-\\ufe2f", is = "\\u20d0-\\u20ff", Hi = Za + Vi + is, Yi = "\\u2700-\\u27bf", Bn = "a-z\\xdf-\\xf6\\xf8-\\xff", ns = "\\xac\\xb1\\xd7\\xf7", $n = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", as = "\\u2000-\\u206f", ss = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", ue = "A-Z\\xc0-\\xd6\\xd8-\\xde", de = "\\ufe0e\\ufe0f", pe = ns + $n + as + ss, Me = "['’]", Re = "[" + Qr + "]", Ie = "[" + pe + "]", Fe = "[" + Hi + "]", ze = "\\d+", Ze = "[" + Yi + "]", Ke = "[" + Bn + "]", Ye = "[^" + Qr + pe + ze + Yi + Bn + ue + "]", dt = "\\ud83c[\\udffb-\\udfff]", Pt = "(?:" + Fe + "|" + dt + ")", Ut = "[^" + Qr + "]", Dt = "(?:\\ud83c[\\udde6-\\uddff]){2}", Qt = "[\\ud800-\\udbff][\\udc00-\\udfff]", Ft = "[" + ue + "]", Ur = "\\u200d", Ki = "(?:" + Ke + "|" + Ye + ")", jn = "(?:" + Ft + "|" + Ye + ")", Un = "(?:" + Me + "(?:d|ll|m|re|s|t|ve))?", Gn = "(?:" + Me + "(?:D|LL|M|RE|S|T|VE))?", Dn = Pt + "?", os = "[" + de + "]?", Ru = "(?:" + Ur + "(?:" + [Ut, Dt, Qt].join("|") + ")" + os + Dn + ")*", Au = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", Mu = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", us = os + Dn + Ru, Ou = "(?:" + [Ze, Dt, Qt].join("|") + ")" + us, Iu = "(?:" + [Ut + Fe + "?", Fe, Dt, Qt, Re].join("|") + ")", Pu = RegExp(Me, "g"), qu = RegExp(Fe, "g"), zn = RegExp(dt + "(?=" + dt + ")|" + Iu + us, "g"), ku = RegExp([
        Ft + "?" + Ke + "+" + Un + "(?=" + [Ie, Ft, "$"].join("|") + ")",
        jn + "+" + Gn + "(?=" + [Ie, Ft + Ki, "$"].join("|") + ")",
        Ft + "?" + Ki + "+" + Un,
        Ft + "+" + Gn,
        Mu,
        Au,
        ze,
        Ou
      ].join("|"), "g"), Lu = RegExp("[" + Ur + Qr + Hi + de + "]"), Nu = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/, Du = [
        "Array",
        "Buffer",
        "DataView",
        "Date",
        "Error",
        "Float32Array",
        "Float64Array",
        "Function",
        "Int8Array",
        "Int16Array",
        "Int32Array",
        "Map",
        "Math",
        "Object",
        "Promise",
        "RegExp",
        "Set",
        "String",
        "Symbol",
        "TypeError",
        "Uint8Array",
        "Uint8ClampedArray",
        "Uint16Array",
        "Uint32Array",
        "WeakMap",
        "_",
        "clearTimeout",
        "isFinite",
        "parseInt",
        "setTimeout"
      ], Fu = -1, Et = {};
      Et[ee] = Et[be] = Et[Se] = Et[Ne] = Et[je] = Et[pt] = Et[oe] = Et[le] = Et[Ue] = true, Et[re] = Et[he] = Et[$] = Et[me] = Et[Y] = Et[Te] = Et[ye] = Et[Ae] = Et[Pe] = Et[Ee] = Et[$e] = Et[vt] = Et[Xe] = Et[at] = Et[It] = false;
      var wt = {};
      wt[re] = wt[he] = wt[$] = wt[Y] = wt[me] = wt[Te] = wt[ee] = wt[be] = wt[Se] = wt[Ne] = wt[je] = wt[Pe] = wt[Ee] = wt[$e] = wt[vt] = wt[Xe] = wt[at] = wt[ct] = wt[pt] = wt[oe] = wt[le] = wt[Ue] = true, wt[ye] = wt[Ae] = wt[It] = false;
      var Bu = {
        // Latin-1 Supplement block.
        À: "A",
        Á: "A",
        Â: "A",
        Ã: "A",
        Ä: "A",
        Å: "A",
        à: "a",
        á: "a",
        â: "a",
        ã: "a",
        ä: "a",
        å: "a",
        Ç: "C",
        ç: "c",
        Ð: "D",
        ð: "d",
        È: "E",
        É: "E",
        Ê: "E",
        Ë: "E",
        è: "e",
        é: "e",
        ê: "e",
        ë: "e",
        Ì: "I",
        Í: "I",
        Î: "I",
        Ï: "I",
        ì: "i",
        í: "i",
        î: "i",
        ï: "i",
        Ñ: "N",
        ñ: "n",
        Ò: "O",
        Ó: "O",
        Ô: "O",
        Õ: "O",
        Ö: "O",
        Ø: "O",
        ò: "o",
        ó: "o",
        ô: "o",
        õ: "o",
        ö: "o",
        ø: "o",
        Ù: "U",
        Ú: "U",
        Û: "U",
        Ü: "U",
        ù: "u",
        ú: "u",
        û: "u",
        ü: "u",
        Ý: "Y",
        ý: "y",
        ÿ: "y",
        Æ: "Ae",
        æ: "ae",
        Þ: "Th",
        þ: "th",
        ß: "ss",
        // Latin Extended-A block.
        Ā: "A",
        Ă: "A",
        Ą: "A",
        ā: "a",
        ă: "a",
        ą: "a",
        Ć: "C",
        Ĉ: "C",
        Ċ: "C",
        Č: "C",
        ć: "c",
        ĉ: "c",
        ċ: "c",
        č: "c",
        Ď: "D",
        Đ: "D",
        ď: "d",
        đ: "d",
        Ē: "E",
        Ĕ: "E",
        Ė: "E",
        Ę: "E",
        Ě: "E",
        ē: "e",
        ĕ: "e",
        ė: "e",
        ę: "e",
        ě: "e",
        Ĝ: "G",
        Ğ: "G",
        Ġ: "G",
        Ģ: "G",
        ĝ: "g",
        ğ: "g",
        ġ: "g",
        ģ: "g",
        Ĥ: "H",
        Ħ: "H",
        ĥ: "h",
        ħ: "h",
        Ĩ: "I",
        Ī: "I",
        Ĭ: "I",
        Į: "I",
        İ: "I",
        ĩ: "i",
        ī: "i",
        ĭ: "i",
        į: "i",
        ı: "i",
        Ĵ: "J",
        ĵ: "j",
        Ķ: "K",
        ķ: "k",
        ĸ: "k",
        Ĺ: "L",
        Ļ: "L",
        Ľ: "L",
        Ŀ: "L",
        Ł: "L",
        ĺ: "l",
        ļ: "l",
        ľ: "l",
        ŀ: "l",
        ł: "l",
        Ń: "N",
        Ņ: "N",
        Ň: "N",
        Ŋ: "N",
        ń: "n",
        ņ: "n",
        ň: "n",
        ŋ: "n",
        Ō: "O",
        Ŏ: "O",
        Ő: "O",
        ō: "o",
        ŏ: "o",
        ő: "o",
        Ŕ: "R",
        Ŗ: "R",
        Ř: "R",
        ŕ: "r",
        ŗ: "r",
        ř: "r",
        Ś: "S",
        Ŝ: "S",
        Ş: "S",
        Š: "S",
        ś: "s",
        ŝ: "s",
        ş: "s",
        š: "s",
        Ţ: "T",
        Ť: "T",
        Ŧ: "T",
        ţ: "t",
        ť: "t",
        ŧ: "t",
        Ũ: "U",
        Ū: "U",
        Ŭ: "U",
        Ů: "U",
        Ű: "U",
        Ų: "U",
        ũ: "u",
        ū: "u",
        ŭ: "u",
        ů: "u",
        ű: "u",
        ų: "u",
        Ŵ: "W",
        ŵ: "w",
        Ŷ: "Y",
        ŷ: "y",
        Ÿ: "Y",
        Ź: "Z",
        Ż: "Z",
        Ž: "Z",
        ź: "z",
        ż: "z",
        ž: "z",
        Ĳ: "IJ",
        ĳ: "ij",
        Œ: "Oe",
        œ: "oe",
        ŉ: "'n",
        ſ: "s"
      }, $u = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;"
      }, ju = {
        "&amp;": "&",
        "&lt;": "<",
        "&gt;": ">",
        "&quot;": '"',
        "&#39;": "'"
      }, Uu = {
        "\\": "\\",
        "'": "'",
        "\n": "n",
        "\r": "r",
        "\u2028": "u2028",
        "\u2029": "u2029"
      }, Gu = parseFloat, zu = parseInt, ls = typeof window == "object" && window && window.Object === Object && window, Vu = typeof self == "object" && self && self.Object === Object && self, $t = ls || Vu || Function("return this")(), Vn = e && !e.nodeType && e, ei = Vn && true && i2 && !i2.nodeType && i2, hs = ei && ei.exports === Vn, Hn = hs && ls.process, ur = function() {
        try {
          var ie = ei && ei.require && ei.require("util").types;
          return ie || Hn && Hn.binding && Hn.binding("util");
        } catch {
        }
      }(), cs = ur && ur.isArrayBuffer, fs = ur && ur.isDate, ds = ur && ur.isMap, ps = ur && ur.isRegExp, ms = ur && ur.isSet, vs = ur && ur.isTypedArray;
      function rr(ie, ve, ce) {
        switch (ce.length) {
          case 0:
            return ie.call(ve);
          case 1:
            return ie.call(ve, ce[0]);
          case 2:
            return ie.call(ve, ce[0], ce[1]);
          case 3:
            return ie.call(ve, ce[0], ce[1], ce[2]);
        }
        return ie.apply(ve, ce);
      }
      function Hu(ie, ve, ce, De) {
        for (var Qe = -1, ft = ie == null ? 0 : ie.length; ++Qe < ft; ) {
          var Lt = ie[Qe];
          ve(De, Lt, ce(Lt), ie);
        }
        return De;
      }
      function lr(ie, ve) {
        for (var ce = -1, De = ie == null ? 0 : ie.length; ++ce < De && ve(ie[ce], ce, ie) !== false; )
          ;
        return ie;
      }
      function Wu(ie, ve) {
        for (var ce = ie == null ? 0 : ie.length; ce-- && ve(ie[ce], ce, ie) !== false; )
          ;
        return ie;
      }
      function gs(ie, ve) {
        for (var ce = -1, De = ie == null ? 0 : ie.length; ++ce < De; )
          if (!ve(ie[ce], ce, ie))
            return false;
        return true;
      }
      function Gr(ie, ve) {
        for (var ce = -1, De = ie == null ? 0 : ie.length, Qe = 0, ft = []; ++ce < De; ) {
          var Lt = ie[ce];
          ve(Lt, ce, ie) && (ft[Qe++] = Lt);
        }
        return ft;
      }
      function Ji(ie, ve) {
        var ce = ie == null ? 0 : ie.length;
        return !!ce && di(ie, ve, 0) > -1;
      }
      function Wn(ie, ve, ce) {
        for (var De = -1, Qe = ie == null ? 0 : ie.length; ++De < Qe; )
          if (ce(ve, ie[De]))
            return true;
        return false;
      }
      function Tt(ie, ve) {
        for (var ce = -1, De = ie == null ? 0 : ie.length, Qe = Array(De); ++ce < De; )
          Qe[ce] = ve(ie[ce], ce, ie);
        return Qe;
      }
      function zr(ie, ve) {
        for (var ce = -1, De = ve.length, Qe = ie.length; ++ce < De; )
          ie[Qe + ce] = ve[ce];
        return ie;
      }
      function Xn(ie, ve, ce, De) {
        var Qe = -1, ft = ie == null ? 0 : ie.length;
        for (De && ft && (ce = ie[++Qe]); ++Qe < ft; )
          ce = ve(ce, ie[Qe], Qe, ie);
        return ce;
      }
      function Xu(ie, ve, ce, De) {
        var Qe = ie == null ? 0 : ie.length;
        for (De && Qe && (ce = ie[--Qe]); Qe--; )
          ce = ve(ce, ie[Qe], Qe, ie);
        return ce;
      }
      function Yn(ie, ve) {
        for (var ce = -1, De = ie == null ? 0 : ie.length; ++ce < De; )
          if (ve(ie[ce], ce, ie))
            return true;
        return false;
      }
      var Yu = Kn("length");
      function Ku(ie) {
        return ie.split("");
      }
      function Ju(ie) {
        return ie.match(Or) || [];
      }
      function ys(ie, ve, ce) {
        var De;
        return ce(ie, function(Qe, ft, Lt) {
          if (ve(Qe, ft, Lt))
            return De = ft, false;
        }), De;
      }
      function Zi(ie, ve, ce, De) {
        for (var Qe = ie.length, ft = ce + (De ? 1 : -1); De ? ft-- : ++ft < Qe; )
          if (ve(ie[ft], ft, ie))
            return ft;
        return -1;
      }
      function di(ie, ve, ce) {
        return ve === ve ? ll(ie, ve, ce) : Zi(ie, bs, ce);
      }
      function Zu(ie, ve, ce, De) {
        for (var Qe = ce - 1, ft = ie.length; ++Qe < ft; )
          if (De(ie[Qe], ve))
            return Qe;
        return -1;
      }
      function bs(ie) {
        return ie !== ie;
      }
      function _s(ie, ve) {
        var ce = ie == null ? 0 : ie.length;
        return ce ? Zn(ie, ve) / ce : W;
      }
      function Kn(ie) {
        return function(ve) {
          return ve == null ? t : ve[ie];
        };
      }
      function Jn(ie) {
        return function(ve) {
          return ie == null ? t : ie[ve];
        };
      }
      function xs(ie, ve, ce, De, Qe) {
        return Qe(ie, function(ft, Lt, _t) {
          ce = De ? (De = false, ft) : ve(ce, ft, Lt, _t);
        }), ce;
      }
      function Qu(ie, ve) {
        var ce = ie.length;
        for (ie.sort(ve); ce--; )
          ie[ce] = ie[ce].value;
        return ie;
      }
      function Zn(ie, ve) {
        for (var ce, De = -1, Qe = ie.length; ++De < Qe; ) {
          var ft = ve(ie[De]);
          ft !== t && (ce = ce === t ? ft : ce + ft);
        }
        return ce;
      }
      function Qn(ie, ve) {
        for (var ce = -1, De = Array(ie); ++ce < ie; )
          De[ce] = ve(ce);
        return De;
      }
      function el(ie, ve) {
        return Tt(ve, function(ce) {
          return [ce, ie[ce]];
        });
      }
      function ws(ie) {
        return ie && ie.slice(0, Ss(ie) + 1).replace(tr, "");
      }
      function ir(ie) {
        return function(ve) {
          return ie(ve);
        };
      }
      function ea(ie, ve) {
        return Tt(ve, function(ce) {
          return ie[ce];
        });
      }
      function Oi(ie, ve) {
        return ie.has(ve);
      }
      function Es(ie, ve) {
        for (var ce = -1, De = ie.length; ++ce < De && di(ve, ie[ce], 0) > -1; )
          ;
        return ce;
      }
      function Ts(ie, ve) {
        for (var ce = ie.length; ce-- && di(ve, ie[ce], 0) > -1; )
          ;
        return ce;
      }
      function tl(ie, ve) {
        for (var ce = ie.length, De = 0; ce--; )
          ie[ce] === ve && ++De;
        return De;
      }
      var rl = Jn(Bu), il = Jn($u);
      function nl(ie) {
        return "\\" + Uu[ie];
      }
      function al(ie, ve) {
        return ie == null ? t : ie[ve];
      }
      function pi(ie) {
        return Lu.test(ie);
      }
      function sl(ie) {
        return Nu.test(ie);
      }
      function ol(ie) {
        for (var ve, ce = []; !(ve = ie.next()).done; )
          ce.push(ve.value);
        return ce;
      }
      function ta(ie) {
        var ve = -1, ce = Array(ie.size);
        return ie.forEach(function(De, Qe) {
          ce[++ve] = [Qe, De];
        }), ce;
      }
      function Cs(ie, ve) {
        return function(ce) {
          return ie(ve(ce));
        };
      }
      function Vr(ie, ve) {
        for (var ce = -1, De = ie.length, Qe = 0, ft = []; ++ce < De; ) {
          var Lt = ie[ce];
          (Lt === ve || Lt === f) && (ie[ce] = f, ft[Qe++] = ce);
        }
        return ft;
      }
      function Qi(ie) {
        var ve = -1, ce = Array(ie.size);
        return ie.forEach(function(De) {
          ce[++ve] = De;
        }), ce;
      }
      function ul(ie) {
        var ve = -1, ce = Array(ie.size);
        return ie.forEach(function(De) {
          ce[++ve] = [De, De];
        }), ce;
      }
      function ll(ie, ve, ce) {
        for (var De = ce - 1, Qe = ie.length; ++De < Qe; )
          if (ie[De] === ve)
            return De;
        return -1;
      }
      function hl(ie, ve, ce) {
        for (var De = ce + 1; De--; )
          if (ie[De] === ve)
            return De;
        return De;
      }
      function mi(ie) {
        return pi(ie) ? fl(ie) : Yu(ie);
      }
      function vr(ie) {
        return pi(ie) ? dl(ie) : Ku(ie);
      }
      function Ss(ie) {
        for (var ve = ie.length; ve-- && _r.test(ie.charAt(ve)); )
          ;
        return ve;
      }
      var cl = Jn(ju);
      function fl(ie) {
        for (var ve = zn.lastIndex = 0; zn.test(ie); )
          ++ve;
        return ve;
      }
      function dl(ie) {
        return ie.match(zn) || [];
      }
      function pl(ie) {
        return ie.match(ku) || [];
      }
      var ml = function ie(ve) {
        ve = ve == null ? $t : vi.defaults($t.Object(), ve, vi.pick($t, Du));
        var ce = ve.Array, De = ve.Date, Qe = ve.Error, ft = ve.Function, Lt = ve.Math, _t = ve.Object, ra = ve.RegExp, vl = ve.String, hr = ve.TypeError, en = ce.prototype, yl = ft.prototype, gi = _t.prototype, tn = ve["__core-js_shared__"], rn = yl.toString, yt = gi.hasOwnProperty, bl = 0, Rs = function() {
          var o = /[^.]+$/.exec(tn && tn.keys && tn.keys.IE_PROTO || "");
          return o ? "Symbol(src)_1." + o : "";
        }(), nn = gi.toString, _l = rn.call(_t), xl = $t._, wl = ra(
          "^" + rn.call(yt).replace(Vt, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
        ), an = hs ? ve.Buffer : t, Hr = ve.Symbol, sn = ve.Uint8Array, As = an ? an.allocUnsafe : t, on = Cs(_t.getPrototypeOf, _t), Ms = _t.create, Os = gi.propertyIsEnumerable, un = en.splice, Is = Hr ? Hr.isConcatSpreadable : t, Ii = Hr ? Hr.iterator : t, ti = Hr ? Hr.toStringTag : t, ln = function() {
          try {
            var o = si(_t, "defineProperty");
            return o({}, "", {}), o;
          } catch {
          }
        }(), El = ve.clearTimeout !== $t.clearTimeout && ve.clearTimeout, Tl = De && De.now !== $t.Date.now && De.now, Cl = ve.setTimeout !== $t.setTimeout && ve.setTimeout, hn = Lt.ceil, cn = Lt.floor, ia = _t.getOwnPropertySymbols, Sl = an ? an.isBuffer : t, Ps = ve.isFinite, Rl = en.join, Al = Cs(_t.keys, _t), Nt = Lt.max, Gt = Lt.min, Ml = De.now, Ol = ve.parseInt, qs = Lt.random, Il = en.reverse, na = si(ve, "DataView"), Pi = si(ve, "Map"), aa = si(ve, "Promise"), yi = si(ve, "Set"), qi = si(ve, "WeakMap"), ki = si(_t, "create"), fn = qi && new qi(), bi = {}, Pl = oi(na), ql = oi(Pi), kl = oi(aa), Ll = oi(yi), Nl = oi(qi), dn = Hr ? Hr.prototype : t, Li = dn ? dn.valueOf : t, ks = dn ? dn.toString : t;
        function j(o) {
          if (At(o) && !tt(o) && !(o instanceof ot)) {
            if (o instanceof cr)
              return o;
            if (yt.call(o, "__wrapped__"))
              return Do(o);
          }
          return new cr(o);
        }
        var _i = /* @__PURE__ */ function() {
          function o() {
          }
          return function(h) {
            if (!St(h))
              return {};
            if (Ms)
              return Ms(h);
            o.prototype = h;
            var v = new o();
            return o.prototype = t, v;
          };
        }();
        function pn() {
        }
        function cr(o, h) {
          this.__wrapped__ = o, this.__actions__ = [], this.__chain__ = !!h, this.__index__ = 0, this.__values__ = t;
        }
        j.templateSettings = {
          /**
           * Used to detect `data` property values to be HTML-escaped.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          escape: Je,
          /**
           * Used to detect code to be evaluated.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          evaluate: ht,
          /**
           * Used to detect `data` property values to inject.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          interpolate: bt,
          /**
           * Used to reference the data object in the template text.
           *
           * @memberOf _.templateSettings
           * @type {string}
           */
          variable: "",
          /**
           * Used to import variables into the compiled template.
           *
           * @memberOf _.templateSettings
           * @type {Object}
           */
          imports: {
            /**
             * A reference to the `lodash` function.
             *
             * @memberOf _.templateSettings.imports
             * @type {Function}
             */
            _: j
          }
        }, j.prototype = pn.prototype, j.prototype.constructor = j, cr.prototype = _i(pn.prototype), cr.prototype.constructor = cr;
        function ot(o) {
          this.__wrapped__ = o, this.__actions__ = [], this.__dir__ = 1, this.__filtered__ = false, this.__iteratees__ = [], this.__takeCount__ = V, this.__views__ = [];
        }
        function Dl() {
          var o = new ot(this.__wrapped__);
          return o.__actions__ = Yt(this.__actions__), o.__dir__ = this.__dir__, o.__filtered__ = this.__filtered__, o.__iteratees__ = Yt(this.__iteratees__), o.__takeCount__ = this.__takeCount__, o.__views__ = Yt(this.__views__), o;
        }
        function Fl() {
          if (this.__filtered__) {
            var o = new ot(this);
            o.__dir__ = -1, o.__filtered__ = true;
          } else
            o = this.clone(), o.__dir__ *= -1;
          return o;
        }
        function Bl() {
          var o = this.__wrapped__.value(), h = this.__dir__, v = tt(o), R = h < 0, N = v ? o.length : 0, H = Jh(0, N, this.__views__), Z = H.start, Q = H.end, se = Q - Z, xe = R ? Q : Z - 1, we = this.__iteratees__, Ce = we.length, Le = 0, Be = Gt(se, this.__takeCount__);
          if (!v || !R && N == se && Be == se)
            return ao(o, this.__actions__);
          var Ve = [];
          e:
            for (; se-- && Le < Be; ) {
              xe += h;
              for (var it = -1, He = o[xe]; ++it < Ce; ) {
                var st = we[it], ut = st.iteratee, sr = st.type, Xt = ut(He);
                if (sr == X)
                  He = Xt;
                else if (!Xt) {
                  if (sr == D)
                    continue e;
                  break e;
                }
              }
              Ve[Le++] = He;
            }
          return Ve;
        }
        ot.prototype = _i(pn.prototype), ot.prototype.constructor = ot;
        function ri(o) {
          var h = -1, v = o == null ? 0 : o.length;
          for (this.clear(); ++h < v; ) {
            var R = o[h];
            this.set(R[0], R[1]);
          }
        }
        function $l() {
          this.__data__ = ki ? ki(null) : {}, this.size = 0;
        }
        function jl(o) {
          var h = this.has(o) && delete this.__data__[o];
          return this.size -= h ? 1 : 0, h;
        }
        function Ul(o) {
          var h = this.__data__;
          if (ki) {
            var v = h[o];
            return v === c ? t : v;
          }
          return yt.call(h, o) ? h[o] : t;
        }
        function Gl(o) {
          var h = this.__data__;
          return ki ? h[o] !== t : yt.call(h, o);
        }
        function zl(o, h) {
          var v = this.__data__;
          return this.size += this.has(o) ? 0 : 1, v[o] = ki && h === t ? c : h, this;
        }
        ri.prototype.clear = $l, ri.prototype.delete = jl, ri.prototype.get = Ul, ri.prototype.has = Gl, ri.prototype.set = zl;
        function Pr(o) {
          var h = -1, v = o == null ? 0 : o.length;
          for (this.clear(); ++h < v; ) {
            var R = o[h];
            this.set(R[0], R[1]);
          }
        }
        function Vl() {
          this.__data__ = [], this.size = 0;
        }
        function Hl(o) {
          var h = this.__data__, v = mn(h, o);
          if (v < 0)
            return false;
          var R = h.length - 1;
          return v == R ? h.pop() : un.call(h, v, 1), --this.size, true;
        }
        function Wl(o) {
          var h = this.__data__, v = mn(h, o);
          return v < 0 ? t : h[v][1];
        }
        function Xl(o) {
          return mn(this.__data__, o) > -1;
        }
        function Yl(o, h) {
          var v = this.__data__, R = mn(v, o);
          return R < 0 ? (++this.size, v.push([o, h])) : v[R][1] = h, this;
        }
        Pr.prototype.clear = Vl, Pr.prototype.delete = Hl, Pr.prototype.get = Wl, Pr.prototype.has = Xl, Pr.prototype.set = Yl;
        function qr(o) {
          var h = -1, v = o == null ? 0 : o.length;
          for (this.clear(); ++h < v; ) {
            var R = o[h];
            this.set(R[0], R[1]);
          }
        }
        function Kl() {
          this.size = 0, this.__data__ = {
            hash: new ri(),
            map: new (Pi || Pr)(),
            string: new ri()
          };
        }
        function Jl(o) {
          var h = Rn(this, o).delete(o);
          return this.size -= h ? 1 : 0, h;
        }
        function Zl(o) {
          return Rn(this, o).get(o);
        }
        function Ql(o) {
          return Rn(this, o).has(o);
        }
        function eh(o, h) {
          var v = Rn(this, o), R = v.size;
          return v.set(o, h), this.size += v.size == R ? 0 : 1, this;
        }
        qr.prototype.clear = Kl, qr.prototype.delete = Jl, qr.prototype.get = Zl, qr.prototype.has = Ql, qr.prototype.set = eh;
        function ii(o) {
          var h = -1, v = o == null ? 0 : o.length;
          for (this.__data__ = new qr(); ++h < v; )
            this.add(o[h]);
        }
        function th(o) {
          return this.__data__.set(o, c), this;
        }
        function rh(o) {
          return this.__data__.has(o);
        }
        ii.prototype.add = ii.prototype.push = th, ii.prototype.has = rh;
        function gr(o) {
          var h = this.__data__ = new Pr(o);
          this.size = h.size;
        }
        function ih() {
          this.__data__ = new Pr(), this.size = 0;
        }
        function nh(o) {
          var h = this.__data__, v = h.delete(o);
          return this.size = h.size, v;
        }
        function ah(o) {
          return this.__data__.get(o);
        }
        function sh(o) {
          return this.__data__.has(o);
        }
        function oh(o, h) {
          var v = this.__data__;
          if (v instanceof Pr) {
            var R = v.__data__;
            if (!Pi || R.length < a - 1)
              return R.push([o, h]), this.size = ++v.size, this;
            v = this.__data__ = new qr(R);
          }
          return v.set(o, h), this.size = v.size, this;
        }
        gr.prototype.clear = ih, gr.prototype.delete = nh, gr.prototype.get = ah, gr.prototype.has = sh, gr.prototype.set = oh;
        function Ls(o, h) {
          var v = tt(o), R = !v && ui(o), N = !v && !R && Jr(o), H = !v && !R && !N && Ti(o), Z = v || R || N || H, Q = Z ? Qn(o.length, vl) : [], se = Q.length;
          for (var xe in o)
            (h || yt.call(o, xe)) && !(Z && // Safari 9 has enumerable `arguments.length` in strict mode.
            (xe == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
            N && (xe == "offset" || xe == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
            H && (xe == "buffer" || xe == "byteLength" || xe == "byteOffset") || // Skip index properties.
            Dr(xe, se))) && Q.push(xe);
          return Q;
        }
        function Ns(o) {
          var h = o.length;
          return h ? o[va(0, h - 1)] : t;
        }
        function uh(o, h) {
          return An(Yt(o), ni(h, 0, o.length));
        }
        function lh(o) {
          return An(Yt(o));
        }
        function sa(o, h, v) {
          (v !== t && !yr(o[h], v) || v === t && !(h in o)) && kr(o, h, v);
        }
        function Ni(o, h, v) {
          var R = o[h];
          (!(yt.call(o, h) && yr(R, v)) || v === t && !(h in o)) && kr(o, h, v);
        }
        function mn(o, h) {
          for (var v = o.length; v--; )
            if (yr(o[v][0], h))
              return v;
          return -1;
        }
        function hh(o, h, v, R) {
          return Wr(o, function(N, H, Z) {
            h(R, N, v(N), Z);
          }), R;
        }
        function Ds(o, h) {
          return o && Tr(h, Bt(h), o);
        }
        function ch(o, h) {
          return o && Tr(h, Jt(h), o);
        }
        function kr(o, h, v) {
          h == "__proto__" && ln ? ln(o, h, {
            configurable: true,
            enumerable: true,
            value: v,
            writable: true
          }) : o[h] = v;
        }
        function oa(o, h) {
          for (var v = -1, R = h.length, N = ce(R), H = o == null; ++v < R; )
            N[v] = H ? t : ja(o, h[v]);
          return N;
        }
        function ni(o, h, v) {
          return o === o && (v !== t && (o = o <= v ? o : v), h !== t && (o = o >= h ? o : h)), o;
        }
        function fr(o, h, v, R, N, H) {
          var Z, Q = h & p, se = h & m, xe = h & y;
          if (v && (Z = N ? v(o, R, N, H) : v(o)), Z !== t)
            return Z;
          if (!St(o))
            return o;
          var we = tt(o);
          if (we) {
            if (Z = Qh(o), !Q)
              return Yt(o, Z);
          } else {
            var Ce = zt(o), Le = Ce == Ae || Ce == ke;
            if (Jr(o))
              return uo(o, Q);
            if (Ce == $e || Ce == re || Le && !N) {
              if (Z = se || Le ? {} : Ao(o), !Q)
                return se ? Uh(o, ch(Z, o)) : jh(o, Ds(Z, o));
            } else {
              if (!wt[Ce])
                return N ? o : {};
              Z = ec(o, Ce, Q);
            }
          }
          H || (H = new gr());
          var Be = H.get(o);
          if (Be)
            return Be;
          H.set(o, Z), iu(o) ? o.forEach(function(He) {
            Z.add(fr(He, h, v, He, o, H));
          }) : tu(o) && o.forEach(function(He, st) {
            Z.set(st, fr(He, h, v, st, o, H));
          });
          var Ve = xe ? se ? Ra : Sa : se ? Jt : Bt, it = we ? t : Ve(o);
          return lr(it || o, function(He, st) {
            it && (st = He, He = o[st]), Ni(Z, st, fr(He, h, v, st, o, H));
          }), Z;
        }
        function fh(o) {
          var h = Bt(o);
          return function(v) {
            return Fs(v, o, h);
          };
        }
        function Fs(o, h, v) {
          var R = v.length;
          if (o == null)
            return !R;
          for (o = _t(o); R--; ) {
            var N = v[R], H = h[N], Z = o[N];
            if (Z === t && !(N in o) || !H(Z))
              return false;
          }
          return true;
        }
        function Bs(o, h, v) {
          if (typeof o != "function")
            throw new hr(u);
          return Gi(function() {
            o.apply(t, v);
          }, h);
        }
        function Di(o, h, v, R) {
          var N = -1, H = Ji, Z = true, Q = o.length, se = [], xe = h.length;
          if (!Q)
            return se;
          v && (h = Tt(h, ir(v))), R ? (H = Wn, Z = false) : h.length >= a && (H = Oi, Z = false, h = new ii(h));
          e:
            for (; ++N < Q; ) {
              var we = o[N], Ce = v == null ? we : v(we);
              if (we = R || we !== 0 ? we : 0, Z && Ce === Ce) {
                for (var Le = xe; Le--; )
                  if (h[Le] === Ce)
                    continue e;
                se.push(we);
              } else H(h, Ce, R) || se.push(we);
            }
          return se;
        }
        var Wr = po(Er), $s = po(la, true);
        function dh(o, h) {
          var v = true;
          return Wr(o, function(R, N, H) {
            return v = !!h(R, N, H), v;
          }), v;
        }
        function vn(o, h, v) {
          for (var R = -1, N = o.length; ++R < N; ) {
            var H = o[R], Z = h(H);
            if (Z != null && (Q === t ? Z === Z && !ar(Z) : v(Z, Q)))
              var Q = Z, se = H;
          }
          return se;
        }
        function ph(o, h, v, R) {
          var N = o.length;
          for (v = rt(v), v < 0 && (v = -v > N ? 0 : N + v), R = R === t || R > N ? N : rt(R), R < 0 && (R += N), R = v > R ? 0 : au(R); v < R; )
            o[v++] = h;
          return o;
        }
        function js(o, h) {
          var v = [];
          return Wr(o, function(R, N, H) {
            h(R, N, H) && v.push(R);
          }), v;
        }
        function jt(o, h, v, R, N) {
          var H = -1, Z = o.length;
          for (v || (v = rc), N || (N = []); ++H < Z; ) {
            var Q = o[H];
            h > 0 && v(Q) ? h > 1 ? jt(Q, h - 1, v, R, N) : zr(N, Q) : R || (N[N.length] = Q);
          }
          return N;
        }
        var ua = mo(), Us = mo(true);
        function Er(o, h) {
          return o && ua(o, h, Bt);
        }
        function la(o, h) {
          return o && Us(o, h, Bt);
        }
        function gn(o, h) {
          return Gr(h, function(v) {
            return Fr(o[v]);
          });
        }
        function ai(o, h) {
          h = Yr(h, o);
          for (var v = 0, R = h.length; o != null && v < R; )
            o = o[Cr(h[v++])];
          return v && v == R ? o : t;
        }
        function Gs(o, h, v) {
          var R = h(o);
          return tt(o) ? R : zr(R, v(o));
        }
        function Ht(o) {
          return o == null ? o === t ? Rt : Oe : ti && ti in _t(o) ? Kh(o) : lc(o);
        }
        function ha(o, h) {
          return o > h;
        }
        function mh(o, h) {
          return o != null && yt.call(o, h);
        }
        function vh(o, h) {
          return o != null && h in _t(o);
        }
        function gh(o, h, v) {
          return o >= Gt(h, v) && o < Nt(h, v);
        }
        function ca(o, h, v) {
          for (var R = v ? Wn : Ji, N = o[0].length, H = o.length, Z = H, Q = ce(H), se = 1 / 0, xe = []; Z--; ) {
            var we = o[Z];
            Z && h && (we = Tt(we, ir(h))), se = Gt(we.length, se), Q[Z] = !v && (h || N >= 120 && we.length >= 120) ? new ii(Z && we) : t;
          }
          we = o[0];
          var Ce = -1, Le = Q[0];
          e:
            for (; ++Ce < N && xe.length < se; ) {
              var Be = we[Ce], Ve = h ? h(Be) : Be;
              if (Be = v || Be !== 0 ? Be : 0, !(Le ? Oi(Le, Ve) : R(xe, Ve, v))) {
                for (Z = H; --Z; ) {
                  var it = Q[Z];
                  if (!(it ? Oi(it, Ve) : R(o[Z], Ve, v)))
                    continue e;
                }
                Le && Le.push(Ve), xe.push(Be);
              }
            }
          return xe;
        }
        function yh(o, h, v, R) {
          return Er(o, function(N, H, Z) {
            h(R, v(N), H, Z);
          }), R;
        }
        function Fi(o, h, v) {
          h = Yr(h, o), o = Po(o, h);
          var R = o == null ? o : o[Cr(pr(h))];
          return R == null ? t : rr(R, o, v);
        }
        function zs(o) {
          return At(o) && Ht(o) == re;
        }
        function bh(o) {
          return At(o) && Ht(o) == $;
        }
        function _h(o) {
          return At(o) && Ht(o) == Te;
        }
        function Bi(o, h, v, R, N) {
          return o === h ? true : o == null || h == null || !At(o) && !At(h) ? o !== o && h !== h : xh(o, h, v, R, Bi, N);
        }
        function xh(o, h, v, R, N, H) {
          var Z = tt(o), Q = tt(h), se = Z ? he : zt(o), xe = Q ? he : zt(h);
          se = se == re ? $e : se, xe = xe == re ? $e : xe;
          var we = se == $e, Ce = xe == $e, Le = se == xe;
          if (Le && Jr(o)) {
            if (!Jr(h))
              return false;
            Z = true, we = false;
          }
          if (Le && !we)
            return H || (H = new gr()), Z || Ti(o) ? Co(o, h, v, R, N, H) : Xh(o, h, se, v, R, N, H);
          if (!(v & x)) {
            var Be = we && yt.call(o, "__wrapped__"), Ve = Ce && yt.call(h, "__wrapped__");
            if (Be || Ve) {
              var it = Be ? o.value() : o, He = Ve ? h.value() : h;
              return H || (H = new gr()), N(it, He, v, R, H);
            }
          }
          return Le ? (H || (H = new gr()), Yh(o, h, v, R, N, H)) : false;
        }
        function wh(o) {
          return At(o) && zt(o) == Pe;
        }
        function fa(o, h, v, R) {
          var N = v.length, H = N, Z = !R;
          if (o == null)
            return !H;
          for (o = _t(o); N--; ) {
            var Q = v[N];
            if (Z && Q[2] ? Q[1] !== o[Q[0]] : !(Q[0] in o))
              return false;
          }
          for (; ++N < H; ) {
            Q = v[N];
            var se = Q[0], xe = o[se], we = Q[1];
            if (Z && Q[2]) {
              if (xe === t && !(se in o))
                return false;
            } else {
              var Ce = new gr();
              if (R)
                var Le = R(xe, we, se, o, h, Ce);
              if (!(Le === t ? Bi(we, xe, x | g, R, Ce) : Le))
                return false;
            }
          }
          return true;
        }
        function Vs(o) {
          if (!St(o) || nc(o))
            return false;
          var h = Fr(o) ? wl : Zr;
          return h.test(oi(o));
        }
        function Eh(o) {
          return At(o) && Ht(o) == vt;
        }
        function Th(o) {
          return At(o) && zt(o) == Xe;
        }
        function Ch(o) {
          return At(o) && kn(o.length) && !!Et[Ht(o)];
        }
        function Hs(o) {
          return typeof o == "function" ? o : o == null ? Zt : typeof o == "object" ? tt(o) ? Ys(o[0], o[1]) : Xs(o) : vu(o);
        }
        function da(o) {
          if (!Ui(o))
            return Al(o);
          var h = [];
          for (var v in _t(o))
            yt.call(o, v) && v != "constructor" && h.push(v);
          return h;
        }
        function Sh(o) {
          if (!St(o))
            return uc(o);
          var h = Ui(o), v = [];
          for (var R in o)
            R == "constructor" && (h || !yt.call(o, R)) || v.push(R);
          return v;
        }
        function pa(o, h) {
          return o < h;
        }
        function Ws(o, h) {
          var v = -1, R = Kt(o) ? ce(o.length) : [];
          return Wr(o, function(N, H, Z) {
            R[++v] = h(N, H, Z);
          }), R;
        }
        function Xs(o) {
          var h = Ma(o);
          return h.length == 1 && h[0][2] ? Oo(h[0][0], h[0][1]) : function(v) {
            return v === o || fa(v, o, h);
          };
        }
        function Ys(o, h) {
          return Ia(o) && Mo(h) ? Oo(Cr(o), h) : function(v) {
            var R = ja(v, o);
            return R === t && R === h ? Ua(v, o) : Bi(h, R, x | g);
          };
        }
        function yn(o, h, v, R, N) {
          o !== h && ua(h, function(H, Z) {
            if (N || (N = new gr()), St(H))
              Rh(o, h, Z, v, yn, R, N);
            else {
              var Q = R ? R(qa(o, Z), H, Z + "", o, h, N) : t;
              Q === t && (Q = H), sa(o, Z, Q);
            }
          }, Jt);
        }
        function Rh(o, h, v, R, N, H, Z) {
          var Q = qa(o, v), se = qa(h, v), xe = Z.get(se);
          if (xe) {
            sa(o, v, xe);
            return;
          }
          var we = H ? H(Q, se, v + "", o, h, Z) : t, Ce = we === t;
          if (Ce) {
            var Le = tt(se), Be = !Le && Jr(se), Ve = !Le && !Be && Ti(se);
            we = se, Le || Be || Ve ? tt(Q) ? we = Q : Mt(Q) ? we = Yt(Q) : Be ? (Ce = false, we = uo(se, true)) : Ve ? (Ce = false, we = lo(se, true)) : we = [] : zi(se) || ui(se) ? (we = Q, ui(Q) ? we = su(Q) : (!St(Q) || Fr(Q)) && (we = Ao(se))) : Ce = false;
          }
          Ce && (Z.set(se, we), N(we, se, R, H, Z), Z.delete(se)), sa(o, v, we);
        }
        function Ks(o, h) {
          var v = o.length;
          if (v)
            return h += h < 0 ? v : 0, Dr(h, v) ? o[h] : t;
        }
        function Js(o, h, v) {
          h.length ? h = Tt(h, function(H) {
            return tt(H) ? function(Z) {
              return ai(Z, H.length === 1 ? H[0] : H);
            } : H;
          }) : h = [Zt];
          var R = -1;
          h = Tt(h, ir(Ge()));
          var N = Ws(o, function(H, Z, Q) {
            var se = Tt(h, function(xe) {
              return xe(H);
            });
            return { criteria: se, index: ++R, value: H };
          });
          return Qu(N, function(H, Z) {
            return $h(H, Z, v);
          });
        }
        function Ah(o, h) {
          return Zs(o, h, function(v, R) {
            return Ua(o, R);
          });
        }
        function Zs(o, h, v) {
          for (var R = -1, N = h.length, H = {}; ++R < N; ) {
            var Z = h[R], Q = ai(o, Z);
            v(Q, Z) && $i(H, Yr(Z, o), Q);
          }
          return H;
        }
        function Mh(o) {
          return function(h) {
            return ai(h, o);
          };
        }
        function ma(o, h, v, R) {
          var N = R ? Zu : di, H = -1, Z = h.length, Q = o;
          for (o === h && (h = Yt(h)), v && (Q = Tt(o, ir(v))); ++H < Z; )
            for (var se = 0, xe = h[H], we = v ? v(xe) : xe; (se = N(Q, we, se, R)) > -1; )
              Q !== o && un.call(Q, se, 1), un.call(o, se, 1);
          return o;
        }
        function Qs(o, h) {
          for (var v = o ? h.length : 0, R = v - 1; v--; ) {
            var N = h[v];
            if (v == R || N !== H) {
              var H = N;
              Dr(N) ? un.call(o, N, 1) : ba(o, N);
            }
          }
          return o;
        }
        function va(o, h) {
          return o + cn(qs() * (h - o + 1));
        }
        function Oh(o, h, v, R) {
          for (var N = -1, H = Nt(hn((h - o) / (v || 1)), 0), Z = ce(H); H--; )
            Z[R ? H : ++N] = o, o += v;
          return Z;
        }
        function ga(o, h) {
          var v = "";
          if (!o || h < 1 || h > P)
            return v;
          do
            h % 2 && (v += o), h = cn(h / 2), h && (o += o);
          while (h);
          return v;
        }
        function nt(o, h) {
          return ka(Io(o, h, Zt), o + "");
        }
        function Ih(o) {
          return Ns(Ci(o));
        }
        function Ph(o, h) {
          var v = Ci(o);
          return An(v, ni(h, 0, v.length));
        }
        function $i(o, h, v, R) {
          if (!St(o))
            return o;
          h = Yr(h, o);
          for (var N = -1, H = h.length, Z = H - 1, Q = o; Q != null && ++N < H; ) {
            var se = Cr(h[N]), xe = v;
            if (se === "__proto__" || se === "constructor" || se === "prototype")
              return o;
            if (N != Z) {
              var we = Q[se];
              xe = R ? R(we, se, Q) : t, xe === t && (xe = St(we) ? we : Dr(h[N + 1]) ? [] : {});
            }
            Ni(Q, se, xe), Q = Q[se];
          }
          return o;
        }
        var eo = fn ? function(o, h) {
          return fn.set(o, h), o;
        } : Zt, qh = ln ? function(o, h) {
          return ln(o, "toString", {
            configurable: true,
            enumerable: false,
            value: za(h),
            writable: true
          });
        } : Zt;
        function kh(o) {
          return An(Ci(o));
        }
        function dr(o, h, v) {
          var R = -1, N = o.length;
          h < 0 && (h = -h > N ? 0 : N + h), v = v > N ? N : v, v < 0 && (v += N), N = h > v ? 0 : v - h >>> 0, h >>>= 0;
          for (var H = ce(N); ++R < N; )
            H[R] = o[R + h];
          return H;
        }
        function Lh(o, h) {
          var v;
          return Wr(o, function(R, N, H) {
            return v = h(R, N, H), !v;
          }), !!v;
        }
        function bn(o, h, v) {
          var R = 0, N = o == null ? R : o.length;
          if (typeof h == "number" && h === h && N <= J) {
            for (; R < N; ) {
              var H = R + N >>> 1, Z = o[H];
              Z !== null && !ar(Z) && (v ? Z <= h : Z < h) ? R = H + 1 : N = H;
            }
            return N;
          }
          return ya(o, h, Zt, v);
        }
        function ya(o, h, v, R) {
          var N = 0, H = o == null ? 0 : o.length;
          if (H === 0)
            return 0;
          h = v(h);
          for (var Z = h !== h, Q = h === null, se = ar(h), xe = h === t; N < H; ) {
            var we = cn((N + H) / 2), Ce = v(o[we]), Le = Ce !== t, Be = Ce === null, Ve = Ce === Ce, it = ar(Ce);
            if (Z)
              var He = R || Ve;
            else xe ? He = Ve && (R || Le) : Q ? He = Ve && Le && (R || !Be) : se ? He = Ve && Le && !Be && (R || !it) : Be || it ? He = false : He = R ? Ce <= h : Ce < h;
            He ? N = we + 1 : H = we;
          }
          return Gt(H, K);
        }
        function to(o, h) {
          for (var v = -1, R = o.length, N = 0, H = []; ++v < R; ) {
            var Z = o[v], Q = h ? h(Z) : Z;
            if (!v || !yr(Q, se)) {
              var se = Q;
              H[N++] = Z === 0 ? 0 : Z;
            }
          }
          return H;
        }
        function ro(o) {
          return typeof o == "number" ? o : ar(o) ? W : +o;
        }
        function nr(o) {
          if (typeof o == "string")
            return o;
          if (tt(o))
            return Tt(o, nr) + "";
          if (ar(o))
            return ks ? ks.call(o) : "";
          var h = o + "";
          return h == "0" && 1 / o == -1 / 0 ? "-0" : h;
        }
        function Xr(o, h, v) {
          var R = -1, N = Ji, H = o.length, Z = true, Q = [], se = Q;
          if (v)
            Z = false, N = Wn;
          else if (H >= a) {
            var xe = h ? null : Hh(o);
            if (xe)
              return Qi(xe);
            Z = false, N = Oi, se = new ii();
          } else
            se = h ? [] : Q;
          e:
            for (; ++R < H; ) {
              var we = o[R], Ce = h ? h(we) : we;
              if (we = v || we !== 0 ? we : 0, Z && Ce === Ce) {
                for (var Le = se.length; Le--; )
                  if (se[Le] === Ce)
                    continue e;
                h && se.push(Ce), Q.push(we);
              } else N(se, Ce, v) || (se !== Q && se.push(Ce), Q.push(we));
            }
          return Q;
        }
        function ba(o, h) {
          return h = Yr(h, o), o = Po(o, h), o == null || delete o[Cr(pr(h))];
        }
        function io(o, h, v, R) {
          return $i(o, h, v(ai(o, h)), R);
        }
        function _n(o, h, v, R) {
          for (var N = o.length, H = R ? N : -1; (R ? H-- : ++H < N) && h(o[H], H, o); )
            ;
          return v ? dr(o, R ? 0 : H, R ? H + 1 : N) : dr(o, R ? H + 1 : 0, R ? N : H);
        }
        function ao(o, h) {
          var v = o;
          return v instanceof ot && (v = v.value()), Xn(h, function(R, N) {
            return N.func.apply(N.thisArg, zr([R], N.args));
          }, v);
        }
        function _a(o, h, v) {
          var R = o.length;
          if (R < 2)
            return R ? Xr(o[0]) : [];
          for (var N = -1, H = ce(R); ++N < R; )
            for (var Z = o[N], Q = -1; ++Q < R; )
              Q != N && (H[N] = Di(H[N] || Z, o[Q], h, v));
          return Xr(jt(H, 1), h, v);
        }
        function so(o, h, v) {
          for (var R = -1, N = o.length, H = h.length, Z = {}; ++R < N; ) {
            var Q = R < H ? h[R] : t;
            v(Z, o[R], Q);
          }
          return Z;
        }
        function xa(o) {
          return Mt(o) ? o : [];
        }
        function wa(o) {
          return typeof o == "function" ? o : Zt;
        }
        function Yr(o, h) {
          return tt(o) ? o : Ia(o, h) ? [o] : No(mt(o));
        }
        var Nh = nt;
        function Kr(o, h, v) {
          var R = o.length;
          return v = v === t ? R : v, !h && v >= R ? o : dr(o, h, v);
        }
        var oo = El || function(o) {
          return $t.clearTimeout(o);
        };
        function uo(o, h) {
          if (h)
            return o.slice();
          var v = o.length, R = As ? As(v) : new o.constructor(v);
          return o.copy(R), R;
        }
        function Ea(o) {
          var h = new o.constructor(o.byteLength);
          return new sn(h).set(new sn(o)), h;
        }
        function Dh(o, h) {
          var v = h ? Ea(o.buffer) : o.buffer;
          return new o.constructor(v, o.byteOffset, o.byteLength);
        }
        function Fh(o) {
          var h = new o.constructor(o.source, Ri.exec(o));
          return h.lastIndex = o.lastIndex, h;
        }
        function Bh(o) {
          return Li ? _t(Li.call(o)) : {};
        }
        function lo(o, h) {
          var v = h ? Ea(o.buffer) : o.buffer;
          return new o.constructor(v, o.byteOffset, o.length);
        }
        function ho(o, h) {
          if (o !== h) {
            var v = o !== t, R = o === null, N = o === o, H = ar(o), Z = h !== t, Q = h === null, se = h === h, xe = ar(h);
            if (!Q && !xe && !H && o > h || H && Z && se && !Q && !xe || R && Z && se || !v && se || !N)
              return 1;
            if (!R && !H && !xe && o < h || xe && v && N && !R && !H || Q && v && N || !Z && N || !se)
              return -1;
          }
          return 0;
        }
        function $h(o, h, v) {
          for (var R = -1, N = o.criteria, H = h.criteria, Z = N.length, Q = v.length; ++R < Z; ) {
            var se = ho(N[R], H[R]);
            if (se) {
              if (R >= Q)
                return se;
              var xe = v[R];
              return se * (xe == "desc" ? -1 : 1);
            }
          }
          return o.index - h.index;
        }
        function co(o, h, v, R) {
          for (var N = -1, H = o.length, Z = v.length, Q = -1, se = h.length, xe = Nt(H - Z, 0), we = ce(se + xe), Ce = !R; ++Q < se; )
            we[Q] = h[Q];
          for (; ++N < Z; )
            (Ce || N < H) && (we[v[N]] = o[N]);
          for (; xe--; )
            we[Q++] = o[N++];
          return we;
        }
        function fo(o, h, v, R) {
          for (var N = -1, H = o.length, Z = -1, Q = v.length, se = -1, xe = h.length, we = Nt(H - Q, 0), Ce = ce(we + xe), Le = !R; ++N < we; )
            Ce[N] = o[N];
          for (var Be = N; ++se < xe; )
            Ce[Be + se] = h[se];
          for (; ++Z < Q; )
            (Le || N < H) && (Ce[Be + v[Z]] = o[N++]);
          return Ce;
        }
        function Yt(o, h) {
          var v = -1, R = o.length;
          for (h || (h = ce(R)); ++v < R; )
            h[v] = o[v];
          return h;
        }
        function Tr(o, h, v, R) {
          var N = !v;
          v || (v = {});
          for (var H = -1, Z = h.length; ++H < Z; ) {
            var Q = h[H], se = R ? R(v[Q], o[Q], Q, v, o) : t;
            se === t && (se = o[Q]), N ? kr(v, Q, se) : Ni(v, Q, se);
          }
          return v;
        }
        function jh(o, h) {
          return Tr(o, Oa(o), h);
        }
        function Uh(o, h) {
          return Tr(o, So(o), h);
        }
        function xn(o, h) {
          return function(v, R) {
            var N = tt(v) ? Hu : hh, H = h ? h() : {};
            return N(v, o, Ge(R, 2), H);
          };
        }
        function xi(o) {
          return nt(function(h, v) {
            var R = -1, N = v.length, H = N > 1 ? v[N - 1] : t, Z = N > 2 ? v[2] : t;
            for (H = o.length > 3 && typeof H == "function" ? (N--, H) : t, Z && Wt(v[0], v[1], Z) && (H = N < 3 ? t : H, N = 1), h = _t(h); ++R < N; ) {
              var Q = v[R];
              Q && o(h, Q, R, H);
            }
            return h;
          });
        }
        function po(o, h) {
          return function(v, R) {
            if (v == null)
              return v;
            if (!Kt(v))
              return o(v, R);
            for (var N = v.length, H = h ? N : -1, Z = _t(v); (h ? H-- : ++H < N) && R(Z[H], H, Z) !== false; )
              ;
            return v;
          };
        }
        function mo(o) {
          return function(h, v, R) {
            for (var N = -1, H = _t(h), Z = R(h), Q = Z.length; Q--; ) {
              var se = Z[o ? Q : ++N];
              if (v(H[se], se, H) === false)
                break;
            }
            return h;
          };
        }
        function Gh(o, h, v) {
          var R = h & _, N = ji(o);
          function H() {
            var Z = this && this !== $t && this instanceof H ? N : o;
            return Z.apply(R ? v : this, arguments);
          }
          return H;
        }
        function vo(o) {
          return function(h) {
            h = mt(h);
            var v = pi(h) ? vr(h) : t, R = v ? v[0] : h.charAt(0), N = v ? Kr(v, 1).join("") : h.slice(1);
            return R[o]() + N;
          };
        }
        function wi(o) {
          return function(h) {
            return Xn(pu(du(h).replace(Pu, "")), o, "");
          };
        }
        function ji(o) {
          return function() {
            var h = arguments;
            switch (h.length) {
              case 0:
                return new o();
              case 1:
                return new o(h[0]);
              case 2:
                return new o(h[0], h[1]);
              case 3:
                return new o(h[0], h[1], h[2]);
              case 4:
                return new o(h[0], h[1], h[2], h[3]);
              case 5:
                return new o(h[0], h[1], h[2], h[3], h[4]);
              case 6:
                return new o(h[0], h[1], h[2], h[3], h[4], h[5]);
              case 7:
                return new o(h[0], h[1], h[2], h[3], h[4], h[5], h[6]);
            }
            var v = _i(o.prototype), R = o.apply(v, h);
            return St(R) ? R : v;
          };
        }
        function zh(o, h, v) {
          var R = ji(o);
          function N() {
            for (var H = arguments.length, Z = ce(H), Q = H, se = Ei(N); Q--; )
              Z[Q] = arguments[Q];
            var xe = H < 3 && Z[0] !== se && Z[H - 1] !== se ? [] : Vr(Z, se);
            if (H -= xe.length, H < v)
              return xo(
                o,
                h,
                wn,
                N.placeholder,
                t,
                Z,
                xe,
                t,
                t,
                v - H
              );
            var we = this && this !== $t && this instanceof N ? R : o;
            return rr(we, this, Z);
          }
          return N;
        }
        function go(o) {
          return function(h, v, R) {
            var N = _t(h);
            if (!Kt(h)) {
              var H = Ge(v, 3);
              h = Bt(h), v = function(Q) {
                return H(N[Q], Q, N);
              };
            }
            var Z = o(h, v, R);
            return Z > -1 ? N[H ? h[Z] : Z] : t;
          };
        }
        function yo(o) {
          return Nr(function(h) {
            var v = h.length, R = v, N = cr.prototype.thru;
            for (o && h.reverse(); R--; ) {
              var H = h[R];
              if (typeof H != "function")
                throw new hr(u);
              if (N && !Z && Sn(H) == "wrapper")
                var Z = new cr([], true);
            }
            for (R = Z ? R : v; ++R < v; ) {
              H = h[R];
              var Q = Sn(H), se = Q == "wrapper" ? Aa(H) : t;
              se && Pa(se[0]) && se[1] == (S | b | w | F) && !se[4].length && se[9] == 1 ? Z = Z[Sn(se[0])].apply(Z, se[3]) : Z = H.length == 1 && Pa(H) ? Z[Q]() : Z.thru(H);
            }
            return function() {
              var xe = arguments, we = xe[0];
              if (Z && xe.length == 1 && tt(we))
                return Z.plant(we).value();
              for (var Ce = 0, Le = v ? h[Ce].apply(this, xe) : we; ++Ce < v; )
                Le = h[Ce].call(this, Le);
              return Le;
            };
          });
        }
        function wn(o, h, v, R, N, H, Z, Q, se, xe) {
          var we = h & S, Ce = h & _, Le = h & T, Be = h & (b | C), Ve = h & M, it = Le ? t : ji(o);
          function He() {
            for (var st = arguments.length, ut = ce(st), sr = st; sr--; )
              ut[sr] = arguments[sr];
            if (Be)
              var Xt = Ei(He), or = tl(ut, Xt);
            if (R && (ut = co(ut, R, N, Be)), H && (ut = fo(ut, H, Z, Be)), st -= or, Be && st < xe) {
              var Ot = Vr(ut, Xt);
              return xo(
                o,
                h,
                wn,
                He.placeholder,
                v,
                ut,
                Ot,
                Q,
                se,
                xe - st
              );
            }
            var br = Ce ? v : this, $r = Le ? br[o] : o;
            return st = ut.length, Q ? ut = hc(ut, Q) : Ve && st > 1 && ut.reverse(), we && se < st && (ut.length = se), this && this !== $t && this instanceof He && ($r = it || ji($r)), $r.apply(br, ut);
          }
          return He;
        }
        function bo(o, h) {
          return function(v, R) {
            return yh(v, o, h(R), {});
          };
        }
        function En(o, h) {
          return function(v, R) {
            var N;
            if (v === t && R === t)
              return h;
            if (v !== t && (N = v), R !== t) {
              if (N === t)
                return R;
              typeof v == "string" || typeof R == "string" ? (v = nr(v), R = nr(R)) : (v = ro(v), R = ro(R)), N = o(v, R);
            }
            return N;
          };
        }
        function Ta(o) {
          return Nr(function(h) {
            return h = Tt(h, ir(Ge())), nt(function(v) {
              var R = this;
              return o(h, function(N) {
                return rr(N, R, v);
              });
            });
          });
        }
        function Tn(o, h) {
          h = h === t ? " " : nr(h);
          var v = h.length;
          if (v < 2)
            return v ? ga(h, o) : h;
          var R = ga(h, hn(o / mi(h)));
          return pi(h) ? Kr(vr(R), 0, o).join("") : R.slice(0, o);
        }
        function Vh(o, h, v, R) {
          var N = h & _, H = ji(o);
          function Z() {
            for (var Q = -1, se = arguments.length, xe = -1, we = R.length, Ce = ce(we + se), Le = this && this !== $t && this instanceof Z ? H : o; ++xe < we; )
              Ce[xe] = R[xe];
            for (; se--; )
              Ce[xe++] = arguments[++Q];
            return rr(Le, N ? v : this, Ce);
          }
          return Z;
        }
        function _o(o) {
          return function(h, v, R) {
            return R && typeof R != "number" && Wt(h, v, R) && (v = R = t), h = Br(h), v === t ? (v = h, h = 0) : v = Br(v), R = R === t ? h < v ? 1 : -1 : Br(R), Oh(h, v, R, o);
          };
        }
        function Cn(o) {
          return function(h, v) {
            return typeof h == "string" && typeof v == "string" || (h = mr(h), v = mr(v)), o(h, v);
          };
        }
        function xo(o, h, v, R, N, H, Z, Q, se, xe) {
          var we = h & b, Ce = we ? Z : t, Le = we ? t : Z, Be = we ? H : t, Ve = we ? t : H;
          h |= we ? w : A, h &= ~(we ? A : w), h & E || (h &= -4);
          var it = [
            o,
            h,
            N,
            Be,
            Ce,
            Ve,
            Le,
            Q,
            se,
            xe
          ], He = v.apply(t, it);
          return Pa(o) && qo(He, it), He.placeholder = R, ko(He, o, h);
        }
        function Ca(o) {
          var h = Lt[o];
          return function(v, R) {
            if (v = mr(v), R = R == null ? 0 : Gt(rt(R), 292), R && Ps(v)) {
              var N = (mt(v) + "e").split("e"), H = h(N[0] + "e" + (+N[1] + R));
              return N = (mt(H) + "e").split("e"), +(N[0] + "e" + (+N[1] - R));
            }
            return h(v);
          };
        }
        var Hh = yi && 1 / Qi(new yi([, -0]))[1] == I ? function(o) {
          return new yi(o);
        } : Wa;
        function wo(o) {
          return function(h) {
            var v = zt(h);
            return v == Pe ? ta(h) : v == Xe ? ul(h) : el(h, o(h));
          };
        }
        function Lr(o, h, v, R, N, H, Z, Q) {
          var se = h & T;
          if (!se && typeof o != "function")
            throw new hr(u);
          var xe = R ? R.length : 0;
          if (xe || (h &= -97, R = N = t), Z = Z === t ? Z : Nt(rt(Z), 0), Q = Q === t ? Q : rt(Q), xe -= N ? N.length : 0, h & A) {
            var we = R, Ce = N;
            R = N = t;
          }
          var Le = se ? t : Aa(o), Be = [
            o,
            h,
            v,
            R,
            N,
            we,
            Ce,
            H,
            Z,
            Q
          ];
          if (Le && oc(Be, Le), o = Be[0], h = Be[1], v = Be[2], R = Be[3], N = Be[4], Q = Be[9] = Be[9] === t ? se ? 0 : o.length : Nt(Be[9] - xe, 0), !Q && h & (b | C) && (h &= -25), !h || h == _)
            var Ve = Gh(o, h, v);
          else h == b || h == C ? Ve = zh(o, h, Q) : (h == w || h == (_ | w)) && !N.length ? Ve = Vh(o, h, v, R) : Ve = wn.apply(t, Be);
          var it = Le ? eo : qo;
          return ko(it(Ve, Be), o, h);
        }
        function Eo(o, h, v, R) {
          return o === t || yr(o, gi[v]) && !yt.call(R, v) ? h : o;
        }
        function To(o, h, v, R, N, H) {
          return St(o) && St(h) && (H.set(h, o), yn(o, h, t, To, H), H.delete(h)), o;
        }
        function Wh(o) {
          return zi(o) ? t : o;
        }
        function Co(o, h, v, R, N, H) {
          var Z = v & x, Q = o.length, se = h.length;
          if (Q != se && !(Z && se > Q))
            return false;
          var xe = H.get(o), we = H.get(h);
          if (xe && we)
            return xe == h && we == o;
          var Ce = -1, Le = true, Be = v & g ? new ii() : t;
          for (H.set(o, h), H.set(h, o); ++Ce < Q; ) {
            var Ve = o[Ce], it = h[Ce];
            if (R)
              var He = Z ? R(it, Ve, Ce, h, o, H) : R(Ve, it, Ce, o, h, H);
            if (He !== t) {
              if (He)
                continue;
              Le = false;
              break;
            }
            if (Be) {
              if (!Yn(h, function(st, ut) {
                if (!Oi(Be, ut) && (Ve === st || N(Ve, st, v, R, H)))
                  return Be.push(ut);
              })) {
                Le = false;
                break;
              }
            } else if (!(Ve === it || N(Ve, it, v, R, H))) {
              Le = false;
              break;
            }
          }
          return H.delete(o), H.delete(h), Le;
        }
        function Xh(o, h, v, R, N, H, Z) {
          switch (v) {
            case Y:
              if (o.byteLength != h.byteLength || o.byteOffset != h.byteOffset)
                return false;
              o = o.buffer, h = h.buffer;
            case $:
              return !(o.byteLength != h.byteLength || !H(new sn(o), new sn(h)));
            case me:
            case Te:
            case Ee:
              return yr(+o, +h);
            case ye:
              return o.name == h.name && o.message == h.message;
            case vt:
            case at:
              return o == h + "";
            case Pe:
              var Q = ta;
            case Xe:
              var se = R & x;
              if (Q || (Q = Qi), o.size != h.size && !se)
                return false;
              var xe = Z.get(o);
              if (xe)
                return xe == h;
              R |= g, Z.set(o, h);
              var we = Co(Q(o), Q(h), R, N, H, Z);
              return Z.delete(o), we;
            case ct:
              if (Li)
                return Li.call(o) == Li.call(h);
          }
          return false;
        }
        function Yh(o, h, v, R, N, H) {
          var Z = v & x, Q = Sa(o), se = Q.length, xe = Sa(h), we = xe.length;
          if (se != we && !Z)
            return false;
          for (var Ce = se; Ce--; ) {
            var Le = Q[Ce];
            if (!(Z ? Le in h : yt.call(h, Le)))
              return false;
          }
          var Be = H.get(o), Ve = H.get(h);
          if (Be && Ve)
            return Be == h && Ve == o;
          var it = true;
          H.set(o, h), H.set(h, o);
          for (var He = Z; ++Ce < se; ) {
            Le = Q[Ce];
            var st = o[Le], ut = h[Le];
            if (R)
              var sr = Z ? R(ut, st, Le, h, o, H) : R(st, ut, Le, o, h, H);
            if (!(sr === t ? st === ut || N(st, ut, v, R, H) : sr)) {
              it = false;
              break;
            }
            He || (He = Le == "constructor");
          }
          if (it && !He) {
            var Xt = o.constructor, or = h.constructor;
            Xt != or && "constructor" in o && "constructor" in h && !(typeof Xt == "function" && Xt instanceof Xt && typeof or == "function" && or instanceof or) && (it = false);
          }
          return H.delete(o), H.delete(h), it;
        }
        function Nr(o) {
          return ka(Io(o, t, $o), o + "");
        }
        function Sa(o) {
          return Gs(o, Bt, Oa);
        }
        function Ra(o) {
          return Gs(o, Jt, So);
        }
        var Aa = fn ? function(o) {
          return fn.get(o);
        } : Wa;
        function Sn(o) {
          for (var h = o.name + "", v = bi[h], R = yt.call(bi, h) ? v.length : 0; R--; ) {
            var N = v[R], H = N.func;
            if (H == null || H == o)
              return N.name;
          }
          return h;
        }
        function Ei(o) {
          var h = yt.call(j, "placeholder") ? j : o;
          return h.placeholder;
        }
        function Ge() {
          var o = j.iteratee || Va;
          return o = o === Va ? Hs : o, arguments.length ? o(arguments[0], arguments[1]) : o;
        }
        function Rn(o, h) {
          var v = o.__data__;
          return ic(h) ? v[typeof h == "string" ? "string" : "hash"] : v.map;
        }
        function Ma(o) {
          for (var h = Bt(o), v = h.length; v--; ) {
            var R = h[v], N = o[R];
            h[v] = [R, N, Mo(N)];
          }
          return h;
        }
        function si(o, h) {
          var v = al(o, h);
          return Vs(v) ? v : t;
        }
        function Kh(o) {
          var h = yt.call(o, ti), v = o[ti];
          try {
            o[ti] = t;
            var R = true;
          } catch {
          }
          var N = nn.call(o);
          return R && (h ? o[ti] = v : delete o[ti]), N;
        }
        var Oa = ia ? function(o) {
          return o == null ? [] : (o = _t(o), Gr(ia(o), function(h) {
            return Os.call(o, h);
          }));
        } : Xa, So = ia ? function(o) {
          for (var h = []; o; )
            zr(h, Oa(o)), o = on(o);
          return h;
        } : Xa, zt = Ht;
        (na && zt(new na(new ArrayBuffer(1))) != Y || Pi && zt(new Pi()) != Pe || aa && zt(aa.resolve()) != gt || yi && zt(new yi()) != Xe || qi && zt(new qi()) != It) && (zt = function(o) {
          var h = Ht(o), v = h == $e ? o.constructor : t, R = v ? oi(v) : "";
          if (R)
            switch (R) {
              case Pl:
                return Y;
              case ql:
                return Pe;
              case kl:
                return gt;
              case Ll:
                return Xe;
              case Nl:
                return It;
            }
          return h;
        });
        function Jh(o, h, v) {
          for (var R = -1, N = v.length; ++R < N; ) {
            var H = v[R], Z = H.size;
            switch (H.type) {
              case "drop":
                o += Z;
                break;
              case "dropRight":
                h -= Z;
                break;
              case "take":
                h = Gt(h, o + Z);
                break;
              case "takeRight":
                o = Nt(o, h - Z);
                break;
            }
          }
          return { start: o, end: h };
        }
        function Zh(o) {
          var h = o.match(xr);
          return h ? h[1].split(Mr) : [];
        }
        function Ro(o, h, v) {
          h = Yr(h, o);
          for (var R = -1, N = h.length, H = false; ++R < N; ) {
            var Z = Cr(h[R]);
            if (!(H = o != null && v(o, Z)))
              break;
            o = o[Z];
          }
          return H || ++R != N ? H : (N = o == null ? 0 : o.length, !!N && kn(N) && Dr(Z, N) && (tt(o) || ui(o)));
        }
        function Qh(o) {
          var h = o.length, v = new o.constructor(h);
          return h && typeof o[0] == "string" && yt.call(o, "index") && (v.index = o.index, v.input = o.input), v;
        }
        function Ao(o) {
          return typeof o.constructor == "function" && !Ui(o) ? _i(on(o)) : {};
        }
        function ec(o, h, v) {
          var R = o.constructor;
          switch (h) {
            case $:
              return Ea(o);
            case me:
            case Te:
              return new R(+o);
            case Y:
              return Dh(o, v);
            case ee:
            case be:
            case Se:
            case Ne:
            case je:
            case pt:
            case oe:
            case le:
            case Ue:
              return lo(o, v);
            case Pe:
              return new R();
            case Ee:
            case at:
              return new R(o);
            case vt:
              return Fh(o);
            case Xe:
              return new R();
            case ct:
              return Bh(o);
          }
        }
        function tc(o, h) {
          var v = h.length;
          if (!v)
            return o;
          var R = v - 1;
          return h[R] = (v > 1 ? "& " : "") + h[R], h = h.join(v > 2 ? ", " : " "), o.replace(wr, `{
/* [wrapped with ` + h + `] */
`);
        }
        function rc(o) {
          return tt(o) || ui(o) || !!(Is && o && o[Is]);
        }
        function Dr(o, h) {
          var v = typeof o;
          return h = h ?? P, !!h && (v == "number" || v != "symbol" && Ai.test(o)) && o > -1 && o % 1 == 0 && o < h;
        }
        function Wt(o, h, v) {
          if (!St(v))
            return false;
          var R = typeof h;
          return (R == "number" ? Kt(v) && Dr(h, v.length) : R == "string" && h in v) ? yr(v[h], o) : false;
        }
        function Ia(o, h) {
          if (tt(o))
            return false;
          var v = typeof o;
          return v == "number" || v == "symbol" || v == "boolean" || o == null || ar(o) ? true : Ar.test(o) || !kt.test(o) || h != null && o in _t(h);
        }
        function ic(o) {
          var h = typeof o;
          return h == "string" || h == "number" || h == "symbol" || h == "boolean" ? o !== "__proto__" : o === null;
        }
        function Pa(o) {
          var h = Sn(o), v = j[h];
          if (typeof v != "function" || !(h in ot.prototype))
            return false;
          if (o === v)
            return true;
          var R = Aa(v);
          return !!R && o === R[0];
        }
        function nc(o) {
          return !!Rs && Rs in o;
        }
        var ac = tn ? Fr : Ya;
        function Ui(o) {
          var h = o && o.constructor, v = typeof h == "function" && h.prototype || gi;
          return o === v;
        }
        function Mo(o) {
          return o === o && !St(o);
        }
        function Oo(o, h) {
          return function(v) {
            return v == null ? false : v[o] === h && (h !== t || o in _t(v));
          };
        }
        function sc(o) {
          var h = Pn(o, function(R) {
            return v.size === d && v.clear(), R;
          }), v = h.cache;
          return h;
        }
        function oc(o, h) {
          var v = o[1], R = h[1], N = v | R, H = N < (_ | T | S), Z = R == S && v == b || R == S && v == F && o[7].length <= h[8] || R == (S | F) && h[7].length <= h[8] && v == b;
          if (!(H || Z))
            return o;
          R & _ && (o[2] = h[2], N |= v & _ ? 0 : E);
          var Q = h[3];
          if (Q) {
            var se = o[3];
            o[3] = se ? co(se, Q, h[4]) : Q, o[4] = se ? Vr(o[3], f) : h[4];
          }
          return Q = h[5], Q && (se = o[5], o[5] = se ? fo(se, Q, h[6]) : Q, o[6] = se ? Vr(o[5], f) : h[6]), Q = h[7], Q && (o[7] = Q), R & S && (o[8] = o[8] == null ? h[8] : Gt(o[8], h[8])), o[9] == null && (o[9] = h[9]), o[0] = h[0], o[1] = N, o;
        }
        function uc(o) {
          var h = [];
          if (o != null)
            for (var v in _t(o))
              h.push(v);
          return h;
        }
        function lc(o) {
          return nn.call(o);
        }
        function Io(o, h, v) {
          return h = Nt(h === t ? o.length - 1 : h, 0), function() {
            for (var R = arguments, N = -1, H = Nt(R.length - h, 0), Z = ce(H); ++N < H; )
              Z[N] = R[h + N];
            N = -1;
            for (var Q = ce(h + 1); ++N < h; )
              Q[N] = R[N];
            return Q[h] = v(Z), rr(o, this, Q);
          };
        }
        function Po(o, h) {
          return h.length < 2 ? o : ai(o, dr(h, 0, -1));
        }
        function hc(o, h) {
          for (var v = o.length, R = Gt(h.length, v), N = Yt(o); R--; ) {
            var H = h[R];
            o[R] = Dr(H, v) ? N[H] : t;
          }
          return o;
        }
        function qa(o, h) {
          if (!(h === "constructor" && typeof o[h] == "function") && h != "__proto__")
            return o[h];
        }
        var qo = Lo(eo), Gi = Cl || function(o, h) {
          return $t.setTimeout(o, h);
        }, ka = Lo(qh);
        function ko(o, h, v) {
          var R = h + "";
          return ka(o, tc(R, cc(Zh(R), v)));
        }
        function Lo(o) {
          var h = 0, v = 0;
          return function() {
            var R = Ml(), N = z - (R - v);
            if (v = R, N > 0) {
              if (++h >= q)
                return arguments[0];
            } else
              h = 0;
            return o.apply(t, arguments);
          };
        }
        function An(o, h) {
          var v = -1, R = o.length, N = R - 1;
          for (h = h === t ? R : h; ++v < h; ) {
            var H = va(v, N), Z = o[H];
            o[H] = o[v], o[v] = Z;
          }
          return o.length = h, o;
        }
        var No = sc(function(o) {
          var h = [];
          return o.charCodeAt(0) === 46 && h.push(""), o.replace(Sr, function(v, R, N, H) {
            h.push(N ? H.replace(Rr, "$1") : R || v);
          }), h;
        });
        function Cr(o) {
          if (typeof o == "string" || ar(o))
            return o;
          var h = o + "";
          return h == "0" && 1 / o == -1 / 0 ? "-0" : h;
        }
        function oi(o) {
          if (o != null) {
            try {
              return rn.call(o);
            } catch {
            }
            try {
              return o + "";
            } catch {
            }
          }
          return "";
        }
        function cc(o, h) {
          return lr(ae, function(v) {
            var R = "_." + v[0];
            h & v[1] && !Ji(o, R) && o.push(R);
          }), o.sort();
        }
        function Do(o) {
          if (o instanceof ot)
            return o.clone();
          var h = new cr(o.__wrapped__, o.__chain__);
          return h.__actions__ = Yt(o.__actions__), h.__index__ = o.__index__, h.__values__ = o.__values__, h;
        }
        function fc(o, h, v) {
          (v ? Wt(o, h, v) : h === t) ? h = 1 : h = Nt(rt(h), 0);
          var R = o == null ? 0 : o.length;
          if (!R || h < 1)
            return [];
          for (var N = 0, H = 0, Z = ce(hn(R / h)); N < R; )
            Z[H++] = dr(o, N, N += h);
          return Z;
        }
        function dc(o) {
          for (var h = -1, v = o == null ? 0 : o.length, R = 0, N = []; ++h < v; ) {
            var H = o[h];
            H && (N[R++] = H);
          }
          return N;
        }
        function pc() {
          var o = arguments.length;
          if (!o)
            return [];
          for (var h = ce(o - 1), v = arguments[0], R = o; R--; )
            h[R - 1] = arguments[R];
          return zr(tt(v) ? Yt(v) : [v], jt(h, 1));
        }
        var mc = nt(function(o, h) {
          return Mt(o) ? Di(o, jt(h, 1, Mt, true)) : [];
        }), vc = nt(function(o, h) {
          var v = pr(h);
          return Mt(v) && (v = t), Mt(o) ? Di(o, jt(h, 1, Mt, true), Ge(v, 2)) : [];
        }), gc = nt(function(o, h) {
          var v = pr(h);
          return Mt(v) && (v = t), Mt(o) ? Di(o, jt(h, 1, Mt, true), t, v) : [];
        });
        function yc(o, h, v) {
          var R = o == null ? 0 : o.length;
          return R ? (h = v || h === t ? 1 : rt(h), dr(o, h < 0 ? 0 : h, R)) : [];
        }
        function bc(o, h, v) {
          var R = o == null ? 0 : o.length;
          return R ? (h = v || h === t ? 1 : rt(h), h = R - h, dr(o, 0, h < 0 ? 0 : h)) : [];
        }
        function _c(o, h) {
          return o && o.length ? _n(o, Ge(h, 3), true, true) : [];
        }
        function xc(o, h) {
          return o && o.length ? _n(o, Ge(h, 3), true) : [];
        }
        function wc(o, h, v, R) {
          var N = o == null ? 0 : o.length;
          return N ? (v && typeof v != "number" && Wt(o, h, v) && (v = 0, R = N), ph(o, h, v, R)) : [];
        }
        function Fo(o, h, v) {
          var R = o == null ? 0 : o.length;
          if (!R)
            return -1;
          var N = v == null ? 0 : rt(v);
          return N < 0 && (N = Nt(R + N, 0)), Zi(o, Ge(h, 3), N);
        }
        function Bo(o, h, v) {
          var R = o == null ? 0 : o.length;
          if (!R)
            return -1;
          var N = R - 1;
          return v !== t && (N = rt(v), N = v < 0 ? Nt(R + N, 0) : Gt(N, R - 1)), Zi(o, Ge(h, 3), N, true);
        }
        function $o(o) {
          var h = o == null ? 0 : o.length;
          return h ? jt(o, 1) : [];
        }
        function Ec(o) {
          var h = o == null ? 0 : o.length;
          return h ? jt(o, I) : [];
        }
        function Tc(o, h) {
          var v = o == null ? 0 : o.length;
          return v ? (h = h === t ? 1 : rt(h), jt(o, h)) : [];
        }
        function Cc(o) {
          for (var h = -1, v = o == null ? 0 : o.length, R = {}; ++h < v; ) {
            var N = o[h];
            R[N[0]] = N[1];
          }
          return R;
        }
        function jo(o) {
          return o && o.length ? o[0] : t;
        }
        function Sc(o, h, v) {
          var R = o == null ? 0 : o.length;
          if (!R)
            return -1;
          var N = v == null ? 0 : rt(v);
          return N < 0 && (N = Nt(R + N, 0)), di(o, h, N);
        }
        function Rc(o) {
          var h = o == null ? 0 : o.length;
          return h ? dr(o, 0, -1) : [];
        }
        var Ac = nt(function(o) {
          var h = Tt(o, xa);
          return h.length && h[0] === o[0] ? ca(h) : [];
        }), Mc = nt(function(o) {
          var h = pr(o), v = Tt(o, xa);
          return h === pr(v) ? h = t : v.pop(), v.length && v[0] === o[0] ? ca(v, Ge(h, 2)) : [];
        }), Oc = nt(function(o) {
          var h = pr(o), v = Tt(o, xa);
          return h = typeof h == "function" ? h : t, h && v.pop(), v.length && v[0] === o[0] ? ca(v, t, h) : [];
        });
        function Ic(o, h) {
          return o == null ? "" : Rl.call(o, h);
        }
        function pr(o) {
          var h = o == null ? 0 : o.length;
          return h ? o[h - 1] : t;
        }
        function Pc(o, h, v) {
          var R = o == null ? 0 : o.length;
          if (!R)
            return -1;
          var N = R;
          return v !== t && (N = rt(v), N = N < 0 ? Nt(R + N, 0) : Gt(N, R - 1)), h === h ? hl(o, h, N) : Zi(o, bs, N, true);
        }
        function qc(o, h) {
          return o && o.length ? Ks(o, rt(h)) : t;
        }
        var kc = nt(Uo);
        function Uo(o, h) {
          return o && o.length && h && h.length ? ma(o, h) : o;
        }
        function Lc(o, h, v) {
          return o && o.length && h && h.length ? ma(o, h, Ge(v, 2)) : o;
        }
        function Nc(o, h, v) {
          return o && o.length && h && h.length ? ma(o, h, t, v) : o;
        }
        var Dc = Nr(function(o, h) {
          var v = o == null ? 0 : o.length, R = oa(o, h);
          return Qs(o, Tt(h, function(N) {
            return Dr(N, v) ? +N : N;
          }).sort(ho)), R;
        });
        function Fc(o, h) {
          var v = [];
          if (!(o && o.length))
            return v;
          var R = -1, N = [], H = o.length;
          for (h = Ge(h, 3); ++R < H; ) {
            var Z = o[R];
            h(Z, R, o) && (v.push(Z), N.push(R));
          }
          return Qs(o, N), v;
        }
        function La(o) {
          return o == null ? o : Il.call(o);
        }
        function Bc(o, h, v) {
          var R = o == null ? 0 : o.length;
          return R ? (v && typeof v != "number" && Wt(o, h, v) ? (h = 0, v = R) : (h = h == null ? 0 : rt(h), v = v === t ? R : rt(v)), dr(o, h, v)) : [];
        }
        function $c(o, h) {
          return bn(o, h);
        }
        function jc(o, h, v) {
          return ya(o, h, Ge(v, 2));
        }
        function Uc(o, h) {
          var v = o == null ? 0 : o.length;
          if (v) {
            var R = bn(o, h);
            if (R < v && yr(o[R], h))
              return R;
          }
          return -1;
        }
        function Gc(o, h) {
          return bn(o, h, true);
        }
        function zc(o, h, v) {
          return ya(o, h, Ge(v, 2), true);
        }
        function Vc(o, h) {
          var v = o == null ? 0 : o.length;
          if (v) {
            var R = bn(o, h, true) - 1;
            if (yr(o[R], h))
              return R;
          }
          return -1;
        }
        function Hc(o) {
          return o && o.length ? to(o) : [];
        }
        function Wc(o, h) {
          return o && o.length ? to(o, Ge(h, 2)) : [];
        }
        function Xc(o) {
          var h = o == null ? 0 : o.length;
          return h ? dr(o, 1, h) : [];
        }
        function Yc(o, h, v) {
          return o && o.length ? (h = v || h === t ? 1 : rt(h), dr(o, 0, h < 0 ? 0 : h)) : [];
        }
        function Kc(o, h, v) {
          var R = o == null ? 0 : o.length;
          return R ? (h = v || h === t ? 1 : rt(h), h = R - h, dr(o, h < 0 ? 0 : h, R)) : [];
        }
        function Jc(o, h) {
          return o && o.length ? _n(o, Ge(h, 3), false, true) : [];
        }
        function Zc(o, h) {
          return o && o.length ? _n(o, Ge(h, 3)) : [];
        }
        var Qc = nt(function(o) {
          return Xr(jt(o, 1, Mt, true));
        }), ef = nt(function(o) {
          var h = pr(o);
          return Mt(h) && (h = t), Xr(jt(o, 1, Mt, true), Ge(h, 2));
        }), tf = nt(function(o) {
          var h = pr(o);
          return h = typeof h == "function" ? h : t, Xr(jt(o, 1, Mt, true), t, h);
        });
        function rf(o) {
          return o && o.length ? Xr(o) : [];
        }
        function nf(o, h) {
          return o && o.length ? Xr(o, Ge(h, 2)) : [];
        }
        function af(o, h) {
          return h = typeof h == "function" ? h : t, o && o.length ? Xr(o, t, h) : [];
        }
        function Na(o) {
          if (!(o && o.length))
            return [];
          var h = 0;
          return o = Gr(o, function(v) {
            if (Mt(v))
              return h = Nt(v.length, h), true;
          }), Qn(h, function(v) {
            return Tt(o, Kn(v));
          });
        }
        function Go(o, h) {
          if (!(o && o.length))
            return [];
          var v = Na(o);
          return h == null ? v : Tt(v, function(R) {
            return rr(h, t, R);
          });
        }
        var sf = nt(function(o, h) {
          return Mt(o) ? Di(o, h) : [];
        }), of = nt(function(o) {
          return _a(Gr(o, Mt));
        }), uf = nt(function(o) {
          var h = pr(o);
          return Mt(h) && (h = t), _a(Gr(o, Mt), Ge(h, 2));
        }), lf = nt(function(o) {
          var h = pr(o);
          return h = typeof h == "function" ? h : t, _a(Gr(o, Mt), t, h);
        }), hf = nt(Na);
        function cf(o, h) {
          return so(o || [], h || [], Ni);
        }
        function ff(o, h) {
          return so(o || [], h || [], $i);
        }
        var df = nt(function(o) {
          var h = o.length, v = h > 1 ? o[h - 1] : t;
          return v = typeof v == "function" ? (o.pop(), v) : t, Go(o, v);
        });
        function zo(o) {
          var h = j(o);
          return h.__chain__ = true, h;
        }
        function pf(o, h) {
          return h(o), o;
        }
        function Mn(o, h) {
          return h(o);
        }
        var mf = Nr(function(o) {
          var h = o.length, v = h ? o[0] : 0, R = this.__wrapped__, N = function(H) {
            return oa(H, o);
          };
          return h > 1 || this.__actions__.length || !(R instanceof ot) || !Dr(v) ? this.thru(N) : (R = R.slice(v, +v + (h ? 1 : 0)), R.__actions__.push({
            func: Mn,
            args: [N],
            thisArg: t
          }), new cr(R, this.__chain__).thru(function(H) {
            return h && !H.length && H.push(t), H;
          }));
        });
        function vf() {
          return zo(this);
        }
        function gf() {
          return new cr(this.value(), this.__chain__);
        }
        function yf() {
          this.__values__ === t && (this.__values__ = nu(this.value()));
          var o = this.__index__ >= this.__values__.length, h = o ? t : this.__values__[this.__index__++];
          return { done: o, value: h };
        }
        function bf() {
          return this;
        }
        function _f(o) {
          for (var h, v = this; v instanceof pn; ) {
            var R = Do(v);
            R.__index__ = 0, R.__values__ = t, h ? N.__wrapped__ = R : h = R;
            var N = R;
            v = v.__wrapped__;
          }
          return N.__wrapped__ = o, h;
        }
        function xf() {
          var o = this.__wrapped__;
          if (o instanceof ot) {
            var h = o;
            return this.__actions__.length && (h = new ot(this)), h = h.reverse(), h.__actions__.push({
              func: Mn,
              args: [La],
              thisArg: t
            }), new cr(h, this.__chain__);
          }
          return this.thru(La);
        }
        function wf() {
          return ao(this.__wrapped__, this.__actions__);
        }
        var Ef = xn(function(o, h, v) {
          yt.call(o, v) ? ++o[v] : kr(o, v, 1);
        });
        function Tf(o, h, v) {
          var R = tt(o) ? gs : dh;
          return v && Wt(o, h, v) && (h = t), R(o, Ge(h, 3));
        }
        function Cf(o, h) {
          var v = tt(o) ? Gr : js;
          return v(o, Ge(h, 3));
        }
        var Sf = go(Fo), Rf = go(Bo);
        function Af(o, h) {
          return jt(On(o, h), 1);
        }
        function Mf(o, h) {
          return jt(On(o, h), I);
        }
        function Of(o, h, v) {
          return v = v === t ? 1 : rt(v), jt(On(o, h), v);
        }
        function Vo(o, h) {
          var v = tt(o) ? lr : Wr;
          return v(o, Ge(h, 3));
        }
        function Ho(o, h) {
          var v = tt(o) ? Wu : $s;
          return v(o, Ge(h, 3));
        }
        var If = xn(function(o, h, v) {
          yt.call(o, v) ? o[v].push(h) : kr(o, v, [h]);
        });
        function Pf(o, h, v, R) {
          o = Kt(o) ? o : Ci(o), v = v && !R ? rt(v) : 0;
          var N = o.length;
          return v < 0 && (v = Nt(N + v, 0)), Ln(o) ? v <= N && o.indexOf(h, v) > -1 : !!N && di(o, h, v) > -1;
        }
        var qf = nt(function(o, h, v) {
          var R = -1, N = typeof h == "function", H = Kt(o) ? ce(o.length) : [];
          return Wr(o, function(Z) {
            H[++R] = N ? rr(h, Z, v) : Fi(Z, h, v);
          }), H;
        }), kf = xn(function(o, h, v) {
          kr(o, v, h);
        });
        function On(o, h) {
          var v = tt(o) ? Tt : Ws;
          return v(o, Ge(h, 3));
        }
        function Lf(o, h, v, R) {
          return o == null ? [] : (tt(h) || (h = h == null ? [] : [h]), v = R ? t : v, tt(v) || (v = v == null ? [] : [v]), Js(o, h, v));
        }
        var Nf = xn(function(o, h, v) {
          o[v ? 0 : 1].push(h);
        }, function() {
          return [[], []];
        });
        function Df(o, h, v) {
          var R = tt(o) ? Xn : xs, N = arguments.length < 3;
          return R(o, Ge(h, 4), v, N, Wr);
        }
        function Ff(o, h, v) {
          var R = tt(o) ? Xu : xs, N = arguments.length < 3;
          return R(o, Ge(h, 4), v, N, $s);
        }
        function Bf(o, h) {
          var v = tt(o) ? Gr : js;
          return v(o, qn(Ge(h, 3)));
        }
        function $f(o) {
          var h = tt(o) ? Ns : Ih;
          return h(o);
        }
        function jf(o, h, v) {
          (v ? Wt(o, h, v) : h === t) ? h = 1 : h = rt(h);
          var R = tt(o) ? uh : Ph;
          return R(o, h);
        }
        function Uf(o) {
          var h = tt(o) ? lh : kh;
          return h(o);
        }
        function Gf(o) {
          if (o == null)
            return 0;
          if (Kt(o))
            return Ln(o) ? mi(o) : o.length;
          var h = zt(o);
          return h == Pe || h == Xe ? o.size : da(o).length;
        }
        function zf(o, h, v) {
          var R = tt(o) ? Yn : Lh;
          return v && Wt(o, h, v) && (h = t), R(o, Ge(h, 3));
        }
        var Vf = nt(function(o, h) {
          if (o == null)
            return [];
          var v = h.length;
          return v > 1 && Wt(o, h[0], h[1]) ? h = [] : v > 2 && Wt(h[0], h[1], h[2]) && (h = [h[0]]), Js(o, jt(h, 1), []);
        }), In = Tl || function() {
          return $t.Date.now();
        };
        function Hf(o, h) {
          if (typeof h != "function")
            throw new hr(u);
          return o = rt(o), function() {
            if (--o < 1)
              return h.apply(this, arguments);
          };
        }
        function Wo(o, h, v) {
          return h = v ? t : h, h = o && h == null ? o.length : h, Lr(o, S, t, t, t, t, h);
        }
        function Xo(o, h) {
          var v;
          if (typeof h != "function")
            throw new hr(u);
          return o = rt(o), function() {
            return --o > 0 && (v = h.apply(this, arguments)), o <= 1 && (h = t), v;
          };
        }
        var Da = nt(function(o, h, v) {
          var R = _;
          if (v.length) {
            var N = Vr(v, Ei(Da));
            R |= w;
          }
          return Lr(o, R, h, v, N);
        }), Yo = nt(function(o, h, v) {
          var R = _ | T;
          if (v.length) {
            var N = Vr(v, Ei(Yo));
            R |= w;
          }
          return Lr(h, R, o, v, N);
        });
        function Ko(o, h, v) {
          h = v ? t : h;
          var R = Lr(o, b, t, t, t, t, t, h);
          return R.placeholder = Ko.placeholder, R;
        }
        function Jo(o, h, v) {
          h = v ? t : h;
          var R = Lr(o, C, t, t, t, t, t, h);
          return R.placeholder = Jo.placeholder, R;
        }
        function Zo(o, h, v) {
          var R, N, H, Z, Q, se, xe = 0, we = false, Ce = false, Le = true;
          if (typeof o != "function")
            throw new hr(u);
          h = mr(h) || 0, St(v) && (we = !!v.leading, Ce = "maxWait" in v, H = Ce ? Nt(mr(v.maxWait) || 0, h) : H, Le = "trailing" in v ? !!v.trailing : Le);
          function Be(Ot) {
            var br = R, $r = N;
            return R = N = t, xe = Ot, Z = o.apply($r, br), Z;
          }
          function Ve(Ot) {
            return xe = Ot, Q = Gi(st, h), we ? Be(Ot) : Z;
          }
          function it(Ot) {
            var br = Ot - se, $r = Ot - xe, gu = h - br;
            return Ce ? Gt(gu, H - $r) : gu;
          }
          function He(Ot) {
            var br = Ot - se, $r = Ot - xe;
            return se === t || br >= h || br < 0 || Ce && $r >= H;
          }
          function st() {
            var Ot = In();
            if (He(Ot))
              return ut(Ot);
            Q = Gi(st, it(Ot));
          }
          function ut(Ot) {
            return Q = t, Le && R ? Be(Ot) : (R = N = t, Z);
          }
          function sr() {
            Q !== t && oo(Q), xe = 0, R = se = N = Q = t;
          }
          function Xt() {
            return Q === t ? Z : ut(In());
          }
          function or() {
            var Ot = In(), br = He(Ot);
            if (R = arguments, N = this, se = Ot, br) {
              if (Q === t)
                return Ve(se);
              if (Ce)
                return oo(Q), Q = Gi(st, h), Be(se);
            }
            return Q === t && (Q = Gi(st, h)), Z;
          }
          return or.cancel = sr, or.flush = Xt, or;
        }
        var Wf = nt(function(o, h) {
          return Bs(o, 1, h);
        }), Xf = nt(function(o, h, v) {
          return Bs(o, mr(h) || 0, v);
        });
        function Yf(o) {
          return Lr(o, M);
        }
        function Pn(o, h) {
          if (typeof o != "function" || h != null && typeof h != "function")
            throw new hr(u);
          var v = function() {
            var R = arguments, N = h ? h.apply(this, R) : R[0], H = v.cache;
            if (H.has(N))
              return H.get(N);
            var Z = o.apply(this, R);
            return v.cache = H.set(N, Z) || H, Z;
          };
          return v.cache = new (Pn.Cache || qr)(), v;
        }
        Pn.Cache = qr;
        function qn(o) {
          if (typeof o != "function")
            throw new hr(u);
          return function() {
            var h = arguments;
            switch (h.length) {
              case 0:
                return !o.call(this);
              case 1:
                return !o.call(this, h[0]);
              case 2:
                return !o.call(this, h[0], h[1]);
              case 3:
                return !o.call(this, h[0], h[1], h[2]);
            }
            return !o.apply(this, h);
          };
        }
        function Kf(o) {
          return Xo(2, o);
        }
        var Jf = Nh(function(o, h) {
          h = h.length == 1 && tt(h[0]) ? Tt(h[0], ir(Ge())) : Tt(jt(h, 1), ir(Ge()));
          var v = h.length;
          return nt(function(R) {
            for (var N = -1, H = Gt(R.length, v); ++N < H; )
              R[N] = h[N].call(this, R[N]);
            return rr(o, this, R);
          });
        }), Fa = nt(function(o, h) {
          var v = Vr(h, Ei(Fa));
          return Lr(o, w, t, h, v);
        }), Qo = nt(function(o, h) {
          var v = Vr(h, Ei(Qo));
          return Lr(o, A, t, h, v);
        }), Zf = Nr(function(o, h) {
          return Lr(o, F, t, t, t, h);
        });
        function Qf(o, h) {
          if (typeof o != "function")
            throw new hr(u);
          return h = h === t ? h : rt(h), nt(o, h);
        }
        function ed(o, h) {
          if (typeof o != "function")
            throw new hr(u);
          return h = h == null ? 0 : Nt(rt(h), 0), nt(function(v) {
            var R = v[h], N = Kr(v, 0, h);
            return R && zr(N, R), rr(o, this, N);
          });
        }
        function td(o, h, v) {
          var R = true, N = true;
          if (typeof o != "function")
            throw new hr(u);
          return St(v) && (R = "leading" in v ? !!v.leading : R, N = "trailing" in v ? !!v.trailing : N), Zo(o, h, {
            leading: R,
            maxWait: h,
            trailing: N
          });
        }
        function rd(o) {
          return Wo(o, 1);
        }
        function id(o, h) {
          return Fa(wa(h), o);
        }
        function nd() {
          if (!arguments.length)
            return [];
          var o = arguments[0];
          return tt(o) ? o : [o];
        }
        function ad(o) {
          return fr(o, y);
        }
        function sd(o, h) {
          return h = typeof h == "function" ? h : t, fr(o, y, h);
        }
        function od(o) {
          return fr(o, p | y);
        }
        function ud(o, h) {
          return h = typeof h == "function" ? h : t, fr(o, p | y, h);
        }
        function ld(o, h) {
          return h == null || Fs(o, h, Bt(h));
        }
        function yr(o, h) {
          return o === h || o !== o && h !== h;
        }
        var hd = Cn(ha), cd = Cn(function(o, h) {
          return o >= h;
        }), ui = zs(/* @__PURE__ */ function() {
          return arguments;
        }()) ? zs : function(o) {
          return At(o) && yt.call(o, "callee") && !Os.call(o, "callee");
        }, tt = ce.isArray, fd = cs ? ir(cs) : bh;
        function Kt(o) {
          return o != null && kn(o.length) && !Fr(o);
        }
        function Mt(o) {
          return At(o) && Kt(o);
        }
        function dd(o) {
          return o === true || o === false || At(o) && Ht(o) == me;
        }
        var Jr = Sl || Ya, pd = fs ? ir(fs) : _h;
        function md(o) {
          return At(o) && o.nodeType === 1 && !zi(o);
        }
        function vd(o) {
          if (o == null)
            return true;
          if (Kt(o) && (tt(o) || typeof o == "string" || typeof o.splice == "function" || Jr(o) || Ti(o) || ui(o)))
            return !o.length;
          var h = zt(o);
          if (h == Pe || h == Xe)
            return !o.size;
          if (Ui(o))
            return !da(o).length;
          for (var v in o)
            if (yt.call(o, v))
              return false;
          return true;
        }
        function gd(o, h) {
          return Bi(o, h);
        }
        function yd(o, h, v) {
          v = typeof v == "function" ? v : t;
          var R = v ? v(o, h) : t;
          return R === t ? Bi(o, h, t, v) : !!R;
        }
        function Ba(o) {
          if (!At(o))
            return false;
          var h = Ht(o);
          return h == ye || h == _e || typeof o.message == "string" && typeof o.name == "string" && !zi(o);
        }
        function bd(o) {
          return typeof o == "number" && Ps(o);
        }
        function Fr(o) {
          if (!St(o))
            return false;
          var h = Ht(o);
          return h == Ae || h == ke || h == ge || h == xt;
        }
        function eu(o) {
          return typeof o == "number" && o == rt(o);
        }
        function kn(o) {
          return typeof o == "number" && o > -1 && o % 1 == 0 && o <= P;
        }
        function St(o) {
          var h = typeof o;
          return o != null && (h == "object" || h == "function");
        }
        function At(o) {
          return o != null && typeof o == "object";
        }
        var tu = ds ? ir(ds) : wh;
        function _d(o, h) {
          return o === h || fa(o, h, Ma(h));
        }
        function xd(o, h, v) {
          return v = typeof v == "function" ? v : t, fa(o, h, Ma(h), v);
        }
        function wd(o) {
          return ru(o) && o != +o;
        }
        function Ed(o) {
          if (ac(o))
            throw new Qe(s);
          return Vs(o);
        }
        function Td(o) {
          return o === null;
        }
        function Cd(o) {
          return o == null;
        }
        function ru(o) {
          return typeof o == "number" || At(o) && Ht(o) == Ee;
        }
        function zi(o) {
          if (!At(o) || Ht(o) != $e)
            return false;
          var h = on(o);
          if (h === null)
            return true;
          var v = yt.call(h, "constructor") && h.constructor;
          return typeof v == "function" && v instanceof v && rn.call(v) == _l;
        }
        var $a = ps ? ir(ps) : Eh;
        function Sd(o) {
          return eu(o) && o >= -9007199254740991 && o <= P;
        }
        var iu = ms ? ir(ms) : Th;
        function Ln(o) {
          return typeof o == "string" || !tt(o) && At(o) && Ht(o) == at;
        }
        function ar(o) {
          return typeof o == "symbol" || At(o) && Ht(o) == ct;
        }
        var Ti = vs ? ir(vs) : Ch;
        function Rd(o) {
          return o === t;
        }
        function Ad(o) {
          return At(o) && zt(o) == It;
        }
        function Md(o) {
          return At(o) && Ht(o) == er;
        }
        var Od = Cn(pa), Id = Cn(function(o, h) {
          return o <= h;
        });
        function nu(o) {
          if (!o)
            return [];
          if (Kt(o))
            return Ln(o) ? vr(o) : Yt(o);
          if (Ii && o[Ii])
            return ol(o[Ii]());
          var h = zt(o), v = h == Pe ? ta : h == Xe ? Qi : Ci;
          return v(o);
        }
        function Br(o) {
          if (!o)
            return o === 0 ? o : 0;
          if (o = mr(o), o === I || o === -1 / 0) {
            var h = o < 0 ? -1 : 1;
            return h * G;
          }
          return o === o ? o : 0;
        }
        function rt(o) {
          var h = Br(o), v = h % 1;
          return h === h ? v ? h - v : h : 0;
        }
        function au(o) {
          return o ? ni(rt(o), 0, V) : 0;
        }
        function mr(o) {
          if (typeof o == "number")
            return o;
          if (ar(o))
            return W;
          if (St(o)) {
            var h = typeof o.valueOf == "function" ? o.valueOf() : o;
            o = St(h) ? h + "" : h;
          }
          if (typeof o != "string")
            return o === 0 ? o : +o;
          o = ws(o);
          var v = Ir.test(o);
          return v || Xi.test(o) ? zu(o.slice(2), v ? 2 : 8) : fi.test(o) ? W : +o;
        }
        function su(o) {
          return Tr(o, Jt(o));
        }
        function Pd(o) {
          return o ? ni(rt(o), -9007199254740991, P) : o === 0 ? o : 0;
        }
        function mt(o) {
          return o == null ? "" : nr(o);
        }
        var qd = xi(function(o, h) {
          if (Ui(h) || Kt(h)) {
            Tr(h, Bt(h), o);
            return;
          }
          for (var v in h)
            yt.call(h, v) && Ni(o, v, h[v]);
        }), ou = xi(function(o, h) {
          Tr(h, Jt(h), o);
        }), Nn = xi(function(o, h, v, R) {
          Tr(h, Jt(h), o, R);
        }), kd = xi(function(o, h, v, R) {
          Tr(h, Bt(h), o, R);
        }), Ld = Nr(oa);
        function Nd(o, h) {
          var v = _i(o);
          return h == null ? v : Ds(v, h);
        }
        var Dd = nt(function(o, h) {
          o = _t(o);
          var v = -1, R = h.length, N = R > 2 ? h[2] : t;
          for (N && Wt(h[0], h[1], N) && (R = 1); ++v < R; )
            for (var H = h[v], Z = Jt(H), Q = -1, se = Z.length; ++Q < se; ) {
              var xe = Z[Q], we = o[xe];
              (we === t || yr(we, gi[xe]) && !yt.call(o, xe)) && (o[xe] = H[xe]);
            }
          return o;
        }), Fd = nt(function(o) {
          return o.push(t, To), rr(uu, t, o);
        });
        function Bd(o, h) {
          return ys(o, Ge(h, 3), Er);
        }
        function $d(o, h) {
          return ys(o, Ge(h, 3), la);
        }
        function jd(o, h) {
          return o == null ? o : ua(o, Ge(h, 3), Jt);
        }
        function Ud(o, h) {
          return o == null ? o : Us(o, Ge(h, 3), Jt);
        }
        function Gd(o, h) {
          return o && Er(o, Ge(h, 3));
        }
        function zd(o, h) {
          return o && la(o, Ge(h, 3));
        }
        function Vd(o) {
          return o == null ? [] : gn(o, Bt(o));
        }
        function Hd(o) {
          return o == null ? [] : gn(o, Jt(o));
        }
        function ja(o, h, v) {
          var R = o == null ? t : ai(o, h);
          return R === t ? v : R;
        }
        function Wd(o, h) {
          return o != null && Ro(o, h, mh);
        }
        function Ua(o, h) {
          return o != null && Ro(o, h, vh);
        }
        var Xd = bo(function(o, h, v) {
          h != null && typeof h.toString != "function" && (h = nn.call(h)), o[h] = v;
        }, za(Zt)), Yd = bo(function(o, h, v) {
          h != null && typeof h.toString != "function" && (h = nn.call(h)), yt.call(o, h) ? o[h].push(v) : o[h] = [v];
        }, Ge), Kd = nt(Fi);
        function Bt(o) {
          return Kt(o) ? Ls(o) : da(o);
        }
        function Jt(o) {
          return Kt(o) ? Ls(o, true) : Sh(o);
        }
        function Jd(o, h) {
          var v = {};
          return h = Ge(h, 3), Er(o, function(R, N, H) {
            kr(v, h(R, N, H), R);
          }), v;
        }
        function Zd(o, h) {
          var v = {};
          return h = Ge(h, 3), Er(o, function(R, N, H) {
            kr(v, N, h(R, N, H));
          }), v;
        }
        var Qd = xi(function(o, h, v) {
          yn(o, h, v);
        }), uu = xi(function(o, h, v, R) {
          yn(o, h, v, R);
        }), ep = Nr(function(o, h) {
          var v = {};
          if (o == null)
            return v;
          var R = false;
          h = Tt(h, function(H) {
            return H = Yr(H, o), R || (R = H.length > 1), H;
          }), Tr(o, Ra(o), v), R && (v = fr(v, p | m | y, Wh));
          for (var N = h.length; N--; )
            ba(v, h[N]);
          return v;
        });
        function tp(o, h) {
          return lu(o, qn(Ge(h)));
        }
        var rp = Nr(function(o, h) {
          return o == null ? {} : Ah(o, h);
        });
        function lu(o, h) {
          if (o == null)
            return {};
          var v = Tt(Ra(o), function(R) {
            return [R];
          });
          return h = Ge(h), Zs(o, v, function(R, N) {
            return h(R, N[0]);
          });
        }
        function ip(o, h, v) {
          h = Yr(h, o);
          var R = -1, N = h.length;
          for (N || (N = 1, o = t); ++R < N; ) {
            var H = o == null ? t : o[Cr(h[R])];
            H === t && (R = N, H = v), o = Fr(H) ? H.call(o) : H;
          }
          return o;
        }
        function np(o, h, v) {
          return o == null ? o : $i(o, h, v);
        }
        function ap(o, h, v, R) {
          return R = typeof R == "function" ? R : t, o == null ? o : $i(o, h, v, R);
        }
        var hu = wo(Bt), cu = wo(Jt);
        function sp(o, h, v) {
          var R = tt(o), N = R || Jr(o) || Ti(o);
          if (h = Ge(h, 4), v == null) {
            var H = o && o.constructor;
            N ? v = R ? new H() : [] : St(o) ? v = Fr(H) ? _i(on(o)) : {} : v = {};
          }
          return (N ? lr : Er)(o, function(Z, Q, se) {
            return h(v, Z, Q, se);
          }), v;
        }
        function op(o, h) {
          return o == null ? true : ba(o, h);
        }
        function up(o, h, v) {
          return o == null ? o : io(o, h, wa(v));
        }
        function lp(o, h, v, R) {
          return R = typeof R == "function" ? R : t, o == null ? o : io(o, h, wa(v), R);
        }
        function Ci(o) {
          return o == null ? [] : ea(o, Bt(o));
        }
        function hp(o) {
          return o == null ? [] : ea(o, Jt(o));
        }
        function cp(o, h, v) {
          return v === t && (v = h, h = t), v !== t && (v = mr(v), v = v === v ? v : 0), h !== t && (h = mr(h), h = h === h ? h : 0), ni(mr(o), h, v);
        }
        function fp(o, h, v) {
          return h = Br(h), v === t ? (v = h, h = 0) : v = Br(v), o = mr(o), gh(o, h, v);
        }
        function dp(o, h, v) {
          if (v && typeof v != "boolean" && Wt(o, h, v) && (h = v = t), v === t && (typeof h == "boolean" ? (v = h, h = t) : typeof o == "boolean" && (v = o, o = t)), o === t && h === t ? (o = 0, h = 1) : (o = Br(o), h === t ? (h = o, o = 0) : h = Br(h)), o > h) {
            var R = o;
            o = h, h = R;
          }
          if (v || o % 1 || h % 1) {
            var N = qs();
            return Gt(o + N * (h - o + Gu("1e-" + ((N + "").length - 1))), h);
          }
          return va(o, h);
        }
        var pp = wi(function(o, h, v) {
          return h = h.toLowerCase(), o + (v ? fu(h) : h);
        });
        function fu(o) {
          return Ga(mt(o).toLowerCase());
        }
        function du(o) {
          return o = mt(o), o && o.replace(rs, rl).replace(qu, "");
        }
        function mp(o, h, v) {
          o = mt(o), h = nr(h);
          var R = o.length;
          v = v === t ? R : ni(rt(v), 0, R);
          var N = v;
          return v -= h.length, v >= 0 && o.slice(v, N) == h;
        }
        function vp(o) {
          return o = mt(o), o && qe.test(o) ? o.replace(ne, il) : o;
        }
        function gp(o) {
          return o = mt(o), o && jr.test(o) ? o.replace(Vt, "\\$&") : o;
        }
        var yp = wi(function(o, h, v) {
          return o + (v ? "-" : "") + h.toLowerCase();
        }), bp = wi(function(o, h, v) {
          return o + (v ? " " : "") + h.toLowerCase();
        }), _p = vo("toLowerCase");
        function xp(o, h, v) {
          o = mt(o), h = rt(h);
          var R = h ? mi(o) : 0;
          if (!h || R >= h)
            return o;
          var N = (h - R) / 2;
          return Tn(cn(N), v) + o + Tn(hn(N), v);
        }
        function wp(o, h, v) {
          o = mt(o), h = rt(h);
          var R = h ? mi(o) : 0;
          return h && R < h ? o + Tn(h - R, v) : o;
        }
        function Ep(o, h, v) {
          o = mt(o), h = rt(h);
          var R = h ? mi(o) : 0;
          return h && R < h ? Tn(h - R, v) + o : o;
        }
        function Tp(o, h, v) {
          return v || h == null ? h = 0 : h && (h = +h), Ol(mt(o).replace(tr, ""), h || 0);
        }
        function Cp(o, h, v) {
          return (v ? Wt(o, h, v) : h === t) ? h = 1 : h = rt(h), ga(mt(o), h);
        }
        function Sp() {
          var o = arguments, h = mt(o[0]);
          return o.length < 3 ? h : h.replace(o[1], o[2]);
        }
        var Rp = wi(function(o, h, v) {
          return o + (v ? "_" : "") + h.toLowerCase();
        });
        function Ap(o, h, v) {
          return v && typeof v != "number" && Wt(o, h, v) && (h = v = t), v = v === t ? V : v >>> 0, v ? (o = mt(o), o && (typeof h == "string" || h != null && !$a(h)) && (h = nr(h), !h && pi(o)) ? Kr(vr(o), 0, v) : o.split(h, v)) : [];
        }
        var Mp = wi(function(o, h, v) {
          return o + (v ? " " : "") + Ga(h);
        });
        function Op(o, h, v) {
          return o = mt(o), v = v == null ? 0 : ni(rt(v), 0, o.length), h = nr(h), o.slice(v, v + h.length) == h;
        }
        function Ip(o, h, v) {
          var R = j.templateSettings;
          v && Wt(o, h, v) && (h = t), o = mt(o), h = Nn({}, h, R, Eo);
          var N = Nn({}, h.imports, R.imports, Eo), H = Bt(N), Z = ea(N, H), Q, se, xe = 0, we = h.interpolate || Mi, Ce = "__p += '", Le = ra(
            (h.escape || Mi).source + "|" + we.source + "|" + (we === bt ? ci : Mi).source + "|" + (h.evaluate || Mi).source + "|$",
            "g"
          ), Be = "//# sourceURL=" + (yt.call(h, "sourceURL") ? (h.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++Fu + "]") + `
`;
          o.replace(Le, function(He, st, ut, sr, Xt, or) {
            return ut || (ut = sr), Ce += o.slice(xe, or).replace(Ja, nl), st && (Q = true, Ce += `' +
__e(` + st + `) +
'`), Xt && (se = true, Ce += `';
` + Xt + `;
__p += '`), ut && (Ce += `' +
((__t = (` + ut + `)) == null ? '' : __t) +
'`), xe = or + He.length, He;
          }), Ce += `';
`;
          var Ve = yt.call(h, "variable") && h.variable;
          if (!Ve)
            Ce = `with (obj) {
` + Ce + `
}
`;
          else if (hi.test(Ve))
            throw new Qe(l);
          Ce = (se ? Ce.replace(et, "") : Ce).replace(lt, "$1").replace(We, "$1;"), Ce = "function(" + (Ve || "obj") + `) {
` + (Ve ? "" : `obj || (obj = {});
`) + "var __t, __p = ''" + (Q ? ", __e = _.escape" : "") + (se ? `, __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }
` : `;
`) + Ce + `return __p
}`;
          var it = mu(function() {
            return ft(H, Be + "return " + Ce).apply(t, Z);
          });
          if (it.source = Ce, Ba(it))
            throw it;
          return it;
        }
        function Pp(o) {
          return mt(o).toLowerCase();
        }
        function qp(o) {
          return mt(o).toUpperCase();
        }
        function kp(o, h, v) {
          if (o = mt(o), o && (v || h === t))
            return ws(o);
          if (!o || !(h = nr(h)))
            return o;
          var R = vr(o), N = vr(h), H = Es(R, N), Z = Ts(R, N) + 1;
          return Kr(R, H, Z).join("");
        }
        function Lp(o, h, v) {
          if (o = mt(o), o && (v || h === t))
            return o.slice(0, Ss(o) + 1);
          if (!o || !(h = nr(h)))
            return o;
          var R = vr(o), N = Ts(R, vr(h)) + 1;
          return Kr(R, 0, N).join("");
        }
        function Np(o, h, v) {
          if (o = mt(o), o && (v || h === t))
            return o.replace(tr, "");
          if (!o || !(h = nr(h)))
            return o;
          var R = vr(o), N = Es(R, vr(h));
          return Kr(R, N).join("");
        }
        function Dp(o, h) {
          var v = U, R = B;
          if (St(h)) {
            var N = "separator" in h ? h.separator : N;
            v = "length" in h ? rt(h.length) : v, R = "omission" in h ? nr(h.omission) : R;
          }
          o = mt(o);
          var H = o.length;
          if (pi(o)) {
            var Z = vr(o);
            H = Z.length;
          }
          if (v >= H)
            return o;
          var Q = v - mi(R);
          if (Q < 1)
            return R;
          var se = Z ? Kr(Z, 0, Q).join("") : o.slice(0, Q);
          if (N === t)
            return se + R;
          if (Z && (Q += se.length - Q), $a(N)) {
            if (o.slice(Q).search(N)) {
              var xe, we = se;
              for (N.global || (N = ra(N.source, mt(Ri.exec(N)) + "g")), N.lastIndex = 0; xe = N.exec(we); )
                var Ce = xe.index;
              se = se.slice(0, Ce === t ? Q : Ce);
            }
          } else if (o.indexOf(nr(N), Q) != Q) {
            var Le = se.lastIndexOf(N);
            Le > -1 && (se = se.slice(0, Le));
          }
          return se + R;
        }
        function Fp(o) {
          return o = mt(o), o && fe.test(o) ? o.replace(te, cl) : o;
        }
        var Bp = wi(function(o, h, v) {
          return o + (v ? " " : "") + h.toUpperCase();
        }), Ga = vo("toUpperCase");
        function pu(o, h, v) {
          return o = mt(o), h = v ? t : h, h === t ? sl(o) ? pl(o) : Ju(o) : o.match(h) || [];
        }
        var mu = nt(function(o, h) {
          try {
            return rr(o, t, h);
          } catch (v) {
            return Ba(v) ? v : new Qe(v);
          }
        }), $p = Nr(function(o, h) {
          return lr(h, function(v) {
            v = Cr(v), kr(o, v, Da(o[v], o));
          }), o;
        });
        function jp(o) {
          var h = o == null ? 0 : o.length, v = Ge();
          return o = h ? Tt(o, function(R) {
            if (typeof R[1] != "function")
              throw new hr(u);
            return [v(R[0]), R[1]];
          }) : [], nt(function(R) {
            for (var N = -1; ++N < h; ) {
              var H = o[N];
              if (rr(H[0], this, R))
                return rr(H[1], this, R);
            }
          });
        }
        function Up(o) {
          return fh(fr(o, p));
        }
        function za(o) {
          return function() {
            return o;
          };
        }
        function Gp(o, h) {
          return o == null || o !== o ? h : o;
        }
        var zp = yo(), Vp = yo(true);
        function Zt(o) {
          return o;
        }
        function Va(o) {
          return Hs(typeof o == "function" ? o : fr(o, p));
        }
        function Hp(o) {
          return Xs(fr(o, p));
        }
        function Wp(o, h) {
          return Ys(o, fr(h, p));
        }
        var Xp = nt(function(o, h) {
          return function(v) {
            return Fi(v, o, h);
          };
        }), Yp = nt(function(o, h) {
          return function(v) {
            return Fi(o, v, h);
          };
        });
        function Ha(o, h, v) {
          var R = Bt(h), N = gn(h, R);
          v == null && !(St(h) && (N.length || !R.length)) && (v = h, h = o, o = this, N = gn(h, Bt(h)));
          var H = !(St(v) && "chain" in v) || !!v.chain, Z = Fr(o);
          return lr(N, function(Q) {
            var se = h[Q];
            o[Q] = se, Z && (o.prototype[Q] = function() {
              var xe = this.__chain__;
              if (H || xe) {
                var we = o(this.__wrapped__), Ce = we.__actions__ = Yt(this.__actions__);
                return Ce.push({ func: se, args: arguments, thisArg: o }), we.__chain__ = xe, we;
              }
              return se.apply(o, zr([this.value()], arguments));
            });
          }), o;
        }
        function Kp() {
          return $t._ === this && ($t._ = xl), this;
        }
        function Wa() {
        }
        function Jp(o) {
          return o = rt(o), nt(function(h) {
            return Ks(h, o);
          });
        }
        var Zp = Ta(Tt), Qp = Ta(gs), em = Ta(Yn);
        function vu(o) {
          return Ia(o) ? Kn(Cr(o)) : Mh(o);
        }
        function tm(o) {
          return function(h) {
            return o == null ? t : ai(o, h);
          };
        }
        var rm = _o(), im = _o(true);
        function Xa() {
          return [];
        }
        function Ya() {
          return false;
        }
        function nm() {
          return {};
        }
        function am() {
          return "";
        }
        function sm() {
          return true;
        }
        function om(o, h) {
          if (o = rt(o), o < 1 || o > P)
            return [];
          var v = V, R = Gt(o, V);
          h = Ge(h), o -= V;
          for (var N = Qn(R, h); ++v < o; )
            h(v);
          return N;
        }
        function um(o) {
          return tt(o) ? Tt(o, Cr) : ar(o) ? [o] : Yt(No(mt(o)));
        }
        function lm(o) {
          var h = ++bl;
          return mt(o) + h;
        }
        var hm = En(function(o, h) {
          return o + h;
        }, 0), cm = Ca("ceil"), fm = En(function(o, h) {
          return o / h;
        }, 1), dm = Ca("floor");
        function pm(o) {
          return o && o.length ? vn(o, Zt, ha) : t;
        }
        function mm(o, h) {
          return o && o.length ? vn(o, Ge(h, 2), ha) : t;
        }
        function vm(o) {
          return _s(o, Zt);
        }
        function gm(o, h) {
          return _s(o, Ge(h, 2));
        }
        function ym(o) {
          return o && o.length ? vn(o, Zt, pa) : t;
        }
        function bm(o, h) {
          return o && o.length ? vn(o, Ge(h, 2), pa) : t;
        }
        var _m = En(function(o, h) {
          return o * h;
        }, 1), xm = Ca("round"), wm = En(function(o, h) {
          return o - h;
        }, 0);
        function Em(o) {
          return o && o.length ? Zn(o, Zt) : 0;
        }
        function Tm(o, h) {
          return o && o.length ? Zn(o, Ge(h, 2)) : 0;
        }
        return j.after = Hf, j.ary = Wo, j.assign = qd, j.assignIn = ou, j.assignInWith = Nn, j.assignWith = kd, j.at = Ld, j.before = Xo, j.bind = Da, j.bindAll = $p, j.bindKey = Yo, j.castArray = nd, j.chain = zo, j.chunk = fc, j.compact = dc, j.concat = pc, j.cond = jp, j.conforms = Up, j.constant = za, j.countBy = Ef, j.create = Nd, j.curry = Ko, j.curryRight = Jo, j.debounce = Zo, j.defaults = Dd, j.defaultsDeep = Fd, j.defer = Wf, j.delay = Xf, j.difference = mc, j.differenceBy = vc, j.differenceWith = gc, j.drop = yc, j.dropRight = bc, j.dropRightWhile = _c, j.dropWhile = xc, j.fill = wc, j.filter = Cf, j.flatMap = Af, j.flatMapDeep = Mf, j.flatMapDepth = Of, j.flatten = $o, j.flattenDeep = Ec, j.flattenDepth = Tc, j.flip = Yf, j.flow = zp, j.flowRight = Vp, j.fromPairs = Cc, j.functions = Vd, j.functionsIn = Hd, j.groupBy = If, j.initial = Rc, j.intersection = Ac, j.intersectionBy = Mc, j.intersectionWith = Oc, j.invert = Xd, j.invertBy = Yd, j.invokeMap = qf, j.iteratee = Va, j.keyBy = kf, j.keys = Bt, j.keysIn = Jt, j.map = On, j.mapKeys = Jd, j.mapValues = Zd, j.matches = Hp, j.matchesProperty = Wp, j.memoize = Pn, j.merge = Qd, j.mergeWith = uu, j.method = Xp, j.methodOf = Yp, j.mixin = Ha, j.negate = qn, j.nthArg = Jp, j.omit = ep, j.omitBy = tp, j.once = Kf, j.orderBy = Lf, j.over = Zp, j.overArgs = Jf, j.overEvery = Qp, j.overSome = em, j.partial = Fa, j.partialRight = Qo, j.partition = Nf, j.pick = rp, j.pickBy = lu, j.property = vu, j.propertyOf = tm, j.pull = kc, j.pullAll = Uo, j.pullAllBy = Lc, j.pullAllWith = Nc, j.pullAt = Dc, j.range = rm, j.rangeRight = im, j.rearg = Zf, j.reject = Bf, j.remove = Fc, j.rest = Qf, j.reverse = La, j.sampleSize = jf, j.set = np, j.setWith = ap, j.shuffle = Uf, j.slice = Bc, j.sortBy = Vf, j.sortedUniq = Hc, j.sortedUniqBy = Wc, j.split = Ap, j.spread = ed, j.tail = Xc, j.take = Yc, j.takeRight = Kc, j.takeRightWhile = Jc, j.takeWhile = Zc, j.tap = pf, j.throttle = td, j.thru = Mn, j.toArray = nu, j.toPairs = hu, j.toPairsIn = cu, j.toPath = um, j.toPlainObject = su, j.transform = sp, j.unary = rd, j.union = Qc, j.unionBy = ef, j.unionWith = tf, j.uniq = rf, j.uniqBy = nf, j.uniqWith = af, j.unset = op, j.unzip = Na, j.unzipWith = Go, j.update = up, j.updateWith = lp, j.values = Ci, j.valuesIn = hp, j.without = sf, j.words = pu, j.wrap = id, j.xor = of, j.xorBy = uf, j.xorWith = lf, j.zip = hf, j.zipObject = cf, j.zipObjectDeep = ff, j.zipWith = df, j.entries = hu, j.entriesIn = cu, j.extend = ou, j.extendWith = Nn, Ha(j, j), j.add = hm, j.attempt = mu, j.camelCase = pp, j.capitalize = fu, j.ceil = cm, j.clamp = cp, j.clone = ad, j.cloneDeep = od, j.cloneDeepWith = ud, j.cloneWith = sd, j.conformsTo = ld, j.deburr = du, j.defaultTo = Gp, j.divide = fm, j.endsWith = mp, j.eq = yr, j.escape = vp, j.escapeRegExp = gp, j.every = Tf, j.find = Sf, j.findIndex = Fo, j.findKey = Bd, j.findLast = Rf, j.findLastIndex = Bo, j.findLastKey = $d, j.floor = dm, j.forEach = Vo, j.forEachRight = Ho, j.forIn = jd, j.forInRight = Ud, j.forOwn = Gd, j.forOwnRight = zd, j.get = ja, j.gt = hd, j.gte = cd, j.has = Wd, j.hasIn = Ua, j.head = jo, j.identity = Zt, j.includes = Pf, j.indexOf = Sc, j.inRange = fp, j.invoke = Kd, j.isArguments = ui, j.isArray = tt, j.isArrayBuffer = fd, j.isArrayLike = Kt, j.isArrayLikeObject = Mt, j.isBoolean = dd, j.isBuffer = Jr, j.isDate = pd, j.isElement = md, j.isEmpty = vd, j.isEqual = gd, j.isEqualWith = yd, j.isError = Ba, j.isFinite = bd, j.isFunction = Fr, j.isInteger = eu, j.isLength = kn, j.isMap = tu, j.isMatch = _d, j.isMatchWith = xd, j.isNaN = wd, j.isNative = Ed, j.isNil = Cd, j.isNull = Td, j.isNumber = ru, j.isObject = St, j.isObjectLike = At, j.isPlainObject = zi, j.isRegExp = $a, j.isSafeInteger = Sd, j.isSet = iu, j.isString = Ln, j.isSymbol = ar, j.isTypedArray = Ti, j.isUndefined = Rd, j.isWeakMap = Ad, j.isWeakSet = Md, j.join = Ic, j.kebabCase = yp, j.last = pr, j.lastIndexOf = Pc, j.lowerCase = bp, j.lowerFirst = _p, j.lt = Od, j.lte = Id, j.max = pm, j.maxBy = mm, j.mean = vm, j.meanBy = gm, j.min = ym, j.minBy = bm, j.stubArray = Xa, j.stubFalse = Ya, j.stubObject = nm, j.stubString = am, j.stubTrue = sm, j.multiply = _m, j.nth = qc, j.noConflict = Kp, j.noop = Wa, j.now = In, j.pad = xp, j.padEnd = wp, j.padStart = Ep, j.parseInt = Tp, j.random = dp, j.reduce = Df, j.reduceRight = Ff, j.repeat = Cp, j.replace = Sp, j.result = ip, j.round = xm, j.runInContext = ie, j.sample = $f, j.size = Gf, j.snakeCase = Rp, j.some = zf, j.sortedIndex = $c, j.sortedIndexBy = jc, j.sortedIndexOf = Uc, j.sortedLastIndex = Gc, j.sortedLastIndexBy = zc, j.sortedLastIndexOf = Vc, j.startCase = Mp, j.startsWith = Op, j.subtract = wm, j.sum = Em, j.sumBy = Tm, j.template = Ip, j.times = om, j.toFinite = Br, j.toInteger = rt, j.toLength = au, j.toLower = Pp, j.toNumber = mr, j.toSafeInteger = Pd, j.toString = mt, j.toUpper = qp, j.trim = kp, j.trimEnd = Lp, j.trimStart = Np, j.truncate = Dp, j.unescape = Fp, j.uniqueId = lm, j.upperCase = Bp, j.upperFirst = Ga, j.each = Vo, j.eachRight = Ho, j.first = jo, Ha(j, function() {
          var o = {};
          return Er(j, function(h, v) {
            yt.call(j.prototype, v) || (o[v] = h);
          }), o;
        }(), { chain: false }), j.VERSION = r, lr(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(o) {
          j[o].placeholder = j;
        }), lr(["drop", "take"], function(o, h) {
          ot.prototype[o] = function(v) {
            v = v === t ? 1 : Nt(rt(v), 0);
            var R = this.__filtered__ && !h ? new ot(this) : this.clone();
            return R.__filtered__ ? R.__takeCount__ = Gt(v, R.__takeCount__) : R.__views__.push({
              size: Gt(v, V),
              type: o + (R.__dir__ < 0 ? "Right" : "")
            }), R;
          }, ot.prototype[o + "Right"] = function(v) {
            return this.reverse()[o](v).reverse();
          };
        }), lr(["filter", "map", "takeWhile"], function(o, h) {
          var v = h + 1, R = v == D || v == k;
          ot.prototype[o] = function(N) {
            var H = this.clone();
            return H.__iteratees__.push({
              iteratee: Ge(N, 3),
              type: v
            }), H.__filtered__ = H.__filtered__ || R, H;
          };
        }), lr(["head", "last"], function(o, h) {
          var v = "take" + (h ? "Right" : "");
          ot.prototype[o] = function() {
            return this[v](1).value()[0];
          };
        }), lr(["initial", "tail"], function(o, h) {
          var v = "drop" + (h ? "" : "Right");
          ot.prototype[o] = function() {
            return this.__filtered__ ? new ot(this) : this[v](1);
          };
        }), ot.prototype.compact = function() {
          return this.filter(Zt);
        }, ot.prototype.find = function(o) {
          return this.filter(o).head();
        }, ot.prototype.findLast = function(o) {
          return this.reverse().find(o);
        }, ot.prototype.invokeMap = nt(function(o, h) {
          return typeof o == "function" ? new ot(this) : this.map(function(v) {
            return Fi(v, o, h);
          });
        }), ot.prototype.reject = function(o) {
          return this.filter(qn(Ge(o)));
        }, ot.prototype.slice = function(o, h) {
          o = rt(o);
          var v = this;
          return v.__filtered__ && (o > 0 || h < 0) ? new ot(v) : (o < 0 ? v = v.takeRight(-o) : o && (v = v.drop(o)), h !== t && (h = rt(h), v = h < 0 ? v.dropRight(-h) : v.take(h - o)), v);
        }, ot.prototype.takeRightWhile = function(o) {
          return this.reverse().takeWhile(o).reverse();
        }, ot.prototype.toArray = function() {
          return this.take(V);
        }, Er(ot.prototype, function(o, h) {
          var v = /^(?:filter|find|map|reject)|While$/.test(h), R = /^(?:head|last)$/.test(h), N = j[R ? "take" + (h == "last" ? "Right" : "") : h], H = R || /^find/.test(h);
          N && (j.prototype[h] = function() {
            var Z = this.__wrapped__, Q = R ? [1] : arguments, se = Z instanceof ot, xe = Q[0], we = se || tt(Z), Ce = function(st) {
              var ut = N.apply(j, zr([st], Q));
              return R && Le ? ut[0] : ut;
            };
            we && v && typeof xe == "function" && xe.length != 1 && (se = we = false);
            var Le = this.__chain__, Be = !!this.__actions__.length, Ve = H && !Le, it = se && !Be;
            if (!H && we) {
              Z = it ? Z : new ot(this);
              var He = o.apply(Z, Q);
              return He.__actions__.push({ func: Mn, args: [Ce], thisArg: t }), new cr(He, Le);
            }
            return Ve && it ? o.apply(this, Q) : (He = this.thru(Ce), Ve ? R ? He.value()[0] : He.value() : He);
          });
        }), lr(["pop", "push", "shift", "sort", "splice", "unshift"], function(o) {
          var h = en[o], v = /^(?:push|sort|unshift)$/.test(o) ? "tap" : "thru", R = /^(?:pop|shift)$/.test(o);
          j.prototype[o] = function() {
            var N = arguments;
            if (R && !this.__chain__) {
              var H = this.value();
              return h.apply(tt(H) ? H : [], N);
            }
            return this[v](function(Z) {
              return h.apply(tt(Z) ? Z : [], N);
            });
          };
        }), Er(ot.prototype, function(o, h) {
          var v = j[h];
          if (v) {
            var R = v.name + "";
            yt.call(bi, R) || (bi[R] = []), bi[R].push({ name: h, func: v });
          }
        }), bi[wn(t, T).name] = [{
          name: "wrapper",
          func: t
        }], ot.prototype.clone = Dl, ot.prototype.reverse = Fl, ot.prototype.value = Bl, j.prototype.at = mf, j.prototype.chain = vf, j.prototype.commit = gf, j.prototype.next = yf, j.prototype.plant = _f, j.prototype.reverse = xf, j.prototype.toJSON = j.prototype.valueOf = j.prototype.value = wf, j.prototype.first = j.prototype.head, Ii && (j.prototype[Ii] = bf), j;
      }, vi = ml();
      ei ? ((ei.exports = vi)._ = vi, Vn._ = vi) : $t._ = vi;
    }).call(lodash);
  }(lodash$1, lodash$1.exports)), lodash$1.exports;
}
var video$1, hasRequiredVideo$1;
function requireVideo$1() {
  if (hasRequiredVideo$1) return video$1;
  hasRequiredVideo$1 = 1;
  const { isBrowser: i2 } = requireLib$5(), e = requireImage$1();
  requireMin();
  const t = requireLogger(), r = requireMd5(), { nodeRequire: a, isUA: s } = requireUtils();
  requireLodash();
  const u = requireVideo$2(), l = requireQueue(), c = a("ffmpeg-probe"), d = a("../utils/ffmpeg"), f = a("../utils/opencv"), p = a("../utils/fs"), m = "player", y = "seeker", x = "init", g = 0.02, _ = {};
  class T extends e {
    constructor(b) {
      super(b), this.setVolume(b.volume), this.setAudio(b.audio === void 0 ? true : !!b.audio), this.OFFSET_TIME = 0.05, this.adjustTime = 0, this.adjustRate = 1, this.time = 0, this.playing = false, this.perpared = false, this.queue = new l(), this.$vh = {}, this.codec = b.codec, this.clarity = b.qscale || b.clarity || 2, this.voImageExtra = b.voImageExtra === void 0 ? "jpg" : b.voImageExtra;
    }
    setVolume(b) {
      this.volume = Number(b), isNaN(this.volume) && (this.volume = 1);
    }
    setAudio(b) {
      var C;
      this.useAudio = b;
      const w = this.$vh && ((C = this.$vh[m]) == null ? void 0 : C.$video);
      w && w.muted === this.useAudio && (w.muted = !this.useAudio, this.useAudio && this.$vh[m].setVolume(this.volume));
    }
    async init(b) {
      const { fps: C } = b;
      if (this.fps = C, i2)
        await this.valloc(x), this.info = await this.$vh[x].getInfo(), this.velease(x), this.creator.mVIDEOS.push(this);
      else {
        _[this.path] || (_[this.path] = await c(this.path)), this.info = { ..._[this.path] }, this.info.duration /= 1e3;
        try {
          this.videoCap = f.VideoCapture(this.path);
        } catch {
        }
        this.acommand = d.createCommand(), this.vcommand = d.createCommand();
      }
      this.canvas = this.initCanvas(this.info.width, this.info.height), this.canvasContext = this.canvas.getContext("2d"), this.length = this.info.duration;
    }
    get hasAudio() {
      var b;
      return ((b = this.info) == null ? void 0 : b.streams) && this.info.streams.some((C) => C.codec_type === "audio");
    }
    async valloc(b) {
      if (this.$vh[b]) return this.$vh[b].$video;
      try {
        this.$vh[b] = await u.get(
          this.path,
          this.creator.uuid,
          `${this.holderId}-${b}`
        );
      } catch {
        return null;
      }
      const C = this.$vh[b].$video;
      return C.muted = true, C;
    }
    velease(b) {
      this.$vh[b] && (this.$vh[b].release(), this.$vh[b] = null);
    }
    async play(b) {
      if (this.playing) return;
      const C = await this.valloc(m);
      return (Math.abs(b - C.currentTime) > 0.1 || !this.creator.getConf("adjustPlaySpeed")) && (C.currentTime = b), this.adjustRate = 1, this.adjustTime = this.creator.currentTime, C.playbackRate = this.playrate, new Promise((w) => {
        T.playing(C) ? (this.playing = true, w()) : (C.addEventListener("playing", () => {
          this.playing = true, w();
        }, { once: true }), C.play());
      });
    }
    pause() {
      var b;
      if (!this.playing && !this.perpared) return;
      const C = (b = this.$vh[m]) == null ? void 0 : b.$video, w = () => {
        this.playing = false, this.perpared = false, this.velease(m);
      };
      !C || !T.playing(C) ? w() : (C.addEventListener("pause", (A) => w(), { once: true }), C.pause());
    }
    async perpare(b, C = false) {
      if (this.perpared || !i2) return;
      this.perpared = true;
      const w = await this.valloc(m), A = this.seekTime(b);
      Math.abs(w.currentTime - A) > 0.1 && (w.currentTime = A, C && w.play());
    }
    async seekTo(b, C = y) {
      return new Promise(async (w, A) => {
        const S = await this.valloc(C);
        if (!S) return w();
        S.currentTime.toFixed(2) == b.toFixed(2) ? (w(S), this.velease(C)) : (S.currentTime = b, S.addEventListener("seeked", () => {
          w(S), this.velease(C);
        }, { once: true }));
      });
    }
    async queuedSeekTo(b, C = y) {
      return new Promise(async (w, A) => {
        this.queue.enqueue(async () => {
          w(await this.seekTo(b, C));
        });
      });
    }
    get playrate() {
      return this.creator.playbackRate * this.speed;
    }
    seekTime(b, C = {}) {
      return super.seekTime(i2 ? b + this.OFFSET_TIME : b, C);
    }
    async getFrameByTime(b, C = 0) {
      this.time = b;
      const w = {}, A = this.seekTime(b, w);
      if (i2)
        w.overflow && (C = 0), C > 0 ? await this.play(A) : this.pause();
      else
        return this.videoCap ? f.getFrameByTime(this.videoCap, A) : this.getFrame(Math.max(0, b * this.fps >> 0));
      return new Promise(async (S, F) => {
        var M;
        const U = this.canvas.width, B = this.canvas.height;
        if (C > 0) {
          const q = (M = this.$vh[m]) == null ? void 0 : M.$video;
          if (!q) return S();
          if (this.playerDelay = A - q.currentTime, this.creator.getConf("adjustPlaySpeed") && (this.playrate * this.adjustRate).toFixed(3) === q.playbackRate.toFixed(3)) {
            Math.abs(this.playerDelay) > 0.05 ? (this.adjustRate += this.playerDelay > 0 ? g : -0.02, this.adjustRate = Math.max(Math.min(this.adjustRate, 1.05), 0.95)) : q.playbackRate != this.playrate && (this.adjustRate += this.adjustRate > 1 ? -0.02 : g);
            const z = this.playrate * this.adjustRate;
            z.toFixed(3) !== q.playbackRate.toFixed(3) && Math.abs(this.creator.currentTime - this.adjustTime) > 100 && (q.playbackRate = z, this.adjustTime = this.creator.currentTime);
          }
          S(this.drawCanvas(q, U, B));
        } else
          S(this.drawCanvas(await this.queuedSeekTo(A), U, B));
      });
    }
    delay() {
      return this.playerDelay;
    }
    getFrame(b) {
      let C = this.vpath.replace("%d", b);
      return p.exists(C) || (C = this.lastPath), this.lastPath = C, C;
    }
    /**
     * Extract the audio/video file from the movie
     * @public
     */
    async extract(b, C) {
      const w = r(`${this.path}-${this.getStartHms()}-${this.getEndHms(true)}`);
      if (!this.videoCap && C) {
        console.log("---------------- extract video ----------------", this.holderId);
        const A = Date.now();
        await this.extractVideo(b, `${w}_video`), f.timer += Date.now() - A;
      }
      this.useAudio && (console.log("---------------- extract audio ----------------"), await this.extractAudio(b, `${w}_audio`));
    }
    async extractAudio(b, C) {
      const w = this.getOutputPath(b, `${C}.mp3`);
      if (p.exists(w)) return this.apath = w;
      let A = "-loglevel info".split(" ");
      A = A.concat(`-af atempo=${this.speed}`.split(" "));
      const S = this.getSliceOpts(), F = this.acommand.noVideo().audioCodec("libmp3lame");
      return this.apath = await this.ffCmdExec({ command: F, inOpts: S, output: w, outOpts: A }), this.apath;
    }
    async extractVideo(b, C) {
      let w = "-loglevel info -pix_fmt rgba -start_number 0".split(" ");
      const A = `-qscale:v ${this.clarity} -filter_complex [0:v]setpts=PTS/${this.speed}[sv];[sv]fps=${this.fps}[ov] -map [ov]`;
      w = w.concat(A.split(" "));
      let S = this.codec ? `-c:v ${this.codec}`.split(" ") : [];
      S = S.concat(this.getSliceOpts());
      const F = this.getOutputPath(b, `${C}_%d.${this.voImageExtra}`);
      return p.exists(F.replace("%d", "0")) ? this.vpath = F : (this.vpath = await this.ffCmdExec({ command: this.vcommand, output: F, inOpts: S, outOpts: w }), this.vpath);
    }
    ffCmdExec({ command: b, output: C, inOpts: w, outOpts: A, onProgress: S }) {
      const F = function(M) {
        return typeof M == "string" && (M = M.split(" ")), M instanceof Array && (M = M.filter((U) => U !== "")), M;
      };
      return b.addInput(this.path).output(C), w && b.inputOptions(F(w)), A && b.outputOptions(F(A)), new Promise((M, U) => {
        b.on("start", (B) => {
          t.info({ pos: "Material", msg: `${this.type} preProcessing start: ${B}` });
        }).on("progress", (B) => {
          S && S(B);
        }).on("end", () => {
          t.info({ pos: "Material", msg: `${this.type} preProcessing completed: ${this}` }), M(C);
        }).on("error", (B) => {
          t.error({ pos: "Material", msg: `${this.type} preProcessing error: `, error: B }), U(B);
        }), b.run();
      });
    }
    destroy() {
      for (const b of Object.keys(this.$vh))
        this.$vh[b] && this.velease(b);
      this.canvas && (this.canvas = null, this.canvasContext = null, this.playing = false), this.acommand && d.destroy(this.acommand), this.vcommand && d.destroy(this.vcommand), this.videoCap && f.destroy(this.videoCap), this.queue && this.queue.destroy(), this.queue = null, super.destroy();
    }
  }
  return video$1 = T, video$1;
}
var gif$1, hasRequiredGif$1;
function requireGif$1() {
  if (hasRequiredGif$1) return gif$1;
  hasRequiredGif$1 = 1;
  const { isBrowser: i2 } = requireLib$5(), e = requireVideo$1(), t = requireUtils(), { getRemote: r } = requireXhr(), { createImageData: a } = requireLib$2();
  class s extends e {
    async init(l) {
      const { fps: c } = l;
      this.OFFSET_TIME = 0, this.disposal = 2, this.fps = c;
      let d, f = this.path;
      i2 && f.startsWith("http") && (d = await r(f, this.creator.uuid), f = URL.createObjectURL(d.data));
      try {
        d = await t.getPixels(this.path, this.conf.srcType || ".GIF");
      } catch {
        d = await t.getPixels(this.path);
      }
      const { pixels: p, frameInfo: m } = d;
      let y = 1;
      if (!m || !m.length)
        if (p && p.shape.length === 3)
          this.frameInfo = [{ delay: Math.pow(10, 9), disposal: 1 }], y = 0;
        else
          throw new Error("Invalid gif frame info: ", m);
      else
        this.frameInfo = m;
      const x = [], g = this.info.width = p.shape[y + 0], _ = this.info.height = p.shape[y + 1], T = g * _ * p.shape[y + 2];
      for (let E = 0; E < this.frameInfo.length; E++) {
        this.frameInfo[E].delay = this.frameInfo[E].delay / 100;
        const b = p.data.slice(E * T, (E + 1) * T), C = a(new Uint8ClampedArray(b.buffer), g, _);
        x.push(C);
      }
      this.length = this.info.duration = this.frameInfo.reduce((E, b) => E + b.delay, 0), this.frames = this.frameInfo.length, this.canvas = this.initCanvas(g, _), this.canvasContext = this.canvas.getContext("2d"), this.imageData = [];
      for (let E = 0; E < this.frameInfo.length; E++) {
        let b = this.frameInfo[E].disposal > 2 ? 2 : this.frameInfo[E].disposal;
        const C = this.initCanvas(g, _), w = C.getContext("2d");
        b === 1 ? (this.drawCanvas(x[E], g, _), i2 ? w.drawImage(this.canvas, 0, 0, g, _) : this.imageData.push(this.canvasContext.getImageData(0, 0, g, _))) : i2 ? w.putImageData(x[E], 0, 0) : this.imageData.push(x[E]), i2 && this.imageData.push(C);
      }
    }
    getFrame(l) {
      const c = l < this.frames ? l : this.frames - 1;
      return this.imageData[c];
    }
    getIndex(l) {
      let c = 0, d = 0;
      for (let f = 0; f < this.frameInfo.length && (c += this.frameInfo[f].delay / this.speed, !(c > l)); f++)
        d = f;
      return d;
    }
    async getFrameByTime(l) {
      const { width: c, height: d } = this.canvas || {};
      this.clearCanvas();
      const f = this.getFrame(this.getIndex(l));
      return f && this.drawCanvas(f, c, d), f;
    }
    destroy() {
      super.destroy(), this.imageData = null, this.frameInfo = null;
    }
  }
  return gif$1 = s, gif$1;
}
var gif, hasRequiredGif;
function requireGif() {
  if (hasRequiredGif) return gif;
  hasRequiredGif = 1;
  const { isBrowser: i2 } = requireLib$5(), e = requireImage(), t = requireGif$1();
  requireUtils();
  class r extends e {
    constructor(s = { list: [] }) {
      super({ type: "gif", ...s }), this.currentTime = 0, this.loops = 0, this.loop = s.loop === void 0 ? true : s.loop;
    }
    get default() {
      const s = super.default;
      return {
        startTime: s.startTime,
        endTime: this.loop ? s.endTime : void 0,
        duration: this.loop ? void 0 : this.material.getDuration()
      };
    }
    get speed() {
      return this.material.speed;
    }
    set speed(s) {
      this.conf.speed = s, this.material.setSpeed(s);
    }
    createMaterial(s) {
      const u = this.confAttr.speed;
      return new t({ speed: u, ...s });
    }
    /**
     * Set whether to loop the animation
     * @param {boolean} loop whether loop
     *
     * @public
     */
    setLoop(s) {
      this.loop = !!s, this.material && (this.material.loop = this.loop);
    }
    setSpeed(s) {
      this.conf.speed = Number(s) || 1, this.material && (this.material.speed = this.confAttr.speed);
    }
    materialTime(s, u = false) {
      return this._materialTime(s, u);
    }
    async getFrameByTime(s) {
      const u = await this.material.getFrameByTime(s);
      return this.material.getImage(u);
    }
    async drawing(s, u) {
      let l = await super.drawing(s, u);
      if (!l) return false;
      const { time: c, loops: d } = this.materialTime(s / 1e3);
      return this.currentTime = c, this.loops !== d && (await this.material.getFrameByTime(this.currentTime, 0), this.loops = d), l = await this.material.getFrameByTime(this.currentTime, u / 1e3), i2 || !l ? this.display.texture.baseTexture.update() : this.draw({ texture: l, useCache: this.useCache }), true;
    }
  }
  return gif = r, gif;
}
var mixin$1, hasRequiredMixin$1;
function requireMixin$1() {
  if (hasRequiredMixin$1) return mixin$1;
  hasRequiredMixin$1 = 1, requireXhr();
  const i2 = requireQueue(), e = requireVideo$1(), { isBrowser: t } = requireLib$5(), { genUuid: r, nodeRequire: a } = requireUtils(), { createCanvas: s, Image: u } = requireLib$2();
  class l extends e {
    constructor(d) {
      super(d), this.OFFSET_TIME = 0, this.msgs = {}, this.queue = new i2(), this.canvas = this.initCanvas(1, 1), this.canvasContext = this.canvas.getContext("2d");
    }
    async init(d) {
      const { fps: f } = d;
      if (t) {
        let T;
        this.conf.mixin.startsWith("http") || this.conf.mixin.startsWith("blob:http") ? T = this.conf.mixin : T = new URL(`./${this.conf.mixin}.js`, this.conf.mns || this.creator.getConf("mns")), this.worker = new Worker(T), this.worker.addEventListener("message", async (E) => {
          if (typeof E.data == "object" && E.data.msgid) {
            if (this.msgs[E.data.msgid]) {
              const b = this.msgs[E.data.msgid];
              b(E.data.resp), delete this.msgs[E.data.msgid];
            } else if (["getImageData"].includes(E.data.method)) {
              const b = await this[E.data.method].call(this, E.data);
              this.worker.postMessage({ resp: b, msgid: E.data.msgid });
            }
          }
        });
      } else {
        const T = a(`../../mixin/src/${this.conf.mixin}.js`);
        this.worker = new T(), this.worker.execCallback = async (E, b) => {
          if (["getImageData"].includes(E))
            return await this[E](b);
        };
      }
      const p = await this.exec(
        { method: "init", fps: f, ...this.conf },
        Number(this.conf.timeout) || 30 * 1e3
      );
      this.info = p || {};
      const { width: m = 0, height: y = 0, duration: x = 1, speed: g, loop: _ } = this.info;
      m && y && this.resize(m, y), this.length = Number(x) || 1, _ !== void 0 && (this.loop = _), g > 0 && this.setSpeed(g);
    }
    async getImageData({ src: d }) {
      if (d)
        return new Promise((f, p) => {
          const m = t ? new Image() : new u();
          m.onload = () => {
            const y = s(m.width, m.height).getContext("2d");
            y.drawImage(m, 0, 0);
            const x = y.getImageData(0, 0, m.width, m.height);
            f(x);
          }, m.onerror = (y) => f(), m.src = d;
        });
    }
    async update(d) {
      const f = await this.exec({ method: "update", ...d }, 3e4);
      this.info = { ...this.info, ...f || {} };
      const { width: p = 0, height: m = 0, duration: y = 1, speed: x, loop: g } = this.info;
      p && m && this.resize(p, m), this.length = Number(y) || 1, g !== void 0 && (this.loop = g), x > 0 && this.setSpeed(x);
    }
    exec(d, f = 10 * 1e3, p = []) {
      return new Promise(async (m, y) => {
        if (t) {
          const x = r();
          this.msgs[x] = (g) => {
            if (typeof g == "object" && g.err) return y(g);
            m(g);
          }, this.worker.postMessage({ ...d, msgid: x }, p), setTimeout(() => {
            delete this.msgs[x], y();
          }, f);
        } else {
          const x = await this.worker[d.method](d);
          m(x);
        }
      });
    }
    resize(d, f) {
      this.canvas.width = d, this.canvas.height = f, this.info.width = this.canvas.width, this.info.height = this.canvas.height;
    }
    async getFrameByTime(d, f) {
      return await this.queuedGetFrameByTime(d, f);
    }
    async queuedGetFrameByTime(d, f, p = null) {
      return new Promise(async (m, y) => {
        this.queue.enqueue(async () => {
          const x = await this.exec({ method: "draw", time: d, delta: f });
          m(this.render(x, p));
        });
      });
    }
    render(d, f = null) {
      f || (f = this.canvas);
      const { width: p, height: m } = f;
      f.getContext("2d").clearRect(0, 0, p, m), this.drawCanvas(d, p, m, f);
    }
    destroy() {
      super.destroy(), this.workerCtx = null, this.queue && this.queue.destroy(), this.updateQueue && this.updateQueue.destroy(), this.queue = null, this.updateQueue = null, this.msgs = null, t && (this.worker && this.worker.terminate(), this.worker = null);
    }
  }
  return mixin$1 = l, mixin$1;
}
var mixin, hasRequiredMixin;
function requireMixin() {
  if (hasRequiredMixin) return mixin;
  hasRequiredMixin = 1;
  const i2 = requireGif(), e = requireMixin$1(), { Rectangle: t, Texture: r, createCanvas: a } = requireLib$2();
  class s extends i2 {
    constructor(l = {}) {
      super({ type: "mixin", ...l }), this.mixin = l.mixin;
    }
    async preProcessing() {
      await super.preProcessing(), this.loop = this.material.loop;
    }
    createMaterial(l) {
      const c = this.px(this.conf.width), d = this.px(this.conf.height);
      return new e({ ...l, width: c, height: d });
    }
    async drawing(l, c) {
      await super.drawing(l, c) && this.animationAttr && this.material.update(this.animationAttr);
    }
    async fitSize() {
      return await this.update(), super.fitSize();
    }
    async update() {
      let { width: l, height: c, "object-fit": d } = this.confAttr;
      l = this.px(l), c = this.px(c);
      const { width: f, height: p } = this.material.info;
      if (this.material.info.keepRatioWhenResize) {
        (!l || !c) && (l ? c = l * (p / f) : c && (l = c * (f / p)));
        const m = (["fill", "contain"].includes(d) ? Math.min : Math.max)(l / f, c / p);
        [l, c] = [Math.round(f * m), Math.round(p * m)];
      }
      await this.material.update({ ...this.conf, width: l, height: c }), this.creator().refresh();
    }
    getParam(l) {
      return l.startsWith("conf.") ? (l = l.substring(5), this.conf[l]) : super.getParam(l);
    }
    async setParam(l, c) {
      return l.startsWith("conf.") && (l = l.substring(5), this.conf[l] = c), super.setParam(l, c);
    }
    materialTime(l, c = true) {
      return super.materialTime(l, c);
    }
    async getFrameByTime(l) {
      const { width: c, height: d } = this.material.canvas, f = a(c, d);
      return await this.material.queuedGetFrameByTime(l, 0, f), f;
    }
    toJson(l = false) {
      const c = super.toJson(l);
      return c.type = this.conf._type, delete c.mixin, c;
    }
  }
  return mixin = s, mixin;
}
var video, hasRequiredVideo;
function requireVideo() {
  if (hasRequiredVideo) return video;
  hasRequiredVideo = 1;
  const i2 = requireGif(), e = requireAudio(), t = requireVideo$1(), r = requireLogger(), { isBrowser: a } = requireLib$5(), s = requireAudio$1();
  class u extends i2 {
    constructor(c) {
      super({ type: "video", loop: false, audio: true, ...c }), this.useCache = false;
    }
    /**
     * Create Material, called by super.constructor
     * @return {Material} material
     * @protected
     */
    createMaterial(c) {
      const d = new t(c);
      return this.muted && d.setAudio(false), d;
    }
    mute(c) {
      this.material && this.material.setAudio(this.confAttr.audio && !c);
    }
    resetMute() {
      this.material && this.material.setAudio(this.confAttr.audio);
    }
    set audio(c) {
      this.conf.audio = !!c, this.resetMute();
    }
    get audio() {
      return !!this.confAttr.audio;
    }
    get volume() {
      return isNaN(this.confAttr.volume) ? 1 : Math.max(Number(this.confAttr.volume), 0);
    }
    set volume(c) {
      this.conf.volume = c, this.material && this.material.setVolume(this.volume);
    }
    grantPlay() {
      return this.material.grantPlay();
    }
    async getFrameByTime(c) {
      return await this.material.queuedSeekTo(c, "preview");
    }
    getAudioFrame(c, d = 1024) {
      var f;
      return (f = this.material) != null && f.useAudio ? super.getAudioFrame(c, d) : null;
    }
    async prepareMaterial() {
      var c, d;
      if (a)
        (c = this.confAttr) != null && c.audioUrl && (this.audioBuffer = await s.getBuffer((d = this.confAttr) == null ? void 0 : d.audioUrl, this.creator().uuid, this.creator().getConf("audioSampleRate")));
      else {
        const { start: f, end: p } = this.creator().outputTime;
        if (!this.active || this.absStartTime > p || this.absEndTime < f) {
          this.disable(), console.log(`ignore prepareMaterial ${this.id} [${this.absStartTime}, ${this.absEndTime}]`);
          return;
        }
        const m = this.rootConf("detailedCacheDir");
        if (await this.material.extract(m, !this.creator().audioOnly), this.material.useAudio && this.material.hasAudio) {
          const y = new e({
            id: `${this.id}_audio`,
            path: this.material.apath,
            loop: this.loop,
            speed: this.speed,
            volume: this.volume,
            duration: this.duration
            // ss: this.confAttr.ss,
            // to: this.confAttr.to,
          });
          this.addChild(y), await y.preProcessing(), y.annotate(), r.info({
            pos: "Video",
            msg: `Add audio track ${y.id.padEnd(10, " ")}: time:[${y.absStartTime.toFixed(2).padStart(6, " ")}, ${y.absEndTime.toFixed(2).padStart(6, " ")})  `
          });
        }
      }
      await super.prepareMaterial();
    }
    async drawing(c, d) {
      const f = this.creator();
      if (f.audioOnly) return;
      f.burning && (d = 0);
      let p = await super.drawing(c, d);
      const m = c / 1e3;
      if (p && d > 0)
        this.mute(f.burning || m < this.absStartTime || m > this.absEndTime);
      else {
        const y = m - this.absDrawStartTime;
        if (-2 < y && y < 0) {
          const { time: x, loops: g } = this.materialTime(this.absDrawStartTime);
          this.material.perpare(x + y, d > 0);
        } else
          this.material.pause();
        !a && m > this.absDrawEndTime && this.material.destroy();
      }
    }
    canFastRender(c = []) {
      var d, f, p, m, y, x;
      if (this.absStartTime === 0 || // todo: 第一段视频不走快速烧制，避免留下封面黑屏
      !this.active || this.rootConf("fast") === false || this.rotate !== 0 || /*this.animations.animations.length > 0 || */
      (d = this.display) != null && d.mask || (f = this.display) != null && f.hasFilters() || (p = this.display) != null && p.blendMode) return false;
      const g = this.parents.find((T) => T.type === "scene");
      if (g && ((m = g.display) != null && m.mask || (y = g.display) != null && y.hasFilters() || (x = g.display) != null && x.blendMode)) return false;
      const _ = 1 / this.rootConf("fps");
      return this.creator().allNodes.filter((T) => {
        var E, b;
        if (T === this || c.includes(T)) return false;
        if (T.type === "trans" && (T.prevSibling === this || T.nextSibling === this)) return true;
        if (["scene"].includes(T.type) || !T.display || T.zIndex > this.zIndex && !((E = T.display) != null && E.blendMode) && T.type !== "cover") return false;
        const C = Math.max(T.absStartTime, this.absStartTime);
        if (Math.min(T.absEndTime, this.absEndTime) - C < _) return false;
        if (T.type === "video") {
          const w = [...c, this];
          return (T.zIndex < this.zIndex || ((b = T.display) == null ? void 0 : b.blendMode)) && !T.canFastRender(w);
        }
        return true;
      }).length <= 0;
    }
    addInput(c) {
      c.addInput(this.material.path);
      let d = ["-an"];
      const f = this.material.getSliceOpts(!this.loop);
      f && (d = d.concat(f)), c.addInputOptions(d);
    }
    toFilters({ input: c, output: d, background: f }) {
      const p = this.rootConf("fps"), { start: m, end: y } = this.creator().outputTime, x = this.absStartTime - m, g = this.absEndTime - m, _ = [];
      let T = "", [E, b] = this.getWH(), [C, w] = this.getXY();
      const { x: A, y: S } = this.getAnchor();
      C -= A * E, w -= S * b;
      const { x: F, y: M, width: U, height: B } = this.display.texture.frame, { width: q, height: z } = this.display, [D, X] = this.getObjectPosition();
      C += Math.max(0, E - q) * D, w += Math.max(0, b - z) * X;
      const k = this.confAttr["object-fit"];
      if (["contain", "scale-down"].includes(k) && (E = q, b = z), T += `crop=w=${U.toFixed(1)}:h=${B.toFixed(1)}:x=${F.toFixed(1)}:y=${M.toFixed(1)},`, this.loop) {
        let V = this.material.getEndOffset(true) - this.material.getStartOffset();
        T += `loop=-1:size=${(V * p).toFixed(0)},`;
      }
      let I;
      this.opacity < 1 && (I || (T += I = "format=bgra,"), T += `colorchannelmixer=aa=${this.opacity.toFixed(2)},`), x != 0 ? T += `setpts=${(1 / this.speed).toFixed(3)}*PTS-STARTPTS${x > 0 ? "+" : "-"}${Math.abs(x).toFixed(3)}/TB,` : this.speed !== 1 && (T += `setpts=${(1 / this.speed).toFixed(3)}*PTS,`);
      let P = `tmp1_${d}`;
      _.push(`[${c}]${T}scale=${E.toFixed(1)}:${b.toFixed(1)}[${P}]`);
      const G = `overlay=${C.toFixed(1)}:${w.toFixed(1)}`, W = `:enable='between(t,${Math.max(x, 0).toFixed(3)},${g.toFixed(3)})'`;
      return _.push(`[${f}][${P}]${G}${W}[${d}]`), this.disable(), _;
    }
  }
  return video = u, video;
}
var scene, hasRequiredScene;
function requireScene() {
  if (hasRequiredScene) return scene;
  hasRequiredScene = 1;
  const i2 = requireCons();
  requireUtils();
  const e = requireCanvas(), { createCanvas: t, Sprite: r, Texture: a } = requireLib$2();
  class s extends i2 {
    constructor(l = {}) {
      super({ type: "scene", ...l }), this.background = null, this.defaultDuration = NaN, this.setBgColor(l.color || l.bgcolor || l.background);
    }
    annotate() {
      let l = Math.max(...this.allNodes.filter((c) => !c.isVirtual && !c.flexibleDuration).map((c) => c.realAbsEndTime));
      l || (l = Math.max(...this.allNodes.filter((c) => !c.isVirtual).map((c) => c.realAbsEndTime))), this.defaultDuration = l - this.absStartTime, super.annotate(), this.resizeBackground();
    }
    get default() {
      return {
        startTime: super.default.startTime,
        duration: this.defaultDuration
      };
    }
    /**
     * Set the time the scene stays in the scree
     * @param {number} duration - the time the scene
     * @public
     */
    setDuration(l) {
      this.conf.duration = l;
    }
    /**
     * Set background color
     * @param {string} bgcolor - background color
     * @public
     */
    setBgColor(l = "#00000000") {
      if (!this.bgCanvas) {
        const { bgSize: c = 400 } = this.conf;
        this.bgCanvas = t(c, c);
      }
      e.fillRect({ canvas: this.bgCanvas, color: l }), this.bgColor = l, this.background && this.display.removeChild(this.background), this.background = new r(a.fromCanvas(this.bgCanvas)), this.display.addChildAt(this.background, 0);
    }
    /**
     * Fast approximate anti-aliasing (FXAA) is a screen-space anti-aliasing algorithm
     * @param {boolean} fxaa anti-aliasing (FXAA)
     * @public
     */
    setFXAA(l) {
      this.display.fxaa = l;
    }
    /**
     * Reset the size of the backgroud image
     * @private
     */
    resizeBackground() {
      const { background: l } = this;
      if (!l) return;
      const c = this.rootConf("width"), d = this.rootConf("height");
      l.width = c, l.height = d;
    }
    destroy() {
      this.background && this.background.destroy(true), this.background = null, this.bgCanvas = null, super.destroy();
    }
  }
  return scene = s, scene;
}
var extras, hasRequiredExtras;
function requireExtras() {
  if (hasRequiredExtras) return extras;
  hasRequiredExtras = 1;
  const i2 = requireLib$2(), e = requireNode();
  class t extends e {
    constructor(a = { animations: [] }) {
      super({ type: "extras", ...a });
    }
    /**
     * Create display object.
     * @private
     */
    createDisplay() {
      this.display = new i2.Container(), this.container = this.display;
    }
    /**
     * Start rendering
     * @private
     */
    start() {
      super.start(), this.drawing = this.drawing.bind(this), TimelineUpdate.addFrameCallback(this.drawing), this.init && this.init(i2), this.emit("init");
    }
    drawing(a, s) {
      this.update && this.update(i2, a, s), this.emit("update");
    }
    destroyContainer() {
      try {
        this.container.destroy(), this.container.removeAllChildren();
      } catch {
      }
    }
    destroy() {
      super.destroy(), this.destroyContainer(), TimelineUpdate.removeFrameCallback(this.drawing), this.destroyed && this.destroyed(i2), this.emit("destroy"), this.update = null, this.drawing = null, this.container = null;
    }
  }
  return extras = t, extras;
}
var lib$1 = {}, dom = {}, conventions = {}, hasRequiredConventions;
function requireConventions() {
  if (hasRequiredConventions) return conventions;
  hasRequiredConventions = 1;
  function i2(s, u, l) {
    if (l === void 0 && (l = Array.prototype), s && typeof l.find == "function")
      return l.find.call(s, u);
    for (var c = 0; c < s.length; c++)
      if (Object.prototype.hasOwnProperty.call(s, c)) {
        var d = s[c];
        if (u.call(void 0, d, c, s))
          return d;
      }
  }
  function e(s, u) {
    return u === void 0 && (u = Object), u && typeof u.freeze == "function" ? u.freeze(s) : s;
  }
  function t(s, u) {
    if (s === null || typeof s != "object")
      throw new TypeError("target is not an object");
    for (var l in u)
      Object.prototype.hasOwnProperty.call(u, l) && (s[l] = u[l]);
    return s;
  }
  var r = e({
    /**
     * `text/html`, the only mime type that triggers treating an XML document as HTML.
     *
     * @see DOMParser.SupportedType.isHTML
     * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration
     * @see https://en.wikipedia.org/wiki/HTML Wikipedia
     * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN
     * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring WHATWG HTML Spec
     */
    HTML: "text/html",
    /**
     * Helper method to check a mime type if it indicates an HTML document
     *
     * @param {string} [value]
     * @returns {boolean}
     *
     * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration
     * @see https://en.wikipedia.org/wiki/HTML Wikipedia
     * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN
     * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring 	 */
    isHTML: function(s) {
      return s === r.HTML;
    },
    /**
     * `application/xml`, the standard mime type for XML documents.
     *
     * @see https://www.iana.org/assignments/media-types/application/xml IANA MimeType registration
     * @see https://tools.ietf.org/html/rfc7303#section-9.1 RFC 7303
     * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia
     */
    XML_APPLICATION: "application/xml",
    /**
     * `text/html`, an alias for `application/xml`.
     *
     * @see https://tools.ietf.org/html/rfc7303#section-9.2 RFC 7303
     * @see https://www.iana.org/assignments/media-types/text/xml IANA MimeType registration
     * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia
     */
    XML_TEXT: "text/xml",
    /**
     * `application/xhtml+xml`, indicates an XML document that has the default HTML namespace,
     * but is parsed as an XML document.
     *
     * @see https://www.iana.org/assignments/media-types/application/xhtml+xml IANA MimeType registration
     * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument WHATWG DOM Spec
     * @see https://en.wikipedia.org/wiki/XHTML Wikipedia
     */
    XML_XHTML_APPLICATION: "application/xhtml+xml",
    /**
     * `image/svg+xml`,
     *
     * @see https://www.iana.org/assignments/media-types/image/svg+xml IANA MimeType registration
     * @see https://www.w3.org/TR/SVG11/ W3C SVG 1.1
     * @see https://en.wikipedia.org/wiki/Scalable_Vector_Graphics Wikipedia
     */
    XML_SVG_IMAGE: "image/svg+xml"
  }), a = e({
    /**
     * The XHTML namespace.
     *
     * @see http://www.w3.org/1999/xhtml
     */
    HTML: "http://www.w3.org/1999/xhtml",
    /**
     * Checks if `uri` equals `NAMESPACE.HTML`.
     *
     * @param {string} [uri]
     *
     * @see NAMESPACE.HTML
     */
    isHTML: function(s) {
      return s === a.HTML;
    },
    /**
     * The SVG namespace.
     *
     * @see http://www.w3.org/2000/svg
     */
    SVG: "http://www.w3.org/2000/svg",
    /**
     * The `xml:` namespace.
     *
     * @see http://www.w3.org/XML/1998/namespace
     */
    XML: "http://www.w3.org/XML/1998/namespace",
    /**
     * The `xmlns:` namespace
     *
     * @see https://www.w3.org/2000/xmlns/
     */
    XMLNS: "http://www.w3.org/2000/xmlns/"
  });
  return conventions.assign = t, conventions.find = i2, conventions.freeze = e, conventions.MIME_TYPE = r, conventions.NAMESPACE = a, conventions;
}
var hasRequiredDom;
function requireDom() {
  if (hasRequiredDom) return dom;
  hasRequiredDom = 1;
  var i2 = requireConventions(), e = i2.find, t = i2.NAMESPACE;
  function r(te) {
    return te !== "";
  }
  function a(te) {
    return te ? te.split(/[\t\n\f\r ]+/).filter(r) : [];
  }
  function s(te, ne) {
    return te.hasOwnProperty(ne) || (te[ne] = true), te;
  }
  function u(te) {
    if (!te) return [];
    var ne = a(te);
    return Object.keys(ne.reduce(s, {}));
  }
  function l(te) {
    return function(ne) {
      return te && te.indexOf(ne) !== -1;
    };
  }
  function c(te, ne) {
    for (var fe in te)
      Object.prototype.hasOwnProperty.call(te, fe) && (ne[fe] = te[fe]);
  }
  function d(te, ne) {
    var fe = te.prototype;
    if (!(fe instanceof ne)) {
      let qe = function() {
      };
      qe.prototype = ne.prototype, qe = new qe(), c(fe, qe), te.prototype = fe = qe;
    }
    fe.constructor != te && (typeof te != "function" && console.error("unknown Class:" + te), fe.constructor = te);
  }
  var f = {}, p = f.ELEMENT_NODE = 1, m = f.ATTRIBUTE_NODE = 2, y = f.TEXT_NODE = 3, x = f.CDATA_SECTION_NODE = 4, g = f.ENTITY_REFERENCE_NODE = 5, _ = f.ENTITY_NODE = 6, T = f.PROCESSING_INSTRUCTION_NODE = 7, E = f.COMMENT_NODE = 8, b = f.DOCUMENT_NODE = 9, C = f.DOCUMENT_TYPE_NODE = 10, w = f.DOCUMENT_FRAGMENT_NODE = 11, A = f.NOTATION_NODE = 12, S = {}, F = {};
  S.INDEX_SIZE_ERR = (F[1] = "Index size error", 1), S.DOMSTRING_SIZE_ERR = (F[2] = "DOMString size error", 2);
  var M = S.HIERARCHY_REQUEST_ERR = (F[3] = "Hierarchy request error", 3);
  S.WRONG_DOCUMENT_ERR = (F[4] = "Wrong document", 4), S.INVALID_CHARACTER_ERR = (F[5] = "Invalid character", 5), S.NO_DATA_ALLOWED_ERR = (F[6] = "No data allowed", 6), S.NO_MODIFICATION_ALLOWED_ERR = (F[7] = "No modification allowed", 7);
  var U = S.NOT_FOUND_ERR = (F[8] = "Not found", 8);
  S.NOT_SUPPORTED_ERR = (F[9] = "Not supported", 9);
  var B = S.INUSE_ATTRIBUTE_ERR = (F[10] = "Attribute in use", 10);
  S.INVALID_STATE_ERR = (F[11] = "Invalid state", 11), S.SYNTAX_ERR = (F[12] = "Syntax error", 12), S.INVALID_MODIFICATION_ERR = (F[13] = "Invalid modification", 13), S.NAMESPACE_ERR = (F[14] = "Invalid namespace", 14), S.INVALID_ACCESS_ERR = (F[15] = "Invalid access", 15);
  function q(te, ne) {
    if (ne instanceof Error)
      var fe = ne;
    else
      fe = this, Error.call(this, F[te]), this.message = F[te], Error.captureStackTrace && Error.captureStackTrace(this, q);
    return fe.code = te, ne && (this.message = this.message + ": " + ne), fe;
  }
  q.prototype = Error.prototype, c(S, q);
  function z() {
  }
  z.prototype = {
    /**
     * The number of nodes in the list. The range of valid child node indices is 0 to length-1 inclusive.
     * @standard level1
     */
    length: 0,
    /**
     * Returns the indexth item in the collection. If index is greater than or equal to the number of nodes in the list, this returns null.
     * @standard level1
     * @param index  unsigned long
     *   Index into the collection.
     * @return Node
     * 	The node at the indexth position in the NodeList, or null if that is not a valid index.
     */
    item: function(te) {
      return te >= 0 && te < this.length ? this[te] : null;
    },
    toString: function(te, ne) {
      for (var fe = [], qe = 0; qe < this.length; qe++)
        Ue(this[qe], fe, te, ne);
      return fe.join("");
    },
    /**
     * @private
     * @param {function (Node):boolean} predicate
     * @returns {Node[]}
     */
    filter: function(te) {
      return Array.prototype.filter.call(this, te);
    },
    /**
     * @private
     * @param {Node} item
     * @returns {number}
     */
    indexOf: function(te) {
      return Array.prototype.indexOf.call(this, te);
    }
  };
  function D(te, ne) {
    this._node = te, this._refresh = ne, X(this);
  }
  function X(te) {
    var ne = te._node._inc || te._node.ownerDocument._inc;
    if (te._inc !== ne) {
      var fe = te._refresh(te._node);
      if (We(te, "length", fe.length), !te.$$length || fe.length < te.$$length)
        for (var qe = fe.length; qe in te; qe++)
          Object.prototype.hasOwnProperty.call(te, qe) && delete te[qe];
      c(fe, te), te._inc = ne;
    }
  }
  D.prototype.item = function(te) {
    return X(this), this[te] || null;
  }, d(D, z);
  function k() {
  }
  function I(te, ne) {
    for (var fe = te.length; fe--; )
      if (te[fe] === ne)
        return fe;
  }
  function P(te, ne, fe, qe) {
    if (qe ? ne[I(ne, qe)] = fe : ne[ne.length++] = fe, te) {
      fe.ownerElement = te;
      var Je = te.ownerDocument;
      Je && (qe && he(Je, te, qe), re(Je, te, fe));
    }
  }
  function G(te, ne, fe) {
    var qe = I(ne, fe);
    if (qe >= 0) {
      for (var Je = ne.length - 1; qe < Je; )
        ne[qe] = ne[++qe];
      if (ne.length = Je, te) {
        var ht = te.ownerDocument;
        ht && (he(ht, te, fe), fe.ownerElement = null);
      }
    } else
      throw new q(U, new Error(te.tagName + "@" + fe));
  }
  k.prototype = {
    length: 0,
    item: z.prototype.item,
    getNamedItem: function(te) {
      for (var ne = this.length; ne--; ) {
        var fe = this[ne];
        if (fe.nodeName == te)
          return fe;
      }
    },
    setNamedItem: function(te) {
      var ne = te.ownerElement;
      if (ne && ne != this._ownerElement)
        throw new q(B);
      var fe = this.getNamedItem(te.nodeName);
      return P(this._ownerElement, this, te, fe), fe;
    },
    /* returns Node */
    setNamedItemNS: function(te) {
      var ne = te.ownerElement, fe;
      if (ne && ne != this._ownerElement)
        throw new q(B);
      return fe = this.getNamedItemNS(te.namespaceURI, te.localName), P(this._ownerElement, this, te, fe), fe;
    },
    /* returns Node */
    removeNamedItem: function(te) {
      var ne = this.getNamedItem(te);
      return G(this._ownerElement, this, ne), ne;
    },
    // raises: NOT_FOUND_ERR,NO_MODIFICATION_ALLOWED_ERR
    //for level2
    removeNamedItemNS: function(te, ne) {
      var fe = this.getNamedItemNS(te, ne);
      return G(this._ownerElement, this, fe), fe;
    },
    getNamedItemNS: function(te, ne) {
      for (var fe = this.length; fe--; ) {
        var qe = this[fe];
        if (qe.localName == ne && qe.namespaceURI == te)
          return qe;
      }
      return null;
    }
  };
  function W() {
  }
  W.prototype = {
    /**
     * The DOMImplementation.hasFeature() method returns a Boolean flag indicating if a given feature is supported.
     * The different implementations fairly diverged in what kind of features were reported.
     * The latest version of the spec settled to force this method to always return true, where the functionality was accurate and in use.
     *
     * @deprecated It is deprecated and modern browsers return true in all cases.
     *
     * @param {string} feature
     * @param {string} [version]
     * @returns {boolean} always true
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/hasFeature MDN
     * @see https://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-5CED94D7 DOM Level 1 Core
     * @see https://dom.spec.whatwg.org/#dom-domimplementation-hasfeature DOM Living Standard
     */
    hasFeature: function(te, ne) {
      return true;
    },
    /**
     * Creates an XML Document object of the specified type with its document element.
     *
     * __It behaves slightly different from the description in the living standard__:
     * - There is no interface/class `XMLDocument`, it returns a `Document` instance.
     * - `contentType`, `encoding`, `mode`, `origin`, `url` fields are currently not declared.
     * - this implementation is not validating names or qualified names
     *   (when parsing XML strings, the SAX parser takes care of that)
     *
     * @param {string|null} namespaceURI
     * @param {string} qualifiedName
     * @param {DocumentType=null} doctype
     * @returns {Document}
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocument MDN
     * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocument DOM Level 2 Core (initial)
     * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument  DOM Level 2 Core
     *
     * @see https://dom.spec.whatwg.org/#validate-and-extract DOM: Validate and extract
     * @see https://www.w3.org/TR/xml/#NT-NameStartChar XML Spec: Names
     * @see https://www.w3.org/TR/xml-names/#ns-qualnames XML Namespaces: Qualified names
     */
    createDocument: function(te, ne, fe) {
      var qe = new ae();
      if (qe.implementation = this, qe.childNodes = new z(), qe.doctype = fe || null, fe && qe.appendChild(fe), ne) {
        var Je = qe.createElementNS(te, ne);
        qe.appendChild(Je);
      }
      return qe;
    },
    /**
     * Returns a doctype, with the given `qualifiedName`, `publicId`, and `systemId`.
     *
     * __This behavior is slightly different from the in the specs__:
     * - this implementation is not validating names or qualified names
     *   (when parsing XML strings, the SAX parser takes care of that)
     *
     * @param {string} qualifiedName
     * @param {string} [publicId]
     * @param {string} [systemId]
     * @returns {DocumentType} which can either be used with `DOMImplementation.createDocument` upon document creation
     * 				  or can be put into the document via methods like `Node.insertBefore()` or `Node.replaceChild()`
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocumentType MDN
     * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocType DOM Level 2 Core
     * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocumenttype DOM Living Standard
     *
     * @see https://dom.spec.whatwg.org/#validate-and-extract DOM: Validate and extract
     * @see https://www.w3.org/TR/xml/#NT-NameStartChar XML Spec: Names
     * @see https://www.w3.org/TR/xml-names/#ns-qualnames XML Namespaces: Qualified names
     */
    createDocumentType: function(te, ne, fe) {
      var qe = new $();
      return qe.name = te, qe.nodeName = te, qe.publicId = ne || "", qe.systemId = fe || "", qe;
    }
  };
  function V() {
  }
  V.prototype = {
    firstChild: null,
    lastChild: null,
    previousSibling: null,
    nextSibling: null,
    attributes: null,
    parentNode: null,
    childNodes: null,
    ownerDocument: null,
    nodeValue: null,
    namespaceURI: null,
    prefix: null,
    localName: null,
    // Modified in DOM Level 2:
    insertBefore: function(te, ne) {
      return xt(this, te, ne);
    },
    replaceChild: function(te, ne) {
      xt(this, te, ne, gt), ne && this.removeChild(ne);
    },
    removeChild: function(te) {
      return me(this, te);
    },
    appendChild: function(te) {
      return this.insertBefore(te, null);
    },
    hasChildNodes: function() {
      return this.firstChild != null;
    },
    cloneNode: function(te) {
      return lt(this.ownerDocument || this, this, te);
    },
    // Modified in DOM Level 2:
    normalize: function() {
      for (var te = this.firstChild; te; ) {
        var ne = te.nextSibling;
        ne && ne.nodeType == y && te.nodeType == y ? (this.removeChild(ne), te.appendData(ne.data)) : (te.normalize(), te = ne);
      }
    },
    // Introduced in DOM Level 2:
    isSupported: function(te, ne) {
      return this.ownerDocument.implementation.hasFeature(te, ne);
    },
    // Introduced in DOM Level 2:
    hasAttributes: function() {
      return this.attributes.length > 0;
    },
    /**
     * Look up the prefix associated to the given namespace URI, starting from this node.
     * **The default namespace declarations are ignored by this method.**
     * See Namespace Prefix Lookup for details on the algorithm used by this method.
     *
     * _Note: The implementation seems to be incomplete when compared to the algorithm described in the specs._
     *
     * @param {string | null} namespaceURI
     * @returns {string | null}
     * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-lookupNamespacePrefix
     * @see https://www.w3.org/TR/DOM-Level-3-Core/namespaces-algorithms.html#lookupNamespacePrefixAlgo
     * @see https://dom.spec.whatwg.org/#dom-node-lookupprefix
     * @see https://github.com/xmldom/xmldom/issues/322
     */
    lookupPrefix: function(te) {
      for (var ne = this; ne; ) {
        var fe = ne._nsMap;
        if (fe) {
          for (var qe in fe)
            if (Object.prototype.hasOwnProperty.call(fe, qe) && fe[qe] === te)
              return qe;
        }
        ne = ne.nodeType == m ? ne.ownerDocument : ne.parentNode;
      }
      return null;
    },
    // Introduced in DOM Level 3:
    lookupNamespaceURI: function(te) {
      for (var ne = this; ne; ) {
        var fe = ne._nsMap;
        if (fe && Object.prototype.hasOwnProperty.call(fe, te))
          return fe[te];
        ne = ne.nodeType == m ? ne.ownerDocument : ne.parentNode;
      }
      return null;
    },
    // Introduced in DOM Level 3:
    isDefaultNamespace: function(te) {
      var ne = this.lookupPrefix(te);
      return ne == null;
    }
  };
  function K(te) {
    return te == "<" && "&lt;" || te == ">" && "&gt;" || te == "&" && "&amp;" || te == '"' && "&quot;" || "&#" + te.charCodeAt() + ";";
  }
  c(f, V), c(f, V.prototype);
  function J(te, ne) {
    if (ne(te))
      return true;
    if (te = te.firstChild)
      do
        if (J(te, ne))
          return true;
      while (te = te.nextSibling);
  }
  function ae() {
    this.ownerDocument = this;
  }
  function re(te, ne, fe) {
    te && te._inc++;
    var qe = fe.namespaceURI;
    qe === t.XMLNS && (ne._nsMap[fe.prefix ? fe.localName : ""] = fe.value);
  }
  function he(te, ne, fe, qe) {
    te && te._inc++;
    var Je = fe.namespaceURI;
    Je === t.XMLNS && delete ne._nsMap[fe.prefix ? fe.localName : ""];
  }
  function ge(te, ne, fe) {
    if (te && te._inc) {
      te._inc++;
      var qe = ne.childNodes;
      if (fe)
        qe[qe.length++] = fe;
      else {
        for (var Je = ne.firstChild, ht = 0; Je; )
          qe[ht++] = Je, Je = Je.nextSibling;
        qe.length = ht, delete qe[qe.length];
      }
    }
  }
  function me(te, ne) {
    var fe = ne.previousSibling, qe = ne.nextSibling;
    return fe ? fe.nextSibling = qe : te.firstChild = qe, qe ? qe.previousSibling = fe : te.lastChild = fe, ne.parentNode = null, ne.previousSibling = null, ne.nextSibling = null, ge(te.ownerDocument, te), ne;
  }
  function Te(te) {
    return te && (te.nodeType === V.DOCUMENT_NODE || te.nodeType === V.DOCUMENT_FRAGMENT_NODE || te.nodeType === V.ELEMENT_NODE);
  }
  function _e(te) {
    return te && (Ae(te) || ke(te) || ye(te) || te.nodeType === V.DOCUMENT_FRAGMENT_NODE || te.nodeType === V.COMMENT_NODE || te.nodeType === V.PROCESSING_INSTRUCTION_NODE);
  }
  function ye(te) {
    return te && te.nodeType === V.DOCUMENT_TYPE_NODE;
  }
  function Ae(te) {
    return te && te.nodeType === V.ELEMENT_NODE;
  }
  function ke(te) {
    return te && te.nodeType === V.TEXT_NODE;
  }
  function Pe(te, ne) {
    var fe = te.childNodes || [];
    if (e(fe, Ae) || ye(ne))
      return false;
    var qe = e(fe, ye);
    return !(ne && qe && fe.indexOf(qe) > fe.indexOf(ne));
  }
  function Ee(te, ne) {
    var fe = te.childNodes || [];
    function qe(ht) {
      return Ae(ht) && ht !== ne;
    }
    if (e(fe, qe))
      return false;
    var Je = e(fe, ye);
    return !(ne && Je && fe.indexOf(Je) > fe.indexOf(ne));
  }
  function Oe(te, ne, fe) {
    if (!Te(te))
      throw new q(M, "Unexpected parent node type " + te.nodeType);
    if (fe && fe.parentNode !== te)
      throw new q(U, "child not in parent");
    if (
      // 4. If `node` is not a DocumentFragment, DocumentType, Element, or CharacterData node, then throw a "HierarchyRequestError" DOMException.
      !_e(ne) || // 5. If either `node` is a Text node and `parent` is a document,
      // the sax parser currently adds top level text nodes, this will be fixed in 0.9.0
      // || (node.nodeType === Node.TEXT_NODE && parent.nodeType === Node.DOCUMENT_NODE)
      // or `node` is a doctype and `parent` is not a document, then throw a "HierarchyRequestError" DOMException.
      ye(ne) && te.nodeType !== V.DOCUMENT_NODE
    )
      throw new q(
        M,
        "Unexpected node type " + ne.nodeType + " for parent node type " + te.nodeType
      );
  }
  function $e(te, ne, fe) {
    var qe = te.childNodes || [], Je = ne.childNodes || [];
    if (ne.nodeType === V.DOCUMENT_FRAGMENT_NODE) {
      var ht = Je.filter(Ae);
      if (ht.length > 1 || e(Je, ke))
        throw new q(M, "More than one element or text in fragment");
      if (ht.length === 1 && !Pe(te, fe))
        throw new q(M, "Element in fragment can not be inserted before doctype");
    }
    if (Ae(ne) && !Pe(te, fe))
      throw new q(M, "Only one element can be added and only after doctype");
    if (ye(ne)) {
      if (e(qe, ye))
        throw new q(M, "Only one doctype is allowed");
      var bt = e(qe, Ae);
      if (fe && qe.indexOf(bt) < qe.indexOf(fe))
        throw new q(M, "Doctype can only be inserted before an element");
      if (!fe && bt)
        throw new q(M, "Doctype can not be appended since element is present");
    }
  }
  function gt(te, ne, fe) {
    var qe = te.childNodes || [], Je = ne.childNodes || [];
    if (ne.nodeType === V.DOCUMENT_FRAGMENT_NODE) {
      var ht = Je.filter(Ae);
      if (ht.length > 1 || e(Je, ke))
        throw new q(M, "More than one element or text in fragment");
      if (ht.length === 1 && !Ee(te, fe))
        throw new q(M, "Element in fragment can not be inserted before doctype");
    }
    if (Ae(ne) && !Ee(te, fe))
      throw new q(M, "Only one element can be added and only after doctype");
    if (ye(ne)) {
      if (e(qe, function(kt) {
        return ye(kt) && kt !== fe;
      }))
        throw new q(M, "Only one doctype is allowed");
      var bt = e(qe, Ae);
      if (fe && qe.indexOf(bt) < qe.indexOf(fe))
        throw new q(M, "Doctype can only be inserted before an element");
    }
  }
  function xt(te, ne, fe, qe) {
    Oe(te, ne, fe), te.nodeType === V.DOCUMENT_NODE && (qe || $e)(te, ne, fe);
    var Je = ne.parentNode;
    if (Je && Je.removeChild(ne), ne.nodeType === w) {
      var ht = ne.firstChild;
      if (ht == null)
        return ne;
      var bt = ne.lastChild;
    } else
      ht = bt = ne;
    var kt = fe ? fe.previousSibling : te.lastChild;
    ht.previousSibling = kt, bt.nextSibling = fe, kt ? kt.nextSibling = ht : te.firstChild = ht, fe == null ? te.lastChild = bt : fe.previousSibling = bt;
    do
      ht.parentNode = te;
    while (ht !== bt && (ht = ht.nextSibling));
    return ge(te.ownerDocument || te, te), ne.nodeType == w && (ne.firstChild = ne.lastChild = null), ne;
  }
  function vt(te, ne) {
    return ne.parentNode && ne.parentNode.removeChild(ne), ne.parentNode = te, ne.previousSibling = te.lastChild, ne.nextSibling = null, ne.previousSibling ? ne.previousSibling.nextSibling = ne : te.firstChild = ne, te.lastChild = ne, ge(te.ownerDocument, te, ne), ne;
  }
  ae.prototype = {
    //implementation : null,
    nodeName: "#document",
    nodeType: b,
    /**
     * The DocumentType node of the document.
     *
     * @readonly
     * @type DocumentType
     */
    doctype: null,
    documentElement: null,
    _inc: 1,
    insertBefore: function(te, ne) {
      if (te.nodeType == w) {
        for (var fe = te.firstChild; fe; ) {
          var qe = fe.nextSibling;
          this.insertBefore(fe, ne), fe = qe;
        }
        return te;
      }
      return xt(this, te, ne), te.ownerDocument = this, this.documentElement === null && te.nodeType === p && (this.documentElement = te), te;
    },
    removeChild: function(te) {
      return this.documentElement == te && (this.documentElement = null), me(this, te);
    },
    replaceChild: function(te, ne) {
      xt(this, te, ne, gt), te.ownerDocument = this, ne && this.removeChild(ne), Ae(te) && (this.documentElement = te);
    },
    // Introduced in DOM Level 2:
    importNode: function(te, ne) {
      return et(this, te, ne);
    },
    // Introduced in DOM Level 2:
    getElementById: function(te) {
      var ne = null;
      return J(this.documentElement, function(fe) {
        if (fe.nodeType == p && fe.getAttribute("id") == te)
          return ne = fe, true;
      }), ne;
    },
    /**
     * The `getElementsByClassName` method of `Document` interface returns an array-like object
     * of all child elements which have **all** of the given class name(s).
     *
     * Returns an empty list if `classeNames` is an empty string or only contains HTML white space characters.
     *
     *
     * Warning: This is a live LiveNodeList.
     * Changes in the DOM will reflect in the array as the changes occur.
     * If an element selected by this array no longer qualifies for the selector,
     * it will automatically be removed. Be aware of this for iteration purposes.
     *
     * @param {string} classNames is a string representing the class name(s) to match; multiple class names are separated by (ASCII-)whitespace
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementsByClassName
     * @see https://dom.spec.whatwg.org/#concept-getelementsbyclassname
     */
    getElementsByClassName: function(te) {
      var ne = u(te);
      return new D(this, function(fe) {
        var qe = [];
        return ne.length > 0 && J(fe.documentElement, function(Je) {
          if (Je !== fe && Je.nodeType === p) {
            var ht = Je.getAttribute("class");
            if (ht) {
              var bt = te === ht;
              if (!bt) {
                var kt = u(ht);
                bt = ne.every(l(kt));
              }
              bt && qe.push(Je);
            }
          }
        }), qe;
      });
    },
    //document factory method:
    createElement: function(te) {
      var ne = new Xe();
      ne.ownerDocument = this, ne.nodeName = te, ne.tagName = te, ne.localName = te, ne.childNodes = new z();
      var fe = ne.attributes = new k();
      return fe._ownerElement = ne, ne;
    },
    createDocumentFragment: function() {
      var te = new Se();
      return te.ownerDocument = this, te.childNodes = new z(), te;
    },
    createTextNode: function(te) {
      var ne = new Rt();
      return ne.ownerDocument = this, ne.appendData(te), ne;
    },
    createComment: function(te) {
      var ne = new It();
      return ne.ownerDocument = this, ne.appendData(te), ne;
    },
    createCDATASection: function(te) {
      var ne = new er();
      return ne.ownerDocument = this, ne.appendData(te), ne;
    },
    createProcessingInstruction: function(te, ne) {
      var fe = new Ne();
      return fe.ownerDocument = this, fe.tagName = fe.nodeName = fe.target = te, fe.nodeValue = fe.data = ne, fe;
    },
    createAttribute: function(te) {
      var ne = new at();
      return ne.ownerDocument = this, ne.name = te, ne.nodeName = te, ne.localName = te, ne.specified = true, ne;
    },
    createEntityReference: function(te) {
      var ne = new be();
      return ne.ownerDocument = this, ne.nodeName = te, ne;
    },
    // Introduced in DOM Level 2:
    createElementNS: function(te, ne) {
      var fe = new Xe(), qe = ne.split(":"), Je = fe.attributes = new k();
      return fe.childNodes = new z(), fe.ownerDocument = this, fe.nodeName = ne, fe.tagName = ne, fe.namespaceURI = te, qe.length == 2 ? (fe.prefix = qe[0], fe.localName = qe[1]) : fe.localName = ne, Je._ownerElement = fe, fe;
    },
    // Introduced in DOM Level 2:
    createAttributeNS: function(te, ne) {
      var fe = new at(), qe = ne.split(":");
      return fe.ownerDocument = this, fe.nodeName = ne, fe.name = ne, fe.namespaceURI = te, fe.specified = true, qe.length == 2 ? (fe.prefix = qe[0], fe.localName = qe[1]) : fe.localName = ne, fe;
    }
  }, d(ae, V);
  function Xe() {
    this._nsMap = {};
  }
  Xe.prototype = {
    nodeType: p,
    hasAttribute: function(te) {
      return this.getAttributeNode(te) != null;
    },
    getAttribute: function(te) {
      var ne = this.getAttributeNode(te);
      return ne && ne.value || "";
    },
    getAttributeNode: function(te) {
      return this.attributes.getNamedItem(te);
    },
    setAttribute: function(te, ne) {
      var fe = this.ownerDocument.createAttribute(te);
      fe.value = fe.nodeValue = "" + ne, this.setAttributeNode(fe);
    },
    removeAttribute: function(te) {
      var ne = this.getAttributeNode(te);
      ne && this.removeAttributeNode(ne);
    },
    //four real opeartion method
    appendChild: function(te) {
      return te.nodeType === w ? this.insertBefore(te, null) : vt(this, te);
    },
    setAttributeNode: function(te) {
      return this.attributes.setNamedItem(te);
    },
    setAttributeNodeNS: function(te) {
      return this.attributes.setNamedItemNS(te);
    },
    removeAttributeNode: function(te) {
      return this.attributes.removeNamedItem(te.nodeName);
    },
    //get real attribute name,and remove it by removeAttributeNode
    removeAttributeNS: function(te, ne) {
      var fe = this.getAttributeNodeNS(te, ne);
      fe && this.removeAttributeNode(fe);
    },
    hasAttributeNS: function(te, ne) {
      return this.getAttributeNodeNS(te, ne) != null;
    },
    getAttributeNS: function(te, ne) {
      var fe = this.getAttributeNodeNS(te, ne);
      return fe && fe.value || "";
    },
    setAttributeNS: function(te, ne, fe) {
      var qe = this.ownerDocument.createAttributeNS(te, ne);
      qe.value = qe.nodeValue = "" + fe, this.setAttributeNode(qe);
    },
    getAttributeNodeNS: function(te, ne) {
      return this.attributes.getNamedItemNS(te, ne);
    },
    getElementsByTagName: function(te) {
      return new D(this, function(ne) {
        var fe = [];
        return J(ne, function(qe) {
          qe !== ne && qe.nodeType == p && (te === "*" || qe.tagName == te) && fe.push(qe);
        }), fe;
      });
    },
    getElementsByTagNameNS: function(te, ne) {
      return new D(this, function(fe) {
        var qe = [];
        return J(fe, function(Je) {
          Je !== fe && Je.nodeType === p && (te === "*" || Je.namespaceURI === te) && (ne === "*" || Je.localName == ne) && qe.push(Je);
        }), qe;
      });
    }
  }, ae.prototype.getElementsByTagName = Xe.prototype.getElementsByTagName, ae.prototype.getElementsByTagNameNS = Xe.prototype.getElementsByTagNameNS, d(Xe, V);
  function at() {
  }
  at.prototype.nodeType = m, d(at, V);
  function ct() {
  }
  ct.prototype = {
    data: "",
    substringData: function(te, ne) {
      return this.data.substring(te, te + ne);
    },
    appendData: function(te) {
      te = this.data + te, this.nodeValue = this.data = te, this.length = te.length;
    },
    insertData: function(te, ne) {
      this.replaceData(te, 0, ne);
    },
    appendChild: function(te) {
      throw new Error(F[M]);
    },
    deleteData: function(te, ne) {
      this.replaceData(te, ne, "");
    },
    replaceData: function(te, ne, fe) {
      var qe = this.data.substring(0, te), Je = this.data.substring(te + ne);
      fe = qe + fe + Je, this.nodeValue = this.data = fe, this.length = fe.length;
    }
  }, d(ct, V);
  function Rt() {
  }
  Rt.prototype = {
    nodeName: "#text",
    nodeType: y,
    splitText: function(te) {
      var ne = this.data, fe = ne.substring(te);
      ne = ne.substring(0, te), this.data = this.nodeValue = ne, this.length = ne.length;
      var qe = this.ownerDocument.createTextNode(fe);
      return this.parentNode && this.parentNode.insertBefore(qe, this.nextSibling), qe;
    }
  }, d(Rt, ct);
  function It() {
  }
  It.prototype = {
    nodeName: "#comment",
    nodeType: E
  }, d(It, ct);
  function er() {
  }
  er.prototype = {
    nodeName: "#cdata-section",
    nodeType: x
  }, d(er, ct);
  function $() {
  }
  $.prototype.nodeType = C, d($, V);
  function Y() {
  }
  Y.prototype.nodeType = A, d(Y, V);
  function ee() {
  }
  ee.prototype.nodeType = _, d(ee, V);
  function be() {
  }
  be.prototype.nodeType = g, d(be, V);
  function Se() {
  }
  Se.prototype.nodeName = "#document-fragment", Se.prototype.nodeType = w, d(Se, V);
  function Ne() {
  }
  Ne.prototype.nodeType = T, d(Ne, V);
  function je() {
  }
  je.prototype.serializeToString = function(te, ne, fe) {
    return pt.call(te, ne, fe);
  }, V.prototype.toString = pt;
  function pt(te, ne) {
    var fe = [], qe = this.nodeType == 9 && this.documentElement || this, Je = qe.prefix, ht = qe.namespaceURI;
    if (ht && Je == null) {
      var Je = qe.lookupPrefix(ht);
      if (Je == null)
        var bt = [
          { namespace: ht, prefix: null }
          //{namespace:uri,prefix:''}
        ];
    }
    return Ue(this, fe, te, ne, bt), fe.join("");
  }
  function oe(te, ne, fe) {
    var qe = te.prefix || "", Je = te.namespaceURI;
    if (!Je || qe === "xml" && Je === t.XML || Je === t.XMLNS)
      return false;
    for (var ht = fe.length; ht--; ) {
      var bt = fe[ht];
      if (bt.prefix === qe)
        return bt.namespace !== Je;
    }
    return true;
  }
  function le(te, ne, fe) {
    te.push(" ", ne, '="', fe.replace(/[<>&"\t\n\r]/g, K), '"');
  }
  function Ue(te, ne, fe, qe, Je) {
    if (Je || (Je = []), qe)
      if (te = qe(te), te) {
        if (typeof te == "string") {
          ne.push(te);
          return;
        }
      } else
        return;
    switch (te.nodeType) {
      case p:
        var ht = te.attributes, bt = ht.length, kt = te.firstChild, Ar = te.tagName;
        fe = t.isHTML(te.namespaceURI) || fe;
        var Sr = Ar;
        if (!fe && !te.prefix && te.namespaceURI) {
          for (var Vt, jr = 0; jr < ht.length; jr++)
            if (ht.item(jr).name === "xmlns") {
              Vt = ht.item(jr).value;
              break;
            }
          if (!Vt)
            for (var tr = Je.length - 1; tr >= 0; tr--) {
              var _r = Je[tr];
              if (_r.prefix === "" && _r.namespace === te.namespaceURI) {
                Vt = _r.namespace;
                break;
              }
            }
          if (Vt !== te.namespaceURI)
            for (var tr = Je.length - 1; tr >= 0; tr--) {
              var _r = Je[tr];
              if (_r.namespace === te.namespaceURI) {
                _r.prefix && (Sr = _r.prefix + ":" + Ar);
                break;
              }
            }
        }
        ne.push("<", Sr);
        for (var wr = 0; wr < bt; wr++) {
          var xr = ht.item(wr);
          xr.prefix == "xmlns" ? Je.push({ prefix: xr.localName, namespace: xr.value }) : xr.nodeName == "xmlns" && Je.push({ prefix: "", namespace: xr.value });
        }
        for (var wr = 0; wr < bt; wr++) {
          var xr = ht.item(wr);
          if (oe(xr, fe, Je)) {
            var Mr = xr.prefix || "", Or = xr.namespaceURI;
            le(ne, Mr ? "xmlns:" + Mr : "xmlns", Or), Je.push({ prefix: Mr, namespace: Or });
          }
          Ue(xr, ne, fe, qe, Je);
        }
        if (Ar === Sr && oe(te, fe, Je)) {
          var Mr = te.prefix || "", Or = te.namespaceURI;
          le(ne, Mr ? "xmlns:" + Mr : "xmlns", Or), Je.push({ prefix: Mr, namespace: Or });
        }
        if (kt || fe && !/^(?:meta|link|img|br|hr|input)$/i.test(Ar)) {
          if (ne.push(">"), fe && /^script$/i.test(Ar))
            for (; kt; )
              kt.data ? ne.push(kt.data) : Ue(kt, ne, fe, qe, Je.slice()), kt = kt.nextSibling;
          else
            for (; kt; )
              Ue(kt, ne, fe, qe, Je.slice()), kt = kt.nextSibling;
          ne.push("</", Sr, ">");
        } else
          ne.push("/>");
        return;
      case b:
      case w:
        for (var kt = te.firstChild; kt; )
          Ue(kt, ne, fe, qe, Je.slice()), kt = kt.nextSibling;
        return;
      case m:
        return le(ne, te.name, te.value);
      case y:
        return ne.push(
          te.data.replace(/[<&>]/g, K)
        );
      case x:
        return ne.push("<![CDATA[", te.data, "]]>");
      case E:
        return ne.push("<!--", te.data, "-->");
      case C:
        var hi = te.publicId, Rr = te.systemId;
        if (ne.push("<!DOCTYPE ", te.name), hi)
          ne.push(" PUBLIC ", hi), Rr && Rr != "." && ne.push(" ", Rr), ne.push(">");
        else if (Rr && Rr != ".")
          ne.push(" SYSTEM ", Rr, ">");
        else {
          var ci = te.internalSubset;
          ci && ne.push(" [", ci, "]"), ne.push(">");
        }
        return;
      case T:
        return ne.push("<?", te.target, " ", te.data, "?>");
      case g:
        return ne.push("&", te.nodeName, ";");
      default:
        ne.push("??", te.nodeName);
    }
  }
  function et(te, ne, fe) {
    var qe;
    switch (ne.nodeType) {
      case p:
        qe = ne.cloneNode(false), qe.ownerDocument = te;
      case w:
        break;
      case m:
        fe = true;
        break;
    }
    if (qe || (qe = ne.cloneNode(false)), qe.ownerDocument = te, qe.parentNode = null, fe)
      for (var Je = ne.firstChild; Je; )
        qe.appendChild(et(te, Je, fe)), Je = Je.nextSibling;
    return qe;
  }
  function lt(te, ne, fe) {
    var qe = new ne.constructor();
    for (var Je in ne)
      if (Object.prototype.hasOwnProperty.call(ne, Je)) {
        var ht = ne[Je];
        typeof ht != "object" && ht != qe[Je] && (qe[Je] = ht);
      }
    switch (ne.childNodes && (qe.childNodes = new z()), qe.ownerDocument = te, qe.nodeType) {
      case p:
        var bt = ne.attributes, kt = qe.attributes = new k(), Ar = bt.length;
        kt._ownerElement = qe;
        for (var Sr = 0; Sr < Ar; Sr++)
          qe.setAttributeNode(lt(te, bt.item(Sr), true));
        break;
      case m:
        fe = true;
    }
    if (fe)
      for (var Vt = ne.firstChild; Vt; )
        qe.appendChild(lt(te, Vt, fe)), Vt = Vt.nextSibling;
    return qe;
  }
  function We(te, ne, fe) {
    te[ne] = fe;
  }
  try {
    if (Object.defineProperty) {
      let te = function(ne) {
        switch (ne.nodeType) {
          case p:
          case w:
            var fe = [];
            for (ne = ne.firstChild; ne; )
              ne.nodeType !== 7 && ne.nodeType !== 8 && fe.push(te(ne)), ne = ne.nextSibling;
            return fe.join("");
          default:
            return ne.nodeValue;
        }
      };
      Object.defineProperty(D.prototype, "length", {
        get: function() {
          return X(this), this.$$length;
        }
      }), Object.defineProperty(V.prototype, "textContent", {
        get: function() {
          return te(this);
        },
        set: function(ne) {
          switch (this.nodeType) {
            case p:
            case w:
              for (; this.firstChild; )
                this.removeChild(this.firstChild);
              (ne || String(ne)) && this.appendChild(this.ownerDocument.createTextNode(ne));
              break;
            default:
              this.data = ne, this.value = ne, this.nodeValue = ne;
          }
        }
      }), We = function(ne, fe, qe) {
        ne["$$" + fe] = qe;
      };
    }
  } catch {
  }
  return dom.DocumentType = $, dom.DOMException = q, dom.DOMImplementation = W, dom.Element = Xe, dom.Node = V, dom.NodeList = z, dom.XMLSerializer = je, dom;
}
var domParser = {}, entities = {}, hasRequiredEntities;
function requireEntities() {
  return hasRequiredEntities || (hasRequiredEntities = 1, function(i2) {
    var e = requireConventions().freeze;
    i2.XML_ENTITIES = e({
      amp: "&",
      apos: "'",
      gt: ">",
      lt: "<",
      quot: '"'
    }), i2.HTML_ENTITIES = e({
      Aacute: "Á",
      aacute: "á",
      Abreve: "Ă",
      abreve: "ă",
      ac: "∾",
      acd: "∿",
      acE: "∾̳",
      Acirc: "Â",
      acirc: "â",
      acute: "´",
      Acy: "А",
      acy: "а",
      AElig: "Æ",
      aelig: "æ",
      af: "⁡",
      Afr: "𝔄",
      afr: "𝔞",
      Agrave: "À",
      agrave: "à",
      alefsym: "ℵ",
      aleph: "ℵ",
      Alpha: "Α",
      alpha: "α",
      Amacr: "Ā",
      amacr: "ā",
      amalg: "⨿",
      AMP: "&",
      amp: "&",
      And: "⩓",
      and: "∧",
      andand: "⩕",
      andd: "⩜",
      andslope: "⩘",
      andv: "⩚",
      ang: "∠",
      ange: "⦤",
      angle: "∠",
      angmsd: "∡",
      angmsdaa: "⦨",
      angmsdab: "⦩",
      angmsdac: "⦪",
      angmsdad: "⦫",
      angmsdae: "⦬",
      angmsdaf: "⦭",
      angmsdag: "⦮",
      angmsdah: "⦯",
      angrt: "∟",
      angrtvb: "⊾",
      angrtvbd: "⦝",
      angsph: "∢",
      angst: "Å",
      angzarr: "⍼",
      Aogon: "Ą",
      aogon: "ą",
      Aopf: "𝔸",
      aopf: "𝕒",
      ap: "≈",
      apacir: "⩯",
      apE: "⩰",
      ape: "≊",
      apid: "≋",
      apos: "'",
      ApplyFunction: "⁡",
      approx: "≈",
      approxeq: "≊",
      Aring: "Å",
      aring: "å",
      Ascr: "𝒜",
      ascr: "𝒶",
      Assign: "≔",
      ast: "*",
      asymp: "≈",
      asympeq: "≍",
      Atilde: "Ã",
      atilde: "ã",
      Auml: "Ä",
      auml: "ä",
      awconint: "∳",
      awint: "⨑",
      backcong: "≌",
      backepsilon: "϶",
      backprime: "‵",
      backsim: "∽",
      backsimeq: "⋍",
      Backslash: "∖",
      Barv: "⫧",
      barvee: "⊽",
      Barwed: "⌆",
      barwed: "⌅",
      barwedge: "⌅",
      bbrk: "⎵",
      bbrktbrk: "⎶",
      bcong: "≌",
      Bcy: "Б",
      bcy: "б",
      bdquo: "„",
      becaus: "∵",
      Because: "∵",
      because: "∵",
      bemptyv: "⦰",
      bepsi: "϶",
      bernou: "ℬ",
      Bernoullis: "ℬ",
      Beta: "Β",
      beta: "β",
      beth: "ℶ",
      between: "≬",
      Bfr: "𝔅",
      bfr: "𝔟",
      bigcap: "⋂",
      bigcirc: "◯",
      bigcup: "⋃",
      bigodot: "⨀",
      bigoplus: "⨁",
      bigotimes: "⨂",
      bigsqcup: "⨆",
      bigstar: "★",
      bigtriangledown: "▽",
      bigtriangleup: "△",
      biguplus: "⨄",
      bigvee: "⋁",
      bigwedge: "⋀",
      bkarow: "⤍",
      blacklozenge: "⧫",
      blacksquare: "▪",
      blacktriangle: "▴",
      blacktriangledown: "▾",
      blacktriangleleft: "◂",
      blacktriangleright: "▸",
      blank: "␣",
      blk12: "▒",
      blk14: "░",
      blk34: "▓",
      block: "█",
      bne: "=⃥",
      bnequiv: "≡⃥",
      bNot: "⫭",
      bnot: "⌐",
      Bopf: "𝔹",
      bopf: "𝕓",
      bot: "⊥",
      bottom: "⊥",
      bowtie: "⋈",
      boxbox: "⧉",
      boxDL: "╗",
      boxDl: "╖",
      boxdL: "╕",
      boxdl: "┐",
      boxDR: "╔",
      boxDr: "╓",
      boxdR: "╒",
      boxdr: "┌",
      boxH: "═",
      boxh: "─",
      boxHD: "╦",
      boxHd: "╤",
      boxhD: "╥",
      boxhd: "┬",
      boxHU: "╩",
      boxHu: "╧",
      boxhU: "╨",
      boxhu: "┴",
      boxminus: "⊟",
      boxplus: "⊞",
      boxtimes: "⊠",
      boxUL: "╝",
      boxUl: "╜",
      boxuL: "╛",
      boxul: "┘",
      boxUR: "╚",
      boxUr: "╙",
      boxuR: "╘",
      boxur: "└",
      boxV: "║",
      boxv: "│",
      boxVH: "╬",
      boxVh: "╫",
      boxvH: "╪",
      boxvh: "┼",
      boxVL: "╣",
      boxVl: "╢",
      boxvL: "╡",
      boxvl: "┤",
      boxVR: "╠",
      boxVr: "╟",
      boxvR: "╞",
      boxvr: "├",
      bprime: "‵",
      Breve: "˘",
      breve: "˘",
      brvbar: "¦",
      Bscr: "ℬ",
      bscr: "𝒷",
      bsemi: "⁏",
      bsim: "∽",
      bsime: "⋍",
      bsol: "\\",
      bsolb: "⧅",
      bsolhsub: "⟈",
      bull: "•",
      bullet: "•",
      bump: "≎",
      bumpE: "⪮",
      bumpe: "≏",
      Bumpeq: "≎",
      bumpeq: "≏",
      Cacute: "Ć",
      cacute: "ć",
      Cap: "⋒",
      cap: "∩",
      capand: "⩄",
      capbrcup: "⩉",
      capcap: "⩋",
      capcup: "⩇",
      capdot: "⩀",
      CapitalDifferentialD: "ⅅ",
      caps: "∩︀",
      caret: "⁁",
      caron: "ˇ",
      Cayleys: "ℭ",
      ccaps: "⩍",
      Ccaron: "Č",
      ccaron: "č",
      Ccedil: "Ç",
      ccedil: "ç",
      Ccirc: "Ĉ",
      ccirc: "ĉ",
      Cconint: "∰",
      ccups: "⩌",
      ccupssm: "⩐",
      Cdot: "Ċ",
      cdot: "ċ",
      cedil: "¸",
      Cedilla: "¸",
      cemptyv: "⦲",
      cent: "¢",
      CenterDot: "·",
      centerdot: "·",
      Cfr: "ℭ",
      cfr: "𝔠",
      CHcy: "Ч",
      chcy: "ч",
      check: "✓",
      checkmark: "✓",
      Chi: "Χ",
      chi: "χ",
      cir: "○",
      circ: "ˆ",
      circeq: "≗",
      circlearrowleft: "↺",
      circlearrowright: "↻",
      circledast: "⊛",
      circledcirc: "⊚",
      circleddash: "⊝",
      CircleDot: "⊙",
      circledR: "®",
      circledS: "Ⓢ",
      CircleMinus: "⊖",
      CirclePlus: "⊕",
      CircleTimes: "⊗",
      cirE: "⧃",
      cire: "≗",
      cirfnint: "⨐",
      cirmid: "⫯",
      cirscir: "⧂",
      ClockwiseContourIntegral: "∲",
      CloseCurlyDoubleQuote: "”",
      CloseCurlyQuote: "’",
      clubs: "♣",
      clubsuit: "♣",
      Colon: "∷",
      colon: ":",
      Colone: "⩴",
      colone: "≔",
      coloneq: "≔",
      comma: ",",
      commat: "@",
      comp: "∁",
      compfn: "∘",
      complement: "∁",
      complexes: "ℂ",
      cong: "≅",
      congdot: "⩭",
      Congruent: "≡",
      Conint: "∯",
      conint: "∮",
      ContourIntegral: "∮",
      Copf: "ℂ",
      copf: "𝕔",
      coprod: "∐",
      Coproduct: "∐",
      COPY: "©",
      copy: "©",
      copysr: "℗",
      CounterClockwiseContourIntegral: "∳",
      crarr: "↵",
      Cross: "⨯",
      cross: "✗",
      Cscr: "𝒞",
      cscr: "𝒸",
      csub: "⫏",
      csube: "⫑",
      csup: "⫐",
      csupe: "⫒",
      ctdot: "⋯",
      cudarrl: "⤸",
      cudarrr: "⤵",
      cuepr: "⋞",
      cuesc: "⋟",
      cularr: "↶",
      cularrp: "⤽",
      Cup: "⋓",
      cup: "∪",
      cupbrcap: "⩈",
      CupCap: "≍",
      cupcap: "⩆",
      cupcup: "⩊",
      cupdot: "⊍",
      cupor: "⩅",
      cups: "∪︀",
      curarr: "↷",
      curarrm: "⤼",
      curlyeqprec: "⋞",
      curlyeqsucc: "⋟",
      curlyvee: "⋎",
      curlywedge: "⋏",
      curren: "¤",
      curvearrowleft: "↶",
      curvearrowright: "↷",
      cuvee: "⋎",
      cuwed: "⋏",
      cwconint: "∲",
      cwint: "∱",
      cylcty: "⌭",
      Dagger: "‡",
      dagger: "†",
      daleth: "ℸ",
      Darr: "↡",
      dArr: "⇓",
      darr: "↓",
      dash: "‐",
      Dashv: "⫤",
      dashv: "⊣",
      dbkarow: "⤏",
      dblac: "˝",
      Dcaron: "Ď",
      dcaron: "ď",
      Dcy: "Д",
      dcy: "д",
      DD: "ⅅ",
      dd: "ⅆ",
      ddagger: "‡",
      ddarr: "⇊",
      DDotrahd: "⤑",
      ddotseq: "⩷",
      deg: "°",
      Del: "∇",
      Delta: "Δ",
      delta: "δ",
      demptyv: "⦱",
      dfisht: "⥿",
      Dfr: "𝔇",
      dfr: "𝔡",
      dHar: "⥥",
      dharl: "⇃",
      dharr: "⇂",
      DiacriticalAcute: "´",
      DiacriticalDot: "˙",
      DiacriticalDoubleAcute: "˝",
      DiacriticalGrave: "`",
      DiacriticalTilde: "˜",
      diam: "⋄",
      Diamond: "⋄",
      diamond: "⋄",
      diamondsuit: "♦",
      diams: "♦",
      die: "¨",
      DifferentialD: "ⅆ",
      digamma: "ϝ",
      disin: "⋲",
      div: "÷",
      divide: "÷",
      divideontimes: "⋇",
      divonx: "⋇",
      DJcy: "Ђ",
      djcy: "ђ",
      dlcorn: "⌞",
      dlcrop: "⌍",
      dollar: "$",
      Dopf: "𝔻",
      dopf: "𝕕",
      Dot: "¨",
      dot: "˙",
      DotDot: "⃜",
      doteq: "≐",
      doteqdot: "≑",
      DotEqual: "≐",
      dotminus: "∸",
      dotplus: "∔",
      dotsquare: "⊡",
      doublebarwedge: "⌆",
      DoubleContourIntegral: "∯",
      DoubleDot: "¨",
      DoubleDownArrow: "⇓",
      DoubleLeftArrow: "⇐",
      DoubleLeftRightArrow: "⇔",
      DoubleLeftTee: "⫤",
      DoubleLongLeftArrow: "⟸",
      DoubleLongLeftRightArrow: "⟺",
      DoubleLongRightArrow: "⟹",
      DoubleRightArrow: "⇒",
      DoubleRightTee: "⊨",
      DoubleUpArrow: "⇑",
      DoubleUpDownArrow: "⇕",
      DoubleVerticalBar: "∥",
      DownArrow: "↓",
      Downarrow: "⇓",
      downarrow: "↓",
      DownArrowBar: "⤓",
      DownArrowUpArrow: "⇵",
      DownBreve: "̑",
      downdownarrows: "⇊",
      downharpoonleft: "⇃",
      downharpoonright: "⇂",
      DownLeftRightVector: "⥐",
      DownLeftTeeVector: "⥞",
      DownLeftVector: "↽",
      DownLeftVectorBar: "⥖",
      DownRightTeeVector: "⥟",
      DownRightVector: "⇁",
      DownRightVectorBar: "⥗",
      DownTee: "⊤",
      DownTeeArrow: "↧",
      drbkarow: "⤐",
      drcorn: "⌟",
      drcrop: "⌌",
      Dscr: "𝒟",
      dscr: "𝒹",
      DScy: "Ѕ",
      dscy: "ѕ",
      dsol: "⧶",
      Dstrok: "Đ",
      dstrok: "đ",
      dtdot: "⋱",
      dtri: "▿",
      dtrif: "▾",
      duarr: "⇵",
      duhar: "⥯",
      dwangle: "⦦",
      DZcy: "Џ",
      dzcy: "џ",
      dzigrarr: "⟿",
      Eacute: "É",
      eacute: "é",
      easter: "⩮",
      Ecaron: "Ě",
      ecaron: "ě",
      ecir: "≖",
      Ecirc: "Ê",
      ecirc: "ê",
      ecolon: "≕",
      Ecy: "Э",
      ecy: "э",
      eDDot: "⩷",
      Edot: "Ė",
      eDot: "≑",
      edot: "ė",
      ee: "ⅇ",
      efDot: "≒",
      Efr: "𝔈",
      efr: "𝔢",
      eg: "⪚",
      Egrave: "È",
      egrave: "è",
      egs: "⪖",
      egsdot: "⪘",
      el: "⪙",
      Element: "∈",
      elinters: "⏧",
      ell: "ℓ",
      els: "⪕",
      elsdot: "⪗",
      Emacr: "Ē",
      emacr: "ē",
      empty: "∅",
      emptyset: "∅",
      EmptySmallSquare: "◻",
      emptyv: "∅",
      EmptyVerySmallSquare: "▫",
      emsp: " ",
      emsp13: " ",
      emsp14: " ",
      ENG: "Ŋ",
      eng: "ŋ",
      ensp: " ",
      Eogon: "Ę",
      eogon: "ę",
      Eopf: "𝔼",
      eopf: "𝕖",
      epar: "⋕",
      eparsl: "⧣",
      eplus: "⩱",
      epsi: "ε",
      Epsilon: "Ε",
      epsilon: "ε",
      epsiv: "ϵ",
      eqcirc: "≖",
      eqcolon: "≕",
      eqsim: "≂",
      eqslantgtr: "⪖",
      eqslantless: "⪕",
      Equal: "⩵",
      equals: "=",
      EqualTilde: "≂",
      equest: "≟",
      Equilibrium: "⇌",
      equiv: "≡",
      equivDD: "⩸",
      eqvparsl: "⧥",
      erarr: "⥱",
      erDot: "≓",
      Escr: "ℰ",
      escr: "ℯ",
      esdot: "≐",
      Esim: "⩳",
      esim: "≂",
      Eta: "Η",
      eta: "η",
      ETH: "Ð",
      eth: "ð",
      Euml: "Ë",
      euml: "ë",
      euro: "€",
      excl: "!",
      exist: "∃",
      Exists: "∃",
      expectation: "ℰ",
      ExponentialE: "ⅇ",
      exponentiale: "ⅇ",
      fallingdotseq: "≒",
      Fcy: "Ф",
      fcy: "ф",
      female: "♀",
      ffilig: "ﬃ",
      fflig: "ﬀ",
      ffllig: "ﬄ",
      Ffr: "𝔉",
      ffr: "𝔣",
      filig: "ﬁ",
      FilledSmallSquare: "◼",
      FilledVerySmallSquare: "▪",
      fjlig: "fj",
      flat: "♭",
      fllig: "ﬂ",
      fltns: "▱",
      fnof: "ƒ",
      Fopf: "𝔽",
      fopf: "𝕗",
      ForAll: "∀",
      forall: "∀",
      fork: "⋔",
      forkv: "⫙",
      Fouriertrf: "ℱ",
      fpartint: "⨍",
      frac12: "½",
      frac13: "⅓",
      frac14: "¼",
      frac15: "⅕",
      frac16: "⅙",
      frac18: "⅛",
      frac23: "⅔",
      frac25: "⅖",
      frac34: "¾",
      frac35: "⅗",
      frac38: "⅜",
      frac45: "⅘",
      frac56: "⅚",
      frac58: "⅝",
      frac78: "⅞",
      frasl: "⁄",
      frown: "⌢",
      Fscr: "ℱ",
      fscr: "𝒻",
      gacute: "ǵ",
      Gamma: "Γ",
      gamma: "γ",
      Gammad: "Ϝ",
      gammad: "ϝ",
      gap: "⪆",
      Gbreve: "Ğ",
      gbreve: "ğ",
      Gcedil: "Ģ",
      Gcirc: "Ĝ",
      gcirc: "ĝ",
      Gcy: "Г",
      gcy: "г",
      Gdot: "Ġ",
      gdot: "ġ",
      gE: "≧",
      ge: "≥",
      gEl: "⪌",
      gel: "⋛",
      geq: "≥",
      geqq: "≧",
      geqslant: "⩾",
      ges: "⩾",
      gescc: "⪩",
      gesdot: "⪀",
      gesdoto: "⪂",
      gesdotol: "⪄",
      gesl: "⋛︀",
      gesles: "⪔",
      Gfr: "𝔊",
      gfr: "𝔤",
      Gg: "⋙",
      gg: "≫",
      ggg: "⋙",
      gimel: "ℷ",
      GJcy: "Ѓ",
      gjcy: "ѓ",
      gl: "≷",
      gla: "⪥",
      glE: "⪒",
      glj: "⪤",
      gnap: "⪊",
      gnapprox: "⪊",
      gnE: "≩",
      gne: "⪈",
      gneq: "⪈",
      gneqq: "≩",
      gnsim: "⋧",
      Gopf: "𝔾",
      gopf: "𝕘",
      grave: "`",
      GreaterEqual: "≥",
      GreaterEqualLess: "⋛",
      GreaterFullEqual: "≧",
      GreaterGreater: "⪢",
      GreaterLess: "≷",
      GreaterSlantEqual: "⩾",
      GreaterTilde: "≳",
      Gscr: "𝒢",
      gscr: "ℊ",
      gsim: "≳",
      gsime: "⪎",
      gsiml: "⪐",
      Gt: "≫",
      GT: ">",
      gt: ">",
      gtcc: "⪧",
      gtcir: "⩺",
      gtdot: "⋗",
      gtlPar: "⦕",
      gtquest: "⩼",
      gtrapprox: "⪆",
      gtrarr: "⥸",
      gtrdot: "⋗",
      gtreqless: "⋛",
      gtreqqless: "⪌",
      gtrless: "≷",
      gtrsim: "≳",
      gvertneqq: "≩︀",
      gvnE: "≩︀",
      Hacek: "ˇ",
      hairsp: " ",
      half: "½",
      hamilt: "ℋ",
      HARDcy: "Ъ",
      hardcy: "ъ",
      hArr: "⇔",
      harr: "↔",
      harrcir: "⥈",
      harrw: "↭",
      Hat: "^",
      hbar: "ℏ",
      Hcirc: "Ĥ",
      hcirc: "ĥ",
      hearts: "♥",
      heartsuit: "♥",
      hellip: "…",
      hercon: "⊹",
      Hfr: "ℌ",
      hfr: "𝔥",
      HilbertSpace: "ℋ",
      hksearow: "⤥",
      hkswarow: "⤦",
      hoarr: "⇿",
      homtht: "∻",
      hookleftarrow: "↩",
      hookrightarrow: "↪",
      Hopf: "ℍ",
      hopf: "𝕙",
      horbar: "―",
      HorizontalLine: "─",
      Hscr: "ℋ",
      hscr: "𝒽",
      hslash: "ℏ",
      Hstrok: "Ħ",
      hstrok: "ħ",
      HumpDownHump: "≎",
      HumpEqual: "≏",
      hybull: "⁃",
      hyphen: "‐",
      Iacute: "Í",
      iacute: "í",
      ic: "⁣",
      Icirc: "Î",
      icirc: "î",
      Icy: "И",
      icy: "и",
      Idot: "İ",
      IEcy: "Е",
      iecy: "е",
      iexcl: "¡",
      iff: "⇔",
      Ifr: "ℑ",
      ifr: "𝔦",
      Igrave: "Ì",
      igrave: "ì",
      ii: "ⅈ",
      iiiint: "⨌",
      iiint: "∭",
      iinfin: "⧜",
      iiota: "℩",
      IJlig: "Ĳ",
      ijlig: "ĳ",
      Im: "ℑ",
      Imacr: "Ī",
      imacr: "ī",
      image: "ℑ",
      ImaginaryI: "ⅈ",
      imagline: "ℐ",
      imagpart: "ℑ",
      imath: "ı",
      imof: "⊷",
      imped: "Ƶ",
      Implies: "⇒",
      in: "∈",
      incare: "℅",
      infin: "∞",
      infintie: "⧝",
      inodot: "ı",
      Int: "∬",
      int: "∫",
      intcal: "⊺",
      integers: "ℤ",
      Integral: "∫",
      intercal: "⊺",
      Intersection: "⋂",
      intlarhk: "⨗",
      intprod: "⨼",
      InvisibleComma: "⁣",
      InvisibleTimes: "⁢",
      IOcy: "Ё",
      iocy: "ё",
      Iogon: "Į",
      iogon: "į",
      Iopf: "𝕀",
      iopf: "𝕚",
      Iota: "Ι",
      iota: "ι",
      iprod: "⨼",
      iquest: "¿",
      Iscr: "ℐ",
      iscr: "𝒾",
      isin: "∈",
      isindot: "⋵",
      isinE: "⋹",
      isins: "⋴",
      isinsv: "⋳",
      isinv: "∈",
      it: "⁢",
      Itilde: "Ĩ",
      itilde: "ĩ",
      Iukcy: "І",
      iukcy: "і",
      Iuml: "Ï",
      iuml: "ï",
      Jcirc: "Ĵ",
      jcirc: "ĵ",
      Jcy: "Й",
      jcy: "й",
      Jfr: "𝔍",
      jfr: "𝔧",
      jmath: "ȷ",
      Jopf: "𝕁",
      jopf: "𝕛",
      Jscr: "𝒥",
      jscr: "𝒿",
      Jsercy: "Ј",
      jsercy: "ј",
      Jukcy: "Є",
      jukcy: "є",
      Kappa: "Κ",
      kappa: "κ",
      kappav: "ϰ",
      Kcedil: "Ķ",
      kcedil: "ķ",
      Kcy: "К",
      kcy: "к",
      Kfr: "𝔎",
      kfr: "𝔨",
      kgreen: "ĸ",
      KHcy: "Х",
      khcy: "х",
      KJcy: "Ќ",
      kjcy: "ќ",
      Kopf: "𝕂",
      kopf: "𝕜",
      Kscr: "𝒦",
      kscr: "𝓀",
      lAarr: "⇚",
      Lacute: "Ĺ",
      lacute: "ĺ",
      laemptyv: "⦴",
      lagran: "ℒ",
      Lambda: "Λ",
      lambda: "λ",
      Lang: "⟪",
      lang: "⟨",
      langd: "⦑",
      langle: "⟨",
      lap: "⪅",
      Laplacetrf: "ℒ",
      laquo: "«",
      Larr: "↞",
      lArr: "⇐",
      larr: "←",
      larrb: "⇤",
      larrbfs: "⤟",
      larrfs: "⤝",
      larrhk: "↩",
      larrlp: "↫",
      larrpl: "⤹",
      larrsim: "⥳",
      larrtl: "↢",
      lat: "⪫",
      lAtail: "⤛",
      latail: "⤙",
      late: "⪭",
      lates: "⪭︀",
      lBarr: "⤎",
      lbarr: "⤌",
      lbbrk: "❲",
      lbrace: "{",
      lbrack: "[",
      lbrke: "⦋",
      lbrksld: "⦏",
      lbrkslu: "⦍",
      Lcaron: "Ľ",
      lcaron: "ľ",
      Lcedil: "Ļ",
      lcedil: "ļ",
      lceil: "⌈",
      lcub: "{",
      Lcy: "Л",
      lcy: "л",
      ldca: "⤶",
      ldquo: "“",
      ldquor: "„",
      ldrdhar: "⥧",
      ldrushar: "⥋",
      ldsh: "↲",
      lE: "≦",
      le: "≤",
      LeftAngleBracket: "⟨",
      LeftArrow: "←",
      Leftarrow: "⇐",
      leftarrow: "←",
      LeftArrowBar: "⇤",
      LeftArrowRightArrow: "⇆",
      leftarrowtail: "↢",
      LeftCeiling: "⌈",
      LeftDoubleBracket: "⟦",
      LeftDownTeeVector: "⥡",
      LeftDownVector: "⇃",
      LeftDownVectorBar: "⥙",
      LeftFloor: "⌊",
      leftharpoondown: "↽",
      leftharpoonup: "↼",
      leftleftarrows: "⇇",
      LeftRightArrow: "↔",
      Leftrightarrow: "⇔",
      leftrightarrow: "↔",
      leftrightarrows: "⇆",
      leftrightharpoons: "⇋",
      leftrightsquigarrow: "↭",
      LeftRightVector: "⥎",
      LeftTee: "⊣",
      LeftTeeArrow: "↤",
      LeftTeeVector: "⥚",
      leftthreetimes: "⋋",
      LeftTriangle: "⊲",
      LeftTriangleBar: "⧏",
      LeftTriangleEqual: "⊴",
      LeftUpDownVector: "⥑",
      LeftUpTeeVector: "⥠",
      LeftUpVector: "↿",
      LeftUpVectorBar: "⥘",
      LeftVector: "↼",
      LeftVectorBar: "⥒",
      lEg: "⪋",
      leg: "⋚",
      leq: "≤",
      leqq: "≦",
      leqslant: "⩽",
      les: "⩽",
      lescc: "⪨",
      lesdot: "⩿",
      lesdoto: "⪁",
      lesdotor: "⪃",
      lesg: "⋚︀",
      lesges: "⪓",
      lessapprox: "⪅",
      lessdot: "⋖",
      lesseqgtr: "⋚",
      lesseqqgtr: "⪋",
      LessEqualGreater: "⋚",
      LessFullEqual: "≦",
      LessGreater: "≶",
      lessgtr: "≶",
      LessLess: "⪡",
      lesssim: "≲",
      LessSlantEqual: "⩽",
      LessTilde: "≲",
      lfisht: "⥼",
      lfloor: "⌊",
      Lfr: "𝔏",
      lfr: "𝔩",
      lg: "≶",
      lgE: "⪑",
      lHar: "⥢",
      lhard: "↽",
      lharu: "↼",
      lharul: "⥪",
      lhblk: "▄",
      LJcy: "Љ",
      ljcy: "љ",
      Ll: "⋘",
      ll: "≪",
      llarr: "⇇",
      llcorner: "⌞",
      Lleftarrow: "⇚",
      llhard: "⥫",
      lltri: "◺",
      Lmidot: "Ŀ",
      lmidot: "ŀ",
      lmoust: "⎰",
      lmoustache: "⎰",
      lnap: "⪉",
      lnapprox: "⪉",
      lnE: "≨",
      lne: "⪇",
      lneq: "⪇",
      lneqq: "≨",
      lnsim: "⋦",
      loang: "⟬",
      loarr: "⇽",
      lobrk: "⟦",
      LongLeftArrow: "⟵",
      Longleftarrow: "⟸",
      longleftarrow: "⟵",
      LongLeftRightArrow: "⟷",
      Longleftrightarrow: "⟺",
      longleftrightarrow: "⟷",
      longmapsto: "⟼",
      LongRightArrow: "⟶",
      Longrightarrow: "⟹",
      longrightarrow: "⟶",
      looparrowleft: "↫",
      looparrowright: "↬",
      lopar: "⦅",
      Lopf: "𝕃",
      lopf: "𝕝",
      loplus: "⨭",
      lotimes: "⨴",
      lowast: "∗",
      lowbar: "_",
      LowerLeftArrow: "↙",
      LowerRightArrow: "↘",
      loz: "◊",
      lozenge: "◊",
      lozf: "⧫",
      lpar: "(",
      lparlt: "⦓",
      lrarr: "⇆",
      lrcorner: "⌟",
      lrhar: "⇋",
      lrhard: "⥭",
      lrm: "‎",
      lrtri: "⊿",
      lsaquo: "‹",
      Lscr: "ℒ",
      lscr: "𝓁",
      Lsh: "↰",
      lsh: "↰",
      lsim: "≲",
      lsime: "⪍",
      lsimg: "⪏",
      lsqb: "[",
      lsquo: "‘",
      lsquor: "‚",
      Lstrok: "Ł",
      lstrok: "ł",
      Lt: "≪",
      LT: "<",
      lt: "<",
      ltcc: "⪦",
      ltcir: "⩹",
      ltdot: "⋖",
      lthree: "⋋",
      ltimes: "⋉",
      ltlarr: "⥶",
      ltquest: "⩻",
      ltri: "◃",
      ltrie: "⊴",
      ltrif: "◂",
      ltrPar: "⦖",
      lurdshar: "⥊",
      luruhar: "⥦",
      lvertneqq: "≨︀",
      lvnE: "≨︀",
      macr: "¯",
      male: "♂",
      malt: "✠",
      maltese: "✠",
      Map: "⤅",
      map: "↦",
      mapsto: "↦",
      mapstodown: "↧",
      mapstoleft: "↤",
      mapstoup: "↥",
      marker: "▮",
      mcomma: "⨩",
      Mcy: "М",
      mcy: "м",
      mdash: "—",
      mDDot: "∺",
      measuredangle: "∡",
      MediumSpace: " ",
      Mellintrf: "ℳ",
      Mfr: "𝔐",
      mfr: "𝔪",
      mho: "℧",
      micro: "µ",
      mid: "∣",
      midast: "*",
      midcir: "⫰",
      middot: "·",
      minus: "−",
      minusb: "⊟",
      minusd: "∸",
      minusdu: "⨪",
      MinusPlus: "∓",
      mlcp: "⫛",
      mldr: "…",
      mnplus: "∓",
      models: "⊧",
      Mopf: "𝕄",
      mopf: "𝕞",
      mp: "∓",
      Mscr: "ℳ",
      mscr: "𝓂",
      mstpos: "∾",
      Mu: "Μ",
      mu: "μ",
      multimap: "⊸",
      mumap: "⊸",
      nabla: "∇",
      Nacute: "Ń",
      nacute: "ń",
      nang: "∠⃒",
      nap: "≉",
      napE: "⩰̸",
      napid: "≋̸",
      napos: "ŉ",
      napprox: "≉",
      natur: "♮",
      natural: "♮",
      naturals: "ℕ",
      nbsp: " ",
      nbump: "≎̸",
      nbumpe: "≏̸",
      ncap: "⩃",
      Ncaron: "Ň",
      ncaron: "ň",
      Ncedil: "Ņ",
      ncedil: "ņ",
      ncong: "≇",
      ncongdot: "⩭̸",
      ncup: "⩂",
      Ncy: "Н",
      ncy: "н",
      ndash: "–",
      ne: "≠",
      nearhk: "⤤",
      neArr: "⇗",
      nearr: "↗",
      nearrow: "↗",
      nedot: "≐̸",
      NegativeMediumSpace: "​",
      NegativeThickSpace: "​",
      NegativeThinSpace: "​",
      NegativeVeryThinSpace: "​",
      nequiv: "≢",
      nesear: "⤨",
      nesim: "≂̸",
      NestedGreaterGreater: "≫",
      NestedLessLess: "≪",
      NewLine: `
`,
      nexist: "∄",
      nexists: "∄",
      Nfr: "𝔑",
      nfr: "𝔫",
      ngE: "≧̸",
      nge: "≱",
      ngeq: "≱",
      ngeqq: "≧̸",
      ngeqslant: "⩾̸",
      nges: "⩾̸",
      nGg: "⋙̸",
      ngsim: "≵",
      nGt: "≫⃒",
      ngt: "≯",
      ngtr: "≯",
      nGtv: "≫̸",
      nhArr: "⇎",
      nharr: "↮",
      nhpar: "⫲",
      ni: "∋",
      nis: "⋼",
      nisd: "⋺",
      niv: "∋",
      NJcy: "Њ",
      njcy: "њ",
      nlArr: "⇍",
      nlarr: "↚",
      nldr: "‥",
      nlE: "≦̸",
      nle: "≰",
      nLeftarrow: "⇍",
      nleftarrow: "↚",
      nLeftrightarrow: "⇎",
      nleftrightarrow: "↮",
      nleq: "≰",
      nleqq: "≦̸",
      nleqslant: "⩽̸",
      nles: "⩽̸",
      nless: "≮",
      nLl: "⋘̸",
      nlsim: "≴",
      nLt: "≪⃒",
      nlt: "≮",
      nltri: "⋪",
      nltrie: "⋬",
      nLtv: "≪̸",
      nmid: "∤",
      NoBreak: "⁠",
      NonBreakingSpace: " ",
      Nopf: "ℕ",
      nopf: "𝕟",
      Not: "⫬",
      not: "¬",
      NotCongruent: "≢",
      NotCupCap: "≭",
      NotDoubleVerticalBar: "∦",
      NotElement: "∉",
      NotEqual: "≠",
      NotEqualTilde: "≂̸",
      NotExists: "∄",
      NotGreater: "≯",
      NotGreaterEqual: "≱",
      NotGreaterFullEqual: "≧̸",
      NotGreaterGreater: "≫̸",
      NotGreaterLess: "≹",
      NotGreaterSlantEqual: "⩾̸",
      NotGreaterTilde: "≵",
      NotHumpDownHump: "≎̸",
      NotHumpEqual: "≏̸",
      notin: "∉",
      notindot: "⋵̸",
      notinE: "⋹̸",
      notinva: "∉",
      notinvb: "⋷",
      notinvc: "⋶",
      NotLeftTriangle: "⋪",
      NotLeftTriangleBar: "⧏̸",
      NotLeftTriangleEqual: "⋬",
      NotLess: "≮",
      NotLessEqual: "≰",
      NotLessGreater: "≸",
      NotLessLess: "≪̸",
      NotLessSlantEqual: "⩽̸",
      NotLessTilde: "≴",
      NotNestedGreaterGreater: "⪢̸",
      NotNestedLessLess: "⪡̸",
      notni: "∌",
      notniva: "∌",
      notnivb: "⋾",
      notnivc: "⋽",
      NotPrecedes: "⊀",
      NotPrecedesEqual: "⪯̸",
      NotPrecedesSlantEqual: "⋠",
      NotReverseElement: "∌",
      NotRightTriangle: "⋫",
      NotRightTriangleBar: "⧐̸",
      NotRightTriangleEqual: "⋭",
      NotSquareSubset: "⊏̸",
      NotSquareSubsetEqual: "⋢",
      NotSquareSuperset: "⊐̸",
      NotSquareSupersetEqual: "⋣",
      NotSubset: "⊂⃒",
      NotSubsetEqual: "⊈",
      NotSucceeds: "⊁",
      NotSucceedsEqual: "⪰̸",
      NotSucceedsSlantEqual: "⋡",
      NotSucceedsTilde: "≿̸",
      NotSuperset: "⊃⃒",
      NotSupersetEqual: "⊉",
      NotTilde: "≁",
      NotTildeEqual: "≄",
      NotTildeFullEqual: "≇",
      NotTildeTilde: "≉",
      NotVerticalBar: "∤",
      npar: "∦",
      nparallel: "∦",
      nparsl: "⫽⃥",
      npart: "∂̸",
      npolint: "⨔",
      npr: "⊀",
      nprcue: "⋠",
      npre: "⪯̸",
      nprec: "⊀",
      npreceq: "⪯̸",
      nrArr: "⇏",
      nrarr: "↛",
      nrarrc: "⤳̸",
      nrarrw: "↝̸",
      nRightarrow: "⇏",
      nrightarrow: "↛",
      nrtri: "⋫",
      nrtrie: "⋭",
      nsc: "⊁",
      nsccue: "⋡",
      nsce: "⪰̸",
      Nscr: "𝒩",
      nscr: "𝓃",
      nshortmid: "∤",
      nshortparallel: "∦",
      nsim: "≁",
      nsime: "≄",
      nsimeq: "≄",
      nsmid: "∤",
      nspar: "∦",
      nsqsube: "⋢",
      nsqsupe: "⋣",
      nsub: "⊄",
      nsubE: "⫅̸",
      nsube: "⊈",
      nsubset: "⊂⃒",
      nsubseteq: "⊈",
      nsubseteqq: "⫅̸",
      nsucc: "⊁",
      nsucceq: "⪰̸",
      nsup: "⊅",
      nsupE: "⫆̸",
      nsupe: "⊉",
      nsupset: "⊃⃒",
      nsupseteq: "⊉",
      nsupseteqq: "⫆̸",
      ntgl: "≹",
      Ntilde: "Ñ",
      ntilde: "ñ",
      ntlg: "≸",
      ntriangleleft: "⋪",
      ntrianglelefteq: "⋬",
      ntriangleright: "⋫",
      ntrianglerighteq: "⋭",
      Nu: "Ν",
      nu: "ν",
      num: "#",
      numero: "№",
      numsp: " ",
      nvap: "≍⃒",
      nVDash: "⊯",
      nVdash: "⊮",
      nvDash: "⊭",
      nvdash: "⊬",
      nvge: "≥⃒",
      nvgt: ">⃒",
      nvHarr: "⤄",
      nvinfin: "⧞",
      nvlArr: "⤂",
      nvle: "≤⃒",
      nvlt: "<⃒",
      nvltrie: "⊴⃒",
      nvrArr: "⤃",
      nvrtrie: "⊵⃒",
      nvsim: "∼⃒",
      nwarhk: "⤣",
      nwArr: "⇖",
      nwarr: "↖",
      nwarrow: "↖",
      nwnear: "⤧",
      Oacute: "Ó",
      oacute: "ó",
      oast: "⊛",
      ocir: "⊚",
      Ocirc: "Ô",
      ocirc: "ô",
      Ocy: "О",
      ocy: "о",
      odash: "⊝",
      Odblac: "Ő",
      odblac: "ő",
      odiv: "⨸",
      odot: "⊙",
      odsold: "⦼",
      OElig: "Œ",
      oelig: "œ",
      ofcir: "⦿",
      Ofr: "𝔒",
      ofr: "𝔬",
      ogon: "˛",
      Ograve: "Ò",
      ograve: "ò",
      ogt: "⧁",
      ohbar: "⦵",
      ohm: "Ω",
      oint: "∮",
      olarr: "↺",
      olcir: "⦾",
      olcross: "⦻",
      oline: "‾",
      olt: "⧀",
      Omacr: "Ō",
      omacr: "ō",
      Omega: "Ω",
      omega: "ω",
      Omicron: "Ο",
      omicron: "ο",
      omid: "⦶",
      ominus: "⊖",
      Oopf: "𝕆",
      oopf: "𝕠",
      opar: "⦷",
      OpenCurlyDoubleQuote: "“",
      OpenCurlyQuote: "‘",
      operp: "⦹",
      oplus: "⊕",
      Or: "⩔",
      or: "∨",
      orarr: "↻",
      ord: "⩝",
      order: "ℴ",
      orderof: "ℴ",
      ordf: "ª",
      ordm: "º",
      origof: "⊶",
      oror: "⩖",
      orslope: "⩗",
      orv: "⩛",
      oS: "Ⓢ",
      Oscr: "𝒪",
      oscr: "ℴ",
      Oslash: "Ø",
      oslash: "ø",
      osol: "⊘",
      Otilde: "Õ",
      otilde: "õ",
      Otimes: "⨷",
      otimes: "⊗",
      otimesas: "⨶",
      Ouml: "Ö",
      ouml: "ö",
      ovbar: "⌽",
      OverBar: "‾",
      OverBrace: "⏞",
      OverBracket: "⎴",
      OverParenthesis: "⏜",
      par: "∥",
      para: "¶",
      parallel: "∥",
      parsim: "⫳",
      parsl: "⫽",
      part: "∂",
      PartialD: "∂",
      Pcy: "П",
      pcy: "п",
      percnt: "%",
      period: ".",
      permil: "‰",
      perp: "⊥",
      pertenk: "‱",
      Pfr: "𝔓",
      pfr: "𝔭",
      Phi: "Φ",
      phi: "φ",
      phiv: "ϕ",
      phmmat: "ℳ",
      phone: "☎",
      Pi: "Π",
      pi: "π",
      pitchfork: "⋔",
      piv: "ϖ",
      planck: "ℏ",
      planckh: "ℎ",
      plankv: "ℏ",
      plus: "+",
      plusacir: "⨣",
      plusb: "⊞",
      pluscir: "⨢",
      plusdo: "∔",
      plusdu: "⨥",
      pluse: "⩲",
      PlusMinus: "±",
      plusmn: "±",
      plussim: "⨦",
      plustwo: "⨧",
      pm: "±",
      Poincareplane: "ℌ",
      pointint: "⨕",
      Popf: "ℙ",
      popf: "𝕡",
      pound: "£",
      Pr: "⪻",
      pr: "≺",
      prap: "⪷",
      prcue: "≼",
      prE: "⪳",
      pre: "⪯",
      prec: "≺",
      precapprox: "⪷",
      preccurlyeq: "≼",
      Precedes: "≺",
      PrecedesEqual: "⪯",
      PrecedesSlantEqual: "≼",
      PrecedesTilde: "≾",
      preceq: "⪯",
      precnapprox: "⪹",
      precneqq: "⪵",
      precnsim: "⋨",
      precsim: "≾",
      Prime: "″",
      prime: "′",
      primes: "ℙ",
      prnap: "⪹",
      prnE: "⪵",
      prnsim: "⋨",
      prod: "∏",
      Product: "∏",
      profalar: "⌮",
      profline: "⌒",
      profsurf: "⌓",
      prop: "∝",
      Proportion: "∷",
      Proportional: "∝",
      propto: "∝",
      prsim: "≾",
      prurel: "⊰",
      Pscr: "𝒫",
      pscr: "𝓅",
      Psi: "Ψ",
      psi: "ψ",
      puncsp: " ",
      Qfr: "𝔔",
      qfr: "𝔮",
      qint: "⨌",
      Qopf: "ℚ",
      qopf: "𝕢",
      qprime: "⁗",
      Qscr: "𝒬",
      qscr: "𝓆",
      quaternions: "ℍ",
      quatint: "⨖",
      quest: "?",
      questeq: "≟",
      QUOT: '"',
      quot: '"',
      rAarr: "⇛",
      race: "∽̱",
      Racute: "Ŕ",
      racute: "ŕ",
      radic: "√",
      raemptyv: "⦳",
      Rang: "⟫",
      rang: "⟩",
      rangd: "⦒",
      range: "⦥",
      rangle: "⟩",
      raquo: "»",
      Rarr: "↠",
      rArr: "⇒",
      rarr: "→",
      rarrap: "⥵",
      rarrb: "⇥",
      rarrbfs: "⤠",
      rarrc: "⤳",
      rarrfs: "⤞",
      rarrhk: "↪",
      rarrlp: "↬",
      rarrpl: "⥅",
      rarrsim: "⥴",
      Rarrtl: "⤖",
      rarrtl: "↣",
      rarrw: "↝",
      rAtail: "⤜",
      ratail: "⤚",
      ratio: "∶",
      rationals: "ℚ",
      RBarr: "⤐",
      rBarr: "⤏",
      rbarr: "⤍",
      rbbrk: "❳",
      rbrace: "}",
      rbrack: "]",
      rbrke: "⦌",
      rbrksld: "⦎",
      rbrkslu: "⦐",
      Rcaron: "Ř",
      rcaron: "ř",
      Rcedil: "Ŗ",
      rcedil: "ŗ",
      rceil: "⌉",
      rcub: "}",
      Rcy: "Р",
      rcy: "р",
      rdca: "⤷",
      rdldhar: "⥩",
      rdquo: "”",
      rdquor: "”",
      rdsh: "↳",
      Re: "ℜ",
      real: "ℜ",
      realine: "ℛ",
      realpart: "ℜ",
      reals: "ℝ",
      rect: "▭",
      REG: "®",
      reg: "®",
      ReverseElement: "∋",
      ReverseEquilibrium: "⇋",
      ReverseUpEquilibrium: "⥯",
      rfisht: "⥽",
      rfloor: "⌋",
      Rfr: "ℜ",
      rfr: "𝔯",
      rHar: "⥤",
      rhard: "⇁",
      rharu: "⇀",
      rharul: "⥬",
      Rho: "Ρ",
      rho: "ρ",
      rhov: "ϱ",
      RightAngleBracket: "⟩",
      RightArrow: "→",
      Rightarrow: "⇒",
      rightarrow: "→",
      RightArrowBar: "⇥",
      RightArrowLeftArrow: "⇄",
      rightarrowtail: "↣",
      RightCeiling: "⌉",
      RightDoubleBracket: "⟧",
      RightDownTeeVector: "⥝",
      RightDownVector: "⇂",
      RightDownVectorBar: "⥕",
      RightFloor: "⌋",
      rightharpoondown: "⇁",
      rightharpoonup: "⇀",
      rightleftarrows: "⇄",
      rightleftharpoons: "⇌",
      rightrightarrows: "⇉",
      rightsquigarrow: "↝",
      RightTee: "⊢",
      RightTeeArrow: "↦",
      RightTeeVector: "⥛",
      rightthreetimes: "⋌",
      RightTriangle: "⊳",
      RightTriangleBar: "⧐",
      RightTriangleEqual: "⊵",
      RightUpDownVector: "⥏",
      RightUpTeeVector: "⥜",
      RightUpVector: "↾",
      RightUpVectorBar: "⥔",
      RightVector: "⇀",
      RightVectorBar: "⥓",
      ring: "˚",
      risingdotseq: "≓",
      rlarr: "⇄",
      rlhar: "⇌",
      rlm: "‏",
      rmoust: "⎱",
      rmoustache: "⎱",
      rnmid: "⫮",
      roang: "⟭",
      roarr: "⇾",
      robrk: "⟧",
      ropar: "⦆",
      Ropf: "ℝ",
      ropf: "𝕣",
      roplus: "⨮",
      rotimes: "⨵",
      RoundImplies: "⥰",
      rpar: ")",
      rpargt: "⦔",
      rppolint: "⨒",
      rrarr: "⇉",
      Rrightarrow: "⇛",
      rsaquo: "›",
      Rscr: "ℛ",
      rscr: "𝓇",
      Rsh: "↱",
      rsh: "↱",
      rsqb: "]",
      rsquo: "’",
      rsquor: "’",
      rthree: "⋌",
      rtimes: "⋊",
      rtri: "▹",
      rtrie: "⊵",
      rtrif: "▸",
      rtriltri: "⧎",
      RuleDelayed: "⧴",
      ruluhar: "⥨",
      rx: "℞",
      Sacute: "Ś",
      sacute: "ś",
      sbquo: "‚",
      Sc: "⪼",
      sc: "≻",
      scap: "⪸",
      Scaron: "Š",
      scaron: "š",
      sccue: "≽",
      scE: "⪴",
      sce: "⪰",
      Scedil: "Ş",
      scedil: "ş",
      Scirc: "Ŝ",
      scirc: "ŝ",
      scnap: "⪺",
      scnE: "⪶",
      scnsim: "⋩",
      scpolint: "⨓",
      scsim: "≿",
      Scy: "С",
      scy: "с",
      sdot: "⋅",
      sdotb: "⊡",
      sdote: "⩦",
      searhk: "⤥",
      seArr: "⇘",
      searr: "↘",
      searrow: "↘",
      sect: "§",
      semi: ";",
      seswar: "⤩",
      setminus: "∖",
      setmn: "∖",
      sext: "✶",
      Sfr: "𝔖",
      sfr: "𝔰",
      sfrown: "⌢",
      sharp: "♯",
      SHCHcy: "Щ",
      shchcy: "щ",
      SHcy: "Ш",
      shcy: "ш",
      ShortDownArrow: "↓",
      ShortLeftArrow: "←",
      shortmid: "∣",
      shortparallel: "∥",
      ShortRightArrow: "→",
      ShortUpArrow: "↑",
      shy: "­",
      Sigma: "Σ",
      sigma: "σ",
      sigmaf: "ς",
      sigmav: "ς",
      sim: "∼",
      simdot: "⩪",
      sime: "≃",
      simeq: "≃",
      simg: "⪞",
      simgE: "⪠",
      siml: "⪝",
      simlE: "⪟",
      simne: "≆",
      simplus: "⨤",
      simrarr: "⥲",
      slarr: "←",
      SmallCircle: "∘",
      smallsetminus: "∖",
      smashp: "⨳",
      smeparsl: "⧤",
      smid: "∣",
      smile: "⌣",
      smt: "⪪",
      smte: "⪬",
      smtes: "⪬︀",
      SOFTcy: "Ь",
      softcy: "ь",
      sol: "/",
      solb: "⧄",
      solbar: "⌿",
      Sopf: "𝕊",
      sopf: "𝕤",
      spades: "♠",
      spadesuit: "♠",
      spar: "∥",
      sqcap: "⊓",
      sqcaps: "⊓︀",
      sqcup: "⊔",
      sqcups: "⊔︀",
      Sqrt: "√",
      sqsub: "⊏",
      sqsube: "⊑",
      sqsubset: "⊏",
      sqsubseteq: "⊑",
      sqsup: "⊐",
      sqsupe: "⊒",
      sqsupset: "⊐",
      sqsupseteq: "⊒",
      squ: "□",
      Square: "□",
      square: "□",
      SquareIntersection: "⊓",
      SquareSubset: "⊏",
      SquareSubsetEqual: "⊑",
      SquareSuperset: "⊐",
      SquareSupersetEqual: "⊒",
      SquareUnion: "⊔",
      squarf: "▪",
      squf: "▪",
      srarr: "→",
      Sscr: "𝒮",
      sscr: "𝓈",
      ssetmn: "∖",
      ssmile: "⌣",
      sstarf: "⋆",
      Star: "⋆",
      star: "☆",
      starf: "★",
      straightepsilon: "ϵ",
      straightphi: "ϕ",
      strns: "¯",
      Sub: "⋐",
      sub: "⊂",
      subdot: "⪽",
      subE: "⫅",
      sube: "⊆",
      subedot: "⫃",
      submult: "⫁",
      subnE: "⫋",
      subne: "⊊",
      subplus: "⪿",
      subrarr: "⥹",
      Subset: "⋐",
      subset: "⊂",
      subseteq: "⊆",
      subseteqq: "⫅",
      SubsetEqual: "⊆",
      subsetneq: "⊊",
      subsetneqq: "⫋",
      subsim: "⫇",
      subsub: "⫕",
      subsup: "⫓",
      succ: "≻",
      succapprox: "⪸",
      succcurlyeq: "≽",
      Succeeds: "≻",
      SucceedsEqual: "⪰",
      SucceedsSlantEqual: "≽",
      SucceedsTilde: "≿",
      succeq: "⪰",
      succnapprox: "⪺",
      succneqq: "⪶",
      succnsim: "⋩",
      succsim: "≿",
      SuchThat: "∋",
      Sum: "∑",
      sum: "∑",
      sung: "♪",
      Sup: "⋑",
      sup: "⊃",
      sup1: "¹",
      sup2: "²",
      sup3: "³",
      supdot: "⪾",
      supdsub: "⫘",
      supE: "⫆",
      supe: "⊇",
      supedot: "⫄",
      Superset: "⊃",
      SupersetEqual: "⊇",
      suphsol: "⟉",
      suphsub: "⫗",
      suplarr: "⥻",
      supmult: "⫂",
      supnE: "⫌",
      supne: "⊋",
      supplus: "⫀",
      Supset: "⋑",
      supset: "⊃",
      supseteq: "⊇",
      supseteqq: "⫆",
      supsetneq: "⊋",
      supsetneqq: "⫌",
      supsim: "⫈",
      supsub: "⫔",
      supsup: "⫖",
      swarhk: "⤦",
      swArr: "⇙",
      swarr: "↙",
      swarrow: "↙",
      swnwar: "⤪",
      szlig: "ß",
      Tab: "	",
      target: "⌖",
      Tau: "Τ",
      tau: "τ",
      tbrk: "⎴",
      Tcaron: "Ť",
      tcaron: "ť",
      Tcedil: "Ţ",
      tcedil: "ţ",
      Tcy: "Т",
      tcy: "т",
      tdot: "⃛",
      telrec: "⌕",
      Tfr: "𝔗",
      tfr: "𝔱",
      there4: "∴",
      Therefore: "∴",
      therefore: "∴",
      Theta: "Θ",
      theta: "θ",
      thetasym: "ϑ",
      thetav: "ϑ",
      thickapprox: "≈",
      thicksim: "∼",
      ThickSpace: "  ",
      thinsp: " ",
      ThinSpace: " ",
      thkap: "≈",
      thksim: "∼",
      THORN: "Þ",
      thorn: "þ",
      Tilde: "∼",
      tilde: "˜",
      TildeEqual: "≃",
      TildeFullEqual: "≅",
      TildeTilde: "≈",
      times: "×",
      timesb: "⊠",
      timesbar: "⨱",
      timesd: "⨰",
      tint: "∭",
      toea: "⤨",
      top: "⊤",
      topbot: "⌶",
      topcir: "⫱",
      Topf: "𝕋",
      topf: "𝕥",
      topfork: "⫚",
      tosa: "⤩",
      tprime: "‴",
      TRADE: "™",
      trade: "™",
      triangle: "▵",
      triangledown: "▿",
      triangleleft: "◃",
      trianglelefteq: "⊴",
      triangleq: "≜",
      triangleright: "▹",
      trianglerighteq: "⊵",
      tridot: "◬",
      trie: "≜",
      triminus: "⨺",
      TripleDot: "⃛",
      triplus: "⨹",
      trisb: "⧍",
      tritime: "⨻",
      trpezium: "⏢",
      Tscr: "𝒯",
      tscr: "𝓉",
      TScy: "Ц",
      tscy: "ц",
      TSHcy: "Ћ",
      tshcy: "ћ",
      Tstrok: "Ŧ",
      tstrok: "ŧ",
      twixt: "≬",
      twoheadleftarrow: "↞",
      twoheadrightarrow: "↠",
      Uacute: "Ú",
      uacute: "ú",
      Uarr: "↟",
      uArr: "⇑",
      uarr: "↑",
      Uarrocir: "⥉",
      Ubrcy: "Ў",
      ubrcy: "ў",
      Ubreve: "Ŭ",
      ubreve: "ŭ",
      Ucirc: "Û",
      ucirc: "û",
      Ucy: "У",
      ucy: "у",
      udarr: "⇅",
      Udblac: "Ű",
      udblac: "ű",
      udhar: "⥮",
      ufisht: "⥾",
      Ufr: "𝔘",
      ufr: "𝔲",
      Ugrave: "Ù",
      ugrave: "ù",
      uHar: "⥣",
      uharl: "↿",
      uharr: "↾",
      uhblk: "▀",
      ulcorn: "⌜",
      ulcorner: "⌜",
      ulcrop: "⌏",
      ultri: "◸",
      Umacr: "Ū",
      umacr: "ū",
      uml: "¨",
      UnderBar: "_",
      UnderBrace: "⏟",
      UnderBracket: "⎵",
      UnderParenthesis: "⏝",
      Union: "⋃",
      UnionPlus: "⊎",
      Uogon: "Ų",
      uogon: "ų",
      Uopf: "𝕌",
      uopf: "𝕦",
      UpArrow: "↑",
      Uparrow: "⇑",
      uparrow: "↑",
      UpArrowBar: "⤒",
      UpArrowDownArrow: "⇅",
      UpDownArrow: "↕",
      Updownarrow: "⇕",
      updownarrow: "↕",
      UpEquilibrium: "⥮",
      upharpoonleft: "↿",
      upharpoonright: "↾",
      uplus: "⊎",
      UpperLeftArrow: "↖",
      UpperRightArrow: "↗",
      Upsi: "ϒ",
      upsi: "υ",
      upsih: "ϒ",
      Upsilon: "Υ",
      upsilon: "υ",
      UpTee: "⊥",
      UpTeeArrow: "↥",
      upuparrows: "⇈",
      urcorn: "⌝",
      urcorner: "⌝",
      urcrop: "⌎",
      Uring: "Ů",
      uring: "ů",
      urtri: "◹",
      Uscr: "𝒰",
      uscr: "𝓊",
      utdot: "⋰",
      Utilde: "Ũ",
      utilde: "ũ",
      utri: "▵",
      utrif: "▴",
      uuarr: "⇈",
      Uuml: "Ü",
      uuml: "ü",
      uwangle: "⦧",
      vangrt: "⦜",
      varepsilon: "ϵ",
      varkappa: "ϰ",
      varnothing: "∅",
      varphi: "ϕ",
      varpi: "ϖ",
      varpropto: "∝",
      vArr: "⇕",
      varr: "↕",
      varrho: "ϱ",
      varsigma: "ς",
      varsubsetneq: "⊊︀",
      varsubsetneqq: "⫋︀",
      varsupsetneq: "⊋︀",
      varsupsetneqq: "⫌︀",
      vartheta: "ϑ",
      vartriangleleft: "⊲",
      vartriangleright: "⊳",
      Vbar: "⫫",
      vBar: "⫨",
      vBarv: "⫩",
      Vcy: "В",
      vcy: "в",
      VDash: "⊫",
      Vdash: "⊩",
      vDash: "⊨",
      vdash: "⊢",
      Vdashl: "⫦",
      Vee: "⋁",
      vee: "∨",
      veebar: "⊻",
      veeeq: "≚",
      vellip: "⋮",
      Verbar: "‖",
      verbar: "|",
      Vert: "‖",
      vert: "|",
      VerticalBar: "∣",
      VerticalLine: "|",
      VerticalSeparator: "❘",
      VerticalTilde: "≀",
      VeryThinSpace: " ",
      Vfr: "𝔙",
      vfr: "𝔳",
      vltri: "⊲",
      vnsub: "⊂⃒",
      vnsup: "⊃⃒",
      Vopf: "𝕍",
      vopf: "𝕧",
      vprop: "∝",
      vrtri: "⊳",
      Vscr: "𝒱",
      vscr: "𝓋",
      vsubnE: "⫋︀",
      vsubne: "⊊︀",
      vsupnE: "⫌︀",
      vsupne: "⊋︀",
      Vvdash: "⊪",
      vzigzag: "⦚",
      Wcirc: "Ŵ",
      wcirc: "ŵ",
      wedbar: "⩟",
      Wedge: "⋀",
      wedge: "∧",
      wedgeq: "≙",
      weierp: "℘",
      Wfr: "𝔚",
      wfr: "𝔴",
      Wopf: "𝕎",
      wopf: "𝕨",
      wp: "℘",
      wr: "≀",
      wreath: "≀",
      Wscr: "𝒲",
      wscr: "𝓌",
      xcap: "⋂",
      xcirc: "◯",
      xcup: "⋃",
      xdtri: "▽",
      Xfr: "𝔛",
      xfr: "𝔵",
      xhArr: "⟺",
      xharr: "⟷",
      Xi: "Ξ",
      xi: "ξ",
      xlArr: "⟸",
      xlarr: "⟵",
      xmap: "⟼",
      xnis: "⋻",
      xodot: "⨀",
      Xopf: "𝕏",
      xopf: "𝕩",
      xoplus: "⨁",
      xotime: "⨂",
      xrArr: "⟹",
      xrarr: "⟶",
      Xscr: "𝒳",
      xscr: "𝓍",
      xsqcup: "⨆",
      xuplus: "⨄",
      xutri: "△",
      xvee: "⋁",
      xwedge: "⋀",
      Yacute: "Ý",
      yacute: "ý",
      YAcy: "Я",
      yacy: "я",
      Ycirc: "Ŷ",
      ycirc: "ŷ",
      Ycy: "Ы",
      ycy: "ы",
      yen: "¥",
      Yfr: "𝔜",
      yfr: "𝔶",
      YIcy: "Ї",
      yicy: "ї",
      Yopf: "𝕐",
      yopf: "𝕪",
      Yscr: "𝒴",
      yscr: "𝓎",
      YUcy: "Ю",
      yucy: "ю",
      Yuml: "Ÿ",
      yuml: "ÿ",
      Zacute: "Ź",
      zacute: "ź",
      Zcaron: "Ž",
      zcaron: "ž",
      Zcy: "З",
      zcy: "з",
      Zdot: "Ż",
      zdot: "ż",
      zeetrf: "ℨ",
      ZeroWidthSpace: "​",
      Zeta: "Ζ",
      zeta: "ζ",
      Zfr: "ℨ",
      zfr: "𝔷",
      ZHcy: "Ж",
      zhcy: "ж",
      zigrarr: "⇝",
      Zopf: "ℤ",
      zopf: "𝕫",
      Zscr: "𝒵",
      zscr: "𝓏",
      zwj: "‍",
      zwnj: "‌"
    }), i2.entityMap = i2.HTML_ENTITIES;
  }(entities)), entities;
}
var sax = {}, hasRequiredSax;
function requireSax() {
  if (hasRequiredSax) return sax;
  hasRequiredSax = 1;
  var i2 = requireConventions().NAMESPACE, e = /[A-Z_a-z\xC0-\xD6\xD8-\xF6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/, t = new RegExp("[\\-\\.0-9" + e.source.slice(1, -1) + "\\u00B7\\u0300-\\u036F\\u203F-\\u2040]"), r = new RegExp("^" + e.source + t.source + "*(?::" + e.source + t.source + "*)?$"), a = 0, s = 1, u = 2, l = 3, c = 4, d = 5, f = 6, p = 7;
  function m(M, U) {
    this.message = M, this.locator = U, Error.captureStackTrace && Error.captureStackTrace(this, m);
  }
  m.prototype = new Error(), m.prototype.name = m.name;
  function y() {
  }
  y.prototype = {
    parse: function(M, U, B) {
      var q = this.domBuilder;
      q.startDocument(), C(U, U = {}), x(
        M,
        U,
        B,
        q,
        this.errorHandler
      ), q.endDocument();
    }
  };
  function x(M, U, B, q, z) {
    function D(Xe) {
      if (Xe > 65535) {
        Xe -= 65536;
        var at = 55296 + (Xe >> 10), ct = 56320 + (Xe & 1023);
        return String.fromCharCode(at, ct);
      } else
        return String.fromCharCode(Xe);
    }
    function X(Xe) {
      var at = Xe.slice(1, -1);
      return Object.hasOwnProperty.call(B, at) ? B[at] : at.charAt(0) === "#" ? D(parseInt(at.substr(1).replace("x", "0x"))) : (z.error("entity not found:" + Xe), Xe);
    }
    function k(Xe) {
      if (Xe > ae) {
        var at = M.substring(ae, Xe).replace(/&#?\w+;/g, X);
        V && I(ae), q.characters(at, 0, Xe - ae), ae = Xe;
      }
    }
    function I(Xe, at) {
      for (; Xe >= G && (at = W.exec(M)); )
        P = at.index, G = P + at[0].length, V.lineNumber++;
      V.columnNumber = Xe - P + 1;
    }
    for (var P = 0, G = 0, W = /.*(?:\r\n?|\n)|.*$/g, V = q.locator, K = [{ currentNSMap: U }], J = {}, ae = 0; ; ) {
      try {
        var re = M.indexOf("<", ae);
        if (re < 0) {
          if (!M.substr(ae).match(/^\s*$/)) {
            var he = q.doc, ge = he.createTextNode(M.substr(ae));
            he.appendChild(ge), q.currentElement = ge;
          }
          return;
        }
        switch (re > ae && k(re), M.charAt(re + 1)) {
          case "/":
            var Oe = M.indexOf(">", re + 3), me = M.substring(re + 2, Oe).replace(/[ \t\n\r]+$/g, ""), Te = K.pop();
            Oe < 0 ? (me = M.substring(re + 2).replace(/[\s<].*/, ""), z.error("end tag name: " + me + " is not complete:" + Te.tagName), Oe = re + 1 + me.length) : me.match(/\s</) && (me = me.replace(/[\s<].*/, ""), z.error("end tag name: " + me + " maybe not complete"), Oe = re + 1 + me.length);
            var _e = Te.localNSMap, ye = Te.tagName == me, Ae = ye || Te.tagName && Te.tagName.toLowerCase() == me.toLowerCase();
            if (Ae) {
              if (q.endElement(Te.uri, Te.localName, me), _e)
                for (var ke in _e)
                  Object.prototype.hasOwnProperty.call(_e, ke) && q.endPrefixMapping(ke);
              ye || z.fatalError("end tag name: " + me + " is not match the current start tagName:" + Te.tagName);
            } else
              K.push(Te);
            Oe++;
            break;
          case "?":
            V && I(re), Oe = A(M, re, q);
            break;
          case "!":
            V && I(re), Oe = w(M, re, q, z);
            break;
          default:
            V && I(re);
            var Pe = new S(), Ee = K[K.length - 1].currentNSMap, Oe = _(M, re, Pe, Ee, X, z), $e = Pe.length;
            if (!Pe.closed && b(M, Oe, Pe.tagName, J) && (Pe.closed = true, B.nbsp || z.warning("unclosed xml attribute")), V && $e) {
              for (var gt = g(V, {}), xt = 0; xt < $e; xt++) {
                var vt = Pe[xt];
                I(vt.offset), vt.locator = g(V, {});
              }
              q.locator = gt, T(Pe, q, Ee) && K.push(Pe), q.locator = V;
            } else
              T(Pe, q, Ee) && K.push(Pe);
            i2.isHTML(Pe.uri) && !Pe.closed ? Oe = E(M, Oe, Pe.tagName, X, q) : Oe++;
        }
      } catch (Xe) {
        if (Xe instanceof m)
          throw Xe;
        z.error("element parse error: " + Xe), Oe = -1;
      }
      Oe > ae ? ae = Oe : k(Math.max(re, ae) + 1);
    }
  }
  function g(M, U) {
    return U.lineNumber = M.lineNumber, U.columnNumber = M.columnNumber, U;
  }
  function _(M, U, B, q, z, D) {
    function X(V, K, J) {
      B.attributeNames.hasOwnProperty(V) && D.fatalError("Attribute " + V + " redefined"), B.addValue(
        V,
        // @see https://www.w3.org/TR/xml/#AVNormalize
        // since the xmldom sax parser does not "interpret" DTD the following is not implemented:
        // - recursive replacement of (DTD) entity references
        // - trimming and collapsing multiple spaces into a single one for attributes that are not of type CDATA
        K.replace(/[\t\n\r]/g, " ").replace(/&#?\w+;/g, z),
        J
      );
    }
    for (var k, I, P = ++U, G = a; ; ) {
      var W = M.charAt(P);
      switch (W) {
        case "=":
          if (G === s)
            k = M.slice(U, P), G = l;
          else if (G === u)
            G = l;
          else
            throw new Error("attribute equal must after attrName");
          break;
        case "'":
        case '"':
          if (G === l || G === s)
            if (G === s && (D.warning('attribute value must after "="'), k = M.slice(U, P)), U = P + 1, P = M.indexOf(W, U), P > 0)
              I = M.slice(U, P), X(k, I, U - 1), G = d;
            else
              throw new Error("attribute value no end '" + W + "' match");
          else if (G == c)
            I = M.slice(U, P), X(k, I, U), D.warning('attribute "' + k + '" missed start quot(' + W + ")!!"), U = P + 1, G = d;
          else
            throw new Error('attribute value must after "="');
          break;
        case "/":
          switch (G) {
            case a:
              B.setTagName(M.slice(U, P));
            case d:
            case f:
            case p:
              G = p, B.closed = true;
            case c:
            case s:
              break;
            case u:
              B.closed = true;
              break;
            default:
              throw new Error("attribute invalid close char('/')");
          }
          break;
        case "":
          return D.error("unexpected end of input"), G == a && B.setTagName(M.slice(U, P)), P;
        case ">":
          switch (G) {
            case a:
              B.setTagName(M.slice(U, P));
            case d:
            case f:
            case p:
              break;
            case c:
            case s:
              I = M.slice(U, P), I.slice(-1) === "/" && (B.closed = true, I = I.slice(0, -1));
            case u:
              G === u && (I = k), G == c ? (D.warning('attribute "' + I + '" missed quot(")!'), X(k, I, U)) : ((!i2.isHTML(q[""]) || !I.match(/^(?:disabled|checked|selected)$/i)) && D.warning('attribute "' + I + '" missed value!! "' + I + '" instead!!'), X(I, I, U));
              break;
            case l:
              throw new Error("attribute value missed!!");
          }
          return P;
        case "":
          W = " ";
        default:
          if (W <= " ")
            switch (G) {
              case a:
                B.setTagName(M.slice(U, P)), G = f;
                break;
              case s:
                k = M.slice(U, P), G = u;
                break;
              case c:
                var I = M.slice(U, P);
                D.warning('attribute "' + I + '" missed quot(")!!'), X(k, I, U);
              case d:
                G = f;
                break;
            }
          else
            switch (G) {
              case u:
                B.tagName, (!i2.isHTML(q[""]) || !k.match(/^(?:disabled|checked|selected)$/i)) && D.warning('attribute "' + k + '" missed value!! "' + k + '" instead2!!'), X(k, k, U), U = P, G = s;
                break;
              case d:
                D.warning('attribute space is required"' + k + '"!!');
              case f:
                G = s, U = P;
                break;
              case l:
                G = c, U = P;
                break;
              case p:
                throw new Error("elements closed character '/' and '>' must be connected to");
            }
      }
      P++;
    }
  }
  function T(M, U, B) {
    for (var q = M.tagName, z = null, D = M.length; D--; ) {
      var X = M[D], k = X.qName, I = X.value, V = k.indexOf(":");
      if (V > 0)
        var P = X.prefix = k.slice(0, V), G = k.slice(V + 1), W = P === "xmlns" && G;
      else
        G = k, P = null, W = k === "xmlns" && "";
      X.localName = G, W !== false && (z == null && (z = {}, C(B, B = {})), B[W] = z[W] = I, X.uri = i2.XMLNS, U.startPrefixMapping(W, I));
    }
    for (var D = M.length; D--; ) {
      X = M[D];
      var P = X.prefix;
      P && (P === "xml" && (X.uri = i2.XML), P !== "xmlns" && (X.uri = B[P || ""]));
    }
    var V = q.indexOf(":");
    V > 0 ? (P = M.prefix = q.slice(0, V), G = M.localName = q.slice(V + 1)) : (P = null, G = M.localName = q);
    var K = M.uri = B[P || ""];
    if (U.startElement(K, G, q, M), M.closed) {
      if (U.endElement(K, G, q), z)
        for (P in z)
          Object.prototype.hasOwnProperty.call(z, P) && U.endPrefixMapping(P);
    } else
      return M.currentNSMap = B, M.localNSMap = z, true;
  }
  function E(M, U, B, q, z) {
    if (/^(?:script|textarea)$/i.test(B)) {
      var D = M.indexOf("</" + B + ">", U), X = M.substring(U + 1, D);
      if (/[&<]/.test(X))
        return /^script$/i.test(B) ? (z.characters(X, 0, X.length), D) : (X = X.replace(/&#?\w+;/g, q), z.characters(X, 0, X.length), D);
    }
    return U + 1;
  }
  function b(M, U, B, q) {
    var z = q[B];
    return z == null && (z = M.lastIndexOf("</" + B + ">"), z < U && (z = M.lastIndexOf("</" + B)), q[B] = z), z < U;
  }
  function C(M, U) {
    for (var B in M)
      Object.prototype.hasOwnProperty.call(M, B) && (U[B] = M[B]);
  }
  function w(M, U, B, q) {
    var z = M.charAt(U + 2);
    switch (z) {
      case "-":
        if (M.charAt(U + 3) === "-") {
          var D = M.indexOf("-->", U + 4);
          return D > U ? (B.comment(M, U + 4, D - U - 4), D + 3) : (q.error("Unclosed comment"), -1);
        } else
          return -1;
      default:
        if (M.substr(U + 3, 6) == "CDATA[") {
          var D = M.indexOf("]]>", U + 9);
          return B.startCDATA(), B.characters(M, U + 9, D - U - 9), B.endCDATA(), D + 3;
        }
        var X = F(M, U), k = X.length;
        if (k > 1 && /!doctype/i.test(X[0][0])) {
          var I = X[1][0], P = false, G = false;
          k > 3 && (/^public$/i.test(X[2][0]) ? (P = X[3][0], G = k > 4 && X[4][0]) : /^system$/i.test(X[2][0]) && (G = X[3][0]));
          var W = X[k - 1];
          return B.startDTD(I, P, G), B.endDTD(), W.index + W[0].length;
        }
    }
    return -1;
  }
  function A(M, U, B) {
    var q = M.indexOf("?>", U);
    if (q) {
      var z = M.substring(U, q).match(/^<\?(\S*)\s*([\s\S]*?)\s*$/);
      return z ? (z[0].length, B.processingInstruction(z[1], z[2]), q + 2) : -1;
    }
    return -1;
  }
  function S() {
    this.attributeNames = {};
  }
  S.prototype = {
    setTagName: function(M) {
      if (!r.test(M))
        throw new Error("invalid tagName:" + M);
      this.tagName = M;
    },
    addValue: function(M, U, B) {
      if (!r.test(M))
        throw new Error("invalid attribute:" + M);
      this.attributeNames[M] = this.length, this[this.length++] = { qName: M, value: U, offset: B };
    },
    length: 0,
    getLocalName: function(M) {
      return this[M].localName;
    },
    getLocator: function(M) {
      return this[M].locator;
    },
    getQName: function(M) {
      return this[M].qName;
    },
    getURI: function(M) {
      return this[M].uri;
    },
    getValue: function(M) {
      return this[M].value;
    }
    //	,getIndex:function(uri, localName)){
    //		if(localName){
    //
    //		}else{
    //			var qName = uri
    //		}
    //	},
    //	getValue:function(){return this.getValue(this.getIndex.apply(this,arguments))},
    //	getType:function(uri,localName){}
    //	getType:function(i){},
  };
  function F(M, U) {
    var B, q = [], z = /'[^']+'|"[^"]+"|[^\s<>\/=]+=?|(\/?\s*>|<)/g;
    for (z.lastIndex = U, z.exec(M); B = z.exec(M); )
      if (q.push(B), B[1]) return q;
  }
  return sax.XMLReader = y, sax.ParseError = m, sax;
}
var hasRequiredDomParser;
function requireDomParser() {
  if (hasRequiredDomParser) return domParser;
  hasRequiredDomParser = 1;
  var i2 = requireConventions(), e = requireDom(), t = requireEntities(), r = requireSax(), a = e.DOMImplementation, s = i2.NAMESPACE, u = r.ParseError, l = r.XMLReader;
  function c(_) {
    return _.replace(/\r[\n\u0085]/g, `
`).replace(/[\r\u0085\u2028]/g, `
`);
  }
  function d(_) {
    this.options = _ || { locator: {} };
  }
  d.prototype.parseFromString = function(_, T) {
    var E = this.options, b = new l(), C = E.domBuilder || new p(), w = E.errorHandler, A = E.locator, S = E.xmlns || {}, F = /\/x?html?$/.test(T), M = F ? t.HTML_ENTITIES : t.XML_ENTITIES;
    A && C.setDocumentLocator(A), b.errorHandler = f(w, C, A), b.domBuilder = E.domBuilder || C, F && (S[""] = s.HTML), S.xml = S.xml || s.XML;
    var U = E.normalizeLineEndings || c;
    return _ && typeof _ == "string" ? b.parse(
      U(_),
      S,
      M
    ) : b.errorHandler.error("invalid doc source"), C.doc;
  };
  function f(_, T, E) {
    if (!_) {
      if (T instanceof p)
        return T;
      _ = T;
    }
    var b = {}, C = _ instanceof Function;
    E = E || {};
    function w(A) {
      var S = _[A];
      !S && C && (S = _.length == 2 ? function(F) {
        _(A, F);
      } : _), b[A] = S && function(F) {
        S("[xmldom " + A + "]	" + F + y(E));
      } || function() {
      };
    }
    return w("warning"), w("error"), w("fatalError"), b;
  }
  function p() {
    this.cdata = false;
  }
  function m(_, T) {
    T.lineNumber = _.lineNumber, T.columnNumber = _.columnNumber;
  }
  p.prototype = {
    startDocument: function() {
      this.doc = new a().createDocument(null, null, null), this.locator && (this.doc.documentURI = this.locator.systemId);
    },
    startElement: function(_, T, E, b) {
      var C = this.doc, w = C.createElementNS(_, E || T), A = b.length;
      g(this, w), this.currentElement = w, this.locator && m(this.locator, w);
      for (var S = 0; S < A; S++) {
        var _ = b.getURI(S), F = b.getValue(S), E = b.getQName(S), M = C.createAttributeNS(_, E);
        this.locator && m(b.getLocator(S), M), M.value = M.nodeValue = F, w.setAttributeNode(M);
      }
    },
    endElement: function(_, T, E) {
      var b = this.currentElement;
      b.tagName, this.currentElement = b.parentNode;
    },
    startPrefixMapping: function(_, T) {
    },
    endPrefixMapping: function(_) {
    },
    processingInstruction: function(_, T) {
      var E = this.doc.createProcessingInstruction(_, T);
      this.locator && m(this.locator, E), g(this, E);
    },
    ignorableWhitespace: function(_, T, E) {
    },
    characters: function(_, T, E) {
      if (_ = x.apply(this, arguments), _) {
        if (this.cdata)
          var b = this.doc.createCDATASection(_);
        else
          var b = this.doc.createTextNode(_);
        this.currentElement ? this.currentElement.appendChild(b) : /^\s*$/.test(_) && this.doc.appendChild(b), this.locator && m(this.locator, b);
      }
    },
    skippedEntity: function(_) {
    },
    endDocument: function() {
      this.doc.normalize();
    },
    setDocumentLocator: function(_) {
      (this.locator = _) && (_.lineNumber = 0);
    },
    //LexicalHandler
    comment: function(_, T, E) {
      _ = x.apply(this, arguments);
      var b = this.doc.createComment(_);
      this.locator && m(this.locator, b), g(this, b);
    },
    startCDATA: function() {
      this.cdata = true;
    },
    endCDATA: function() {
      this.cdata = false;
    },
    startDTD: function(_, T, E) {
      var b = this.doc.implementation;
      if (b && b.createDocumentType) {
        var C = b.createDocumentType(_, T, E);
        this.locator && m(this.locator, C), g(this, C), this.doc.doctype = C;
      }
    },
    /**
     * @see org.xml.sax.ErrorHandler
     * @link http://www.saxproject.org/apidoc/org/xml/sax/ErrorHandler.html
     */
    warning: function(_) {
      console.warn("[xmldom warning]	" + _, y(this.locator));
    },
    error: function(_) {
      console.error("[xmldom error]	" + _, y(this.locator));
    },
    fatalError: function(_) {
      throw new u(_, this.locator);
    }
  };
  function y(_) {
    if (_)
      return `
@` + (_.systemId || "") + "#[line:" + _.lineNumber + ",col:" + _.columnNumber + "]";
  }
  function x(_, T, E) {
    return typeof _ == "string" ? _.substr(T, E) : _.length >= T + E || T ? new java.lang.String(_, T, E) + "" : _;
  }
  "endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(/\w+/g, function(_) {
    p.prototype[_] = function() {
      return null;
    };
  });
  function g(_, T) {
    _.currentElement ? _.currentElement.appendChild(T) : _.doc.appendChild(T);
  }
  return domParser.__DOMHandler = p, domParser.normalizeLineEndings = c, domParser.DOMParser = d, domParser;
}
var hasRequiredLib$1;
function requireLib$1() {
  if (hasRequiredLib$1) return lib$1;
  hasRequiredLib$1 = 1;
  var i2 = requireDom();
  return lib$1.DOMImplementation = i2.DOMImplementation, lib$1.XMLSerializer = i2.XMLSerializer, lib$1.DOMParser = requireDomParser().DOMParser, lib$1;
}
var xml, hasRequiredXml;
function requireXml() {
  if (hasRequiredXml) return xml;
  hasRequiredXml = 1;
  const { isBrowser: i2 } = requireLib$5();
  let e, t;
  if (i2)
    e = new DOMParser();
  else {
    const { DOMParser: s, XMLSerializer: u } = requireLib$1();
    e = new s(), t = new u().serializeToString;
  }
  const r = (s) => {
    const u = Number(s);
    if (!isNaN(u)) return u;
    let l = s.toLowerCase().trim();
    if (["true", "false"].includes(l))
      return l == "true";
    if (l.match(/^\[(.*)\]$/)) {
      const d = JSON.parse(l);
      return Array.isArray(d) ? d.map((f) => r(f)) : s;
    }
    const c = (d, f) => {
      if (!d.endsWith(f)) return null;
      const p = Number(d.substring(0, d.length - f.length));
      return isNaN(p) ? null : p;
    };
    for (const d of ["rpx", "px", "vw", "vh"]) {
      const f = c(l, d);
      if (f !== null) return `${f}${d}`;
    }
    return s;
  };
  function a(s) {
    const u = { type: s.nodeName };
    if (s.attributes.length > 0)
      for (let c = 0; c < s.attributes.length; c++) {
        const d = s.attributes[c];
        u[d.name] = r(d.value);
      }
    if (u.children = [], s.childNodes.length > 0 && (Array.isArray(s.childNodes) ? s.childNodes : Object.values(s.childNodes)).map((c) => {
      typeof c != "object" || !c.nodeName || c.nodeName.startsWith("#") || u.children.push(a(c));
    }), i2)
      u.innerHTML = s.innerHTML;
    else {
      const c = t(s), d = new RegExp(`\\<${u.type}[^\\>]*\\>`, "g"), f = new RegExp(`\\<\\/${u.type}[^\\>]*\\>`, "g");
      u.innerHTML = c.replace(d, "").replace(f, "");
    }
    let l = u.innerHTML.trim();
    return l && l.startsWith("<![CDATA[") && l.endsWith("]]>") && (u.innerHTML = l.substring(9, l.length - 3)), u;
  }
  return xml = {
    parseXml: function(s) {
      const u = e.parseFromString(s, "application/xml");
      if (u.documentElement.nodeName.toLowerCase() == "miraml")
        return a(u.documentElement);
    },
    getValue: function(s) {
      if (typeof s != "object") return s;
      if (s.innerHTML) return s.innerHTML.replace("<![CDATA[", "").replace("]]>", "");
    }
  }, xml;
}
var filter, hasRequiredFilter;
function requireFilter() {
  if (hasRequiredFilter) return filter;
  hasRequiredFilter = 1;
  const i2 = requireClip(), e = requireXml(), { getRemote: t } = requireXhr();
  class r extends i2 {
    constructor(s = {}) {
      super({ type: "filter", ...s });
    }
    createDisplay() {
    }
    addDisplayChild(s) {
    }
    removeDisplayChild(s) {
    }
    show() {
      this.visible = true, this.filter && (this.filter.enabled = true);
    }
    hide() {
      this.visible = false, this.filter && (this.filter.enabled = false);
    }
    setMask(s) {
      !this.filter || this.filter.mask === s || (this.filter.mask = s, this.parent.addDisplayChild(s), s.renderable = false, s.isMask = true);
    }
    removeMask() {
      !this.filter || !this.filter.mask || (this.parent.removeDisplayChild(this.filter.mask), this.filter.mask = null);
    }
    async preProcessing(s) {
      for (const u of ["vert", "frag", "render"]) {
        if (typeof this[u] != "string" || !this[u].startsWith("http")) continue;
        const l = await t(this[u], this.creator().uuid, (c) => {
          const { total: d, loaded: f } = c;
          d && s && s(f / d);
        });
        this[`${u}Shader`] = await l.data.text();
      }
      this.filter = this.addFilterTo(this.parent.display), this.filter.enabled = false;
    }
    addFilterTo(s) {
      return s.addFilter({
        key: this.id,
        vars: this.vars,
        // shader code: render
        render: this.render,
        // shaders
        vert: this.vert,
        frag: this.frag
      });
    }
    get vert() {
      return this.vertShader || e.getValue(this.conf.vert);
    }
    get frag() {
      return this.fragShader || e.getValue(this.conf.frag);
    }
    get render() {
      return this.renderShader || e.getValue(this.conf.render) || this.conf.src;
    }
    get vars() {
      return this.conf.vars;
    }
    async drawing(s, u) {
      let l = await super.drawing(s, u);
      const c = s / 1e3 - this.absStartTime;
      return this.filter.setTime(c, this.duration), l;
    }
  }
  return filter = r, filter;
}
var speech, hasRequiredSpeech;
function requireSpeech() {
  if (hasRequiredSpeech) return speech;
  hasRequiredSpeech = 1;
  const i2 = requireAudio();
  requireLib$5();
  class e extends i2 {
    constructor(r) {
      r = typeof r == "string" ? { path: r } : r, super({ type: "speech", audio: true, ...r });
    }
  }
  return speech = e, speech;
}
var _listCacheClear, hasRequired_listCacheClear;
function require_listCacheClear() {
  if (hasRequired_listCacheClear) return _listCacheClear;
  hasRequired_listCacheClear = 1;
  function i2() {
    this.__data__ = [], this.size = 0;
  }
  return _listCacheClear = i2, _listCacheClear;
}
var eq_1, hasRequiredEq;
function requireEq() {
  if (hasRequiredEq) return eq_1;
  hasRequiredEq = 1;
  function i2(e, t) {
    return e === t || e !== e && t !== t;
  }
  return eq_1 = i2, eq_1;
}
var _assocIndexOf, hasRequired_assocIndexOf;
function require_assocIndexOf() {
  if (hasRequired_assocIndexOf) return _assocIndexOf;
  hasRequired_assocIndexOf = 1;
  var i2 = requireEq();
  function e(t, r) {
    for (var a = t.length; a--; )
      if (i2(t[a][0], r))
        return a;
    return -1;
  }
  return _assocIndexOf = e, _assocIndexOf;
}
var _listCacheDelete, hasRequired_listCacheDelete;
function require_listCacheDelete() {
  if (hasRequired_listCacheDelete) return _listCacheDelete;
  hasRequired_listCacheDelete = 1;
  var i2 = require_assocIndexOf(), e = Array.prototype, t = e.splice;
  function r(a) {
    var s = this.__data__, u = i2(s, a);
    if (u < 0)
      return false;
    var l = s.length - 1;
    return u == l ? s.pop() : t.call(s, u, 1), --this.size, true;
  }
  return _listCacheDelete = r, _listCacheDelete;
}
var _listCacheGet, hasRequired_listCacheGet;
function require_listCacheGet() {
  if (hasRequired_listCacheGet) return _listCacheGet;
  hasRequired_listCacheGet = 1;
  var i2 = require_assocIndexOf();
  function e(t) {
    var r = this.__data__, a = i2(r, t);
    return a < 0 ? void 0 : r[a][1];
  }
  return _listCacheGet = e, _listCacheGet;
}
var _listCacheHas, hasRequired_listCacheHas;
function require_listCacheHas() {
  if (hasRequired_listCacheHas) return _listCacheHas;
  hasRequired_listCacheHas = 1;
  var i2 = require_assocIndexOf();
  function e(t) {
    return i2(this.__data__, t) > -1;
  }
  return _listCacheHas = e, _listCacheHas;
}
var _listCacheSet, hasRequired_listCacheSet;
function require_listCacheSet() {
  if (hasRequired_listCacheSet) return _listCacheSet;
  hasRequired_listCacheSet = 1;
  var i2 = require_assocIndexOf();
  function e(t, r) {
    var a = this.__data__, s = i2(a, t);
    return s < 0 ? (++this.size, a.push([t, r])) : a[s][1] = r, this;
  }
  return _listCacheSet = e, _listCacheSet;
}
var _ListCache, hasRequired_ListCache;
function require_ListCache() {
  if (hasRequired_ListCache) return _ListCache;
  hasRequired_ListCache = 1;
  var i2 = require_listCacheClear(), e = require_listCacheDelete(), t = require_listCacheGet(), r = require_listCacheHas(), a = require_listCacheSet();
  function s(u) {
    var l = -1, c = u == null ? 0 : u.length;
    for (this.clear(); ++l < c; ) {
      var d = u[l];
      this.set(d[0], d[1]);
    }
  }
  return s.prototype.clear = i2, s.prototype.delete = e, s.prototype.get = t, s.prototype.has = r, s.prototype.set = a, _ListCache = s, _ListCache;
}
var _stackClear, hasRequired_stackClear;
function require_stackClear() {
  if (hasRequired_stackClear) return _stackClear;
  hasRequired_stackClear = 1;
  var i2 = require_ListCache();
  function e() {
    this.__data__ = new i2(), this.size = 0;
  }
  return _stackClear = e, _stackClear;
}
var _stackDelete, hasRequired_stackDelete;
function require_stackDelete() {
  if (hasRequired_stackDelete) return _stackDelete;
  hasRequired_stackDelete = 1;
  function i2(e) {
    var t = this.__data__, r = t.delete(e);
    return this.size = t.size, r;
  }
  return _stackDelete = i2, _stackDelete;
}
var _stackGet, hasRequired_stackGet;
function require_stackGet() {
  if (hasRequired_stackGet) return _stackGet;
  hasRequired_stackGet = 1;
  function i2(e) {
    return this.__data__.get(e);
  }
  return _stackGet = i2, _stackGet;
}
var _stackHas, hasRequired_stackHas;
function require_stackHas() {
  if (hasRequired_stackHas) return _stackHas;
  hasRequired_stackHas = 1;
  function i2(e) {
    return this.__data__.has(e);
  }
  return _stackHas = i2, _stackHas;
}
var _coreJsData, hasRequired_coreJsData;
function require_coreJsData() {
  if (hasRequired_coreJsData) return _coreJsData;
  hasRequired_coreJsData = 1;
  var i2 = require_root(), e = i2["__core-js_shared__"];
  return _coreJsData = e, _coreJsData;
}
var _isMasked, hasRequired_isMasked;
function require_isMasked() {
  if (hasRequired_isMasked) return _isMasked;
  hasRequired_isMasked = 1;
  var i2 = require_coreJsData(), e = function() {
    var r = /[^.]+$/.exec(i2 && i2.keys && i2.keys.IE_PROTO || "");
    return r ? "Symbol(src)_1." + r : "";
  }();
  function t(r) {
    return !!e && e in r;
  }
  return _isMasked = t, _isMasked;
}
var _toSource, hasRequired_toSource;
function require_toSource() {
  if (hasRequired_toSource) return _toSource;
  hasRequired_toSource = 1;
  var i2 = Function.prototype, e = i2.toString;
  function t(r) {
    if (r != null) {
      try {
        return e.call(r);
      } catch {
      }
      try {
        return r + "";
      } catch {
      }
    }
    return "";
  }
  return _toSource = t, _toSource;
}
var _baseIsNative, hasRequired_baseIsNative;
function require_baseIsNative() {
  if (hasRequired_baseIsNative) return _baseIsNative;
  hasRequired_baseIsNative = 1;
  var i2 = requireIsFunction(), e = require_isMasked(), t = requireIsObject(), r = require_toSource(), a = /[\\^$.*+?()[\]{}|]/g, s = /^\[object .+?Constructor\]$/, u = Function.prototype, l = Object.prototype, c = u.toString, d = l.hasOwnProperty, f = RegExp(
    "^" + c.call(d).replace(a, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  );
  function p(m) {
    if (!t(m) || e(m))
      return false;
    var y = i2(m) ? f : s;
    return y.test(r(m));
  }
  return _baseIsNative = p, _baseIsNative;
}
var _getValue, hasRequired_getValue;
function require_getValue() {
  if (hasRequired_getValue) return _getValue;
  hasRequired_getValue = 1;
  function i2(e, t) {
    return e == null ? void 0 : e[t];
  }
  return _getValue = i2, _getValue;
}
var _getNative, hasRequired_getNative;
function require_getNative() {
  if (hasRequired_getNative) return _getNative;
  hasRequired_getNative = 1;
  var i2 = require_baseIsNative(), e = require_getValue();
  function t(r, a) {
    var s = e(r, a);
    return i2(s) ? s : void 0;
  }
  return _getNative = t, _getNative;
}
var _Map, hasRequired_Map;
function require_Map() {
  if (hasRequired_Map) return _Map;
  hasRequired_Map = 1;
  var i2 = require_getNative(), e = require_root(), t = i2(e, "Map");
  return _Map = t, _Map;
}
var _nativeCreate, hasRequired_nativeCreate;
function require_nativeCreate() {
  if (hasRequired_nativeCreate) return _nativeCreate;
  hasRequired_nativeCreate = 1;
  var i2 = require_getNative(), e = i2(Object, "create");
  return _nativeCreate = e, _nativeCreate;
}
var _hashClear, hasRequired_hashClear;
function require_hashClear() {
  if (hasRequired_hashClear) return _hashClear;
  hasRequired_hashClear = 1;
  var i2 = require_nativeCreate();
  function e() {
    this.__data__ = i2 ? i2(null) : {}, this.size = 0;
  }
  return _hashClear = e, _hashClear;
}
var _hashDelete, hasRequired_hashDelete;
function require_hashDelete() {
  if (hasRequired_hashDelete) return _hashDelete;
  hasRequired_hashDelete = 1;
  function i2(e) {
    var t = this.has(e) && delete this.__data__[e];
    return this.size -= t ? 1 : 0, t;
  }
  return _hashDelete = i2, _hashDelete;
}
var _hashGet, hasRequired_hashGet;
function require_hashGet() {
  if (hasRequired_hashGet) return _hashGet;
  hasRequired_hashGet = 1;
  var i2 = require_nativeCreate(), e = "__lodash_hash_undefined__", t = Object.prototype, r = t.hasOwnProperty;
  function a(s) {
    var u = this.__data__;
    if (i2) {
      var l = u[s];
      return l === e ? void 0 : l;
    }
    return r.call(u, s) ? u[s] : void 0;
  }
  return _hashGet = a, _hashGet;
}
var _hashHas, hasRequired_hashHas;
function require_hashHas() {
  if (hasRequired_hashHas) return _hashHas;
  hasRequired_hashHas = 1;
  var i2 = require_nativeCreate(), e = Object.prototype, t = e.hasOwnProperty;
  function r(a) {
    var s = this.__data__;
    return i2 ? s[a] !== void 0 : t.call(s, a);
  }
  return _hashHas = r, _hashHas;
}
var _hashSet, hasRequired_hashSet;
function require_hashSet() {
  if (hasRequired_hashSet) return _hashSet;
  hasRequired_hashSet = 1;
  var i2 = require_nativeCreate(), e = "__lodash_hash_undefined__";
  function t(r, a) {
    var s = this.__data__;
    return this.size += this.has(r) ? 0 : 1, s[r] = i2 && a === void 0 ? e : a, this;
  }
  return _hashSet = t, _hashSet;
}
var _Hash, hasRequired_Hash;
function require_Hash() {
  if (hasRequired_Hash) return _Hash;
  hasRequired_Hash = 1;
  var i2 = require_hashClear(), e = require_hashDelete(), t = require_hashGet(), r = require_hashHas(), a = require_hashSet();
  function s(u) {
    var l = -1, c = u == null ? 0 : u.length;
    for (this.clear(); ++l < c; ) {
      var d = u[l];
      this.set(d[0], d[1]);
    }
  }
  return s.prototype.clear = i2, s.prototype.delete = e, s.prototype.get = t, s.prototype.has = r, s.prototype.set = a, _Hash = s, _Hash;
}
var _mapCacheClear, hasRequired_mapCacheClear;
function require_mapCacheClear() {
  if (hasRequired_mapCacheClear) return _mapCacheClear;
  hasRequired_mapCacheClear = 1;
  var i2 = require_Hash(), e = require_ListCache(), t = require_Map();
  function r() {
    this.size = 0, this.__data__ = {
      hash: new i2(),
      map: new (t || e)(),
      string: new i2()
    };
  }
  return _mapCacheClear = r, _mapCacheClear;
}
var _isKeyable, hasRequired_isKeyable;
function require_isKeyable() {
  if (hasRequired_isKeyable) return _isKeyable;
  hasRequired_isKeyable = 1;
  function i2(e) {
    var t = typeof e;
    return t == "string" || t == "number" || t == "symbol" || t == "boolean" ? e !== "__proto__" : e === null;
  }
  return _isKeyable = i2, _isKeyable;
}
var _getMapData, hasRequired_getMapData;
function require_getMapData() {
  if (hasRequired_getMapData) return _getMapData;
  hasRequired_getMapData = 1;
  var i2 = require_isKeyable();
  function e(t, r) {
    var a = t.__data__;
    return i2(r) ? a[typeof r == "string" ? "string" : "hash"] : a.map;
  }
  return _getMapData = e, _getMapData;
}
var _mapCacheDelete, hasRequired_mapCacheDelete;
function require_mapCacheDelete() {
  if (hasRequired_mapCacheDelete) return _mapCacheDelete;
  hasRequired_mapCacheDelete = 1;
  var i2 = require_getMapData();
  function e(t) {
    var r = i2(this, t).delete(t);
    return this.size -= r ? 1 : 0, r;
  }
  return _mapCacheDelete = e, _mapCacheDelete;
}
var _mapCacheGet, hasRequired_mapCacheGet;
function require_mapCacheGet() {
  if (hasRequired_mapCacheGet) return _mapCacheGet;
  hasRequired_mapCacheGet = 1;
  var i2 = require_getMapData();
  function e(t) {
    return i2(this, t).get(t);
  }
  return _mapCacheGet = e, _mapCacheGet;
}
var _mapCacheHas, hasRequired_mapCacheHas;
function require_mapCacheHas() {
  if (hasRequired_mapCacheHas) return _mapCacheHas;
  hasRequired_mapCacheHas = 1;
  var i2 = require_getMapData();
  function e(t) {
    return i2(this, t).has(t);
  }
  return _mapCacheHas = e, _mapCacheHas;
}
var _mapCacheSet, hasRequired_mapCacheSet;
function require_mapCacheSet() {
  if (hasRequired_mapCacheSet) return _mapCacheSet;
  hasRequired_mapCacheSet = 1;
  var i2 = require_getMapData();
  function e(t, r) {
    var a = i2(this, t), s = a.size;
    return a.set(t, r), this.size += a.size == s ? 0 : 1, this;
  }
  return _mapCacheSet = e, _mapCacheSet;
}
var _MapCache, hasRequired_MapCache;
function require_MapCache() {
  if (hasRequired_MapCache) return _MapCache;
  hasRequired_MapCache = 1;
  var i2 = require_mapCacheClear(), e = require_mapCacheDelete(), t = require_mapCacheGet(), r = require_mapCacheHas(), a = require_mapCacheSet();
  function s(u) {
    var l = -1, c = u == null ? 0 : u.length;
    for (this.clear(); ++l < c; ) {
      var d = u[l];
      this.set(d[0], d[1]);
    }
  }
  return s.prototype.clear = i2, s.prototype.delete = e, s.prototype.get = t, s.prototype.has = r, s.prototype.set = a, _MapCache = s, _MapCache;
}
var _stackSet, hasRequired_stackSet;
function require_stackSet() {
  if (hasRequired_stackSet) return _stackSet;
  hasRequired_stackSet = 1;
  var i2 = require_ListCache(), e = require_Map(), t = require_MapCache(), r = 200;
  function a(s, u) {
    var l = this.__data__;
    if (l instanceof i2) {
      var c = l.__data__;
      if (!e || c.length < r - 1)
        return c.push([s, u]), this.size = ++l.size, this;
      l = this.__data__ = new t(c);
    }
    return l.set(s, u), this.size = l.size, this;
  }
  return _stackSet = a, _stackSet;
}
var _Stack, hasRequired_Stack;
function require_Stack() {
  if (hasRequired_Stack) return _Stack;
  hasRequired_Stack = 1;
  var i2 = require_ListCache(), e = require_stackClear(), t = require_stackDelete(), r = require_stackGet(), a = require_stackHas(), s = require_stackSet();
  function u(l) {
    var c = this.__data__ = new i2(l);
    this.size = c.size;
  }
  return u.prototype.clear = e, u.prototype.delete = t, u.prototype.get = r, u.prototype.has = a, u.prototype.set = s, _Stack = u, _Stack;
}
var _defineProperty, hasRequired_defineProperty;
function require_defineProperty() {
  if (hasRequired_defineProperty) return _defineProperty;
  hasRequired_defineProperty = 1;
  var i2 = require_getNative(), e = function() {
    try {
      var t = i2(Object, "defineProperty");
      return t({}, "", {}), t;
    } catch {
    }
  }();
  return _defineProperty = e, _defineProperty;
}
var _baseAssignValue, hasRequired_baseAssignValue;
function require_baseAssignValue() {
  if (hasRequired_baseAssignValue) return _baseAssignValue;
  hasRequired_baseAssignValue = 1;
  var i2 = require_defineProperty();
  function e(t, r, a) {
    r == "__proto__" && i2 ? i2(t, r, {
      configurable: true,
      enumerable: true,
      value: a,
      writable: true
    }) : t[r] = a;
  }
  return _baseAssignValue = e, _baseAssignValue;
}
var _assignValue, hasRequired_assignValue;
function require_assignValue() {
  if (hasRequired_assignValue) return _assignValue;
  hasRequired_assignValue = 1;
  var i2 = require_baseAssignValue(), e = requireEq(), t = Object.prototype, r = t.hasOwnProperty;
  function a(s, u, l) {
    var c = s[u];
    (!(r.call(s, u) && e(c, l)) || l === void 0 && !(u in s)) && i2(s, u, l);
  }
  return _assignValue = a, _assignValue;
}
var _copyObject, hasRequired_copyObject;
function require_copyObject() {
  if (hasRequired_copyObject) return _copyObject;
  hasRequired_copyObject = 1;
  var i2 = require_assignValue(), e = require_baseAssignValue();
  function t(r, a, s, u) {
    var l = !s;
    s || (s = {});
    for (var c = -1, d = a.length; ++c < d; ) {
      var f = a[c], p = u ? u(s[f], r[f], f, s, r) : void 0;
      p === void 0 && (p = r[f]), l ? e(s, f, p) : i2(s, f, p);
    }
    return s;
  }
  return _copyObject = t, _copyObject;
}
var _baseAssign, hasRequired_baseAssign;
function require_baseAssign() {
  if (hasRequired_baseAssign) return _baseAssign;
  hasRequired_baseAssign = 1;
  var i2 = require_copyObject(), e = requireKeys();
  function t(r, a) {
    return r && i2(a, e(a), r);
  }
  return _baseAssign = t, _baseAssign;
}
var _nativeKeysIn, hasRequired_nativeKeysIn;
function require_nativeKeysIn() {
  if (hasRequired_nativeKeysIn) return _nativeKeysIn;
  hasRequired_nativeKeysIn = 1;
  function i2(e) {
    var t = [];
    if (e != null)
      for (var r in Object(e))
        t.push(r);
    return t;
  }
  return _nativeKeysIn = i2, _nativeKeysIn;
}
var _baseKeysIn, hasRequired_baseKeysIn;
function require_baseKeysIn() {
  if (hasRequired_baseKeysIn) return _baseKeysIn;
  hasRequired_baseKeysIn = 1;
  var i2 = requireIsObject(), e = require_isPrototype(), t = require_nativeKeysIn(), r = Object.prototype, a = r.hasOwnProperty;
  function s(u) {
    if (!i2(u))
      return t(u);
    var l = e(u), c = [];
    for (var d in u)
      d == "constructor" && (l || !a.call(u, d)) || c.push(d);
    return c;
  }
  return _baseKeysIn = s, _baseKeysIn;
}
var keysIn_1, hasRequiredKeysIn;
function requireKeysIn() {
  if (hasRequiredKeysIn) return keysIn_1;
  hasRequiredKeysIn = 1;
  var i2 = require_arrayLikeKeys(), e = require_baseKeysIn(), t = requireIsArrayLike();
  function r(a) {
    return t(a) ? i2(a, true) : e(a);
  }
  return keysIn_1 = r, keysIn_1;
}
var _baseAssignIn, hasRequired_baseAssignIn;
function require_baseAssignIn() {
  if (hasRequired_baseAssignIn) return _baseAssignIn;
  hasRequired_baseAssignIn = 1;
  var i2 = require_copyObject(), e = requireKeysIn();
  function t(r, a) {
    return r && i2(a, e(a), r);
  }
  return _baseAssignIn = t, _baseAssignIn;
}
var _cloneBuffer = { exports: {} };
_cloneBuffer.exports;
var hasRequired_cloneBuffer;
function require_cloneBuffer() {
  return hasRequired_cloneBuffer || (hasRequired_cloneBuffer = 1, function(i2, e) {
    var t = require_root(), r = e && !e.nodeType && e, a = r && true && i2 && !i2.nodeType && i2, s = a && a.exports === r, u = s ? t.Buffer : void 0, l = u ? u.allocUnsafe : void 0;
    function c(d, f) {
      if (f)
        return d.slice();
      var p = d.length, m = l ? l(p) : new d.constructor(p);
      return d.copy(m), m;
    }
    i2.exports = c;
  }(_cloneBuffer, _cloneBuffer.exports)), _cloneBuffer.exports;
}
var _copyArray, hasRequired_copyArray;
function require_copyArray() {
  if (hasRequired_copyArray) return _copyArray;
  hasRequired_copyArray = 1;
  function i2(e, t) {
    var r = -1, a = e.length;
    for (t || (t = Array(a)); ++r < a; )
      t[r] = e[r];
    return t;
  }
  return _copyArray = i2, _copyArray;
}
var _arrayFilter, hasRequired_arrayFilter;
function require_arrayFilter() {
  if (hasRequired_arrayFilter) return _arrayFilter;
  hasRequired_arrayFilter = 1;
  function i2(e, t) {
    for (var r = -1, a = e == null ? 0 : e.length, s = 0, u = []; ++r < a; ) {
      var l = e[r];
      t(l, r, e) && (u[s++] = l);
    }
    return u;
  }
  return _arrayFilter = i2, _arrayFilter;
}
var stubArray_1, hasRequiredStubArray;
function requireStubArray() {
  if (hasRequiredStubArray) return stubArray_1;
  hasRequiredStubArray = 1;
  function i2() {
    return [];
  }
  return stubArray_1 = i2, stubArray_1;
}
var _getSymbols, hasRequired_getSymbols;
function require_getSymbols() {
  if (hasRequired_getSymbols) return _getSymbols;
  hasRequired_getSymbols = 1;
  var i2 = require_arrayFilter(), e = requireStubArray(), t = Object.prototype, r = t.propertyIsEnumerable, a = Object.getOwnPropertySymbols, s = a ? function(u) {
    return u == null ? [] : (u = Object(u), i2(a(u), function(l) {
      return r.call(u, l);
    }));
  } : e;
  return _getSymbols = s, _getSymbols;
}
var _copySymbols, hasRequired_copySymbols;
function require_copySymbols() {
  if (hasRequired_copySymbols) return _copySymbols;
  hasRequired_copySymbols = 1;
  var i2 = require_copyObject(), e = require_getSymbols();
  function t(r, a) {
    return i2(r, e(r), a);
  }
  return _copySymbols = t, _copySymbols;
}
var _arrayPush, hasRequired_arrayPush;
function require_arrayPush() {
  if (hasRequired_arrayPush) return _arrayPush;
  hasRequired_arrayPush = 1;
  function i2(e, t) {
    for (var r = -1, a = t.length, s = e.length; ++r < a; )
      e[s + r] = t[r];
    return e;
  }
  return _arrayPush = i2, _arrayPush;
}
var _getPrototype, hasRequired_getPrototype;
function require_getPrototype() {
  if (hasRequired_getPrototype) return _getPrototype;
  hasRequired_getPrototype = 1;
  var i2 = require_overArg(), e = i2(Object.getPrototypeOf, Object);
  return _getPrototype = e, _getPrototype;
}
var _getSymbolsIn, hasRequired_getSymbolsIn;
function require_getSymbolsIn() {
  if (hasRequired_getSymbolsIn) return _getSymbolsIn;
  hasRequired_getSymbolsIn = 1;
  var i2 = require_arrayPush(), e = require_getPrototype(), t = require_getSymbols(), r = requireStubArray(), a = Object.getOwnPropertySymbols, s = a ? function(u) {
    for (var l = []; u; )
      i2(l, t(u)), u = e(u);
    return l;
  } : r;
  return _getSymbolsIn = s, _getSymbolsIn;
}
var _copySymbolsIn, hasRequired_copySymbolsIn;
function require_copySymbolsIn() {
  if (hasRequired_copySymbolsIn) return _copySymbolsIn;
  hasRequired_copySymbolsIn = 1;
  var i2 = require_copyObject(), e = require_getSymbolsIn();
  function t(r, a) {
    return i2(r, e(r), a);
  }
  return _copySymbolsIn = t, _copySymbolsIn;
}
var _baseGetAllKeys, hasRequired_baseGetAllKeys;
function require_baseGetAllKeys() {
  if (hasRequired_baseGetAllKeys) return _baseGetAllKeys;
  hasRequired_baseGetAllKeys = 1;
  var i2 = require_arrayPush(), e = requireIsArray();
  function t(r, a, s) {
    var u = a(r);
    return e(r) ? u : i2(u, s(r));
  }
  return _baseGetAllKeys = t, _baseGetAllKeys;
}
var _getAllKeys, hasRequired_getAllKeys;
function require_getAllKeys() {
  if (hasRequired_getAllKeys) return _getAllKeys;
  hasRequired_getAllKeys = 1;
  var i2 = require_baseGetAllKeys(), e = require_getSymbols(), t = requireKeys();
  function r(a) {
    return i2(a, t, e);
  }
  return _getAllKeys = r, _getAllKeys;
}
var _getAllKeysIn, hasRequired_getAllKeysIn;
function require_getAllKeysIn() {
  if (hasRequired_getAllKeysIn) return _getAllKeysIn;
  hasRequired_getAllKeysIn = 1;
  var i2 = require_baseGetAllKeys(), e = require_getSymbolsIn(), t = requireKeysIn();
  function r(a) {
    return i2(a, t, e);
  }
  return _getAllKeysIn = r, _getAllKeysIn;
}
var _DataView, hasRequired_DataView;
function require_DataView() {
  if (hasRequired_DataView) return _DataView;
  hasRequired_DataView = 1;
  var i2 = require_getNative(), e = require_root(), t = i2(e, "DataView");
  return _DataView = t, _DataView;
}
var _Promise, hasRequired_Promise;
function require_Promise() {
  if (hasRequired_Promise) return _Promise;
  hasRequired_Promise = 1;
  var i2 = require_getNative(), e = require_root(), t = i2(e, "Promise");
  return _Promise = t, _Promise;
}
var _Set, hasRequired_Set;
function require_Set() {
  if (hasRequired_Set) return _Set;
  hasRequired_Set = 1;
  var i2 = require_getNative(), e = require_root(), t = i2(e, "Set");
  return _Set = t, _Set;
}
var _WeakMap, hasRequired_WeakMap;
function require_WeakMap() {
  if (hasRequired_WeakMap) return _WeakMap;
  hasRequired_WeakMap = 1;
  var i2 = require_getNative(), e = require_root(), t = i2(e, "WeakMap");
  return _WeakMap = t, _WeakMap;
}
var _getTag, hasRequired_getTag;
function require_getTag() {
  if (hasRequired_getTag) return _getTag;
  hasRequired_getTag = 1;
  var i2 = require_DataView(), e = require_Map(), t = require_Promise(), r = require_Set(), a = require_WeakMap(), s = require_baseGetTag(), u = require_toSource(), l = "[object Map]", c = "[object Object]", d = "[object Promise]", f = "[object Set]", p = "[object WeakMap]", m = "[object DataView]", y = u(i2), x = u(e), g = u(t), _ = u(r), T = u(a), E = s;
  return (i2 && E(new i2(new ArrayBuffer(1))) != m || e && E(new e()) != l || t && E(t.resolve()) != d || r && E(new r()) != f || a && E(new a()) != p) && (E = function(b) {
    var C = s(b), w = C == c ? b.constructor : void 0, A = w ? u(w) : "";
    if (A)
      switch (A) {
        case y:
          return m;
        case x:
          return l;
        case g:
          return d;
        case _:
          return f;
        case T:
          return p;
      }
    return C;
  }), _getTag = E, _getTag;
}
var _initCloneArray, hasRequired_initCloneArray;
function require_initCloneArray() {
  if (hasRequired_initCloneArray) return _initCloneArray;
  hasRequired_initCloneArray = 1;
  var i2 = Object.prototype, e = i2.hasOwnProperty;
  function t(r) {
    var a = r.length, s = new r.constructor(a);
    return a && typeof r[0] == "string" && e.call(r, "index") && (s.index = r.index, s.input = r.input), s;
  }
  return _initCloneArray = t, _initCloneArray;
}
var _Uint8Array, hasRequired_Uint8Array;
function require_Uint8Array() {
  if (hasRequired_Uint8Array) return _Uint8Array;
  hasRequired_Uint8Array = 1;
  var i2 = require_root(), e = i2.Uint8Array;
  return _Uint8Array = e, _Uint8Array;
}
var _cloneArrayBuffer, hasRequired_cloneArrayBuffer;
function require_cloneArrayBuffer() {
  if (hasRequired_cloneArrayBuffer) return _cloneArrayBuffer;
  hasRequired_cloneArrayBuffer = 1;
  var i2 = require_Uint8Array();
  function e(t) {
    var r = new t.constructor(t.byteLength);
    return new i2(r).set(new i2(t)), r;
  }
  return _cloneArrayBuffer = e, _cloneArrayBuffer;
}
var _cloneDataView, hasRequired_cloneDataView;
function require_cloneDataView() {
  if (hasRequired_cloneDataView) return _cloneDataView;
  hasRequired_cloneDataView = 1;
  var i2 = require_cloneArrayBuffer();
  function e(t, r) {
    var a = r ? i2(t.buffer) : t.buffer;
    return new t.constructor(a, t.byteOffset, t.byteLength);
  }
  return _cloneDataView = e, _cloneDataView;
}
var _cloneRegExp, hasRequired_cloneRegExp;
function require_cloneRegExp() {
  if (hasRequired_cloneRegExp) return _cloneRegExp;
  hasRequired_cloneRegExp = 1;
  var i2 = /\w*$/;
  function e(t) {
    var r = new t.constructor(t.source, i2.exec(t));
    return r.lastIndex = t.lastIndex, r;
  }
  return _cloneRegExp = e, _cloneRegExp;
}
var _cloneSymbol, hasRequired_cloneSymbol;
function require_cloneSymbol() {
  if (hasRequired_cloneSymbol) return _cloneSymbol;
  hasRequired_cloneSymbol = 1;
  var i2 = require_Symbol(), e = i2 ? i2.prototype : void 0, t = e ? e.valueOf : void 0;
  function r(a) {
    return t ? Object(t.call(a)) : {};
  }
  return _cloneSymbol = r, _cloneSymbol;
}
var _cloneTypedArray, hasRequired_cloneTypedArray;
function require_cloneTypedArray() {
  if (hasRequired_cloneTypedArray) return _cloneTypedArray;
  hasRequired_cloneTypedArray = 1;
  var i2 = require_cloneArrayBuffer();
  function e(t, r) {
    var a = r ? i2(t.buffer) : t.buffer;
    return new t.constructor(a, t.byteOffset, t.length);
  }
  return _cloneTypedArray = e, _cloneTypedArray;
}
var _initCloneByTag, hasRequired_initCloneByTag;
function require_initCloneByTag() {
  if (hasRequired_initCloneByTag) return _initCloneByTag;
  hasRequired_initCloneByTag = 1;
  var i2 = require_cloneArrayBuffer(), e = require_cloneDataView(), t = require_cloneRegExp(), r = require_cloneSymbol(), a = require_cloneTypedArray(), s = "[object Boolean]", u = "[object Date]", l = "[object Map]", c = "[object Number]", d = "[object RegExp]", f = "[object Set]", p = "[object String]", m = "[object Symbol]", y = "[object ArrayBuffer]", x = "[object DataView]", g = "[object Float32Array]", _ = "[object Float64Array]", T = "[object Int8Array]", E = "[object Int16Array]", b = "[object Int32Array]", C = "[object Uint8Array]", w = "[object Uint8ClampedArray]", A = "[object Uint16Array]", S = "[object Uint32Array]";
  function F(M, U, B) {
    var q = M.constructor;
    switch (U) {
      case y:
        return i2(M);
      case s:
      case u:
        return new q(+M);
      case x:
        return e(M, B);
      case g:
      case _:
      case T:
      case E:
      case b:
      case C:
      case w:
      case A:
      case S:
        return a(M, B);
      case l:
        return new q();
      case c:
      case p:
        return new q(M);
      case d:
        return t(M);
      case f:
        return new q();
      case m:
        return r(M);
    }
  }
  return _initCloneByTag = F, _initCloneByTag;
}
var _baseCreate, hasRequired_baseCreate;
function require_baseCreate() {
  if (hasRequired_baseCreate) return _baseCreate;
  hasRequired_baseCreate = 1;
  var i2 = requireIsObject(), e = Object.create, t = /* @__PURE__ */ function() {
    function r() {
    }
    return function(a) {
      if (!i2(a))
        return {};
      if (e)
        return e(a);
      r.prototype = a;
      var s = new r();
      return r.prototype = void 0, s;
    };
  }();
  return _baseCreate = t, _baseCreate;
}
var _initCloneObject, hasRequired_initCloneObject;
function require_initCloneObject() {
  if (hasRequired_initCloneObject) return _initCloneObject;
  hasRequired_initCloneObject = 1;
  var i2 = require_baseCreate(), e = require_getPrototype(), t = require_isPrototype();
  function r(a) {
    return typeof a.constructor == "function" && !t(a) ? i2(e(a)) : {};
  }
  return _initCloneObject = r, _initCloneObject;
}
var _baseIsMap, hasRequired_baseIsMap;
function require_baseIsMap() {
  if (hasRequired_baseIsMap) return _baseIsMap;
  hasRequired_baseIsMap = 1;
  var i2 = require_getTag(), e = requireIsObjectLike(), t = "[object Map]";
  function r(a) {
    return e(a) && i2(a) == t;
  }
  return _baseIsMap = r, _baseIsMap;
}
var isMap_1, hasRequiredIsMap;
function requireIsMap() {
  if (hasRequiredIsMap) return isMap_1;
  hasRequiredIsMap = 1;
  var i2 = require_baseIsMap(), e = require_baseUnary(), t = require_nodeUtil(), r = t && t.isMap, a = r ? e(r) : i2;
  return isMap_1 = a, isMap_1;
}
var _baseIsSet, hasRequired_baseIsSet;
function require_baseIsSet() {
  if (hasRequired_baseIsSet) return _baseIsSet;
  hasRequired_baseIsSet = 1;
  var i2 = require_getTag(), e = requireIsObjectLike(), t = "[object Set]";
  function r(a) {
    return e(a) && i2(a) == t;
  }
  return _baseIsSet = r, _baseIsSet;
}
var isSet_1, hasRequiredIsSet;
function requireIsSet() {
  if (hasRequiredIsSet) return isSet_1;
  hasRequiredIsSet = 1;
  var i2 = require_baseIsSet(), e = require_baseUnary(), t = require_nodeUtil(), r = t && t.isSet, a = r ? e(r) : i2;
  return isSet_1 = a, isSet_1;
}
var _baseClone, hasRequired_baseClone;
function require_baseClone() {
  if (hasRequired_baseClone) return _baseClone;
  hasRequired_baseClone = 1;
  var i2 = require_Stack(), e = require_arrayEach(), t = require_assignValue(), r = require_baseAssign(), a = require_baseAssignIn(), s = require_cloneBuffer(), u = require_copyArray(), l = require_copySymbols(), c = require_copySymbolsIn(), d = require_getAllKeys(), f = require_getAllKeysIn(), p = require_getTag(), m = require_initCloneArray(), y = require_initCloneByTag(), x = require_initCloneObject(), g = requireIsArray(), _ = requireIsBuffer(), T = requireIsMap(), E = requireIsObject(), b = requireIsSet(), C = requireKeys(), w = requireKeysIn(), A = 1, S = 2, F = 4, M = "[object Arguments]", U = "[object Array]", B = "[object Boolean]", q = "[object Date]", z = "[object Error]", D = "[object Function]", X = "[object GeneratorFunction]", k = "[object Map]", I = "[object Number]", P = "[object Object]", G = "[object RegExp]", W = "[object Set]", V = "[object String]", K = "[object Symbol]", J = "[object WeakMap]", ae = "[object ArrayBuffer]", re = "[object DataView]", he = "[object Float32Array]", ge = "[object Float64Array]", me = "[object Int8Array]", Te = "[object Int16Array]", _e = "[object Int32Array]", ye = "[object Uint8Array]", Ae = "[object Uint8ClampedArray]", ke = "[object Uint16Array]", Pe = "[object Uint32Array]", Ee = {};
  Ee[M] = Ee[U] = Ee[ae] = Ee[re] = Ee[B] = Ee[q] = Ee[he] = Ee[ge] = Ee[me] = Ee[Te] = Ee[_e] = Ee[k] = Ee[I] = Ee[P] = Ee[G] = Ee[W] = Ee[V] = Ee[K] = Ee[ye] = Ee[Ae] = Ee[ke] = Ee[Pe] = true, Ee[z] = Ee[D] = Ee[J] = false;
  function Oe($e, gt, xt, vt, Xe, at) {
    var ct, Rt = gt & A, It = gt & S, er = gt & F;
    if (xt && (ct = Xe ? xt($e, vt, Xe, at) : xt($e)), ct !== void 0)
      return ct;
    if (!E($e))
      return $e;
    var $ = g($e);
    if ($) {
      if (ct = m($e), !Rt)
        return u($e, ct);
    } else {
      var Y = p($e), ee = Y == D || Y == X;
      if (_($e))
        return s($e, Rt);
      if (Y == P || Y == M || ee && !Xe) {
        if (ct = It || ee ? {} : x($e), !Rt)
          return It ? c($e, a(ct, $e)) : l($e, r(ct, $e));
      } else {
        if (!Ee[Y])
          return Xe ? $e : {};
        ct = y($e, Y, Rt);
      }
    }
    at || (at = new i2());
    var be = at.get($e);
    if (be)
      return be;
    at.set($e, ct), b($e) ? $e.forEach(function(je) {
      ct.add(Oe(je, gt, xt, je, $e, at));
    }) : T($e) && $e.forEach(function(je, pt) {
      ct.set(pt, Oe(je, gt, xt, pt, $e, at));
    });
    var Se = er ? It ? f : d : It ? w : C, Ne = $ ? void 0 : Se($e);
    return e(Ne || $e, function(je, pt) {
      Ne && (pt = je, je = $e[pt]), t(ct, pt, Oe(je, gt, xt, pt, $e, at));
    }), ct;
  }
  return _baseClone = Oe, _baseClone;
}
var clone_1, hasRequiredClone;
function requireClone() {
  if (hasRequiredClone) return clone_1;
  hasRequiredClone = 1;
  var i2 = require_baseClone(), e = 4;
  function t(r) {
    return i2(r, e);
  }
  return clone_1 = t, clone_1;
}
var task, hasRequiredTask;
function requireTask() {
  if (hasRequiredTask) return task;
  hasRequiredTask = 1;
  const i2 = requireClone(), e = requireForEach(), t = requireUtils();
  class r {
    constructor() {
      this.queue = [], this.storeData = {};
    }
    /**
     * Add a subtask to the end of the task queue
     * @param {function} task - a task handler function
     * @return {string} task id
     * @public
     */
    push({ task: s, params: u = {} }) {
      const l = t.genUuid(), c = { ...u, taskId: l };
      return this.queue.push({ id: l, task: s, params: c, state: "waiting", file: null }), l;
    }
    /**
     * Delete a task from the task queue
     * @param {object} taskObj - a task config object
     * @return {number} the task index
     * @public
     */
    remove(s) {
      const u = this.queue.indexOf(s);
      return u > -1 && this.queue.splice(u, 1), u;
    }
    /**
     * Clear all tasks in the queue
     * @public
     */
    clear() {
      e(this.queue, (s) => t.destroyObj(s)), this.queue.length = 0;
    }
    /**
     * Store all make complete data
     * @public
     */
    store(s) {
      const u = this.getTaskById(s);
      if (!u) return;
      const l = i2(u);
      this.storeData[s] = l, setTimeout(() => {
        delete this.storeData[s];
      }, 15 * 60 * 1e3);
    }
    getLength() {
      return this.queue.length;
    }
    /**
     * Get the status of a task by id
     * @public
     */
    getTaskState(s) {
      const u = this.getTaskById(s);
      return u ? u.state : "unknown";
    }
    /**
     * Get the result file by id
     * @public
     */
    getResultFile(s) {
      const u = this.getTaskById(s);
      return u ? u.file : null;
    }
    /**
     * Get the task from queue
     * @public
     */
    getTaskById(s) {
      for (let u = 0; u < this.queue.length; u++) {
        const l = this.queue[u];
        if (s === l.id) return l;
      }
      for (let u in this.storeData) {
        const l = this.storeData[u];
        if (s === l.id) return l;
      }
      return null;
    }
    /**
     * Get a task by index
     * @public
     */
    getTaskByIndex(s) {
      return s < this.queue.length ? this.queue[s] : null;
    }
  }
  return task = r, task;
}
var progress, hasRequiredProgress;
function requireProgress() {
  if (hasRequiredProgress) return progress;
  hasRequiredProgress = 1;
  class i2 {
    constructor(t = 60) {
      this.id = -1, this.ids = [], this.percent = 0, this.max = t;
    }
    add(t) {
      this.ids.push(t), this.ids.length > this.max && this.ids.shift();
    }
    getPercent(t) {
      return this.id == t ? this.percent : this.ids.indexOf(t) > -1 ? 1 : 0;
    }
  }
  return progress = i2, progress;
}
var center, hasRequiredCenter;
function requireCenter() {
  if (hasRequiredCenter) return center;
  hasRequiredCenter = 1;
  const i2 = requireUtil$1(), e = requireEventemitter3(), t = requireTask(), r = requireProgress(), a = requireUtils(), s = requireLogger(), { nodeRequire: u } = requireUtils(), l = u("../utils/ffmpeg");
  return center = {
    cursor: 0,
    num: 0,
    delay: 500,
    state: "free",
    temps: {},
    progress: new r(),
    event: new e(),
    taskQueue: new t(),
    /**
     * Close logger switch
     * @public
     */
    closeLog() {
      s.enable = false;
    },
    /**
     * Open logger switch
     * @public
     */
    openLog() {
      s.enable = true;
    },
    /**
     * Add a production task
     * @param {function} task - a production task
     * @public
     */
    addTask(c) {
      const d = this.taskQueue.push({ task: c });
      return this.state === "free" && this.start(), d;
    },
    /**
     * Add a production task by template
     * @param {string} tempid - a template id
     * @public
     */
    addTaskByTemplate(c, d) {
      const f = this.temps[c], p = this.taskQueue.push({ task: f, params: d });
      return this.state === "free" && this.start(), p;
    },
    /**
     * Listen to production task events
     * @param {string} id - a task id
     * @param {strint} eventName - task name
     * @param {function} func - task event handler
     * @public
     */
    onTask(c, d, f) {
      const p = (m) => {
        m.id == c && (this.event.removeListener(d, p), f(m));
      };
      this.event.on(d, p);
    },
    removeTaskObj(c, d) {
      (c === "single-error" || c === "single-complete") && setTimeout(() => {
        const { taskObj: f } = d;
        this.taskQueue.remove(f);
      }, 5e3);
    },
    /**
     * Listen to production task Error events
     * @param {string} id - a task id
     * @param {function} func - task event handler
     * @public
     */
    onTaskError(c, d) {
      this.onTask(c, "single-error", d);
    },
    /**
     * Listen to production task Complete events
     * @param {string} id - a task id
     * @param {function} func - task event handler
     * @public
     */
    onTaskComplete(c, d) {
      this.onTask(c, "single-complete", d);
    },
    /**
     * Start a task
     * @async
     * @public
     */
    async start() {
      const c = this.taskQueue.getTaskByIndex(this.cursor);
      this.execTask(c);
    },
    /**
     * Get the status of a task by id
     * @public
     */
    getTaskState(c) {
      return this.taskQueue.getTaskState(c);
    },
    getInfo() {
      const { cursor: c, num: d } = this, f = this.taskQueue.getLength();
      return { num: d, cursor: c, tasks: f };
    },
    getResultFile(c) {
      return this.taskQueue.getResultFile(c);
    },
    getProgress(c) {
      return this.progress.getPercent(c);
    },
    async execTask(c) {
      this.state = "busy";
      try {
        this.num++, this.cursor++;
        const { task: d, params: f } = c, p = await d(f);
        p ? this.initCreator(p, c) : this.handlingError({
          taskObj: c,
          error: "execTask: await taskObj.task(taskObj.id) return null"
        });
      } catch (d) {
        this.handlingError({ taskObj: c, error: d });
      }
    },
    initCreator(c, d) {
      c.inCenter = true, c.generateOutput(), c.on("start", () => {
        const f = { id: d.id, taskObj: d };
        this.event.emit("single-start", f);
      }), c.on("error", (f) => {
        this.handlingError({ taskObj: d, error: f });
      }), c.on("progress", (f) => {
        this.progress.id = d.id, this.progress.state = f.state, this.progress.percent = f.percent;
      }), c.on("complete", () => {
        try {
          const { id: f } = d, p = c.getFile();
          d.state = "complete", d.file = p, this.progress.add(f), this.taskQueue.store(f);
          const m = { id: f, file: p, taskObj: d };
          this.event.emit("single-complete", m), s.info(`Creator production completed. id:${f} file: ${p}`);
        } catch (f) {
          s.error(`Creator production error. ${i2.inspect(f)}`);
        }
        setTimeout(this.nextTask.bind(this), this.delay);
      });
    },
    handlingError({ taskObj: c, error: d = "normal" }) {
      d = a.getErrStack(d);
      const f = { id: c.id, taskObj: c, error: d };
      c.state = "error", this.event.emit("single-error", f), setTimeout(this.nextTask.bind(this), this.delay), s.error(`Creator production error. ${i2.inspect(d)}`);
    },
    nextTask() {
      if (this.cursor >= this.taskQueue.getLength()) {
        this.resetTasks(), this.event.emit("all-complete");
        return;
      }
      const c = this.taskQueue.getTaskByIndex(this.cursor);
      this.execTask(c);
    },
    resetTasks() {
      this.cursor = 0, this.state = "free", this.taskQueue.clear();
    },
    /**
     * add a creator task template
     *
     * @param {string} id - task template id name
     * @param {function} taskFunc - task template
     * @public
     */
    createTemplate(c, d) {
      this.temps[c] = d;
    },
    /**
     * Set the installation path of the current server ffmpeg.
     * If not set, the ffmpeg command of command will be found by default.
     *
     * @param {string} path - installation path of the current server ffmpeg
     * @public
     */
    setFFmpegPath(c) {
      l.setFFmpegPath(c);
    },
    /**
     * Set the installation path of the current server ffprobe.
     * If not set, the ffprobe command of command will be found by default.
     *
     * @param {string} path - installation path of the current server ffprobe
     * @public
     */
    setFFprobePath(c) {
      l.setFFprobePath(c);
    }
  }, center;
}
var lib, hasRequiredLib;
function requireLib() {
  if (hasRequiredLib) return lib;
  hasRequiredLib = 1;
  /*!
   * FFCreator - a lightweight and flexible short video production library
   * Copyright(c) TNFE Team
   *
   * Licensed under the MIT license:
   * http://www.opensource.org/licenses/mit-license.php
   */
  const { isBrowser: i2 } = requireLib$5(), e = requireLib$2(), t = requireCreator(), r = requireSpine(), a = requireTransition(), s = requireNode(), u = requireGraphic(), l = requireCover(), c = requireText(), d = requireMixin(), f = requireImage(), p = requireVideo(), m = requireScene(), y = requireExtras(), x = requireFilter(), g = requireGif(), _ = requireAudio(), T = requireSpeech(), E = requireLogger(), b = requireCenter(), C = {
    canvas: t,
    spine: r,
    trans: a,
    scene: m,
    node: s,
    text: c,
    mixin: d,
    image: f,
    video: p,
    audio: _,
    speech: T,
    gif: g,
    graph: u,
    cover: l,
    filter: x
  };
  return lib = {
    InkPaint: e,
    TYPES: C,
    Factory: {
      debug: false,
      cacheNode: null,
      parseAttribute(w, A) {
        const { type: S, children: F, ...M } = w;
        for (let U of F)
          M[U.type] = this.parseAttribute(U, M[U.type]);
        return A && Array.isArray(A) && A.length > 0 ? (A.push(M), A) : A ? [A, M] : M;
      },
      nodeClass(w) {
        return C[w] || (w.startsWith("mixin-") ? d : null);
      },
      fromJson(w, A, S, F) {
        const { type: M, children: U = [], ...B } = w;
        M == "canvas" && (B.canvasWidth = B.width, B.canvasHeight = B.height), this.debug && M == "canvas" && (B.log = true);
        for (let D of U)
          this.nodeClass(D.type) || (B[D.type] = this.parseAttribute(D, B[D.type]));
        F && (B.parent = F);
        const q = this.nodeClass(M);
        q === d && (B.mixin = M.replace("mixin-", ""));
        const z = new q({ ...B, _type: M });
        if (!(!i2 && !z.active && !U.length)) {
          for (let D of U)
            this.nodeClass(D.type) && (D.canvasWidth = B.canvasWidth, D.canvasHeight = B.canvasHeight, this.fromJson(D, A, S, z));
          return this.cacheNode && A.push(this.cacheNode(z, S)), z;
        }
      },
      genNode(w, A, S) {
        const F = [];
        return { node: this.fromJson({ ...w, ...A }, F, S), cache: Promise.all(F) };
      },
      fromXml(w, A, S) {
        const { parseXml: F } = requireXml(), M = F(w);
        this.debug && console.log("parser xml -> json", M);
        const { name: U, author: B, description: q, mns: z } = M, D = { ...M.children[0], name: U, author: B, description: q, mns: z };
        return this.genNode(D, A, S);
      },
      from(w, A, S = null) {
        if (typeof w == "string" && w.includes("<miraml"))
          return this.fromXml(w, A, S);
        if (typeof w == "string" && w.trim().startsWith("{") && (w = JSON.parse(w)), w instanceof Object && w.type === "canvas")
          return this.genNode(w, A, S);
        throw new Error("invalid value");
      }
    },
    FFCreator: t,
    FFSpine: r,
    FFNode: s,
    FFGraphic: u,
    FFFilter: x,
    FFMixin: d,
    FFText: c,
    FFImage: f,
    FFVideo: p,
    FFScene: m,
    FFAudio: _,
    FFExtras: y,
    FFGifImage: g,
    FFCover: l,
    FFTransition: a,
    FFLogger: E,
    FFCreatorCenter: b
  }, lib;
}
var libExports = requireLib();
const FFCreator = /* @__PURE__ */ getDefaultExportFromCjs(libExports), IconCreator = {
  DEFAULT_ICON_CONFIGS: iconTheme,
  IconConverter,
  IconWrapper: createIcon
};
var iconTheme = {
  size: "1em",
  strokeWidth: 4,
  strokeLinecap: "round",
  strokeLinejoin: "round",
  rtl: false,
  theme: "outline",
  colors: {
    outline: {
      fill: "#333",
      background: "transparent"
    },
    filled: {
      fill: "#333",
      background: "#FFF"
    },
    twoTone: {
      fill: "#333",
      twoTone: "#2F88FF"
    },
    multiColor: {
      outStrokeColor: "#333",
      outFillColor: "#2F88FF",
      innerStrokeColor: "#FFF",
      innerFillColor: "#43CCF8"
    }
  },
  prefix: "i"
};
function IconConverter(i2, e, t) {
  var r = typeof e.fill == "string" ? [e.fill] : e.fill || [], a = [];
  switch (e.theme || t.theme) {
    case "outline":
      a.push(
        typeof r[0] == "string" ? r[0] : "currentColor"
      ), a.push("none"), a.push(
        typeof r[0] == "string" ? r[0] : "currentColor"
      ), a.push("none");
      break;
    case "filled":
      a.push(
        typeof r[0] == "string" ? r[0] : "currentColor"
      ), a.push(
        typeof r[0] == "string" ? r[0] : "currentColor"
      ), a.push("#FFF"), a.push("#FFF");
      break;
    case "two-tone":
      a.push(
        typeof r[0] == "string" ? r[0] : "currentColor"
      ), a.push(
        typeof r[1] == "string" ? r[1] : t.colors.twoTone.twoTone
      ), a.push(
        typeof r[0] == "string" ? r[0] : "currentColor"
      ), a.push(
        typeof r[1] == "string" ? r[1] : t.colors.twoTone.twoTone
      );
      break;
    case "multi-color":
      a.push(
        typeof r[0] == "string" ? r[0] : "currentColor"
      ), a.push(
        typeof r[1] == "string" ? r[1] : t.colors.multiColor.outFillColor
      ), a.push(
        typeof r[2] == "string" ? r[2] : t.colors.multiColor.innerStrokeColor
      ), a.push(
        typeof r[3] == "string" ? r[3] : t.colors.multiColor.innerFillColor
      );
  }
  return {
    size: e.size || t.size,
    strokeWidth: e.strokeWidth || t.strokeWidth,
    strokeLinecap: e.strokeLinecap || t.strokeLinecap,
    strokeLinejoin: e.strokeLinejoin || t.strokeLinejoin,
    colors: a,
    id: i2
  };
}
function createIcon(i2, e, t) {
  return {
    name: "icon-" + i2,
    inject: {
      ICON_CONFIGS: {
        default: iconTheme
      }
    },
    props: [
      "size",
      "strokeWidth",
      "strokeLinecap",
      "strokeLinejoin",
      "theme",
      "fill",
      "spin"
    ],
    data() {
      return {
        id: "icon-" + ((1 + Math.random()) * 4294967296 | 0).toString(16).substring(1)
      };
    },
    inheritAttrs: false,
    render(r) {
      var a = this.size, s = this.strokeWidth, u = this.strokeLinecap, l = this.strokeLinejoin, c = this.theme, d = this.fill, f = this.id, p = this.spin, m = this.ICON_CONFIGS, y = m === void 0 ? iconTheme : m, x = IconConverter(
        f,
        {
          size: a,
          strokeWidth: s,
          strokeLinecap: u,
          strokeLinejoin: l,
          theme: c,
          fill: d
        },
        y
      ), g = [y.prefix + "-icon"];
      return g.push(y.prefix + "-icon-" + i2), e && y.rtl && g.push(y.prefix + "-icon-rtl"), p && g.push(y.prefix + "-icon-spin"), r(
        "span",
        {
          class: g.join(" "),
          on: this.$listeners,
          attrs: this.$attrs
        },
        [t(r, x)]
      );
    }
  };
}
let { IconWrapper: IconWrapper$2 } = IconCreator;
const PlayOne = IconWrapper$2(
  "play-one",
  true,
  function(i2, e) {
    return i2(
      "svg",
      {
        attrs: {
          width: e.size,
          height: e.size,
          viewBox: "0 0 48 48",
          fill: "none"
        }
      },
      [
        i2("path", {
          attrs: {
            d: "M15 24V11.8756L25.5 17.9378L36 24L25.5 30.0622L15 36.1244V24Z",
            fill: e.colors[1],
            stroke: e.colors[0],
            "stroke-width": e.strokeWidth,
            "stroke-linejoin": e.strokeLinejoin
          }
        })
      ]
    );
  }
);
let { IconWrapper: IconWrapper$1 } = IconCreator;
const Pause = IconWrapper$1(
  "pause",
  true,
  function(i2, e) {
    return i2(
      "svg",
      {
        attrs: {
          width: e.size,
          height: e.size,
          viewBox: "0 0 48 48",
          fill: "none"
        }
      },
      [
        i2("path", {
          attrs: {
            d: "M16 12V36",
            stroke: e.colors[0],
            "stroke-width": e.strokeWidth,
            "stroke-linecap": e.strokeLinecap,
            "stroke-linejoin": e.strokeLinejoin
          }
        }),
        i2("path", {
          attrs: {
            d: "M32 12V36",
            stroke: e.colors[0],
            "stroke-width": e.strokeWidth,
            "stroke-linecap": e.strokeLinecap,
            "stroke-linejoin": e.strokeLinejoin
          }
        })
      ]
    );
  }
);
let { IconWrapper } = IconCreator;
const ErrorComponent = IconWrapper(
  "error",
  false,
  function(i2, e) {
    return i2(
      "svg",
      {
        attrs: {
          width: e.size,
          height: e.size,
          viewBox: "0 0 48 48",
          fill: "none"
        }
      },
      [
        i2("path", {
          attrs: {
            "fill-rule": "evenodd",
            "clip-rule": "evenodd",
            d: "M6 11L11 6L24 19L37 6L42 11L29 24L42 37L37 42L24 29L11 42L6 37L19 24L6 11Z",
            fill: e.colors[1],
            stroke: e.colors[0],
            "stroke-width": e.strokeWidth,
            "stroke-linecap": e.strokeLinecap,
            "stroke-linejoin": e.strokeLinejoin
          }
        })
      ]
    );
  }
);
var trimRegex = /^\s+|\s+$/g, isHexInteger = /^[-+]0x[0-9a-f]+$/i, isOctalInt = /^0b[01]+$/i, isOctal = /^0o[0-7]+$/i, parseToInt = parseInt, currentSelf = typeof self == "object" && self && self.Object === Object && self, fallbackParse = window || currentSelf || Function("return this")(), isFunctionOrO = Object.prototype.toString, max = Math.max, findSmaller = Math.min;
function getNow() {
  return fallbackParse.Date.now();
}
function isObjectOrFn(i2) {
  var e = typeof i2;
  return !!i2 && (e == "object" || e == "function");
}
function toNumber(i2) {
  if (typeof i2 == "number")
    return i2;
  if (function(r) {
    return typeof r == "symbol" || /* @__PURE__ */ function(a) {
      return !!a && typeof a == "object";
    }(r) && isFunctionOrO.call(r) == "[object Symbol]";
  }(i2))
    return NaN;
  if (isObjectOrFn(i2)) {
    var e = typeof i2.valueOf == "function" ? i2.valueOf() : i2;
    isObjectOrFn(e) ? i2 = e + "" : i2 = e;
  }
  if (typeof i2 != "string")
    return i2 === 0 ? i2 : +i2;
  i2 = i2.replace(trimRegex, "");
  var t = isOctalInt.test(i2);
  return t || isOctal.test(i2) ? parseToInt(i2.slice(2), t ? 2 : 8) : isHexInteger.test(i2) ? NaN : +i2;
}
function togglePlay(i2, e, t) {
  var r, a, s, u, l, c, d = 0, f = false, p = false, m = true;
  if (typeof i2 != "function")
    throw new TypeError("Expected a function");
  function y(b) {
    var C = r, w = a;
    return r = a = void 0, d = b, u = i2.apply(w, C);
  }
  function x(b) {
    return d = b, l = setTimeout(_, e), f ? y(b) : u;
  }
  function g(b) {
    var C = b - c;
    return c === void 0 || C >= e || C < 0 || p && b - d >= s;
  }
  function _() {
    var b = getNow();
    if (g(b))
      return T(b);
    l = setTimeout(
      _,
      function(C) {
        var w = e - (C - c);
        return p ? findSmaller(
          w,
          s - (C - d)
        ) : w;
      }(b)
    );
  }
  function T(b) {
    return l = void 0, m && r ? y(b) : (r = a = void 0, u);
  }
  function E() {
    var b = getNow(), C = g(b);
    if (r = arguments, a = this, c = b, C) {
      if (l === void 0)
        return x(c);
      if (p)
        return l = setTimeout(_, e), y(c);
    }
    return l === void 0 && (l = setTimeout(_, e)), u;
  }
  return e = toNumber(e) || 0, isObjectOrFn(t) && (f = !!t.leading, (p = "maxWait" in t) ? s = max(toNumber(t.maxWait) || 0, e) : s = s, "trailing" in t ? m = !!t.trailing : m = m), E.cancel = function() {
    l !== void 0 && clearTimeout(l), d = 0, r = c = a = l = void 0;
  }, E.flush = function() {
    return l === void 0 ? u : T(getNow());
  }, E;
}
function n(i2, e, t, r, a, s, u, l) {
  var c = typeof i2 == "function" ? i2.options : i2;
  return c.render = e, c.staticRenderFns = t, c._compiled = true, c._scopeId = "data-v-" + s, {
    exports: i2,
    options: c
  };
}
function insertStyleElement(i2) {
  const e = document.createElement("style");
  return i2.setAttributes(e, i2.attributes), i2.insert(e, i2.options), e;
}
function domAPI(i2) {
  const e = i2.insertStyleElement(i2);
  return {
    update: function(t) {
      let r = "";
      t.supports && (r += `@supports (${t.supports}) {`), t.media && (r += `@media ${t.media} {`);
      const a = t.layer !== void 0;
      a && (r += `@layer${t.layer.length > 0 ? ` ${t.layer}` : ""} {`), r += t.css, a && (r += "}"), t.media && (r += "}"), t.supports && (r += "}");
      const s = t.sourceMap;
      s && typeof btoa < "u" && (r += `
/*# sourceMappingURL=data:application/json;base64,${btoa(
        unescape(encodeURIComponent(JSON.stringify(s)))
      )} */`), i2.styleTagTransform(r, e, i2.options);
    },
    remove: function() {
      e.parentNode && e.parentNode.removeChild(e);
    }
  };
}
function styleTagTransform(i2, e) {
  if (e.styleSheet)
    e.styleSheet.cssText = i2;
  else {
    for (; e.firstChild; )
      e.removeChild(e.firstChild);
    e.appendChild(document.createTextNode(i2));
  }
}
function setAttributes(i2, e) {
  Object.keys(e).forEach((t) => {
    i2.setAttribute(t, e[t]);
  });
}
const styleTargets = {};
function insert(i2, e) {
  const t = ((r) => {
    if (styleTargets[r] === void 0) {
      let a = document.querySelector(r);
      if (window.HTMLIFrameElement && a instanceof window.HTMLIFrameElement)
        try {
          a = a.contentDocument.head;
        } catch {
          a = null;
        }
      styleTargets[r] = a;
    }
    return styleTargets[r];
  })(i2);
  if (!t)
    throw new Error(
      "Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid."
    );
  t.appendChild(e);
}
function createStyleOption(i2 = {}) {
  const e = {
    attributes: { mira: "player" },
    ...i2
  };
  return e.styleTagTransform = styleTagTransform, e.setAttributes = setAttributes, e.insert = insert.bind(null, "head"), e.domAPI = domAPI, e.insertStyleElement = insertStyleElement, e;
}
const styleCache = [];
function findStyleIndex(i2) {
  for (let e = 0; e < styleCache.length; e++)
    if (styleCache[e].identifier === i2)
      return e;
  return -1;
}
function updateStyles(i2, e) {
  const t = [], r = {};
  for (let a = 0; a < i2.length; a++) {
    const s = i2[a], u = e.base ? s[0] + e.base : s[0], l = r[u] || 0, c = `${u} ${l}`;
    r[u] = l + 1;
    const d = {
      css: s[1],
      media: s[2],
      sourceMap: s[3],
      supports: s[4],
      layer: s[5]
    }, f = findStyleIndex(c);
    if (f !== -1)
      styleCache[f].references++, styleCache[f].updater(d);
    else {
      const p = createStyleUpdater(d, e);
      e.byIndex = a, styleCache.splice(a, 0, { identifier: c, updater: p, references: 1 });
    }
    t.push(c);
  }
  return t;
}
function createStyleUpdater(i2, e) {
  const t = e.domAPI(e);
  return t.update(i2), function(r) {
    if (r) {
      if (r.css === i2.css && r.media === i2.media && r.sourceMap === i2.sourceMap && r.supports === i2.supports && r.layer === i2.layer)
        return;
      t.update(i2 = r);
    } else
      t.remove();
  };
}
function createStyleManager(i2, e) {
  i2 = i2 || [], e = e || {};
  let t = updateStyles(i2, e);
  return function(r) {
    r = r || [];
    for (let s = 0; s < t.length; s++) {
      const u = findStyleIndex(t[s]);
      u !== -1 && styleCache[u].references--;
    }
    const a = updateStyles(r, e);
    for (let s = 0; s < t.length; s++) {
      const u = findStyleIndex(t[s]);
      u !== -1 && styleCache[u].references === 0 && (styleCache[u].updater(), styleCache.splice(u, 1));
    }
    t = a;
  };
}
function extractCss(i2) {
  return i2[1];
}
function createStyleListInner(i2) {
  const e = [];
  return e.toString = function() {
    return this.map((t) => {
      let r = "";
      return t[4] && (r += `@supports (${t[4]}) {`), t[2] && (r += `@media ${t[2]} {`), t[5] !== void 0 && (r += `@layer${t[5].length > 0 ? ` ${t[5]}` : ""} {`), r += i2(t), t[5] !== void 0 && (r += "}"), t[2] && (r += "}"), t[4] && (r += "}"), r;
    }).join("");
  }, e.i = function(t, r, a, s, u) {
    typeof t == "string" && (t = [[null, t, void 0]]);
    const l = {};
    if (s)
      for (let c = 0; c < this.length; c++) {
        const d = this[c][0];
        d !== null && (l[d] = true);
      }
    for (let c = 0; c < t.length; c++) {
      const d = [...t[c]];
      (!s || !l[d[0]]) && (u !== void 0 && (d[5] !== void 0 && (d[1] = `@layer${d[5].length > 0 ? ` ${d[5]}` : ""} {${d[1]}}`), d[5] = u), r && (d[2] && (d[1] = `@media ${d[2]} {${d[1]}}`), d[2] = r), a && (d[4] && (d[1] = `@supports (${d[4]}) {${d[1]}}`), d[4] = a), e.push(d));
    }
  }, e;
}
function createStyleList() {
  return createStyleListInner(extractCss);
}
const styleList$1$1 = createStyleList();
styleList$1$1.push([
  519,
  `.mirap-player * {
  border-radius: 0;
  border: 0;
  padding: 0px;
  margin: 0px;
  user-select: none;
  -webkit-user-select: none;
  font-family: Helvetica, Arial;
}
.mirap-player ::before {
  border: 0;
  margin: 0;
  padding: 0;
  font-family: Helvetica, Arial;
}
.mirap-player ::after {
  border: 0;
  margin: 0;
  padding: 0;
  font-family: Helvetica, Arial;
}
`,
  ""
]);
createStyleManager(styleList$1$1, createStyleOption());
styleList$1$1.locals && styleList$1$1.locals;
const styleList$6 = createStyleList();
styleList$6.push([
  524,
  `*[data-v-63fb8f55]:focus {
  outline: 0 !important;
}
.font[data-v-63fb8f55] {
  font-weight: 380;
  font-family: Noto Sans,Helvetica Neue,Helvetica,PingFang SC!important;
}
.mirap-player[data-v-63fb8f55] {
  font-weight: 380;
  font-family: Noto Sans,Helvetica Neue,Helvetica,PingFang SC!important;
  position: relative;
  max-width: 100%;
  width: 100%;
  height: 100%;
  outline: 0px solid transparent;
  background: var(--playerBgColor);
  overflow: hidden;
  padding: 0px;
  margin: 0px;
  user-select: none;
  -webkit-user-select: none;
}
.mirap-player .mirap-toast[data-v-63fb8f55] {
  white-space: pre-wrap;
  color: #FFF;
  text-align: center;
  position: absolute;
  display: flex;
  align-items: center;
  justify-content: center;
  margin-left: -50%;
  width: 100%;
  height: 60px;
  left: 50%;
  top: 0;
  opacity: 1;
  transition-property: top opacity;
  transition-duration: 0.3s;
}
.mirap-player .mirap-toast.hide[data-v-63fb8f55] {
  pointer-events: none;
  top: -20px;
  opacity: 0;
  transition-property: top opacity;
  transition-duration: 0.3s;
}
.mirap-player .mirap-toast span[data-v-63fb8f55] {
  background: rgba(30, 30, 30, 0.8);
  padding: 5px 8px;
  border-radius: 3px;
  font-size: 12px;
  max-width: 95%;
  word-break: break-all;
}
.mirap-player span.i-icon[data-v-63fb8f55],
.mirap-player svg[data-v-63fb8f55],
.mirap-player path[data-v-63fb8f55] {
  pointer-events: none;
}
.mirap-player:hover .mirap-cover[data-v-63fb8f55] {
  background-color: var(--majorColor30);
  transition: background-color 0.3s;
}
.mirap-player .mirap-cover[data-v-63fb8f55] {
  position: absolute;
  margin-left: -50px;
  margin-top: -40px;
  width: 100px;
  height: 80px;
  top: 50%;
  left: 50%;
  border-radius: 30px;
  background-color: var(--controlBgColor30);
  display: flex;
  justify-content: center;
  align-items: center;
  cursor: pointer;
  transition: background-color 0.3s;
}
.mirap-player .mirap-cover span[data-v-63fb8f55] {
  /* for vertical-align:center */
  display: inline-flex;
}
.mirap-player .mirap-loading[data-v-63fb8f55] {
  position: absolute;
  margin-left: -50px;
  margin-top: -40px;
  width: 100px;
  height: 80px;
  top: 50%;
  left: 50%;
  border-radius: 30px;
  background-color: var(--controlBgColor30);
  display: flex;
  justify-content: center;
  align-items: center;
  cursor: pointer;
  transition: background-color 0.3s;
}
.mirap-player .mirap-loading span[data-v-63fb8f55] {
  /* for vertical-align:center */
  display: inline-flex;
}
.mirap-player .mirap-loading svg[data-v-63fb8f55] {
  transform: rotateZ(-90deg);
}
.mirap-player .mirap-loading svg circle[data-v-63fb8f55] {
  stroke: var(--controlBgColor);
  stroke-width: 2px;
}
.mirap-player .mirap-loading svg .mirap-loading-bar[data-v-63fb8f55] {
  stroke: var(--majorColor);
  stroke-width: 3px;
}
.mirap-player .mirap-loading.mirap-error svg .mirap-loading-bar[data-v-63fb8f55] {
  stroke: var(--errorColor);
}
.mirap-player .mirap-loading .i-icon-error[data-v-63fb8f55] {
  position: absolute;
  display: block;
  color: var(--errorColor);
  width: 28px;
  height: 28px;
}
.mirap-player .mirap-loading span.mirap-percent[data-v-63fb8f55] {
  position: absolute;
  display: block;
  color: var(--controlBgColor);
  font-size: 16px;
}
.mirap-player .mirap-loading span.mirap-percent[data-v-63fb8f55]:after {
  display: inline-block;
  content: "%";
  font-size: 12px;
  margin-left: -1px;
  transform: scale(0.7) translateY(1px);
}
.mirap-player .mirap-mini-bar[data-v-63fb8f55] {
  position: absolute;
  bottom: 0px;
  left: 0px;
  width: 100%;
  height: 3px;
  opacity: 1;
  background: var(--playerBgColor30);
  transition: bottom 0.3s;
  transition-delay: 0.1s;
}
.mirap-player .mirap-mini-bar-hide[data-v-63fb8f55] {
  opacity: 0!important;
  transition: opacity 0.3s;
  transition-delay: 0s!important;
}
.mirap-player .mirap-controls-hide[data-v-63fb8f55] {
  bottom: -39px !important;
  transition: bottom 0.3s;
  transition-delay: 0s!important;
}
.mirap-player .mirap-controls[data-v-63fb8f55] {
  visibility: visible;
  opacity: 1;
  position: absolute;
  bottom: 0px;
  left: 0px;
  width: 100%;
  height: 39px;
  display: flex;
  cursor: pointer;
  transition: bottom 0.3s;
  transition-delay: 0.1s;
}
.mirap-player .mirap-controls .mirap-play[data-v-63fb8f55] {
  width: 39px;
}
.mirap-player .mirap-controls button[data-v-63fb8f55] {
  border: 0;
  margin: 0;
  padding: 0;
  min-width: 39px;
  display: flex;
  justify-content: center;
  align-items: center;
  cursor: pointer;
  background: var(--controlBgColor);
  opacity: 0.5;
}
.mirap-player .mirap-controls button[data-v-63fb8f55]:hover {
  opacity: 0.9;
}
.mirap-player .mirap-controls button span[data-v-63fb8f55] {
  /* for vertical-align:center */
  display: inline-flex;
}
.mirap-player .mirap-controls .mirap-info[data-v-63fb8f55] {
  color: var(--majorColor);
  font-size: 12px;
}
.mirap-player .mirap-controls .mirap-info span[data-v-63fb8f55] {
  margin: 0 10px;
  font-weight: 380;
  font-family: Noto Sans,Helvetica Neue,Helvetica,PingFang SC!important;
}
.mirap-player .mirap-controls .mirap-bar[data-v-63fb8f55] {
  position: relative;
  background-color: var(--controlBgColor);
  flex-grow: 1;
  opacity: 0.6;
}
.mirap-player .mirap-controls .mirap-bar[data-v-63fb8f55]:hover {
  opacity: 0.8;
}
.mirap-player .mirap-controls .mirap-bar:hover .mirap-note[data-v-63fb8f55] {
  top: -30px;
  opacity: 1;
}
.mirap-player .mirap-controls .mirap-bar:hover .mirap-cursor[data-v-63fb8f55] {
  opacity: 1;
}
.mirap-player .mirap-controls .mirap-bar .mirap-note[data-v-63fb8f55] {
  position: absolute;
  width: 60px;
  height: 30px;
  right: -30px;
  text-align: center;
  top: -20px;
  opacity: 0;
  transition: top 0.3s, opacity 0.2s;
}
.mirap-player .mirap-controls .mirap-bar .mirap-note span[data-v-63fb8f55] {
  white-space: nowrap;
  font-size: 12px;
  border-radius: 3px;
  padding: 3px 5px;
}
.mirap-player .mirap-controls .mirap-bar .mirap-cursor[data-v-63fb8f55] {
  position: absolute;
  background: #000;
  width: 1px;
  height: 100%;
  pointer-events: none;
  opacity: 0;
  transition: opacity 0.2s;
}
.mirap-player .mirap-controls .mirap-bar .mirap-cursor span[data-v-63fb8f55] {
  color: var(--majorColor);
  background: var(--controlBgColor90);
}
.mirap-player .mirap-progress[data-v-63fb8f55] {
  position: absolute;
  background: var(--majorColor);
  height: 100%;
  width: 0;
  pointer-events: none;
}
.mirap-player .mirap-progress span[data-v-63fb8f55] {
  color: var(--controlBgColor);
  background: var(--majorColor90);
}
`,
  ""
]);
createStyleManager(styleList$6, createStyleOption());
styleList$6.locals && styleList$6.locals;
const { Factory } = FFCreator, { secToHms } = TimeUtil, { color } = colorColorUtil, { forceCacheNode, cacheNode } = defaultOut, defaultOptions = {
  volume: 1,
  playbackRate: 1,
  resetOnEnd: false,
  majorColor: "#4d75b4",
  controlBgColor: "#FFF",
  playerBgColor: "#000",
  errorColor: "#E55",
  timeRemain: true,
  decimal: 0,
  hideControls: "auto",
  hideMiniBar: false,
  cover: "auto",
  keyboardPlay: true,
  tapPlay: true,
  keySeekStep: 1,
  playing: false,
  play: false,
  currentTime: 0,
  duration: 0
}, eventTypes = [
  "loadedmetadata",
  "canplay",
  "emptied",
  "timeupdate",
  "playing",
  "seeked",
  "pause",
  "ended",
  "play"
], keyCodes = { space: " ", left: "ArrowLeft", right: "ArrowRight" }, VideoPlayer = {
  components: {
    PlayOne,
    Pause,
    Error: ErrorComponent
  },
  props: ["options", "width", "height"],
  data() {
    return {
      version: "$VERSION",
      opts: this.options,
      w: this.width,
      h: this.height,
      error: null,
      pr: 27,
      scale: 0,
      toastHide: true,
      toastMsg: null,
      mouseStaying: false,
      hover: false,
      seekingTimer: null,
      loading: false,
      loadingProgress: 0,
      progress: "0",
      progressHms: "0:00",
      seekTime: 0,
      cursor: "0",
      cursorHms: "0:00",
      timeHms: "0:00",
      canvasStyle: { width: 0, height: 0, margin: 0 },
      burningProgress: 0,
      burnerLoadProgress: 0,
      burning: false,
      burner: null,
      enable: true
    };
  },
  mounted() {
    this.log("player mounted"), this.load(), this.$refs.player.addEventListener("keyup", (i2) => {
      if (this.$emit("keyup", i2), this.opts.keyboardPlay) {
        if (i2.key === keyCodes.space && i2.target.className !== "mirap-play")
          this.togglePlay(i2);
        else if ([keyCodes.left, keyCodes.right].includes(i2.key)) {
          const e = keyCodes.left === i2.key ? -1 : 1;
          this.seek(this.opts.currentTime + this.opts.keySeekStep * e);
        }
      }
    }), this.$refs.player.addEventListener("keydown", (i2) => {
      this.$emit("keydown", i2), this.opts.keyboardPlay && Object.values(keyCodes).includes(i2.key) && i2.preventDefault();
    });
  },
  watch: {
    size() {
      this.fit();
    },
    optChange() {
      this.updateBarWidth();
    },
    info() {
      this.updateBarWidth();
    }
  },
  computed: {
    optChange() {
      return JSON.stringify([this.opts.hideControls]);
    },
    size() {
      return `${this.w}x${this.h}`;
    },
    info() {
      return `${this.timeHms}${this.opts.playbackRate > 1 ? ` ×${this.opts.playbackRate}` : ""}`;
    },
    hideControls() {
      return this.opts.hideControls !== true && this.mouseStaying || this.opts.cover !== true && !this.opts.play;
    },
    showCover() {
      return this.opts.cover === true && !this.opts.playing || this.opts.cover === "auto" && !this.opts.play;
    }
  },
  methods: {
    updateBarWidth() {
      setTimeout(() => {
        var i2;
        this.barWidth = (i2 = this.$refs.bar) == null ? void 0 : i2.clientWidth;
      }, 0);
    },
    log(...i2) {
      this.opts.debug && console.log(...i2);
    },
    async destroy() {
      this.creator && await this.creator.destroy();
    },
    hideToast() {
      this.toast(null);
    },
    toast(i2, e = 3e3) {
      if (this.toastTimer && (clearTimeout(this.toastTimer), this.toastTimer = null), !i2) return this.toastHide = true;
      this.toastMsg = i2, this.toastHide = false, (e = parseInt(e)) >= 0 && (this.toastTimer = setTimeout(() => {
        this.toastHide = true;
      }, e));
    },
    setSize({ width: i2, height: e }) {
      this.w = i2, this.h = e;
    },
    togglePlay: togglePlay(function(i2) {
      var e, t;
      (((e = i2.target) == null ? void 0 : e.tagName) === "BUTTON" || this.opts.keyboardPlay && i2.type === "keyup" || this.opts.tapPlay && (t = i2.target) != null && t.className.includes("screen")) && (this.opts.playing ? this.pause() : this.play());
    }, 10),
    showLoadingMsg() {
      this.error && (this.toast(this.error, 15e3), navigator.clipboard.writeText(this.error));
    },
    play() {
      if (this.enable) {
        if (!this.opts.loaded) return this.toast("Loading..");
        1e-3 * this.creator.currentTime > this.creator.duration - 0.1 && this.creator.jumpTo(1), this.creator.play(this.opts.playbackRate), this.error = null;
      }
    },
    pause() {
      this.enable && this.creator.pause();
    },
    seek(i2) {
      this.enable && this.creator.jumpTo(1e3 * i2 >> 0);
    },
    focus() {
      this.opts.keyboardPlay && this.$refs.player.focus();
    },
    async capture() {
      return await this.creator.getPreview(this.opts.currentTime);
    },
    menu() {
      let { value: i2, json: e } = this.opts;
      i2 = i2 || e, typeof i2 != "string" && (i2 = JSON.stringify(i2, null, 2));
      try {
        navigator.clipboard.writeText(i2);
      } catch {
        this.toast("Failed to copy source! See console log"), console.log(i2);
      }
    },
    async genNode(i2, e) {
      const { node: t, cache: r } = Factory.genNode(i2, {}, e);
      return await r, t;
    },
    async load() {
      var i2;
      this.log("player load start..", this.opts), this.opts.loaded = false, this.loading = true, this.loadingProgress = 0.01, this.error = null;
      const e = this.$refs.player.style;
      for (const [c, d] of Object.entries(defaultOptions))
        this.$set(
          this.opts,
          c,
          this.opts[c] === void 0 ? d : this.opts[c]
        ), c.includes("Color") && (e.setProperty(`--${c}`, color(this.opts[c], 100)), e.setProperty(`--${c}90`, color(this.opts[c], 90)), e.setProperty(`--${c}30`, color(this.opts[c], 30)));
      let { value: t, json: r } = this.opts;
      t = t || r, Factory.cacheNode = this.opts.cache === "all" ? forceCacheNode : this.opts.cache !== true ? cacheNode : null, Factory.debug = this.opts.debug;
      const a = this.$refs.canvas, s = {}, { node: u, cache: l } = Factory.from(t, { canvas: a }, (c) => {
        s[c.key] = c, this.updateProgress(s);
      });
      this.creator = u, this.log("creater init"), await l, this.log("creater loaded"), this.fit(), this.creator.on("playing", () => {
        this.focus(), this.opts.playing = true;
      }).on("pause", () => {
        this.focus(), this.opts.playing = false;
      }).on("play", () => {
        this.focus(), this.opts.play = true;
      }).on("preloading", (c) => {
        this.log("preloading", c), this.loadingProgress = 0.6 + c.loaded / c.total * 0.4;
      }).on("seeking", (c) => {
        this.log("seeking", c), this.opts.playing && (this.loading = true, this.loadingProgress = 0, this.seekingTimer && clearInterval(this.seekingTimer), this.seekingTimer = setInterval(() => {
          this.loadingProgress += 0.01 * (1 - this.loadingProgress);
        }, 50));
      }).on("seeked", (c) => {
        this.log("seeked", c), this.loading && (this.loadingProgress = 0.98, setTimeout(() => {
          this.loading = false, this.seekingTimer && clearInterval(this.seekingTimer);
        }, 100));
      }).on("error", (c) => {
        c.error && (this.error = c.error, this.toast(c.error));
      }).on("loadedmetadata", (c) => {
        this.focus(), this.toast(), this.loading = false, this.opts.loaded = true, this.opts.duration = c.duration, this.timeHms = secToHms(c.duration, this.opts.decimal);
      }).on("timeupdate", (c) => {
        this.opts.currentTime = c.currentTime / 1e3, this.progressHms = secToHms(
          this.opts.currentTime,
          this.opts.decimal
        );
        const d = Math.min(
          100,
          Math.max(0, 100 * this.opts.currentTime) / this.opts.duration
        ).toFixed(2);
        d !== this.progress && (this.progress = d), this.opts.timeRemain && (this.timeHms = "-" + secToHms(
          this.opts.duration - this.opts.currentTime,
          this.opts.decimal
        ));
      }).on("ended", () => {
        this.opts.resetOnEnd && this.seek(0.01), this.opts.playing = false;
      }).on("resize", () => {
        this.fit();
      });
      for (const c of eventTypes)
        this.creator.on(c, (d) => {
          this.$emit(c, d);
        });
      this.barWidth = (i2 = this.$refs.bar) == null ? void 0 : i2.clientWidth, this.start(), this.opts.burn && (this.burner = new Burner(), await this.burner.init((c) => {
        this.burnerLoadProgress = c, this.log("burner init", c);
      }));
    },
    async burn() {
      if (!this.burner || !this.burner.ready || this.burner.burning)
        return false;
      this.enable = false, await this.creator.pause();
      const i2 = await this.burner.start(this.creator, (e) => {
        this.loadingProgress = e, this.loading = true, this.log("burning", e);
      });
      return !!i2 && (this.loadingProgress = 0, this.loading = false, this.enable = true, i2);
    },
    async start() {
      this.log("creater start..", this.creator);
      try {
        await this.creator.start();
      } catch (i2) {
        console.error(i2);
      }
    },
    updateProgress(i2) {
      const e = { total: 1, loaded: 0 };
      Object.values(i2).map((t) => {
        e.total += t.total, e.loaded += t.loaded;
      }), this.loadingProgress = 0.6 * Math.min(1, e.loaded / e.total);
    },
    fit() {
      if (!this.creator) return;
      let i2 = this.creator.getConf("width"), e = this.creator.getConf("height");
      this.scale = Math.min(this.w / i2, this.h / e), i2 = this.scale * i2 >> 0, e = this.scale * e >> 0;
      const t = (this.w - i2) / 2, r = (this.h - e) / 2;
      this.canvasStyle.width = `${i2}px`, this.canvasStyle.height = `${e}px`, this.canvasStyle.margin = `${r}px ${t}px`, this.$emit("resize");
    },
    mouseMove() {
      this.mouseMovingTimer && clearTimeout(this.mouseMovingTimer), this.mouseStaying = false, this.mouseMovingTimer = setTimeout(() => {
        this.hover || (this.mouseStaying = true);
      }, 1e3 * (this.opts.cover === true ? 1 : 2));
    },
    barMouseMove(i2) {
      const e = Math.min(
        100,
        Math.max(0, 100 * i2.offsetX) / this.barWidth
      ).toFixed(2);
      e !== this.cursor && (this.cursor = e, this.seekTime = 0.01 * Number(e) * this.opts.duration, this.cursorHms = secToHms(this.seekTime, this.opts.decimal)), (this.barSeek || i2.type === "click") && this.seek(this.seekTime);
    }
  }
};
function RenderPlayerUI() {
  var i2 = this, e = i2.$createElement, t = i2._self._c || e;
  return t(
    "div",
    {
      ref: "player",
      staticClass: "mirap-player mirap-screen",
      attrs: {
        tabIndex: "-1"
      },
      on: {
        click: i2.togglePlay,
        mousemove: i2.mouseMove
      }
    },
    [
      t("canvas", {
        ref: "canvas",
        staticClass: "mirap-screen",
        style: i2.canvasStyle
      }),
      i2._v(" "),
      t(
        "div",
        {
          class: {
            "mirap-toast": true,
            hide: i2.toastHide
          },
          on: {
            mousemove: i2.hideToast
          }
        },
        [t("span", [i2._v(i2._s(i2.toastMsg))])]
      ),
      i2._v(" "),
      i2.showCover && i2.opts.loaded && i2.enable ? t(
        "button",
        {
          staticClass: "mirap-cover",
          on: {
            click: i2.togglePlay
          }
        },
        [
          t("play-one", {
            attrs: {
              theme: "filled",
              size: "28",
              fill: i2.opts.controlBgColor,
              strokeLinejoin: "miter"
            }
          })
        ],
        1
      ) : i2._e(),
      i2._v(" "),
      i2.loading ? t(
        "div",
        {
          class: {
            "mirap-loading": true,
            "mirap-error": !!i2.error
          },
          on: {
            click: i2.showLoadingMsg
          }
        },
        [
          t(
            "svg",
            {
              attrs: {
                width: "60",
                height: "60",
                viewPort: "0 0 60 60",
                version: "1.1",
                xmlns: "http://www.w3.org/2000/svg"
              }
            },
            [
              t("circle", {
                attrs: {
                  cx: "30",
                  cy: "30",
                  fill: "transparent",
                  "stroke-dashoffset": "0",
                  r: i2.pr,
                  "stroke-dasharray": Math.PI * 2 * i2.pr
                }
              }),
              i2._v(" "),
              t("circle", {
                staticClass: "mirap-loading-bar",
                attrs: {
                  cx: "30",
                  cy: "30",
                  fill: "transparent",
                  r: i2.pr,
                  "stroke-dasharray": Math.PI * 2 * i2.pr,
                  "stroke-dashoffset": (1 - i2.loadingProgress) * Math.PI * 2 * i2.pr
                }
              })
            ]
          ),
          i2._v(" "),
          i2.error ? t("error", {
            attrs: {
              theme: "filled",
              size: "28"
            }
          }) : t(
            "span",
            {
              staticClass: "mirap-percent"
            },
            [i2._v(i2._s(Math.round(i2.loadingProgress * 100)))]
          )
        ],
        1
      ) : i2._e(),
      i2._v(" "),
      i2.opts.hideMiniBar ? i2._e() : t(
        "div",
        {
          class: {
            "mirap-mini-bar": true,
            "mirap-mini-bar-hide": !i2.hideControls && i2.opts.hideControls !== true
          }
        },
        [
          t("div", {
            staticClass: "mirap-progress",
            style: {
              width: i2.progress + "%"
            }
          })
        ]
      ),
      i2._v(" "),
      i2.opts.hideControls !== true ? t(
        "div",
        {
          class: {
            "mirap-controls": true,
            "mirap-controls-hide": i2.hideControls
          },
          on: {
            mouseover(r) {
              i2.hover = true;
            },
            mouseleave(r) {
              i2.hover = false;
            }
          }
        },
        [
          t(
            "button",
            {
              staticClass: "mirap-play",
              attrs: {
                "aria-label": "Play/Pause"
              },
              on: {
                click(r) {
                  return r.stopPropagation(), i2.togglePlay.apply(null, arguments);
                }
              }
            },
            [
              i2.opts.playing ? t("pause", {
                attrs: {
                  theme: "filled",
                  size: "26",
                  fill: i2.opts.majorColor,
                  strokeWidth: 8,
                  strokeLinecap: "butt"
                }
              }) : t("play-one", {
                attrs: {
                  theme: "filled",
                  size: "24",
                  fill: i2.opts.majorColor,
                  strokeLinejoin: "miter"
                }
              })
            ],
            1
          ),
          i2._v(" "),
          t(
            "div",
            {
              ref: "bar",
              staticClass: "mirap-bar",
              on: {
                mousedown(r) {
                  i2.barSeek = true;
                },
                mouseup(r) {
                  i2.barSeek = false;
                },
                click(r) {
                  return r.stopPropagation(), i2.barMouseMove.apply(null, arguments);
                },
                mousemove: i2.barMouseMove
              }
            },
            [
              t(
                "div",
                {
                  staticClass: "mirap-progress",
                  style: {
                    width: i2.progress + "%"
                  }
                },
                [
                  t(
                    "div",
                    {
                      staticClass: "mirap-note"
                    },
                    [
                      t("span", [
                        i2._v(i2._s(i2.progressHms))
                      ])
                    ]
                  )
                ]
              ),
              i2._v(" "),
              t(
                "div",
                {
                  staticClass: "mirap-cursor",
                  style: {
                    "margin-left": i2.cursor + "%"
                  }
                },
                [
                  t(
                    "div",
                    {
                      staticClass: "mirap-note"
                    },
                    [
                      t("span", [
                        i2._v(i2._s(i2.cursorHms))
                      ])
                    ]
                  )
                ]
              )
            ]
          ),
          i2._v(" "),
          t(
            "button",
            {
              staticClass: "mirap-info",
              on: {
                click(r) {
                  r.stopPropagation();
                },
                dblclick: i2.menu
              }
            },
            [t("span", [i2._v(i2._s(i2.info))])]
          )
        ]
      ) : i2._e()
    ]
  );
}
var staticRenderFns = [];
const videoPlayerComponent = n(
  VideoPlayer,
  RenderPlayerUI,
  staticRenderFns,
  false,
  null,
  "63fb8f55"
).exports;
class _videoPlayer {
  constructor(e, t) {
    this.container = e, this.load(t);
  }
  async load(e) {
    this.options = e || {};
    const t = this.container;
    this.player && await this.destroy();
    const { width: r, height: a } = Utils.DomUtil.innerSize(t);
    for (this.setSize({
      width: r,
      height: a
    }); t.firstChild; )
      t.removeChild(t.firstChild);
    const s = new Vue({
      render: (u) => u(videoPlayerComponent, {
        props: {
          options: this.options,
          width: r,
          height: a
        }
      })
    }).$mount();
    t.appendChild(s.$el), this.player = s.$children[0], this.resizeListener = this.onResize(), window.addEventListener("resize", this.resizeListener);
  }
  fit() {
    this.resizeListener && this.resizeListener();
  }
  async destroy() {
    window.removeEventListener("resize", this.resizeListener), await this.player.destroy(), this.resizeListener = null;
  }
  onResize() {
    return () => {
      this.resizing || (this.resizing = true, requestAnimationFrame(() => {
        const { width: e, height: t } = Utils.DomUtil.innerSize(this.container);
        (e != this.width || t != this.height) && this.setSize({
          width: e,
          height: t
        }), this.resizing = false;
      }));
    };
  }
  setSize({ width: e, height: t }) {
    this.width = e, this.height = t, this.player && this.player.setSize({
      width: e,
      height: t
    });
  }
  toast(e, t) {
    this.player.toast(e, t);
  }
  async burn(e = false) {
    const t = await this.player.burn();
    if (!t || !e)
      return t;
    const r = document.createElement("a");
    r.style.display = "none", r.href = t, typeof e == "string" && e.endsWith(".mp4") ? r.download = e : r.download = "mira.mp4", document.body.appendChild(r), r.click(), setTimeout(() => {
      window.URL.revokeObjectURL(t);
    }, 1e3);
  }
  log(...e) {
    this.player.log(...e);
  }
  play() {
    this.player.play();
  }
  pause() {
    this.player.pause();
  }
  on(e, t) {
    this.player.$on(e, t);
  }
  off(e, t) {
    this.player.$off(e, t);
  }
  once(e, t) {
    this.player.$once(e, t);
  }
  async capture() {
    return await this.player.capture();
  }
  get playing() {
    return this.options.playing || false;
  }
  get duration() {
    return this.options.duration || 0;
  }
  get currentTime() {
    return this.options.currentTime || 0;
  }
  set currentTime(e) {
    this.player.seek(Number(e) || 0);
  }
  get playbackRate() {
    return this.options.speed || 1;
  }
  set playbackRate(e) {
    this.options.speed = Number(e) || 1;
  }
  get volume() {
    return this.options.volume || 1;
  }
  set volume(e) {
    this.options.volume = Number(e) || 1;
  }
  get version() {
    return this.player.version;
  }
}
const index$2 = {
  utils: Utils,
  TYPES: FFCreator.TYPES,
  InkPaint: FFCreator.InkPaint,
  create: (i2, e) => new _videoPlayer(i2, e)
}, { secondsToHmsf: formatTime, secondsToHms: toHumanReads } = TimeUtils$1, dustyVariable = {}, globalW = 120, AnimationFinA = (i2, e) => {
  if (i2.complete)
    return e(i2);
  i2.onload = () => e(i2);
};
class EditorClipElement extends CustomHtmlElementBase {
  init() {
    return super.addClass("mirae-clip"), this.videoQueue = new TaskQueue(), this.audioQueue = new TaskQueue(), super.init();
  }
  addClass(e, t) {
    return super.addClass(e, t), this.classChanged(), this;
  }
  removeClass(e) {
    return this.hasClass(e) ? (super.removeClass(e), this.classChanged(), this) : this;
  }
  get visible() {
    var d;
    const [e, t] = [this.offsetLeft, (d = this.parentNode) == null ? void 0 : d.offsetTop], [r, a] = [this.offsetWidth, this.offsetHeight], [s, u, l, c] = this.boardSize;
    return s > 0 && e + r > l && e < l + s && t + a > c && t < c + u;
  }
  onScroll({ x: e, y: t }) {
    const r = this.styleNumber("left"), a = this.styleNumber("width");
    r - e < 0 && r + a - e > 76 ? this.setStyleVars({
      "--leftOffset": e - r + "px"
    }) : r - e >= 0 && this.setStyleVars({
      "--leftOffset": "0px"
    }), this.updateView();
  }
  setStyle(e) {
    return super.setStyle(e), e.width ? this.classChanged() : e.left && this.updateParentLines(), this;
  }
  setInfo() {
    if (!this.node || !this.node.parent)
      return;
    let e = "";
    this.name && (e += `${this.name} `), this.node.groupId && this.node.groupId !== "NULL" && (e += "(已组合) "), this.node.rootConf && (e += " - 时长: " + toHumanReads(this.node.duration, 1, true)), e && this.set("data-info", e);
  }
  classChanged() {
    var t;
    this.handles || (this.handles = {});
    const e = this.styleNumber("width");
    this.setInfo(), this.addResizeHandles(e), ((t = this.node) == null ? void 0 : t.type) !== "text" && this.audioBtn && (!this.audioBtn.parentNode && e >= 72 ? this.addAudioBtn() : this.audioBtn.parentNode && e < 72 && this.audioBtn.hide()), this.updateParentLines();
  }
  updateParentLines() {
    var r, a, s, u, l;
    const e = "hover-parent", t = this.node && this.node.parent && !this.isShadow && !["creator", "scene", "spine", "track"].includes((r = this.node) == null ? void 0 : r.parent.type);
    if (t && this.parentNode && (this.pLineView || (this.pLineView = EditorClipPlineElement.create(this)), this.pView = (u = (s = (a = this.node) == null ? void 0 : a.parent) == null ? void 0 : s.clip) == null ? void 0 : u.view, this.pView)) {
      const c = this.parentNode.offsetTop + this.offsetTop, d = this.offsetHeight, f = this.pView.parentNode.offsetTop + this.pView.offsetTop, p = this.pView.offsetHeight;
      let m = d * 0.5, y = f > c ? c + m - f : c - m - f, x = 0;
      this.node.startTime <= 0 ? (x = Math.floor(this.node.startTime * this.scale) + 1, y = c + m - (f + p * 0.5)) : this.node.startTime >= this.node.parent.duration && (x = Math.ceil(
        (this.node.startTime - this.node.parent.duration) * this.scale
      ) + 1, y = c + m - (f + p * 0.5)), this.pLineView.update(
        m,
        x,
        Math.round(y)
      );
    }
    if (!t || !this.pLineView || !this.hasClass(["hover", "moving"]))
      return (() => {
        this.pLineView && this.pLineView.hasClass("show") && (this.pLineView.removeClass("show"), this.pView && (this.pView.removeClass(e), this.pView = null), this.unlinkBtn && setTimeout(() => {
          this.hasClass("hover") || this.unlinkBtn.hide();
        }, 10));
      })();
    this.unlinkBtn || (this.unlinkBtn = EditorButtonComponent.create(this).addClass("unlink-btn"), this.unlinkBtn.onClick = (c) => {
      const d = this.node.creator(), f = this.node.absStartTime;
      this.apply(
        {
          parent: d,
          start: f
        },
        () => {
          this.unlinkBtn.remove(), this.unlinkBtn = null;
        }
      );
    }), !((l = window.event) != null && l.mctrlKey) || this.hasClass("selected") ? this.unlinkBtn.hide() : this.unlinkBtn.parentNode || this.unlinkBtn.appendTo(this), this.pView && (this.pView.addClass(e), this.pLineView.addClass("show"));
  }
  addResizeHandles(e) {
    if (this.node && this.node.type !== "scene")
      if (this.classList.contains("selected") && e > 15)
        for (const t of ["start", "end"])
          this.handles[t] ? this.handles[t].parentNode || this.append(this.handles[t]) : this.handles[t] = this.createHandle(t);
      else
        Object.values(this.handles).map((t) => t.hide());
  }
  createHandle(e) {
    return EditorClipHandleElement.create(this).set("data-type", e).addClass(`mirae-clip-handle-${e}`).addMoveListener(this);
  }
  clear() {
    this.cropView && this.cropView.clear(), this.handles.start && this.handles.start.clear(), this.handles.end && this.handles.end.clear(), super.clear();
  }
  onTimeResizeStart(e) {
    this.cropMode && this.initProxyState();
  }
  onTimeResizeEnd(e) {
    this.cropMode && this.node.emit(CHANGING, {
      action: OP_END
    });
  }
  onTimeResize(e, t) {
    if (!this.cropMode)
      return;
    const r = {}, a = t.x / this.scale;
    e === "start" ? (this.proxyState.start += a, r.cropStart = this.roundCropTime(this.proxyState.start)) : e === "end" && (this.proxyState.end += a, r.cropEnd = this.roundCropTime(this.proxyState.end)), this.moveListener.apply(
      {
        to: r
      },
      OP_MOVE
    );
  }
  onMove(e) {
    if ([this.handles.start, this.handles.end].includes(e.target) && this.moveListener.onTimeResize) {
      const t = e.target.get("data-type");
      if ((t === "start" && e.delta.x > 0 || t === "end" && e.delta.x < 0) && this.styleNumber("width") < 30)
        return;
      this.moveListener.onTimeResize(t, e.delta);
    } else if (e.target === this.cropView && this.cropMode) {
      this.proxyState || this.initProxyState();
      const t = this.board;
      if (t) {
        const s = t.scrollToVisible(e.event);
        e.delta.x += s.x;
      }
      let r = e.delta.x / this.scale;
      this.proxyState.start += r, this.proxyState.end += r;
      const a = {
        to: {
          cropStart: this.roundCropTime(this.proxyState.start),
          cropEnd: this.roundCropTime(this.proxyState.end)
        }
      };
      this.moveListener.apply(a, OP_MOVE);
    }
  }
  onMoveStart(e) {
    this.node.emit && this.node.emit(CHANGING, {
      action: OP_START
    }), this.addClass("moving"), [this.handles.start, this.handles.end].includes(e.target) && this.moveListener.onTimeResizeStart ? this.moveListener.onTimeResizeStart(e) : this.cropMode && this.initProxyState();
  }
  onMoveEnd(e) {
    this.addClass("hover").removeClass("moving"), [this.handles.start, this.handles.end].includes(e.target) && this.moveListener.onTimeResizeEnd ? this.moveListener.onTimeResizeEnd(e) : this.node.cropMode && !e.moved && this.moveListener.onTimeMark && this.moveListener.onTimeMark({
      time: this.node.cropStart
    }), this.node.emit && this.node.emit(CHANGING, {
      action: OP_END
    });
  }
  roundCropTime(e) {
    return e = Math.floor(e * this.fps) / this.fps, Math.max(Math.min(e, this.node.duration), 0);
  }
  get fps() {
    return this._fps || (this._fps = this.node.rootConf("fps")), this._fps;
  }
  initProxyState() {
    this.proxyState = {
      start: this.node.cropStart,
      end: this.node.cropEnd
    };
  }
  remove() {
    Object.values(this.handles).map((e) => e.remove()), this.audioBtn && this.audioBtn.remove(), this.cropView && this.cropView.remove(), this.node = null, this.root = null, super.remove();
  }
  setOpts(e) {
    const { node: t, root: r } = e;
    return this.node = t, this.root = r, e.shadow ? (this.isShadow = true, this.addClass("shadow")) : (t.id && this.set("id", `mirae-clip-${t.id}`), this.addClass("node"), this.refresh()), this;
  }
  setScale(e) {
    if (this.node && this.root)
      return this.scale = e, this.startTime = this.node.absStartTime, this.cropView && (this.cropView.setScale(e), this.refreshCropShadow()), this.updateDuration(true).setStyle({
        top: this.node.type === "crop" ? "-2px" : "2px",
        left: this.scale * (this.node.absStartTime - this.root.absStartTime) + "px"
      });
  }
  updateDuration(e = false) {
    if (e || this.duration != this.node.duration)
      return this.duration = this.node.duration, this.setStyle({
        width: this.scale * this.node.duration + "px"
      }), this.updateView();
  }
  update(e = false) {
    var t, r;
    return this.node ? ((e || this.startTime != this.node.absStartTime || this.duration != this.node.duration) && (this.setScale(this.scale), !this.cropMode && ((r = (t = this.node) == null ? void 0 : t.parent) == null ? void 0 : r.type) !== TYPE_SPINE && this.addClass("auto-hover", 500)), (e || this.active !== this.node.active) && (this.active = this.node.active, this.toggleClass("disable", !this.active), this.isShadow || this.refresh()), this.updateParentLines(), this) : this;
  }
  styleNumber(e) {
    return Number(this.style[e].replace("px", ""));
  }
  moveDelta(e) {
    return this.setStyle({
      left: `${this.styleNumber("left") + e.x}px`,
      top: `${this.styleNumber("top") + e.y}px`
    }), this.updateParentLines(), this;
  }
  apply(e, t) {
    this.lock(
      50,
      () => {
        this.moveListener.applyChange({
          to: e
        }), t && t();
      },
      "apply"
    );
  }
  refresh() {
    var t;
    if (!this.node)
      return;
    this.name = this.filename();
    const e = this[this.node.type];
    return e && typeof e == "function" && e.call(this), this.cropMode && this.addCropView(), (t = this.parentNode) != null && t.refresh && this.parentNode.refresh(), this.updateView();
  }
  addCropView() {
    if (!this.cropView) {
      const e = {
        id: `crop-${this.node.id}`,
        type: "crop",
        absStartTime: 0,
        duration: 0
      };
      this.cropView = BaseSkeleton.create({
        node: e,
        root: this.root,
        moveListener: this
      }), this.addClass("no-info");
    }
    this.cropView.parentNode !== this && this.append(this.cropView), this.cropView.node.absStartTime = this.node.cropStart, this.cropView.node.duration = this.node.cropEnd - this.node.cropStart, this.cropView.update().crop(), this.refreshCropShadow();
  }
  refreshCropShadow() {
    const e = this.scale || 1;
    this.setStyleVars({
      "--leftShadow": `${Math.ceil(this.node.cropStart * e) + 1}px`,
      "--rightShadow": `${Math.ceil(
        (this.node.duration - this.node.cropEnd) * e + 1
      )}px`
    });
  }
  addAudioBtn() {
    var e;
    if (this.cropMode || !this.node || this.node.audio === void 0)
      return (e = this.audioBtn) == null ? void 0 : e.hide();
    this.audioBtn || (this.audioBtn = EditorButtonComponent.create(this).addClass("audio-btn"), this.audioBtn.onClick = (t) => {
      this.apply({
        audio: !this.node.audio
      });
    }), this.audioBtn.toggleClass("audio-btn-off", !this.node.audio), this.canvasCtr && this.canvasCtr.append(this.audioBtn);
  }
  filename() {
    var e;
    return short(this.node.name, 15) || short((e = this.node.conf.userfile) == null ? void 0 : e.name, 20, 5) || this.node.id;
  }
  crop() {
    super.addClass(["crop", "selected"]), this.infoLabel || (this.infoLabel = document.createElement("div"), this.infoLabel.classList.add("crop-info-label"), this.append(this.infoLabel)), this.infoLabel.innerText = toHumanReads(this.node.duration, 1);
  }
  image() {
    super.addClass("video");
  }
  gif() {
    super.addClass("video");
  }
  video() {
    super.addClass("video"), this.addAudioBtn();
  }
  audio() {
    super.addClass("audio"), this.addAudioBtn(), this.active = this.node.active && this.node.audio, this.toggleClass("disable", !this.active);
  }
  text() {
    super.addClass("text"), this.textView || (this.textView = document.createElement("div"), this.textView.classList.add("text-view"), this.append(this.textView));
    let e = `${this.node.conf.text}`;
    e = e.trim().replaceAll(`
`, " ").replaceAll("\r", " "), this.textView.innerText = e, this.name = short(e, 20), this.node.speech ? this.updateAudioView() : this.preview && this.preview.remove();
  }
  placeholder() {
    super.addClass("placeholder"), this.innerText = placeholderMessage;
  }
  scene() {
    super.addClass("scene"), this.addAudioBtn();
  }
  trans() {
    super.addClass("trans"), this.name = "转场效果: " + this.filename();
  }
  cover() {
  }
  updateView() {
    return this.isShadow || (["video", "image", "gif", "scene"].includes(this.node.type) ? this.updatePreview() : ["audio", "text"].includes(this.node.type) && this.updateAudioView()), this;
  }
  async updateAudioView() {
    const e = this.node.material;
    if (!e)
      return;
    const t = e.path, { duration: r, data: a } = await this.audioData(
      t
    );
    if (!this.visible)
      return;
    let s = [
      {
        color: "#1abc9c",
        h: 0
      },
      {
        color: "#F8DD0B",
        h: 24
      },
      {
        color: "#EE3333",
        h: 32
      }
    ];
    this.node.type === "text" && (s = [
      {
        color: this.node.audio ? "#166C96" : "#334455",
        h: 0
      }
    ]);
    const {
      left: u,
      width: l,
      clipWidth: c
    } = this.renderPreviewCanvas(40);
    if (!u && !l)
      return;
    const d = this.node.volume, f = e.speed || 1, p = e.getStartOffset(), m = e.getDuration() * f, y = Math.round(
      a.length * (p / r)
    ), x = Math.round(
      a.length * ((p + m) / r)
    ) - y, g = m / f * this.scale, _ = Math.max(
      Math.round(g / x),
      3
    ), T = Math.ceil(g / _), E = round$2(x / T, 1), b = (F, M) => F < this.node.fadeIn * this.scale ? M * (F / (this.node.fadeIn * this.scale)) : c - F < this.node.fadeOut * this.scale ? M * ((c - F) / (this.node.fadeOut * this.scale)) : M, C = round$2(
      p / f * this.scale,
      3
    ), w = C % _, A = this.preview.getContext("2d");
    let S = 0;
    for (let F = Math.round(u / _) * _; F < u + l && (!(F > g) || this.node.loop); F += _) {
      const M = F % g, U = Math.floor(
        (M + C) / _
      ), B = a.slice(
        Math.round(U * E),
        Math.round((U + 1) * E)
      ), q = b(
        F,
        Math.max.apply(null, B) * d
      ), z = Math.min(q, 0.98) * 40;
      for (const X of s)
        z < X.h || (A.fillStyle = X.color, A.fillRect(
          F - u - w,
          40 - z,
          _ - 1,
          z - X.h
        ));
      const D = Math.floor(F / g);
      D !== S && (A.fillStyle = "#FFF", A.fillRect(F - u - w - 1, 0, 1, 40), S = D);
    }
  }
  updatePreview() {
    if (!this.visible)
      return;
    const e = this.renderId = uuid(), { left: t, width: r } = this.renderPreviewCanvas(60, 2);
    if (!t && !r)
      return;
    let a = Math.max(0, Math.floor(t * 2 / globalW - 1)), s = a + Math.ceil(r * 2 / globalW) + 1;
    const u = this.preview.getContext("2d"), l = this.node.material;
    let c = 1, d = 0;
    if (l) {
      c = l.speed || 1;
      const p = l.getStartOffset() / c * this.scale * 2;
      d = Math.floor(p / globalW) * globalW - p;
    }
    const f = c * globalW / (this.scale * 2);
    for (let p = a; p < s; p++) {
      let m = d + p * globalW, y = this.node.absStartTime + (m + 60) / (this.scale * 2);
      const x = l ? this.node.materialTime(y, true).time : Math.min(y, this.node.absEndTime - 0.1);
      this.renderFrame(
        round$2(x, 1),
        f,
        (g) => {
          e == this.renderId && AnimationFinA(g, () => {
            u.drawImage(
              g,
              m - t * 2,
              0,
              globalW,
              globalW
            );
          });
        }
      );
    }
  }
  renderPreviewCanvas(e, t = 1) {
    this.preview || (this.preview = document.createElement("canvas"), this.preview.classList.add("preview-canvas"), this.canvasCtr = document.createElement("div"), this.canvasCtr.classList.add("canvas-ctr"), this.canvasCtr.append(this.preview), this.append(this.canvasCtr), this.addAudioBtn()), this.preview.parentNode || this.canvasCtr.append(this.preview), this.preview.setAttribute("height", e * t);
    let [r, a, s] = this.boardSize;
    if (r < 0)
      return {};
    const u = this.styleNumber("width"), l = Math.round(Math.min(u, r + 200));
    this.preview.style.width = `${l}px`, this.preview.setAttribute("width", l * t);
    const c = this.styleNumber("left") - s, d = Math.max(0, -c - 100);
    return this.preview.style.left = `${d}px`, this.preview.getContext("2d").clearRect(0, 0, this.preview.width, this.preview.height), {
      left: d,
      width: l,
      clipWidth: u
    };
  }
  async audioData(e) {
    return dustyVariable[e] ? dustyVariable[e] : new Promise((t) => {
      this.audioQueue.enqueue(async () => {
        if (!dustyVariable[e]) {
          const r = new AudioContext({
            sampleRate: 3e3
          }), s = await (await index$2.utils.CacheUtil.cachedResource(e)).data.arrayBuffer(), u = await r.decodeAudioData(
            s
          );
          dustyVariable[e] = await AudioProcessor.data(u);
        }
        t(dustyVariable[e]);
      });
    });
  }
  renderFrame(e, t, r) {
    if (!this.node)
      return;
    const a = this.renderId, s = this.node.material ? this.node.material.path : this.node.id;
    if (dustyVariable[s] || (dustyVariable[s] = {}), dustyVariable[s][e])
      return r(
        dustyVariable[s][e],
        e
      );
    e: for (let u = 0; u < t * 5; u += 0.1)
      for (let l of [-1, 1]) {
        const c = u * l + e;
        if (dustyVariable[s][c]) {
          if (r(
            dustyVariable[s][c],
            c
          ), u < t)
            return;
          break e;
        }
      }
    this.videoQueue.enqueue(async () => {
      if (a === this.renderId) {
        if (!dustyVariable[s][e]) {
          const u = {
            width: globalW,
            height: globalW,
            rawFrame: true
          };
          let l;
          try {
            l = await this.node.getPreview(
              e || 0.01,
              u
            );
          } catch {
            return;
          }
          if (!l) {
            setTimeout(() => {
              a === this.renderId && this.renderFrame(e, t, r);
            }, 300);
            return;
          }
          const c = document.createElement("img");
          c.src = l, dustyVariable[s] || (dustyVariable[s] = {}), dustyVariable[s][e] = c;
        }
        r(dustyVariable[s][e], e);
      }
    });
  }
  get boardSize() {
    const e = this.board;
    return e != null && e.parentNode ? [
      e.parentNode.offsetWidth,
      e.parentNode.offsetHeight,
      e.scrollLeft - e.trackHeadWidth,
      e.scrollTop
    ] : [-1, -1];
  }
  get board() {
    var t;
    let e = this.parentNode;
    if (!e)
      return null;
    for (; e; ) {
      if ((t = e.classList) != null && t.contains("mirae-board"))
        return e;
      e = e.parentNode;
    }
  }
  scrollToVisible(e) {
    return this.cropMode && this.cropView ? this.cropView.scrollToVisible(e) : super.scrollToVisible(e);
  }
  get cropMode() {
    var e;
    return ((e = this.node) == null ? void 0 : e.cropMode) === "time";
  }
  clearCache(e) {
    dustyVariable[e] && delete dustyVariable[e];
  }
  static create(e) {
    const { moveListener: t } = e;
    return super.create().setOpts(e).addMoveListener(t);
  }
}
Ct(EditorClipElement, "TAG", "mira-editor-clip");
EditorClipElement.register();
class EditorClipComponent extends ViewComponentBase {
  constructor(e, t, r) {
    super(r), this.id = `cp-${uuid().substring(0, 3)}`, this.root = t, this.node = e, this.track = null, this.view = EditorClipElement.create({
      node: e,
      root: t,
      moveListener: this
    }), this.onchange = this.onNodeChange(), e.on(CHANGING, this.onchange);
  }
  overlap(e) {
    if (this.node.type === "trans" || e.node.type === "trans" || !this.node.parent || !e.node.parent || [this.node.type, e.node.type].includes(TYPE_PLACEHOLDER))
      return false;
    const t = Math.max(
      e.node.absStartTime,
      this.node.absStartTime
    );
    return Math.min(e.node.absEndTime, this.node.absEndTime) - t > 1 / this.node.fps;
  }
  show(e) {
    e && this.track ? this.view.appendTo(this.track.view) : this.view.hide();
  }
  onHover(e) {
    this.node.emit(HOVER, {
      action: e.event.type,
      event: e.event,
      source: "clip"
    });
  }
  onTimeResizeStart(e) {
    this.initProxyState();
  }
  onTimeResizeEnd(e) {
    this.node.parent.type === TYPE_SPINE && (EditorClipComponent.apply(
      this.node,
      {
        to: {
          start: "NULL"
        }
      },
      OP_MOVE
    ), this.view.update());
  }
  onTimeResize(e, t) {
    let r = t.x;
    if (Math.abs(r) < Number.EPSILON)
      return;
    e === "start" ? (this.proxyState.left += r, this.proxyState.width -= r, this.node.type === "trans" && (this.proxyState.width -= r)) : e === "end" && (this.proxyState.width += r, this.node.type === "trans" && (this.proxyState.width += r, this.proxyState.left -= r));
    let a = this.proxyDuration - this.node.duration;
    a = this.applyResize(e, a), Math.abs(a) < Number.EPSILON || this.emit("resize", {
      target: e,
      dt: a
    });
  }
  applyResize(e, t) {
    var s;
    const r = {};
    let a = this.node.loop ? NaN : ((s = this.node.material) == null ? void 0 : s.length) || NaN;
    if (this.node.type === "text" && (a = NaN), e === "start") {
      if (this.node.parent.type !== TYPE_SPINE) {
        let u = 0;
        for (const l of this.track.clips)
          l.node.absEndTime > this.node.absStartTime || (u = Math.max(
            u,
            l.node.absEndTime
          ));
        this.node.absStartTime - t < u && (t = this.node.absStartTime - u);
      }
      if (!isNaN(a)) {
        const u = this.node.material.speed, l = this.node.material.getStartOffset() / u, c = Math.max(0, l - t);
        t = l - c, r.ss = c * u;
      }
      r.start = this.node.startTime - t;
    } else if (e === "end") {
      if (this.node.parent.type !== TYPE_SPINE) {
        let u = MAX;
        for (const l of this.track.clips)
          l.node.absStartTime < this.node.absEndTime || (u = Math.min(
            u,
            l.node.absStartTime
          ));
        this.node.absEndTime + t > u && (t = u - this.node.absEndTime);
      }
      if (isNaN(this.node.conf.end) || (r.end = "NULL"), !isNaN(a)) {
        const u = this.node.material.speed, l = this.node.material.getEndOffset(true) / u, c = Math.min(a, l + t);
        t = c - l, r.to = c * u;
      }
    }
    if (Math.abs(t) < Number.EPSILON)
      return 0;
    if (r.duration = this.node.duration + t, this.node.type === "trans" && t > 0 && (this.node.prevSibling && r.duration * 0.5 > this.node.prevSibling.duration || this.node.nextSibling && r.duration * 0.5 > this.node.nextSibling.duration))
      return 0;
    !isNaN(a) && r.duration > a && (r.duration = Math.min(a, r.duration)), r.duration < 0.2 || (EditorClipComponent.apply(
      this.node,
      {
        to: r
      },
      OP_MOVE
    ), this.view.update());
  }
  onDblClick(e) {
    this.emit("dblclick", e);
  }
  onMove(e) {
    this.emit("move", e);
  }
  onMoveStart(e) {
    this.emit("movestart", e);
  }
  onMoveEnd(e) {
    this.emit("moveend", e);
  }
  onTimeMark(e) {
    this.emit("timemark", e);
  }
  initProxyState() {
    this.proxyState = {
      left: this.view.styleNumber("left"),
      top: this.view.styleNumber("top"),
      width: this.view.styleNumber("width")
    }, this.nodeOriParent = this.node.parent, this.nodeOriNext = this.node.nextSibling, this.nodeOriPrev = this.node.prevSibling;
  }
  moveStart() {
    this.shadowTrack = this.track, this.node.emit(CHANGING, {
      action: OP_START
    }), this.initProxyState();
  }
  moveDelta(e) {
    var r, a, s;
    this.proxyState || this.initProxyState(), this.proxyState.left += e.x, this.proxyState.top += e.y;
    let t = this.proxyStartTime - (((r = this.node.parent) == null ? void 0 : r.absStartTime) || 0);
    if (this.view.moveDelta(e).addClass("moving"), this.shadowTrack || (this.shadowTrack = this.track), ((a = this.node.parent) == null ? void 0 : a.type) !== TYPE_SPINE && (EditorClipComponent.apply(
      this.node,
      {
        to: {
          start: t
        }
      },
      OP_MOVE
    ), this.view.updateDuration()), !this.shadowView) {
      const u = {
        node: this.node,
        root: this.root,
        shadow: true
      };
      this.shadowView = EditorClipElement.create(u).setScale(this.view.scale).appendTo(this.track.view);
    }
    return this.shadowView.update(), ((s = this.node.parent) == null ? void 0 : s.type) !== TYPE_SPINE && this.node.type !== "trans" && this.view.setStyle({
      left: this.shadowView.style.left
    }), e;
  }
  moveEnd(e) {
    if (this.view.update(true).removeClass("moving"), this.shadowView && (this.shadowView.remove(), this.shadowView = null), this.shadowTrack && (this.shadowTrack.view.removeClass("top-insert"), this.shadowTrack = null), e) {
      const t = e.node, r = {
        parent: t,
        start: this.node.absStartTime - t.absStartTime
      };
      EditorClipComponent.apply(
        this.node,
        {
          to: r
        },
        OP_MOVE
      );
    }
    this.nodeOriParent = null, this.nodeOriNext = null, this.nodeOriPrev = null, this.node.emit(CHANGING, {
      action: OP_END
    });
  }
  get proxyStartTime() {
    return this.root.absStartTime + Math.max(this.proxyState.left / this.view.scale, 0);
  }
  get proxyDuration() {
    return this.proxyState.width / this.view.scale;
  }
  get proxyEndTime() {
    return this.proxyStartTime + this.proxyDuration;
  }
  get proxyCenterTime() {
    return (this.proxyStartTime + this.proxyEndTime) * 0.5;
  }
  get absStartTime() {
    return this.root.absStartTime + this.view.styleNumber("left") / this.view.scale;
  }
  get duration() {
    return this.view.styleNumber("width") / this.view.scale;
  }
  get absEndTime() {
    return this.absStartTime + this.duration;
  }
  get centerTime() {
    return (this.absStartTime + this.absEndTime) * 0.5;
  }
  shadowTo(e) {
    var a;
    if (!this.shadowView)
      return;
    this.shadowView.parentNode !== e.view && this.shadowView.parentNode.removeClass("top-insert"), this.shadowView.appendTo(e.view).update();
    const t = {};
    let r = null;
    if (e.accept(this) ? (this.shadowView.removeClass("conflict"), e.view.removeClass("top-insert"), t.trackId = e.id, r = e.type) : (this.shadowView.addClass("conflict"), e.view.addClass("top-insert")), this.shadowTrack != e) {
      if (this.shadowTrack.type === TYPE_SPINE && this.shadowTrack.type !== r)
        this.nodeOriParent && ((a = this.nodeOriParent) == null ? void 0 : a.type) !== TYPE_SPINE ? t.parent = this.nodeOriParent : t.parent = this.node.creator(), t.prevSibling = null, t.nextSibling = null, t.start = this.absStartTime;
      else if (r === TYPE_SPINE) {
        const s = e.nodeTrack;
        t.parent = s, t.start = "NULL", this.node.prevRefId && (t.prevRefId = "NULL"), this.node.nextRefId && (t.nextRefId = "NULL");
      }
      EditorClipComponent.apply(
        this.node,
        {
          to: t
        },
        OP_MOVE
      ), this.shadowTrack = e;
    }
  }
  virtualBox(e, t) {
    const r = typeof e == "string" ? e : e ? "selected" : "hover";
    return this.view.addClass(r), {
      remove: () => {
        this.view.removeClass(r), t && t.map(
          (a) => a && a.remove()
        );
      },
      show: () => {
      },
      [OP_MOVE]: () => {
      }
    };
  }
  applyChange(e) {
    EditorClipComponent.apply(this.node, e, OP_CHANGE), this.editor._history.append(
      new Record(OP_CHANGE, this.node, e)
    );
  }
  apply(e, t) {
    EditorClipComponent.apply(this.node, e, t);
  }
  onNodeChange() {
    return (e) => {
      if (e.action === OP_CLEAR_CACHE && this.node.type === "scene")
        return this.view.clearCache(this.node.id), this.lock(1e3, () => this.view.refresh(), "scene_refresh");
      const t = [e.action, e.sourceAction];
      (t.includes(OP_CHANGE) || this.view.cropMode && t.includes(OP_MOVE)) && this.view.refresh();
    };
  }
  destroy() {
    this.view && this.view.remove(), this.track && this.track.remove(this), this.shadowView && this.shadowView.remove(), this.shadowTrack && this.shadowTrack.view.removeClass("top-insert"), this.node && (this.node.off(CHANGING, this.onchange), this.node.clip = null), this.shadowView = null, this.shadowTrack = null, this.node = null, this.root = null, this.track = null, this.onchange = null, super.destroy();
  }
}
const svgDataURL1 = '"data:image/svg+xml,%3Csvg width=%2720%27 height=%2720%27 viewBox=%270 0 20 20%27 fill=%27none%27 xmlns=%27http://www.w3.org/2000/svg%27 aria-hidden=%27true%27%3E%3Cpath d=%27M12 3a1 1 0 0 0-1.68-.73l-3.88 3.6A.5.5 0 0 1 6.1 6H3.5C2.67 6 2 6.67 2 7.5v5c0 .83.67 1.5 1.5 1.5h2.6a.5.5 0 0 1 .34.13l3.88 3.6a1 1 0 0 0 1.68-.74V3.01ZM7.12 6.6 11 3v14l-3.88-3.6A1.5 1.5 0 0 0 6.1 13H3.5a.5.5 0 0 1-.5-.5v-5c0-.28.22-.5.5-.5h2.6c.38 0 .75-.14 1.02-.4Zm8.14-1.97a.5.5 0 0 1 .7.04 8 8 0 0 1 0 10.66.5.5 0 0 1-.74-.66 7 7 0 0 0 0-9.34.5.5 0 0 1 .04-.7Zm-1.18 8.3a.5.5 0 0 1-.18-.68 4.5 4.5 0 0 0 0-4.5.5.5 0 0 1 .86-.5 5.5 5.5 0 0 1 0 5.5.5.5 0 0 1-.68.18Z%27 fill=%27%23FFF%27%3E%3C/path%3E%3C/svg%3E"', svgDataURL2 = '"data:image/svg+xml,%3Csvg width=%2720%27 height=%2720%27 xmlns=%27http://www.w3.org/2000/svg%27%3E%3Cg fill=%27%23FFF%27 fill-rule=%27nonzero%27%3E%3Cpath d=%27M13.371 3.003a1 1 0 0 0-1.68-.73l-3.88 3.6a.5.5 0 0 1-.34.13h-2.6c-.83 0-1.5.67-1.5 1.5v5c0 .83.67 1.5 1.5 1.5h2.6a.5.5 0 0 1 .34.13l3.88 3.6a1 1 0 0 0 1.68-.74V3.003zm-4.88 3.6 3.88-3.6v14l-3.88-3.6a1.5 1.5 0 0 0-1.02-.4h-2.6a.5.5 0 0 1-.5-.5v-5c0-.28.22-.5.5-.5h2.6c.38 0 .75-.14 1.02-.4z%27/%3E%3Cpath d=%27m4.072 1.757.095.002 12.291 13.777a.901.901 0 0 1 .216.591.901.901 0 0 1-.216.592.727.727 0 0 1-1.035.086L3.542 3.201a.901.901 0 0 1-.216-.592c0-.214.073-.428.216-.591a.738.738 0 0 1 .625-.26z%27/%3E%3C/g%3E%3C/svg%3E"', svgDataURL3 = '"data:image/svg+xml,%3C%3Fxml version=%271.0%27 encoding=%27UTF-8%27%3F%3E%3Csvg width=%2720%27 height=%2720%27 viewBox=%270 0 48 48%27 fill=%27none%27 xmlns=%27http://www.w3.org/2000/svg%27%3E%3Cpath d=%27M24 36C35.0457 36 44 24 44 24C44 24 35.0457 12 24 12C12.9543 12 4 24 4 24C4 24 12.9543 36 24 36Z%27 fill=%27none%27 stroke=%27%23FFF%27 stroke-width=%272%27 stroke-linejoin=%27round%27/%3E%3Cpath d=%27M24 29C26.7614 29 29 26.7614 29 24C29 21.2386 26.7614 19 24 19C21.2386 19 19 21.2386 19 24C19 26.7614 21.2386 29 24 29Z%27 fill=%27none%27 stroke=%27%23FFF%27 stroke-width=%272%27 stroke-linejoin=%27round%27/%3E%3C/svg%3E"', svgDataURL4 = '"data:image/svg+xml,%3C%3Fxml version=%271.0%27 encoding=%27UTF-8%27%3F%3E%3Csvg width=%2720%27 height=%2720%27 viewBox=%270 0 48 48%27 fill=%27none%27 xmlns=%27http://www.w3.org/2000/svg%27%3E%3Cpath d=%27M9.85786 18C6.23858 21 4 24 4 24C4 24 12.9543 36 24 36C25.3699 36 26.7076 35.8154 28 35.4921M20.0318 12.5C21.3144 12.1816 22.6414 12 24 12C35.0457 12 44 24 44 24C44 24 41.7614 27 38.1421 30%27 stroke=%27%23FFF%27 stroke-width=%272%27 stroke-linecap=%27round%27 stroke-linejoin=%27round%27/%3E%3Cpath d=%27M20.3142 20.6211C19.4981 21.5109 19 22.6972 19 23.9998C19 26.7612 21.2386 28.9998 24 28.9998C25.3627 28.9998 26.5981 28.4546 27.5 27.5705%27 stroke=%27%23FFF%27 stroke-width=%272%27 stroke-linecap=%27round%27 stroke-linejoin=%27round%27/%3E%3Cpath d=%27M42 42L6 6%27 stroke=%27%23FFF%27 stroke-width=%272%27 stroke-linecap=%27round%27 stroke-linejoin=%27round%27/%3E%3C/svg%3E"', svgDataURL5 = '"data:image/svg+xml,%3Csvg width=%2720%27 height=%2720%27 xmlns=%27http://www.w3.org/2000/svg%27%3E%3Cg stroke=%27%23FFF%27 fill=%27none%27 fill-rule=%27evenodd%27%3E%3Crect x=%2714.234%27 y=%278.477%27 width=%271.577%27 height=%273.123%27 rx=%27.789%27/%3E%3Cpath d=%27M10.993 13.205H6.66c-1.625 0-2.942-1.418-2.942-3.166 0-1.75 1.317-3.167 2.942-3.167h4.332%27 stroke-linecap=%27round%27/%3E%3Cg stroke-linecap=%27round%27%3E%3Cpath stroke-linejoin=%27round%27 d=%27m9.437 8.44-1.67 1.554 1.67 1.567%27/%3E%3Cpath d=%27M8.505 10h4.488%27/%3E%3C/g%3E%3C/g%3E%3C/svg%3E"', svgDataURL6 = '"data:image/svg+xml,%3Csvg width=%2712%27 height=%2712%27 viewBox=%270 0 12 12%27 fill=%27none%27 xmlns=%27http://www.w3.org/2000/svg%27 aria-hidden=%27true%27%3E%3Cpath d=%27M4.65 2.15a.5.5 0 0 0 0 .7L7.79 6 4.65 9.15a.5.5 0 1 0 .7.7l3.5-3.5a.5.5 0 0 0 0-.7l-3.5-3.5a.5.5 0 0 0-.7 0Z%27 fill=%27%23FFF%27 transform=%27rotate%28180, 6 6%29%27%3E%3C/path%3E%3C/svg%3E"', svgDataURL7 = '"data:image/svg+xml,%3Csvg width=%2720%27 height=%2720%27 viewBox=%270 0 20 20%27 fill=%27none%27 xmlns=%27http://www.w3.org/2000/svg%27 aria-hidden=%27true%27%3E%3Cpath d=%27M4.5 4A2.5 2.5 0 0 0 2 6.5v7A2.5 2.5 0 0 0 4.5 16h7a2.5 2.5 0 0 0 2.5-2.5v-1l2.4 1.8a1 1 0 0 0 1.6-.8v-7a1 1 0 0 0-1.6-.8L14 7.5v-1A2.5 2.5 0 0 0 11.5 4h-7ZM14 8.75l3-2.25v7l-3-2.25v-2.5ZM13 6.5v7c0 .83-.67 1.5-1.5 1.5h-7A1.5 1.5 0 0 1 3 13.5v-7C3 5.67 3.67 5 4.5 5h7c.83 0 1.5.67 1.5 1.5Z%27 fill=%27%23FFF%27%3E%3C/path%3E%3C/svg%3E"', svgDataURL8 = '"data:image/svg+xml,%3Csvg width=%2720%27 height=%2720%27 viewBox=%270 0 20 20%27 fill=%27none%27 xmlns=%27http://www.w3.org/2000/svg%27 aria-hidden=%27true%27%3E%3Cpath d=%27M4 3.5c0-.28.22-.5.5-.5h10c.28 0 .5.22.5.5v2a.5.5 0 0 1-1 0V4h-4v12h1.5a.5.5 0 0 1 0 1h-4a.5.5 0 0 1 0-1H9V4H5v1.5a.5.5 0 0 1-1 0v-2Z%27 fill=%27%23FFF%27%3E%3C/path%3E%3C/svg%3E"', svgDataURL9 = '"data:image/svg+xml,%3Csvg width=%2720%27 height=%2720%27 viewBox=%270 0 20 20%27 fill=%27none%27 xmlns=%27http://www.w3.org/2000/svg%27 aria-hidden=%27true%27%3E%3Cpath d=%27M6.3549 3.32239L6.68274 2.98983C6.68283 2.98974 6.68292 2.98965 6.68301 2.98956C7.32829 2.33672 8.3699 2.33681 9.01506 2.98983C9.66145 3.64409 9.66181 4.70494 9.01514 5.36362C9.01499 5.36377 9.01483 5.36393 9.01468 5.36409L5.99929 8.41437L2.98529 5.36369C2.33824 4.70877 2.33824 3.64445 2.98529 2.98953C3.62902 2.33797 4.67018 2.33797 5.31391 2.98953L5.64314 3.32278L5.99922 3.68318L6.3549 3.32239ZM10.8616 8.5L14 3.00778L17.1384 8.5H10.8616ZM2.5 11.5H8.5V17.5H2.5V11.5ZM17.5 14.5C17.5 16.1569 16.1569 17.5 14.5 17.5C12.8431 17.5 11.5 16.1569 11.5 14.5C11.5 12.8431 12.8431 11.5 14.5 11.5C16.1569 11.5 17.5 12.8431 17.5 14.5Z%27 stroke=%27%23FFF%27%3E%3C/path%3E%3C/svg%3E"', svgDataURL10 = '"data:image/svg+xml,%3Csvg width=%2720%27 height=%2720%27 viewBox=%270 0 20 20%27 fill=%27none%27 xmlns=%27http://www.w3.org/2000/svg%27 aria-hidden=%27true%27%3E%3Cpath d=%27M14.7 2.23a1 1 0 0 1 1.3.95V13.5a2.5 2.5 0 1 1-1-2V6.18L8 8.37v7.13a2.5 2.5 0 1 1-1-2V5.37a1 1 0 0 1 .7-.96l7-2.18ZM8 7.32l7-2.19V3.18L8 5.37v1.95ZM5.5 14a1.5 1.5 0 1 0 0 3 1.5 1.5 0 0 0 0-3Zm6.5-.5a1.5 1.5 0 1 0 3 0 1.5 1.5 0 0 0-3 0Z%27 fill=%27%23FFF%27%3E%3C/path%3E%3C/svg%3E"', styleList$5 = createStyleList$1();
styleList$5.push([
  117,
  `
  .no-head[mira-editor-el] .track-btn {
    display: none !important;
  }
  .mirae-track[mira-editor-el] {
    display: block;
    position: relative;
    height: 50px;
    // border-top: 4px solid #17171D;
    // border-top: 4px solid #004d52;
    background: #20202D;
    margin: 0px;
    margin-top: 4px;
    padding: 0;
    left: var(--trackHeadWidth);
    pointer-events: auto;
  }
  .mirae-track[mira-editor-el] ::before {
    border: 0;
    margin: 0;
    padding: 0;
  }
  .mirae-track[mira-editor-el] ::after {
    border: 0;
    margin: 0;
    padding: 0;
  }
  .mirae-track[mira-editor-el] .head {
    pointer-events: none;
    position: absolute;
    left: -150px;
    width: 150px;
    height: 100%;
    z-index: 10;
    background-color: rgba(32, 32, 45, 0.8);
  }
  .mirae-track[mira-editor-el] .head:before {
    content: "";
    position: absolute;
    width: 100%;
    height: 2px;
    top: -3px;
    background: transparent;
  }
  .mirae-track[mira-editor-el] .track-icon-btn {
    pointer-events: auto;
    cursor: pointer;
    background-color: rgba(54, 54, 91, 0.8);
    position: absolute;
    width: 20px;
    height: 20px;
    top: 50%;
    z-index: 13;
    transform: translateY(-50%);
    border-radius: 10px;
    left: -115px;
    width: 24px;
    height: 24px;
    border-radius: 5px;
    background-color: transparent;
  }
  .mirae-track[mira-editor-el] .track-icon-btn:hover {
    background-color: rgba(88, 88, 100, 0.8);
  }
  .mirae-track[mira-editor-el] .track-icon-btn:hover {
    z-index: 999;
  }
  .mirae-track[mira-editor-el] .track-icon-btn:hover:after {
    content: attr(data-tint);
    display: inline-block;
    position: absolute;
    left: calc(100% + 3px);
    top: 50%;
    padding: 0px 5px;
    height: 24px;
    background: rgba(54, 54, 91, 0.8);
    color: #FFF;
    font-size: 12px;
    line-height: 24px;
    white-space: nowrap;
    border-radius: 3px;
    transform: translateY(-50%);
  }
  .mirae-track[mira-editor-el] .track-audio-btn {
    pointer-events: auto;
    cursor: pointer;
    background-color: rgba(54, 54, 91, 0.8);
    position: absolute;
    width: 20px;
    height: 20px;
    top: 50%;
    z-index: 13;
    transform: translateY(-50%);
    border-radius: 10px;
    background-color: #004d52;
    background-position: center;
    background-size: 13px 13px;
    background-repeat: no-repeat;
    background-image: url(${svgDataURL1});
    left: -87px;
  }
  .mirae-track[mira-editor-el] .track-audio-btn:hover {
    background-color: rgba(88, 88, 100, 0.8);
  }
  .mirae-track[mira-editor-el] .track-audio-btn:hover {
    background-color: #004d52;
  }
  .mirae-track[mira-editor-el] .track-audio-btn.track-audio-off {
    background-color: rgba(54, 54, 91, 0.8);
    background-position: center;
    background-size: 13px 13px;
    background-repeat: no-repeat;
    background-image: url(${svgDataURL2});
  }
  .mirae-track[mira-editor-el] .track-audio-btn.track-audio-off:hover {
    background-color: rgba(88, 88, 100, 0.8);
  }
  .mirae-track[mira-editor-el] .track-visible-btn {
    pointer-events: auto;
    cursor: pointer;
    background-color: rgba(54, 54, 91, 0.8);
    position: absolute;
    width: 20px;
    height: 20px;
    top: 50%;
    z-index: 13;
    transform: translateY(-50%);
    border-radius: 10px;
    background-color: #004d52;
    background-position: center;
    background-size: 16px 16px;
    background-repeat: no-repeat;
    background-image: url(${svgDataURL3});
    left: -59px;
  }
  .mirae-track[mira-editor-el] .track-visible-btn:hover {
    background-color: rgba(88, 88, 100, 0.8);
  }
  .mirae-track[mira-editor-el] .track-visible-btn:hover {
    background-color: #004d52;
  }
  .mirae-track[mira-editor-el] .track-visible-btn.track-visible-off {
    background-color: rgba(54, 54, 91, 0.8);
    background-position: center;
    background-size: 16px 16px;
    background-repeat: no-repeat;
    background-image: url(${svgDataURL4});
  }
  .mirae-track[mira-editor-el] .track-visible-btn.track-visible-off:hover {
    background-color: rgba(88, 88, 100, 0.8);
  }
  .mirae-track[mira-editor-el] .track-arrange-btn {
    pointer-events: auto;
    cursor: pointer;
    position: absolute;
    width: 20px;
    height: 20px;
    top: 50%;
    z-index: 13;
    transform: translateY(-50%);
    border-radius: 10px;
    background-color: rgba(54, 54, 91, 0.8);
    background-position: center;
    background-size: 23px 23px;
    background-repeat: no-repeat;
    background-image: url(${svgDataURL5});
    left: -31px;
  }
  .mirae-track[mira-editor-el] .track-arrange-btn:hover {
    background-color: rgba(88, 88, 100, 0.8);
  }
  .mirae-track[mira-editor-el] .track-arrange-btn:hover {
    background-color: rgba(88, 88, 100, 0.8);
  }
  .mirae-track[mira-editor-el] .track-arrange-btn:hover {
    z-index: 999;
  }
  .mirae-track[mira-editor-el] .track-arrange-btn:hover:after {
    content: attr(data-tint);
    display: inline-block;
    position: absolute;
    left: calc(100% + 3px);
    top: 50%;
    padding: 0px 5px;
    height: 24px;
    background: rgba(54, 54, 91, 0.8);
    color: #FFF;
    font-size: 12px;
    line-height: 24px;
    white-space: nowrap;
    border-radius: 3px;
    transform: translateY(-50%);
  }
  .mirae-track[mira-editor-el] .go-back-btn {
    pointer-events: auto;
    cursor: pointer;
    background-color: rgba(54, 54, 91, 0.8);
    position: absolute;
    width: 20px;
    height: 20px;
    top: 50%;
    z-index: 13;
    transform: translateY(-50%);
    border-radius: 10px;
    background-position: center;
    background-size: 13px 13px;
    background-repeat: no-repeat;
    background-image: url(${svgDataURL6});
    background-position: 6px center;
    background-color: var(--miraeSelBorderColor);
    top: 18px;
    left: -70px;
    width: 62px;
  }
  .mirae-track[mira-editor-el] .go-back-btn:hover {
    background-color: rgba(88, 88, 100, 0.8);
  }
  .mirae-track[mira-editor-el] .go-back-btn:after {
    content: "返回";
    color: #FFF;
    font-size: 12px;
    line-height: 20px;
    position: absolute;
    left: 20px;
  }
  .mirae-track[mira-editor-el]:hover {
    background-color: #292933 !important;
  }
  .mirae-track[mira-editor-el]:hover .head {
    background-color: rgba(41, 41, 51, 0.8) !important;
  }
  .mirae-track[mira-editor-el].hide {
    border: 0!important;
    height: 0!important;
  }
  .mirae-track[mira-editor-el]:after {
    content: attr(data-name);
    position: absolute;
    width: 100%;
    height: 12px;
    top: 0px;
    left: calc(0px - var(--trackHeadWidth));
    color: #FFF;
    font-size: 12px;
    background: transparent;
  }
  .mirae-track[mira-editor-el]:before {
    content: "";
    position: absolute;
    width: var(--maxWidth);
    height: 2px;
    top: -3px;
    background: transparent;
  }
  .mirae-track[mira-editor-el].ruler {
    z-index: 100;
    position: sticky;
    top: 0px;
    height: 18px;
    border: 0px;
    margin: 0px;
    padding: 0px;
    background: rgba(23, 23, 29, 0.9);
    margin-bottom: 18px;
  }
  .mirae-track[mira-editor-el].ruler .head {
    background-color: transparent;
  }
  .mirae-track[mira-editor-el].ruler:hover {
    background: rgba(23, 23, 29, 0.9) !important;
  }
  .mirae-track[mira-editor-el].ruler:hover .head {
    background-color: transparent !important;
  }
  .mirae-track[mira-editor-el].ruler:hover .mark:after {
    opacity: 1;
  }
  .mirae-track[mira-editor-el].ruler:hover .cursor:after {
    opacity: 1;
  }
  .mirae-track[mira-editor-el].mirae-track-spine {
    background: #313147;
    height: 65px;
    margin-top: 0px;
    border-top-width: 0px;
  }
  .mirae-track[mira-editor-el].mirae-track-spine .track-icon-btn {
    background-position: center;
    background-size: 13px 13px;
    background-repeat: no-repeat;
    background-image: url(${svgDataURL7});
  }
  .mirae-track[mira-editor-el].mirae-track-spine .head {
    background: #313147;
  }
  .mirae-track[mira-editor-el].mirae-track-video {
    height: 69px;
  }
  .mirae-track[mira-editor-el].mirae-track-video .track-icon-btn {
    background-position: center;
    background-size: 13px 13px;
    background-repeat: no-repeat;
    background-image: url(${svgDataURL7});
  }
  .mirae-track[mira-editor-el].mirae-track-text {
    height: 36px;
  }
  .mirae-track[mira-editor-el].mirae-track-text .track-icon-btn {
    background-position: center;
    background-size: 13px 13px;
    background-repeat: no-repeat;
    background-image: url(${svgDataURL8});
  }
  .mirae-track[mira-editor-el].mirae-track-sticker {
    height: 36px;
  }
  .mirae-track[mira-editor-el].mirae-track-sticker .track-icon-btn {
    background-position: center;
    background-size: 13px 13px;
    background-repeat: no-repeat;
    background-image: url(${svgDataURL9});
  }
  .mirae-track[mira-editor-el].mirae-track-audio {
    height: 50px;
  }
  .mirae-track[mira-editor-el].mirae-track-audio .track-icon-btn {
    background-position: center;
    background-size: 13px 13px;
    background-repeat: no-repeat;
    background-image: url(${svgDataURL10});
  }
  .mirae-track[mira-editor-el].mirae-track-placeholder {
    background: transparent;
  }
  .mirae-track[mira-editor-el].mirae-track-placeholder .track-icon-btn {
    display: none;
  }
  .mirae-track[mira-editor-el].mirae-track-placeholder:after {
    content: "";
  }
  .mirae-track[mira-editor-el].mirae-track-placeholder.mirae-track-placeholder-bottom {
    height: 30px;
    border-color:#17171D;
  }
  .mirae-track[mira-editor-el].mirae-track-placeholder.mirae-track-placeholder-top {
    height: 0px;
  }
  .mirae-track[mira-editor-el].mirae-track-placeholder .head {
    background-color: transparent;
  }
  .mirae-track[mira-editor-el].mirae-track-placeholder:hover {
    background: transparent !important;
  }
  .mirae-track[mira-editor-el].mirae-track-placeholder:hover .head {
    background: transparent !important;
  }
  .mirae-track[mira-editor-el].top-insert:before {
    background-color: var(--miraeSelBorderColor);
  }
  .mirae-track[mira-editor-el].top-insert .head:before {
    background-color: var(--miraeSelBorderColor);
  }
  `,
  ""
]);
createStyleManager$1(styleList$5, createStyleOption$1());
styleList$5.locals && styleList$5.locals;
class EditorTrackElement extends CustomHtmlElementBase {
  init() {
    return this.addClass("mirae-track"), this.head = document.createElement("div"), this.head.classList.add("head"), this.append(this.head), super.init();
  }
  clear() {
    this.innerHTML = "";
  }
  get canSetAudio() {
    return this.type !== TYPE_PLACEHOLDER;
  }
  get canSetVisible() {
    return [TYPE_SPINE, TYPE_VIDEO, TYPE_TEXT, TYPE_STICKER].includes(
      this.type
    );
  }
  get canArrange() {
    return [TYPE_TEXT, TYPE_VIDEO].includes(this.type);
  }
  refresh() {
    if (this.canSetAudio) {
      let e = false;
      this.childNodes.forEach((t) => {
        t.node && t.node.audio && (e = true);
      }), this.audioBtn.toggleClass("track-audio-off", !e);
    }
    if (this.canSetVisible) {
      let e = false;
      this.childNodes.forEach((t) => {
        t.node && t.node.active && (e = true);
      }), this.visibleBtn.toggleClass("track-visible-off", !e);
    }
  }
  addBackBtn(e) {
    const t = EditorButtonComponent.create(this).addClass("go-back-btn");
    e && (t.onClick = e);
  }
  setType(e) {
    return this.type = e, this.iconBtn || (this.iconBtn = EditorButtonComponent.create(this).addClass(["track-icon-btn", "track-btn"]).set("data-tint", "Track selection all Ctrl+A"), this.iconBtn.onClick = () => {
      const t = [], r = [];
      this.childNodes.forEach((s) => {
        s.node && s.node.type && s.node.type !== "placeholder" && (s.hasClass("selected") ? t.push(s.node) : r.push(s.node), t.push(s.node));
      });
      const a = r.length > 0 ? r : t;
      a.length > 0 && a[0].emit(SELECT, {
        action: "multi",
        nodes: a
      });
    }), this.canSetAudio && (this.audioBtn = EditorButtonComponent.create(this).addClass([
      "track-audio-btn",
      "track-btn"
    ]), this.audioBtn.onClick = () => {
      const t = this.audioBtn.classList.contains("track-audio-off"), r = [], a = {};
      this.childNodes.forEach((s) => {
        s.node && s.apply && s.node.audio !== t && (r.push(s.node), a[s.node.id] = { to: { audio: t } });
      }), r.length > 0 && (this.applyChange(r, a), this.refresh());
    }), this.canSetVisible && (this.visibleBtn = EditorButtonComponent.create(this).addClass([
      "track-visible-btn",
      "track-btn"
    ]), this.visibleBtn.onClick = () => {
      const t = this.visibleBtn.classList.contains("track-visible-off"), r = [], a = {};
      this.childNodes.forEach((s) => {
        s.node && s.apply && s.node.active !== t && (r.push(s.node), a[s.node.id] = { to: { active: t } });
      }), r.length > 0 && (this.applyChange(r, a), this.refresh());
    }), this.canArrange && (this.arrangeBtn = EditorButtonComponent.create(this).addClass(["track-arrange-btn", "track-btn"]).set("data-tint", "对齐片段"), this.arrangeBtn.onClick = () => {
      const t = [], r = {}, a = [...this.childNodes].map((u) => u.node).filter((u) => u && u.apply).sort((u, l) => u.absStartTime - l.absStartTime);
      let s = 0;
      for (const u of a) {
        const l = u.parents.reverse().find((d) => ["creator", "scene"].includes(d.type));
        if (u.absStartTime - l.absStartTime === s && l === u.parent) {
          s += u.duration;
          continue;
        }
        const c = { start: s };
        !u.conf.duration && !u.conf.end && (c.duration = u.duration), l !== u.parent && (c.parent = l), r[u.id] = { to: c }, t.push(u), s += u.duration;
      }
      console.log("rrrr", r), t.length > 0 && this.applyChange(t, r);
    }), this.setName(e).addClass(`mirae-track-${e}`);
  }
  setName(e) {
    return this;
  }
  remove() {
    this.applyChange = null, super.remove();
  }
}
Ct(EditorTrackElement, "TAG", "mira-editor-track");
EditorTrackElement.register();
class EditorTrackComponent extends ViewComponentBase {
  constructor(e, t) {
    var r;
    super(t), this.type = this.determineType(e), [(r = e == null ? void 0 : e.parent) == null ? void 0 : r.type, e == null ? void 0 : e.type].includes(TYPE_SPINE) ? (this.type = TYPE_SPINE, this.id = `sp-${uuid().substring(0, 3)}`) : this.id = `tk-${uuid().substring(0, 3)}`, this.clips = [], this.view = EditorTrackElement.create().setType(this.type), this.view.applyChange = (a, s) => this.applyChange(a, s), this.type === TYPE_PLACEHOLDER && (this.view.addClass(`mirae-track-placeholder-${e}`), this.id = `ph-${e}`), this.view.set("data-id", this.id).setName(`${this.type}.${this.id}`);
  }
  selectAll() {
    const e = [];
    this.clips.forEach((t) => {
      t.node && t.node.type !== TYPE_PLACEHOLDER && e.push(t.node);
    }), e.length > 0 && e[0].emit(SELECT, { action: "multi", nodes: e });
  }
  canRemove() {
    return ![TYPE_PLACEHOLDER, TYPE_SPINE].includes(this.type) && this.clips.length === 0;
  }
  hide() {
    this.clips.forEach((e) => this.remove(e, false)), this.clips = [], this.view.show(false);
  }
  determineType(e) {
    return typeof e != "object" ? TYPE_PLACEHOLDER : ["image", "video", "scene", "trans"].includes(e.type) ? TYPE_VIDEO : e.type === "audio" ? TYPE_AUDIO : ["text", "richtext"].includes(e.type) ? TYPE_TEXT : TYPE_STICKER;
  }
  overlap(e) {
    if (!e.node.display || this.type === TYPE_AUDIO)
      return false;
    for (const t of this.clips)
      if (t !== e && t.overlap(e))
        return true;
    return false;
  }
  accept(e, t = false, r = []) {
    if (Array.isArray(e))
      return e.every((s) => this.accept(s, t, r));
    if (this.type === TYPE_SPINE && t)
      return e.node.parent === this.nodeTrack;
    if (this.nodeTrack && this.nodeTrack === e.node.parent)
      return true;
    const a = this.type === TYPE_SPINE ? TYPE_VIDEO : this.type;
    if (this.determineType(e.node) !== a)
      return false;
    if (!t && this.type === TYPE_SPINE)
      return true;
    for (const s of this.clips)
      if (s !== e && !r.includes(s.node) && s.overlap(e))
        return false;
    return true;
  }
  append(e, t = OP_MOVE) {
    var r;
    this.type === TYPE_SPINE && ((r = e.node.parent) == null ? void 0 : r.type) === TYPE_SPINE && (this.nodeTrack = e.node.parent), e.track && e.track !== this && e.track.remove(e, false), this.clips.includes(e) || this.clips.push(e), e.track = this, this.view.append(e.view), e.node.trackId ? e.node.trackId !== this.id && EditorTrackComponent.apply(e.node, { to: { trackId: this.id } }, t) : e.node.trackId = this.id, this.view.show(true), e.shadowTrack && (e.shadowTrack.view.removeClass("top-insert"), e.shadowTrack = null), this.lock(100, () => this.view.refresh(), "refresh"), window.requestAnimationFrame(() => e.view.refresh());
  }
  remove(e, t = true) {
    this.clips = this.clips.filter((r) => r.node.id !== e.node.id), e.track = null, t && e.view.remove(), this.lock(100, () => this.view.refresh(), "refresh");
  }
  toString() {
    return `${this.type} clips(${this.clips.length}): ${this.clips.map((e) => `${e.node.type}[${e.node.id}]`).join(", ")}`;
  }
  applyChange(e, t) {
    e.forEach((r) => {
      t[r.id] && EditorTrackComponent.apply(r, t[r.id], OP_CHANGE, {
        relativeNodes: e
      });
    }), this.editor._history.append(new Record(OP_CHANGE, e, t));
  }
  destroy() {
    this.clips = null, super.destroy();
  }
}
var splitCursorUrlPath = '"data:image/svg+xml,%3Csvg width=%2716%27 height=%2718%27 xmlns=%27http://www.w3.org/2000/svg%27%3E%3Cpath d=%27M3.205.716A.744.744 0 0 1 3.6.929l.079.095 6.476 9.97a3.242 3.242 0 0 1 2.125-.236c.77.176 1.474.63 1.953 1.326.478.696.65 1.517.54 2.298a3.242 3.242 0 0 1-1.156 2.057 3.242 3.242 0 0 1-2.244.732 3.242 3.242 0 0 1-2.147-.978 3.242 3.242 0 0 1-.92-2.174 3.243 3.243 0 0 1 .54-1.889l.134-.187-1.43-2.204-1.432 2.204c.472.611.695 1.347.674 2.076a3.242 3.242 0 0 1-.919 2.174 3.242 3.242 0 0 1-2.147.978 3.242 3.242 0 0 1-2.244-.732 3.242 3.242 0 0 1-1.156-2.057c-.11-.781.061-1.602.54-2.298a3.242 3.242 0 0 1 1.952-1.326 3.243 3.243 0 0 1 1.896.136l.23.1L6.651 8.36 2.417 1.83a.748.748 0 0 1-.08-.556c.522-.64.706-.589.868-.558zM11.55 12.18c-.483 0-.92.196-1.237.513A1.745 1.745 0 0 0 9.8 13.93c0 .483.196.92.513 1.238.317.316.754.512 1.237.512.484 0 .921-.196 1.238-.512.317-.317.512-.755.512-1.238s-.195-.92-.512-1.237a1.745 1.745 0 0 0-1.238-.513zm-8 0c-.483 0-.92.196-1.237.513A1.745 1.745 0 0 0 1.8 13.93c0 .483.196.92.513 1.238.317.316.754.512 1.237.512.484 0 .921-.196 1.238-.512.317-.317.512-.755.512-1.238s-.195-.92-.512-1.237a1.745 1.745 0 0 0-1.238-.513zM11.896.716c.8.21.83.398.868.558a.748.748 0 0 1-.08.557L8.75 7.899 7.852 6.52l3.576-5.506a.748.748 0 0 1 .468-.298z%27 fill=%27%23000%27 fill-rule=%27nonzero%27 stroke=%27%23FFF%27 stroke-width=%271%27/%3E%3C/svg%3E"', loadingImageUrlPath = '"data:image/svg+xml,%3C%3Fxml version=%271.0%27 encoding=%27utf-8%27%3F%3E%3Csvg xmlns=%27http://www.w3.org/2000/svg%27 xmlns:xlink=%27http://www.w3.org/1999/xlink%27 style=%27margin: auto; background: none; display: block; shape-rendering: auto;%27 width=%27200px%27 height=%27200px%27 viewBox=%270 0 100 100%27 preserveAspectRatio=%27xMidYMid%27%3E%3Ccircle cx=%2730%27 cy=%2750%27 fill=%27%231fb0f9%27 r=%2720%27%3E%3Canimate attributeName=%27cx%27 repeatCount=%27indefinite%27 dur=%271s%27 keyTimes=%270;0.5;1%27 values=%2730;70;30%27 begin=%27-0.5s%27%3E%3C/animate%3E%3C/circle%3E%3Ccircle cx=%2770%27 cy=%2750%27 fill=%27%23f8dd0b%27 r=%2720%27%3E%3Canimate attributeName=%27cx%27 repeatCount=%27indefinite%27 dur=%271s%27 keyTimes=%270;0.5;1%27 values=%2730;70;30%27 begin=%270s%27%3E%3C/animate%3E%3C/circle%3E%3Ccircle cx=%2730%27 cy=%2750%27 fill=%27%231fb0f9%27 r=%2720%27%3E%3Canimate attributeName=%27cx%27 repeatCount=%27indefinite%27 dur=%271s%27 keyTimes=%270;0.5;1%27 values=%2730;70;30%27 begin=%27-0.5s%27%3E%3C/animate%3E%3Canimate attributeName=%27fill-opacity%27 values=%270;0;1;1%27 calcMode=%27discrete%27 keyTimes=%270;0.499;0.5;1%27 dur=%271s%27 repeatCount=%27indefinite%27%3E%3C/animate%3E%3C/circle%3E%3C/svg%3E"';
const styleList$4 = createStyleList$1();
styleList$4.push([
  128,
  `
  .mirae-board[mira-editor-el] {
    display: block;
    position: relative;
    width: 100%;
    height: 100%;
    border: 0px;
    background: #17171D;
    overflow: scroll;
    pointer-events: auto;
    font-family: Helvetica, Arial;
  }
  .mirae-board[mira-editor-el].dragAdd {
    cursor: copy !important;
  }
  .mirae-board[mira-editor-el] * {
    font-family: Helvetica, Arial;
  }
  .mirae-board[mira-editor-el] ::before {
    border: 0;
    margin: 0;
    padding: 0;
    font-family: Helvetica, Arial;
  }
  .mirae-board[mira-editor-el] ::after {
    border: 0;
    margin: 0;
    padding: 0;
    font-family: Helvetica, Arial;
  }
  .mirae-board[mira-editor-el] * {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
  }
  .mirae-board[mira-editor-el].split-mode {
    cursor: url(${splitCursorUrlPath}) 7.5 9, auto;
  }
  .mirae-board[mira-editor-el].split-mode * {
    cursor: url(${splitCursorUrlPath}) 7.5 9, auto;
  }
  .mirae-board[mira-editor-el]::-webkit-scrollbar {
    width: 15px;
    height: 15px;
  }
  .mirae-board[mira-editor-el]::-webkit-scrollbar-corner {
    display: none;
  }
  .mirae-board[mira-editor-el]::-webkit-scrollbar-track {
    background: #17171D;
  }
  .mirae-board[mira-editor-el]::-webkit-scrollbar-thumb {
    background: #59575F;
    border-radius: 7.5px;
  }
  .mirae-board[mira-editor-el]::-webkit-scrollbar-thumb:hover {
    background: #73707C;
  }
  .mirae-board[mira-editor-el] .cursor {
    position: absolute;
    top: 0;
    width: 10px;
    height: var(--boardHeight);
    border-left: 1px solid #f80b76;
    pointer-events: none;
    z-index: 198;
    z-index: 199;
  }
  .mirae-board[mira-editor-el] .cursor:before {
    position: absolute;
    left: -6.5px;
    content: "";
    width: 0;
    height: 0;
    border: 6px solid;
    border-color: #f80b76 transparent transparent;
  }
  .mirae-board[mira-editor-el] .cursor:after {
    position: absolute;
    left: 2px;
    top: 12px;
    padding: 0px 5px;
    content: attr(data-time);
    height: 18px;
    background: rgba(54, 54, 91, 0.8);
    color: #FFF;
    font-size: 12px;
    line-height: 18px;
    border-radius: 3px;
    opacity: 0;
    transition-property: opacity;
    transition-duration: 0.3s;
  }
  .mirae-board[mira-editor-el] .mark {
    position: absolute;
    top: 0;
    width: 10px;
    height: var(--boardHeight);
    border-left: 1px solid var(--miraeSelBorderColor);
    pointer-events: none;
    z-index: 198;
  }
  .mirae-board[mira-editor-el] .mark:before {
    position: absolute;
    left: -6.5px;
    content: "";
    width: 0;
    height: 0;
    border: 6px solid;
    border-color: var(--miraeSelBorderColor) transparent transparent;
  }
  .mirae-board[mira-editor-el] .mark:after {
    position: absolute;
    left: 2px;
    top: 12px;
    padding: 0px 5px;
    content: attr(data-time);
    height: 18px;
    background: rgba(54, 54, 91, 0.8);
    color: #FFF;
    font-size: 12px;
    line-height: 18px;
    border-radius: 3px;
    opacity: 0;
    transition-property: opacity;
    transition-duration: 0.3s;
  }
  .mirae-board[mira-editor-el] .mark.split {
    border-left-width: 2px !important;
  }
  .mirae-board[mira-editor-el] .mark.error {
    border-left: 1px solid #E33 !important;
  }
  .mirae-board[mira-editor-el] .mark.error:before {
    border-color: #E33 transparent transparent !important;
  }
  .mirae-board[mira-editor-el] .pointer {
    position: absolute;
    top: 0;
    width: 10px;
    height: var(--boardHeight);
    border-left: 1px solid #F8DD0B;
    pointer-events: none;
    z-index: 198;
    border-left: 1px solid transparent;
    z-index: 199;
  }
  .mirae-board[mira-editor-el] .pointer:before {
    position: absolute;
    left: -3.5px;
    content: "";
    width: 0;
    height: 0;
    border: 3px solid;
    border-color: #F8DD0B transparent transparent;
  }
  .mirae-board[mira-editor-el] .pointer:after {
    position: absolute;
    left: 2px;
    top: 12px;
    padding: 0px 5px;
    content: attr(data-time);
    height: 18px;
    background: rgba(54, 54, 91, 0.8);
    color: #FFF;
    font-size: 12px;
    line-height: 18px;
    border-radius: 3px;
    opacity: 0;
    transition-property: opacity;
    transition-duration: 0.3s;
  }
  .mirae-board[mira-editor-el] .pointer:after {
    background: rgba(88, 88, 100, 0.5);
  }
  .mirae-board[mira-editor-el] .constraint {
    position: absolute;
    top: 0;
    width: 10px;
    height: var(--boardHeight);
    border-left: 1px solid var(--miraeRefLineColor);
    pointer-events: none;
    z-index: 198;
    border-left-style: dashed;
  }
  .mirae-board[mira-editor-el] .constraint:before {
    position: absolute;
    left: -0.5px;
    content: "";
    width: 0;
    height: 0;
    border: 0px solid;
    border-color: var(--miraeRefLineColor) transparent transparent;
  }
  .mirae-board[mira-editor-el] .constraint:after {
    position: absolute;
    left: 2px;
    top: 12px;
    padding: 0px 5px;
    content: attr(data-time);
    height: 18px;
    background: rgba(54, 54, 91, 0.8);
    color: #FFF;
    font-size: 12px;
    line-height: 18px;
    border-radius: 3px;
    opacity: 0;
    transition-property: opacity;
    transition-duration: 0.3s;
  }
  .mirae-board[mira-editor-el] .constraint:after {
    display: none;
  }
  .mirae-board[mira-editor-el] .mirae-board-selection {
    position: absolute;
    z-index: 199;
    border: 1px solid rgba(230, 230, 230, 0.6);
    border-radius: 3px;
    background: rgba(255, 255, 255, 0.3);
  }
  .mirae-board[mira-editor-el] .video-end-cover {
    pointer-events: none;
    position: absolute;
    z-index: 200;
    top: 0;
    left: var(--endLeft);
    height: var(--boardHeight);
    width: calc(var(--maxWidth) + var(--trackHeadWidth) - var(--endLeft));
    background: rgba(0, 0, 0, 0.5);
    transition-duration: 0;
    border-left: 2px dashed #666;
  }
  .mirae-board[mira-editor-el] .video-end-cover.animation {
    transition-duration: 0.3s;
    transition-property: left;
  }
  .mirae-loading-bg {
    position: absolute;
    background-color: rgba(0, 0, 0, 0.6);
    background-image: url(${loadingImageUrlPath});
    background-position: center;
    background-size: 50px 50px;
    background-repeat: no-repeat;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 201;
  }
  .mirae-loading-bg:before {
    border: 0;
    margin: 0;
    padding: 0;
    font-family: Helvetica, Arial;
    content: attr(data-progress);
    position: absolute;
    height: 20px;
    width: 50px;
    top: calc(50% + 15px);
    left: calc(50% - 25px);
    color: #CCC;
    font-size: 12px;
    text-align: center;
  }
  .ruler-canvas {
    position: absolute;
    width: 100%;
    height: 16px;
    top: 0;
    left: 0;
    z-index: 100;
    pointer-events: none;
    margin: 0;
    padding: 0;
  }
  `,
  ""
]);
createStyleManager$1(styleList$4, createStyleOption$1());
styleList$4.locals && styleList$4.locals;
var { bounds, intersect } = PositionUtils;
class EditorBoardElement extends CustomHtmlElementBase {
  init() {
    return this.addClass("mirae-board"), this.cursor = {}, this.cursorTime = {}, this.onscroll = (e) => this.onScroll(e), super.init();
  }
  setHead(e) {
    return this.trackHeadWidth = 120, e || this.addClass("no-head"), this.setStyleVars({
      "--trackHeadWidth": `${this.trackHeadWidth}px`
    });
  }
  addEndCover() {
    this.videoEndCover || (this.videoEndCover = document.createElement("div"), this.videoEndCover.classList.add("video-end-cover")), this.ruler.append(this.videoEndCover);
  }
  addMoveListener(e) {
    return super.addMoveListener(e), this.addEventListener("mousewheel", (t) => {
      if (t.ctrlKey && (t.preventDefault(), t.stopImmediatePropagation(), e && e.onScale)) {
        const r = t.wheelDelta % 120 === 0 ? t.wheelDelta : t.wheelDeltaX || t.wheelDeltaY;
        e.onScale(e.relativeScale + (r > 0 ? 0.01 : -0.01));
      }
    }), this;
  }
  onScroll(e) {
    this.updateClipScroll(), this.moveListener.onScroll(e);
  }
  updateClipScroll() {
    for (const e of this.childNodes)
      if (e.classList.contains("mirae-track"))
        for (const t of e.childNodes)
          t.onScroll && t.onScroll({
            x: this.scrollLeft - this.trackHeadWidth,
            y: this.scrollTop
          });
  }
  pointerTime(e) {
    return ((e instanceof Vector ? e.x : this.eventPoint(e).x) - this.trackHeadWidth) / this.scale;
  }
  eventPoint(e) {
    return this.rebase(new Vector(e));
  }
  rebase(e) {
    const t = [-this.scrollLeft, -this.scrollTop];
    return e.rebase(this).rebase(t);
  }
  relativeRect(e) {
    const t = [-this.scrollLeft, -this.scrollTop];
    return e.nodeType === 1 && e.getBoundingClientRect && (e = e.getBoundingClientRect()), e.rebase(this.getBoundingClientRect()).rebase(t);
  }
  selection(e, t) {
    if (!e || !t) {
      this.selectionBox && (this.selectionBox.remove(), this.selectionBox = null);
      return;
    }
    const r = bounds([e, t]), a = this.rebase(r);
    this.selectionBox || (this.selectionBox = document.createElement("div"), this.selectionBox.classList.add("mirae-board-selection"), this.append(this.selectionBox), this.selected = {});
    for (const s of ["top", "left", "width", "height"])
      this.selectionBox.style[s] = `${a[s]}px`;
    this.rendering || (this.rendering = true, requestAnimationFrame(() => {
      var l;
      const s = {};
      for (const c of this.childNodes)
        if (c.classList.contains("mirae-track"))
          for (const d of c.childNodes)
            (l = d.node) != null && l.id && d.node.type !== "placeholder" && intersect(a, this.relativeRect(d)) && (s[d.node.id] = d.node);
      const u = [];
      for (const [c, d] of Object.entries(s))
        this.selected[c] || u.push(d);
      for (const [c, d] of Object.entries(this.selected))
        s[c] || u.push(d);
      u[0] && u[0].emit(SELECT, {
        action: "multi",
        nodes: u
      }), this.selected = s, this.rendering = false;
    }));
  }
  setScale(e) {
    this.scale = e;
    for (const [t, r] of Object.entries(this.cursor))
      r.parentNode && (r.style.left = this.cursorTime[t] * this.scale + "px");
    this.refreshEndCover(false);
  }
  get ruler() {
    if (this._ruler) return this._ruler;
    for (const e of this.childNodes)
      if (e.classList.contains("ruler")) {
        this._ruler = e;
        break;
      }
    return this._ruler;
  }
  showCursor(e, t, r = true, a = true) {
    return a && (t = Math.max(Math.min(t, this.duration), 0)), t = r ? Math.floor(t * this.fps) / this.fps : Math.floor(100 * t) / 100, t = round$2(t, 3), this.cursorTime[e] = t, this.cursor[e] || (this.cursor[e] = document.createElement("div"), this.cursor[e].classList.add(e)), this.cursor[e].parentNode || this.ruler.append(this.cursor[e]), this.cursor[e].style.left = t * this.scale + "px", this.cursor[e].setAttribute(
      "data-time",
      TimeUtils$1.secondsToHms(t, 1, true)
    ), t;
  }
  flashCursor(e, t, r = 500) {
    this.cursor[e] && (this.cursor[e].classList.add(t), this.lock(
      r,
      () => {
        this.cursor[e].classList.remove(t);
      },
      `FlashCursor:${e}`
    ));
  }
  scrollToCursor(e) {
    if (!this.parentElement) return;
    const t = this.cursorTime[e] * this.scale;
    !this.cursor[e] || !this.cursor[e].parentNode || this.locked("scroll") || this.scrollLeft <= t && t <= this.scrollLeft + this.parentElement.offsetWidth || (this.lock(2e3, null, "scroll"), this.cursor[e].scrollIntoView({
      behavior: "smooth",
      block: "center",
      inline: "start"
    }));
  }
  hideCursor(e) {
    this.cursor[e] && (this.cursor[e].remove(), delete this.cursor[e]);
  }
  showConstraint(e) {
    this.constraint && this.constraint !== e && this.hideConstraint(), this.constraint = e, this.showCursor(
      "constraint",
      e.time - this.root.absStartTime,
      false,
      false
    ), this.constraint.clip && this.constraint.clip.view.addClass("constraint-related");
  }
  hideConstraint() {
    this.hideCursor("constraint"), this.constraint && this.constraint.clip && this.constraint.clip.view.removeClass("constraint-related");
  }
  setDuration(e) {
    this.duration = e, this.refreshEndCover();
  }
  refreshEndCover(e = true) {
    e && this.videoEndCover && (this.videoEndCover.classList.add("animation"), this.lock(
      500,
      () => {
        this.videoEndCover.classList.remove("animation");
      },
      "end-cover-ani"
    )), this.setStyleVars({
      "--endLeft": 1 + this.duration * this.scale + "px"
    });
  }
  setWidth(e) {
    this.setStyleVars({ "--maxWidth": e });
  }
  setHeight(e) {
    this.setStyleVars({ "--boardHeight": `${e}px` });
  }
  scrollToVisible(e) {
    const t = this.eventPoint(e), [r, a, s, u] = [
      this.scrollLeft,
      this.scrollTop,
      this.scrollWidth,
      this.scrollHeight
    ], [l, c] = [
      this.parentElement.offsetWidth,
      this.parentElement.offsetHeight
    ], d = { x: 0, y: 0 };
    return t.x < r + 8 && r > 0 ? d.x = -Math.min(30, r) : t.x > r + l - 8 && r + l < s && (d.x = Math.min(30, s - (r + l))), t.y < a + 8 && a > 0 ? d.y = -Math.min(30, a) : t.y > a + c - 8 && a + c < u && (d.y = Math.min(30, u - (a + c))), this.scrollTo({
      top: a + d.y,
      left: r + d.x,
      behavior: "auto"
    }), d;
  }
  remove() {
    this.root = null, super.remove();
  }
}
Ct(EditorBoardElement, "TAG", "mira-editor-board");
EditorBoardElement.register();
const styleList$3 = createStyleList$1();
styleList$3.push([
  133,
  `
  .mirae-menu[mira-editor-el] {
    margin: 0px;
    padding: 0px;
    display: block;
    position: absolute;
    overflow: hidden;
    pointer-events: auto;
    background: #1A191B;
    border: 1px solid #393943;
    border-radius: 3px;
    z-index: 199;
    opacity: 0;
    transition-property: opacity, height;
    transition-duration: 0.3s;
    -webkit-user-select: none;
    user-select: none;
  }
  .mirae-menu[mira-editor-el] * {
    margin: 0px;
    padding: 0px;
  }
  .mirae-menu[mira-editor-el] .mirae-menu-line {
    height: 1px;
    width: 100%;
    background: #393943;
  }
  .mirae-menu[mira-editor-el] .mirae-menu-item {
    display: flex;
    min-width: 130px;
    padding: 8px 12px;
    align-items: center;
    justify-content: center;
    color: #FFF;
  }
  .mirae-menu[mira-editor-el] .mirae-menu-item.mirae-menu-item-disable {
    color: #666;
    cursor: not-allowed;
  }
  .mirae-menu[mira-editor-el] .mirae-menu-item:hover {
    background: #3D3D48;
  }
  .mirae-menu[mira-editor-el] .mirae-menu-item .mirae-menu-item-title {
    flex-grow: 1;
    font-size: 12px;
    margin-right: 15px;
  }
  .mirae-menu[mira-editor-el] .mirae-menu-item .mirae-menu-item-keys {
    display: flex;
    align-items: center;
    justify-content: center;
  }
  .mirae-menu[mira-editor-el] .mirae-menu-item .mirae-menu-item-keys div {
    margin-left: 3px;
    color: #FFF;
    font-size: 12px;
    min-width: 18px;
    height: 18px;
    background: #3e3e48;
    border-radius: 2px;
    line-height: 18px;
    text-align: center;
  }
  `,
  ""
]);
createStyleManager$1(styleList$3, createStyleOption$1());
styleList$3.locals && styleList$3.locals;
class EditorMenuElement extends CustomHtmlElementBase {
  init() {
    return this.addClass("mirae-menu"), super.init();
  }
  addItem(e) {
    const t = document.createElement("div");
    if (this.append(t), typeof e != "object")
      return t.classList.add("mirae-menu-line");
    const r = e.keys || [];
    t.innerHTML = `
      <div class="mirae-menu-item-title">${e.title}</div>
      <div class="mirae-menu-item-keys">${r.map((a) => `<div>${a}</div>`).join("")}</div>
    `, t.classList.add("mirae-menu-item"), e.enable === false && t.classList.add("mirae-menu-item-disable"), t.addEventListener("click", (a) => {
      a.preventDefault(), e.click && e.click(a), this.remove();
    });
  }
  setMenu(e) {
    for (const t of e)
      this.addItem(t);
    return this;
  }
  setPosition(e) {
    const t = this.parentNode, r = new Vector(e).rebase(t), a = t.getBoundingClientRect(), s = this.getBoundingClientRect(), u = { opacity: 1 };
    return a.width - (r.x - t.scrollLeft) > s.width + 15 ? u.left = `${r.x}px` : u.left = `${r.x - s.width}px`, a.height - (r.y - t.scrollTop) > s.height + 15 ? u.top = `${r.y}px` : u.top = `${r.y - s.height}px`, this.setStyle(u), this;
  }
  remove() {
    this.setStyle({ opacity: 0 }), this.lock(300, () => super.remove(), "remove");
  }
  static create(e) {
    const { parent: t, menu: r, event: a } = e;
    return super.create(t).setMenu(r).setPosition(a);
  }
}
Ct(EditorMenuElement, "TAG", "mira-editor-menu");
EditorMenuElement.register();
class EditorClipGroup extends VNode$1 {
  constructor(e, t) {
    super({ type: "clipgroup" }), this.board = e, this.nodes = {}, Array.isArray(t) ? t.map((r) => this.toggleNode(r)) : typeof t == "object" && this.toggleNode(t);
  }
  get canUnlock() {
    return this.ns.filter((e) => e.groupId === this.id).length > 0;
  }
  get canLock() {
    return this.ns.filter((e) => e.groupId !== this.id).length > 0 && this.ns.length > 1;
  }
  get ns() {
    return Object.values(this.nodes);
  }
  lock() {
    this.ns.map(
      (e) => ViewComponentBase.apply(e, { to: { groupId: this.id } }, OP_MOVE)
    ), this.emit(CHANGING, { action: OP_END });
  }
  unlock() {
    this.ns.map(
      (e) => ViewComponentBase.apply(e, { to: { groupId: "NULL" } }, OP_MOVE)
    ), this.emit(CHANGING, { action: OP_END });
  }
  moveDelta(e) {
    let t = this.clips();
    t.sort((r, a) => r.node.startTime - a.node.startTime), t[0] && t[0].proxyState.left + e.x < 0 && (e.x = -t[0].proxyState.left), t.map((r) => r.moveDelta(e));
  }
  clips() {
    return this.mapClip((e) => e);
  }
  contains(e) {
    return e && this.nodes && this.nodes[e.id];
  }
  mapClip(e) {
    return this.ns.map(
      (t) => this.board.clips[t.id] && this.contains(t) ? e(this.board.clips[t.id]) : null
    ).filter((t) => t);
  }
  toggleNode(e) {
    return this.groupSelect(e) || (this.contains(e) ? delete this.nodes[e.id] : this.nodes[e.id] = e), this;
  }
  virtualBox(e) {
    const t = [];
    return this.ns.map((r) => {
      t.push(this.board.createBox(r, e));
    }), {
      remove: () => {
        t.map((r) => r && r.remove());
      },
      show: () => {
      }
    };
  }
  destroy() {
    super.destroy(), this.nodes = null, this.board = null;
  }
  groupSelect(e) {
    return false;
  }
}
var { secondsToHms: O } = TimeUtils$1;
const L = [1, 2, 3, 5, 10, 30, 60], Su = class Su2 extends EditorSelectComponent {
  constructor(e, t, r) {
    super(r), this.dirtyRuler = true, this.root = e, this.boardEvents = {}, e.conf.cropMode === "time" && (e.cropMode = e.conf.cropMode), this.container = t, this.init(), this.bindBoardEvents(true);
  }
  get cropMode() {
    var e;
    return ((e = this.editor.opts) == null ? void 0 : e.cropMode) === "time" || this.root.cropMode === "time";
  }
  bindBoardEvents(e) {
    const t = this.editor.playerWrapper;
    Object.values(this.boardEvents).length || (this.boardEvents.timeupdate = (r) => {
      if (t.playing) {
        const a = r.currentTime / 1e3 - this.root.absStartTime;
        this.view.hideCursor("cursor"), this.view.showCursor("mark", a), this.markTime = a, this.editor.opts.followTimeMark && this.view.scrollToCursor("mark"), this.root.type !== "creator" && a > this.duration && t.pause(), this.pauseAfterCropEnd && a > this.cropNode.cropEnd && (t.pause(), this.pausedByEnd = true, t.currentTime = this.cropNode.cropEnd);
      }
    }, this.boardEvents.playing = (r) => {
      this.pausedByEnd = false;
      const a = r.currentTime / 1e3;
      this.cropMode && this.cropNode && (this.pauseAfterCropEnd = a < this.cropNode.cropEnd);
    }, this.boardEvents.menu = (r) => {
      var s, u, l;
      if (r.preventDefault(), this.cropMode)
        return void this.lock(100, () => this.showCropMenu(r), "contextmenu");
      let a = r.target;
      for (; a.parentNode; ) {
        if ((s = a.node) != null && s.id && this.clips[(u = a.node) == null ? void 0 : u.id]) {
          (l = this.selected) != null && l.nodes && this.selected.contains(a.node) || a.node.emit(SELECT, { action: "track", event });
          break;
        }
        a = a.parentNode;
      }
      this.lock(100, () => this.showMenu(r), "contextmenu");
    }, this.boardEvents.mousemove = (r) => {
      this.view.cursor.cursor && r.path && !r.path.includes(this.view) && (this.view.hideCursor("cursor"), this.markTime !== void 0 && this.editor.enabled && this.seek(this.markTime, 200)), Array.isArray(this.editor.dragNodes) && this.editor.dragNodes.length && this.dragNodes(this.editor.dragNodes, r);
    }), e ? (t.on("timeupdate", this.boardEvents.timeupdate), t.on("playing", this.boardEvents.playing), this.editor.on("mousemove", this.boardEvents.mousemove), this.container.addEventListener("contextmenu", this.boardEvents.menu)) : (t.off("timeupdate", this.boardEvents.timeupdate), t.off("playing", this.boardEvents.playing), this.editor.off("mousemove", this.boardEvents.mousemove), this.container.removeEventListener(
      "contextmenu",
      this.boardEvents.menu
    ));
  }
  get duration() {
    return this.root.duration || 60;
  }
  init() {
    this.view = EditorBoardElement.create(this.container).addMoveListener(this).setHead(!this.cropMode), this.view.root = this.root, this.container.style.position = "relative", this.container.style.padding = "0", this.view.setStyleVars(this.editor.colors), this.fps = this.view.fps = this.root.rootConf("fps");
    const e = [];
    this.getAllNodes(this.root, e), this.nodes = e;
    let t = this.duration, r = 1.6;
    this.cropMode && (e.map((a) => {
      a.cropMode = "time", a.cropStart = Number(a.conf.cropStart || 0), a.cropEnd = Number(a.conf.cropEnd || a.endTime), t = a.cropEnd - a.cropStart, this.cropNode = a;
    }), r = 3), this.scale = this.container.offsetWidth / (t * r), this.view.setScale(this.scale), this.setScaleRange(), this.ruler = EditorTrackElement.create(this.view).addClass("ruler").addMoveListener(this), this.renderRuler(), this.clips = {};
    for (const a of e) this.createClip(a);
    if (this.tracks = [], this.parseTrack(), !this.cropMode) {
      this.view.addEndCover(), this.bottomTrack = new EditorTrackComponent("bottom", this.editor), this.topTrack = new EditorTrackComponent("top", this.editor);
      const a = this.tracks.findIndex((s) => s.type === TYPE_SPINE);
      a < 0 ? (this.tracks.push(this.topTrack), this.tracks.push(new EditorTrackComponent({ type: TYPE_SPINE }, this.editor)), this.tracks.push(this.bottomTrack)) : (this.tracks.push(this.bottomTrack), this.tracks.splice(a, 0, this.topTrack));
    }
    for (const a of this.tracks) this.view.append(a.view);
    this.renderTrack(), this.view.setDuration(this.duration), this.cropMode && setTimeout(() => {
      this.cropNode && (this.clips[this.cropNode.id].view.scrollToVisible({
        center: true,
        smooth: false
      }), this.mark(this.cropNode.cropStart));
    }, 100);
  }
  createClip(e) {
    var r;
    const t = new EditorClipComponent(e, this.root, this.editor);
    if (t.view.setScale(this.scale), t.on("movestart", (a) => this.onClipMoveStart(t, a)), t.on("moveend", (a) => this.onClipMoveEnd(t, a)), t.on("move", (a) => this.onClipMove(t, a)), t.on("resize", (a) => this.onClipResize(t, a)), t.on("dblclick", (a) => this.onClipDblClick(t, a)), t.on("timemark", (a) => {
      this.mark(a.time), this.pausedByEnd && this.editor.playerWrapper.play();
    }), this.clips[e.id] = t, e.clip = t, !e.trackId && this.tracks)
      if (((r = e.parent) == null ? void 0 : r.type) === TYPE_SPINE) {
        const a = this.tracks.find((s) => s.type === TYPE_SPINE);
        e.trackId = a ? a.id : null;
      } else
        e.type === "audio" && e.parent === this.root && (e.trackId = this.bottomTrack.id);
    if (t.view.addClass("auto-hover", 500), e.type !== TYPE_PLACEHOLDER) {
      const a = Object.values(this.clips).find((s) => s.node.type === TYPE_PLACEHOLDER);
      if (a) {
        const s = a.node;
        a.destroy(), s.remove().destroy(), delete this.clips[s.id];
      }
    }
    return t;
  }
  autoScale(e) {
    e = e || 1.6, this.setScale(this.container.offsetWidth / (this.duration * e), false), this.setScaleRange();
  }
  trackInfo(e = true) {
    return this.tracks.filter((t) => !e || !t.canRemove()).map((t, r) => {
      const a = this.view.relativeRect(t.view);
      return { track: t, i: r, y: [a.top, a.bottom] };
    }).sort((t, r) => t.y[0] - r.y[0]);
  }
  escape() {
    this.splitMode = false, this.view.toggleClass("split-mode", this.splitMode);
  }
  enableMulti(e) {
    super.enableMulti(e), Object.values(this.clips).map((t) => {
      t.view.update();
    });
  }
  get splitMode() {
    return this._splitMode;
  }
  set splitMode(e) {
    this._splitMode = e, this.editor.emit("splitModeChanged", { value: this.splitMode });
  }
  onKey(e, t) {
    const r = t.altKey || t.ctrlKey || t.shiftKey || t.metaKey;
    if (t.mctrlKey && e === "a") this.selectAll(this.markTrack);
    else if (t.mctrlKey && e === "x" && this.editor.responder === "board" && this.selected)
      this.cut(this.selected);
    else if (e === "v" && this.editor.responder === "board" && this.selected && !r)
      t.type !== "keyup" || this.locked("paste") || this.toggleEnable(this.selected);
    else if (["i", "o"].includes(e) && this.cropMode && this.cropNode)
      t.type === "keyup" && this.crop(e);
    else if (!["a", "b", "s"].includes(e) || this.cropMode || r)
      if (["b", "k"].includes(e) && !this.cropMode && t.mctrlKey && this.editor.responder === "board") {
        const a = this.currentMarkTime();
        if (!a) return;
        let s = [];
        e === "b" && this.selected ? this.selected.nodes ? s = Object.values(this.selected.nodes) : s.push(this.selected) : e === "k" && (s = this.nodes), s = s.filter((u) => a > u.absStartTime && a < u.absEndTime), s.length > 0 ? (this.view.flashCursor("mark", "split"), (async () => {
          for (const u of s) await this.editor.split(u, a, false);
          s[0].emit(CHANGING, { action: OP_END });
        })()) : this.view.flashCursor("mark", "error");
      } else {
        if (t.type !== "keydown" || !["arrowleft", "arrowright"].includes(e))
          return;
        {
          const a = this.markTime || this.cursorTime;
          if (this.editor.responder !== "board" || isNaN(a)) return;
          const s = e === "arrowleft" ? -Math.floor(100 / this.fps) / 100 : Math.ceil(100 / this.fps) / 100;
          this.mark(a + s);
        }
      }
    else
      this.editor.playerWrapper.playing && this.editor.playerWrapper.pause(), this.splitMode = e === "s" ? t.type === "keydown" : e === "b", this.view.toggleClass("split-mode", this.splitMode);
    t != null && t.preventDefault && t.preventDefault();
  }
  changeEvents() {
    return {
      history: ["undo", "redo"],
      starts: [],
      ends: [OP_END],
      [OP_DELETE]: OP_DELETE,
      [OP_ADD]: OP_ADD,
      [OP_MOVE]: OP_MOVE,
      [OP_SPLIT]: OP_SPLIT
    };
  }
  copy() {
    super.copy(), this.addClassToNode(this.editor.copyNode, "copy");
  }
  cut(e) {
    this.editor.copyNode = null, this.editor.cutNode = e, this.addClassToNode(e, "cut");
  }
  dragEnd() {
    Array.isArray(this.dragClips) && this.dragClips.map((e) => e.destroy()), this.dragClips = null, this.view.removeClass("dragAdd");
  }
  dragNodes(e, t) {
    var p, m;
    const { scrollLeft: r, scrollTop: a } = this.view, s = this.view.eventPoint(t).rebase([r, a]), { offsetWidth: u, offsetHeight: l } = this.view.parentElement;
    if (!(5 < s.y && s.y < l - 5 && 5 < s.x && s.x < u - 5))
      return void (this.dragClips && (this.dragEnd(), this.editor.emit("dragNodeOut")));
    if (!this.dragClips) {
      this.dragClips = [];
      for (const y of e) {
        const x = new EditorClipComponent(y, this.root, this.editor);
        this.bottomTrack.append(x), x.view.setScale(this.scale).addClass("hover").set("data-vtitle", ((p = y.conf.userfile) == null ? void 0 : p.name) || "").set("vtype", y.type === "trans" ? "trans" : x.track.typeOf(y)), x.oriRect = this.view.relativeRect(x.view), this.dragClips.push(x);
      }
      this.view.addClass("dragAdd"), this.editor.emit("dragNodeIn");
    }
    const c = this.view.eventPoint(t);
    let d = Math.max(0, this.view.pointerTime(c)), f = 0;
    for (const y of this.dragClips) {
      if (!y.node) return;
      y.node.conf.start = ((m = y.shadowTrack) == null ? void 0 : m.type) == TYPE_SPINE ? void 0 : d, y.view.setStyle({
        left: `${c.x - this.view.trackHeadWidth + f}px`,
        top: c.y - y.oriRect.top - 0.5 * y.oriRect.height + "px"
      }), d = y.node.absEndTime, f += y.oriRect.width, y.initProxyState(), y.moveDelta({ x: 0, y: 0 });
    }
    this.locked("auto-scroll") || (this.view.scrollToVisible(t), this.lock(50, () => this.renderTrack(), "auto-scroll")), this.onClipsChange(this.dragClips), this.relatedMove(true), this.constraint(this.dragClips, { type: "move", event: t });
  }
  addClassToNode(e, t, r = 300) {
    e && (e.nodes && e.mapClip ? e.mapClip((a) => a.view.addClass(t, r)) : this.clips[e.id] && this.clips[e.id].view.addClass(t, r));
  }
  async paste(e, t = {}) {
    if (this.lock(500, null, "paste"), !t.time && this.markTime && (t.time = this.currentMarkTime()), !t.track && this.markTrack && (t.track = this.markTrack), e || this.editor.copyNode)
      return await super.paste(e || this.editor.copyNode, t);
    if (this.editor.cutNode && t.time && t.track && t.track.type !== TYPE_SPINE) {
      let r = [];
      if (this.editor.cutNode instanceof EditorClipGroup ? r = this.editor.cutNode.clips() : this.clips[this.editor.cutNode.id] && r.push(this.clips[this.editor.cutNode.id]), !r.length)
        return;
      r.sort((l, c) => l.absStartTime - c.absStartTime);
      const a = r[0].absStartTime, s = this.root.creator(), u = r.map((l) => t.time + (l.node.absStartTime - a));
      r.map((l, c) => {
        const d = { start: u[c], parent: s };
        EditorClipComponent.apply(l.node, { to: d }, OP_MOVE), l.shadowTrack = t.track, this.addToTrack(l);
      }), r.map((l) => l.moveEnd()), this.editor.cutNode = null;
    }
  }
  setClipShow(e) {
    let t = this.clips[e.target.id];
    if (t) {
      const r = !this.visible(e.target);
      t.show(!r), r && (t.track.remove(t), delete this.clips[e.target.id]);
    }
  }
  updatezIndex() {
    this.root.maxzIndex = 0;
    for (const e of this.trackInfo().reverse())
      e.track.clips.map((t) => {
        this.root.maxzIndex++, t.node.conf.zIndex = t.node.zIndex = this.root.maxzIndex;
      });
  }
  reload() {
    this.lock(
      50,
      () => {
        const e = this.duration;
        this.updatezIndex();
        const t = this.root.creator();
        t.annotate(), t.jumpTo(t.currentTime), Object.values(this.clips).map((r) => {
          r.view.update(), r.track.accept(r) || this.addToTrack(r);
        }), this.hideEmptyTracks(), this.view.setDuration(this.duration), this.renderTrack(), this.duration > 1 && Math.abs(this.duration - e) / e > 0.5 && setTimeout(() => {
          this.duration < this.cursorTime && (this.cursorTime = 1e-3), this.autoScale();
        }, 300);
      },
      "reload"
    );
  }
  addClip(e, t = []) {
    var a;
    let r = this.clips[e.id];
    return r || (r = this.createClip(e)), e.trackId && ((a = r.track) == null ? void 0 : a.id) != e.trackId && (r.shadowTrack = this.tracks.find((s) => s.id === e.trackId)), this.addToTrack(r, [], t), r;
  }
  onOpsChange(e) {
    const t = [];
    if (this.getAllNodes(this.root, t), this.nodes = t, t.includes(e.target)) {
      const r = Array.isArray(e.relativeNodes) ? e.relativeNodes : [], a = this.addClip(e.target, r);
      ["undo", "redo"].includes(e.action) && !a.view.visible && this.lock(
        100,
        () => {
          a.view.scrollToVisible();
        },
        "scrollToVisible"
      );
    } else this.setClipShow(e);
    return this.reload();
  }
  onChanging() {
    const e = super.onChanging();
    return (t) => {
      if ([OP_ADD, OP_DELETE, OP_SPLIT, OP_CHANGE, OP_END].includes(t.action)) {
        if (this.onOpsChange(t), [OP_ADD, OP_DELETE, OP_CHANGE].includes(t.action))
          return this.record = null;
        t.action === OP_END && this.view.hideConstraint();
      }
      if (this.cropMode && t.action === OP_MOVE) {
        let r = null;
        t.delta.to.cropStart !== void 0 && t.delta.to.cropEnd !== void 0 ? r = 0.5 * (t.delta.to.cropStart + t.delta.to.cropEnd) : t.delta.to.cropStart !== void 0 ? r = t.delta.to.cropStart : t.delta.to.cropEnd !== void 0 && (r = t.delta.to.cropEnd), r && (this.cursorTime = this.view.showCursor("cursor", r), this.seek(this.cursorTime, 50));
      }
      e(t);
    };
  }
  onHistoryChange(e) {
    this.onOpsChange(e);
  }
  onScroll(e) {
    this.dirtyRuler = true, this.hideMenu();
  }
  onScale(e) {
    if (!this.root.duration) return;
    const t = Math.pow(
      Math.E,
      Math.log(this.scaleRange[0]) + e * (Math.log(this.scaleRange[1]) - Math.log(this.scaleRange[0]))
    );
    this.setScale(t);
  }
  get relativeScale() {
    return (Math.log(this.scale) - Math.log(this.scaleRange[0])) / (Math.log(this.scaleRange[1]) - Math.log(this.scaleRange[0]));
  }
  emitScaleChange() {
    this.relativeScale < 0 || this.editor.emit("boardscale", {
      scale: this.scale,
      range: this.scaleRange,
      relative: this.relativeScale
    });
  }
  setScaleRange(e = true) {
    const t = [
      this.container.offsetWidth / (this.duration * (this.cropMode ? 1.1 : 10)),
      750
    ];
    this.scaleRange = [Math.min(...t), Math.max(...t)], e && this.emitScaleChange();
  }
  setScale(e, t = true) {
    e = Math.min(this.scaleRange[1], Math.max(this.scaleRange[0], e));
    let r = this.cursorPreview ? this.cursorTime : this.markTime;
    r || (r = (this.container.offsetWidth / 2 + this.view.scrollLeft) / this.scale);
    const a = r * this.scale - this.view.scrollLeft;
    this.scale = e, this.view.scrollLeft = r * this.scale - a, this.view.setScale(e), this.dirtyRuler = true, this.renderTrack(), Object.values(this.clips).map((s) => s.view.setScale(e)), t && this.emitScaleChange();
  }
  renderTrack() {
    const e = Object.values(this.clips).map((r) => r.absEndTime * this.scale);
    e.push(this.container.offsetWidth), this.cropMode ? e.push(this.duration * this.scale + 80) : e.push(1.6 * this.duration * this.scale);
    const t = { width: `${Math.max.apply(null, e)}px` };
    this.ruler.setStyle(t);
    for (const r of this.tracks) r.view.setStyle(t);
    this.trackInfo(), this.view.setWidth(t.width), this.view.setHeight(this.container.offsetHeight - 8);
  }
  renderRuler() {
    if (!this.container) return;
    const e = 2 * this.container.offsetWidth;
    if (this.rulerView || (this.rulerView = document.createElement("canvas"), this.rulerView.setAttribute("width", e), this.rulerView.setAttribute("height", 32), this.rulerView.classList.add("ruler-canvas"), this.container.append(this.rulerView)), window.requestAnimationFrame(() => {
      this.renderRuler();
    }), !this.dirtyRuler)
      return;
    this.dirtyRuler = false, this.rulerView.setAttribute("width", e);
    const t = this.rulerView.getContext("2d");
    t.clearRect(0, 0, e, 32), t.fillStyle = "#CCC", t.font = "25px helvetica";
    const r = this.calcBlock(this.scale), a = r * this.scale, s = r === 1 && this.scale > 300 ? this.fps : 10, u = this.view.trackHeadWidth - this.view.scrollLeft, l = Math.max(0, Math.floor(-u / a)), c = a / s;
    let d = l * r;
    for (let f = u + l * a; f < this.container.offsetWidth; f += a) {
      const p = 2 * f;
      t.fillRect(p, 0, 2, 30), t.fillText(O(d), p + 10, 30), d += r;
      for (let m = 0; m < s; m++) t.fillRect(p + 1 + m * c * 2, 0, 1, 8);
    }
  }
  calcBlock(e) {
    const t = 150 / e;
    let r = 216e3;
    for (let a = 0; a < 3; a++) {
      const s = Math.pow(60, a);
      if (t < 60 * s) {
        const u = t / s;
        for (const l of L) if (r = l * s, u < l) break;
        break;
      }
    }
    return r;
  }
  visible(e) {
    return !(["creator", "spine", "track", "speech"].includes(e.type) || !e.parent || e === this.root);
  }
  getAllNodes(e, t) {
    e.type === "filter" || e.conf.asMask || (this.visible(e) && t.push(e), e !== this.root && e.type === "scene" || e.children.map((r) => this.getAllNodes(r, t)), e.type !== TYPE_SPINE || e.children.length || this.root.duration || (this.spinePlaceholder || (this.spinePlaceholder = new VNode$1({ type: TYPE_PLACEHOLDER }), this.spinePlaceholder.duration = this.duration, this.spinePlaceholder.parent = e), t.push(this.spinePlaceholder)));
  }
  parseTrack() {
    const e = Object.values(this.clips);
    e.sort((t, r) => t.node.zIndex - r.node.zIndex);
    for (const t of e) {
      let r = this.dropToTrack(t);
      r || (r = new EditorTrackComponent(t.node, this.editor), this.tracks.unshift(r)), r.append(t);
    }
  }
  dropToTrack(e, t = true) {
    var u, l;
    if (e.node.parent.type === TYPE_SPINE) return this.tracks.find((c) => c.type === TYPE_SPINE);
    if (e.node.type === "trans") {
      const c = ((u = e.node.prevSibling) == null ? void 0 : u.trackId) || ((l = e.node.nextSibling) == null ? void 0 : l.trackId);
      if (c) return this.tracks.find((d) => d.id === c);
    }
    const r = this.trackInfo();
    let a, s = r.findIndex((c) => c.track.overlap(e));
    s < 0 ? s = r.length - 1 : s -= 1;
    for (let c = s; c >= 0; c--)
      if (r[c] && r[c].track.accept(e, t)) {
        a = r[c].track;
        break;
      }
    return a;
  }
  onHover(e) {
    if (!e) return super.onHover();
    e.target === this.view && (this.editor.responder = e.event.type === "mouseover" ? "board" : "select"), e.event.type === "mouseout" && e.target === this.ruler && (this.view.hideCursor("cursor"), this.markTime !== void 0 && this.editor.enabled && this.seek(this.markTime, 200));
  }
  onMove(e) {
    var t;
    this.cropMode || e.target === this.view && this.selectionStart && e.moved && ((t = e.event) != null && t.mctrlKey || this.hasUnselectAll || (this.editor.emit(SELECT, { action: "multi" }), this.hasUnselectAll = true), this.view.selection(this.selectionStart, e.event));
  }
  onMoveStart(e) {
    this.selectionStart = e.target === this.view ? e.event : null, this.hasUnselectAll = false;
  }
  onMoveEnd(e) {
    !e.moved || e.target.classList.contains("ruler") ? (this.mark(e.event), e.target === this.view && this.editor.emit(SELECT)) : e.target === this.view && this.selectionStart && this.view.selection(null);
  }
  mark(e) {
    const t = isNaN(e) ? this.pointerTime(e) : e;
    this.markTime = this.view.showCursor("mark", t), this.seek(this.markTime);
  }
  seek(e, t) {
    const r = () => {
      this.editor.player.seek(e + this.root.absStartTime);
    };
    t ? this.lock(t, r, "seek") : r();
  }
  get cursorPreview() {
    return this.editor.opts.enableCursorPreview || this.cropMode || this.splitMode;
  }
  onCursor(e, t = false) {
    if (this.mouseEvent = e, this.markTrack = this.pointerTrack(e.event), !this.cursorPreview && e.target !== this.ruler && !t)
      return this.cursorTime = this.view.showCursor(
        "pointer",
        this.pointerTime(e.event)
      ), this.view.hideCursor("cursor"), void (!this.editor.playing && this.markTime && this.currentMarkTime() !== this.editor.currentTime && this.seek(this.markTime));
    this.editor.playing || (this.view.hideCursor("pointer"), this.cursorTime = this.view.showCursor(
      "cursor",
      this.pointerTime(e.event)
    ), this.seek(this.cursorTime, 50));
  }
  onResize() {
    return (e) => {
      this.dirtyRuler = true, this.renderTrack(), this.lock(
        300,
        () => {
          Object.values(this.clips).map((t) => t.view.refresh());
        },
        "resize-clip"
      );
    };
  }
  multiSelect(e, t) {
    if (t = t || this.selected, (e == null ? void 0 : e.type) && e.type !== "creator")
      return t instanceof EditorClipGroup ? (t.toggleNode(e), Object.values(t.nodes).length === 0 ? (t.destroy(), this.editor.emit(SELECT), null) : t) : e.groupId && e.groupId !== "NULL" ? new EditorClipGroup(this, e) : t && t.id !== e.id ? new EditorClipGroup(this, [t, e]) : e;
  }
  showSelect(e, t) {
    var r, a;
    if (this.hideMenu(), this.cropMode)
      return Object.values(this.clips).map((s) => s.view.clear()), void ((t == null ? void 0 : t.action) === "track" && ((r = t == null ? void 0 : t.event) == null ? void 0 : r.type) === "mouseup" && this.mark(t.event));
    t.action !== "multi" && (this.view.selection(null), this.selectionStart = null), e && this.selected instanceof EditorClipGroup && this.selected.contains(e) || e instanceof EditorGroup || (super.showSelect(e, t), (t == null ? void 0 : t.action) === "track" && ((a = t == null ? void 0 : t.event) == null ? void 0 : a.type) === "mouseup" && this.editor.opts.enableClipMark && this.mark(t.event));
  }
  createBox(e, t = false, r) {
    if (this.cropMode) return;
    if (e instanceof EditorClipGroup) return e.virtualBox(t);
    let a = this.clips[e.id];
    if (t !== "auto-hover" && !a)
      for (; !a && e.parent; ) e = e.parent, a = this.clips[e.id];
    if (!a) return;
    let s = [];
    return (t || (r == null ? void 0 : r.source) === "clip") && e.type !== "scene" && e.children.length > 0 && (s = e.allNodes.map((u) => this.createBox(u, "auto-hover"))), a.virtualBox(t, s);
  }
  pointerTime(e) {
    return this.view.pointerTime(e);
  }
  pointerTrack(e) {
    const t = this.view.eventPoint(e), r = this.trackInfo().filter((a) => a.y[0] <= t.y && a.y[1] > t.y)[0];
    return r ? r.track : null;
  }
  pointerClip(e) {
    const { y: t } = this.view.eventPoint(e), r = this.pointerTime(e);
    return Object.values(this.clips).filter(
      (a) => a.node.absStartTime < r && r < a.node.absEndTime && a.track.view.offsetTop < t && t < a.track.view.offsetTop + a.view.offsetHeight
    )[0];
  }
  addToTrack(e, t = [], r = [], a = true) {
    var l;
    t.includes(e) || t.push(e);
    let s = e.shadowTrack || e.track;
    const u = this.trackInfo(false);
    if (s || (s = u[0].track), !s.accept(t, false, r) && !s.id.startsWith("ph-")) {
      let c = u.findIndex((f) => f.track === s), d = 0;
      for (c -= 1; c >= 0; c--) {
        const f = (l = u[c]) == null ? void 0 : l.track;
        if (f.type !== TYPE_PLACEHOLDER && d++, d > 1 && !a) break;
        if (f && f.type !== TYPE_SPINE && f.accept(t, false, r)) {
          s = f;
          break;
        }
      }
    }
    if (!s.accept(t, false, r)) {
      let c = s;
      c.type === TYPE_SPINE && (c = this.topTrack), s = new EditorTrackComponent(e.node, this.editor), this.tracks.unshift(s), this.view.insertBefore(s.view, c.view);
    }
    s.append(e);
  }
  hideEmptyTracks() {
    this.tracks.map((e) => {
      e.canRemove() && e.hide();
    });
  }
  select(e, t) {
    e.emit(SELECT, { action: "track", event: t });
  }
  onClipMoveEnd(e, t) {
    if (!t.moved) {
      if (this.editor.playerWrapper.playing && this.editor.playerWrapper.pause(), this.splitMode) {
        const a = this.cursorTime + this.root.absStartTime;
        e.node && a && this.editor.split(e.node, a);
      } else this.lock(50, () => this.select(e.node, t.event), "select");
      return;
    }
    const r = {};
    if (this.selected instanceof EditorClipGroup) {
      const a = [];
      this.selected.mapClip((s) => {
        const u = [];
        this.selected.mapClip((l) => {
          l !== s && l.track === s.track && u.push(l);
        }), a.push({ clip: s, alliance: u });
        for (const l of s.node.allNodes)
          !this.selected.contains(l) && this.clips[l.id] && (r[l.id] = this.clips[l.id]);
      }), a.map(({ clip: s, alliance: u }) => {
        this.addToTrack(s, u, [], false), s.moveEnd(this.moveParentClip);
      });
    } else {
      this.addToTrack(e, [], [], false), e.moveEnd(this.moveParentClip);
      for (const a of e.node.allNodes)
        this.clips[a.id] && (r[a.id] = this.clips[a.id]);
    }
    Object.values(r).map((a) => {
      a.track.accept(a) || this.addToTrack(a);
    }), this.hideEmptyTracks(), this.hideParentClip();
  }
  onClipMoveStart(e, t) {
    this.selected instanceof EditorClipGroup ? this.selected.mapClip((r) => r.moveStart()) : e.moveStart();
  }
  onClipMove(e, t) {
    var s;
    if (this.hasSelected(e.node) || (this.select(e.node, t.event), this.onClipMoveStart(e, t)), !t.moved)
      return;
    const r = e;
    let a = [];
    if (this.selected instanceof EditorClipGroup)
      e = this.selected, a = this.selected.clips();
    else {
      if (((s = this.selected) == null ? void 0 : s.id) !== e.node.id) return;
      a.push(e);
    }
    if (a.map((u) => {
      const l = u.node.nextSibling;
      if (!l || l.type !== "trans" || !this.clips[l.id]) return;
      const c = this.clips[l.id];
      a.includes(c) || (a.push(c), c.moveStart(), e instanceof EditorClipGroup ? e.nodes[l.id] = l : this.selected = e = new EditorClipGroup(this, [e.node, l]));
    }), !this.locked("auto-scroll")) {
      const u = this.view.scrollToVisible(t.event);
      t.delta.x += u.x, t.delta.y += u.y, this.lock(50, () => this.renderTrack(), "auto-scroll");
    }
    e.moveDelta(t.delta), this.onClipsChange(a), this.relatedMove(), this.constraint(e, t), Array.from(new Set(a.map((u) => u.node.parent.id))).length === 1 && this.editor.opts.enableDragChangeParent && t.event.mctrlKey && this.changeParent(r, a);
  }
  changeParent(e, t) {
    if (!t.length || t.filter((l) => {
      var c;
      return ((c = l.shadowTrack) == null ? void 0 : c.type) === TYPE_SPINE;
    }).length)
      return this.hideParentClip();
    const r = e.centerTime, a = e.shadowTrack, s = e.track.view.offsetTop + e.view.offsetTop + 0.5 * e.view.offsetHeight;
    let u = null;
    for (const l of Object.values(this.clips)) {
      if (t.includes(l) || l.track !== a || !l.node.active || r <= l.node.absStartTime || r >= l.node.absEndTime)
        continue;
      const c = l.track.view.offsetTop + 0.5 * l.view.offsetHeight;
      if (Math.abs(s - c) < 10) {
        u = l;
        break;
      }
    }
    return u ? t.filter(
      (l) => l === u || l.node.parent === u.node || u.node.parents.includes(l.node)
    ).length > 0 ? this.hideParentClip() : void (this.moveParentClip != u && (this.hideParentClip(), this.moveParentClip = u, u.view.addClass("move-parent"))) : this.hideParentClip();
  }
  hideParentClip() {
    this.moveParentClip && this.moveParentClip.view.removeClass("move-parent"), this.moveParentClip = null;
  }
  onClipsChange(e) {
    var d, f, p, m;
    const t = "onClipsChange";
    if (this.locked(t)) return;
    this.lock(100, null, t);
    const r = {}, a = [], s = e.map((y) => {
      r[y.track.id] = y.track.id;
      const { x, y: g } = this.view.relativeRect(y.view).center;
      return a.push(y.node), { clip: y, x, y: g };
    });
    s.sort((y, x) => y.x - x.x);
    let u = this.trackInfo();
    Object.keys(r).length > 1 && (u = u.filter((y) => y.track.type !== TYPE_SPINE)), u[0].y[0] = -99999999, u[u.length - 1].y[1] = MAX;
    for (const y of s)
      for (const x of u)
        y.y >= x.y[0] && y.y < x.y[1] && y.clip.shadowTo(x.track);
    const l = e.filter((y) => {
      var x;
      return ((x = y.node.parent) == null ? void 0 : x.type) === TYPE_SPINE;
    }), c = l.map((y) => y.node.id);
    if (l.length > 0) {
      l.sort((w, A) => w.absStartTime - A.absStartTime);
      let y = 0, x = 0;
      for (const w of l) y += w.centerTime, x += w.duration;
      y /= l.length;
      const g = l.length === 1 && l[0].node.type === "trans", _ = g ? y + 0.5 * x : y - 0.5 * x, T = l[0].node.parent;
      let E = null, b = 0, C = null;
      for (const w of T.children) {
        C = w;
        const A = this.clips[w.id];
        if (A && !l.includes(A) && (b += w.type === "trans" ? 0 : w.duration, !(b < _ || w.type === "trans") && (!g || ((d = w.prevSibling) == null ? void 0 : d.type) !== "trans" || c.includes((f = w.prevSibling) == null ? void 0 : f.id)))) {
          E = A;
          break;
        }
      }
      if (!E && g && C.type === "trans") return;
      l.push(E);
      for (let w = l.length - 2; w >= 0; w--) {
        const A = ((p = l[w + 1]) == null ? void 0 : p.node) || "NULL", S = l[w];
        if (S.node.nextSibling != A) {
          const F = {
            to: { parent: T, nextSibling: A },
            from: {
              parent: S.nodeOriParent,
              nextSibling: S.nodeOriNext
            }
          };
          EditorClipComponent.apply(S.node, F, OP_MOVE);
        }
      }
      l.map((w) => (w == null ? void 0 : w.shadowView) && w.shadowView.update());
    }
    for (const y of s) {
      const x = y.clip.node;
      if (!x || x.parent.type === TYPE_SPINE) continue;
      if (x.type !== "trans") {
        if (((m = x.prevSibling) == null ? void 0 : m.type) === "trans" && (x.prevSibling.trackId != x.trackId || x.prevSibling.absStartTime + x.prevSibling.duration < x.absStartTime))
          EditorClipComponent.apply(x.prevSibling, { to: { nextRefId: "NULL" } }, OP_MOVE);
        else if (!x.prevSibling) {
          for (const _ of y.clip.shadowTrack.clips)
            if (_.node.type === "trans" && _.node.absStartTime < x.absStartTime && _.node.absStartTime + _.node.duration > x.absStartTime) {
              EditorClipComponent.apply(_.node, { to: { nextRefId: x.refId } }, OP_MOVE);
              break;
            }
        }
        continue;
      }
      const g = {};
      if (y.clip.nodeOriNext && a.includes(y.clip.nodeOriNext) && (g.nextRefId = y.clip.nodeOriNext.refId), y.clip.nodeOriPrev && a.includes(y.clip.nodeOriPrev) && (g.prevRefId = y.clip.nodeOriPrev.refId), Object.keys(g).length <= 0 && y.clip.shadowTrack.accept(y.clip)) {
        const _ = y.clip.proxyCenterTime, T = y.clip.shadowTrack.clips.map((C) => ({
          dt: _ - C.centerTime,
          clip: C
        }));
        let E, b;
        for (const C of T.sort((w, A) => A.dt - w.dt))
          if (C.clip !== y.clip) {
            if (b = C.clip, C.dt < 0) break;
            E = C.clip, b = null;
          }
        g.prevRefId = (E && (E == null ? void 0 : E.node.absEndTime) > x.absStartTime ? E == null ? void 0 : E.node.refId : "") || "NULL", g.nextRefId = (b && (b == null ? void 0 : b.node.absStartTime) < x.absStartTime + x.duration ? b == null ? void 0 : b.node.refId : "") || "NULL";
      }
      Object.keys(g).length > 0 && (x.prevRefId != g.prevRefId || x.nextRefId != g.nextRefId) && EditorClipComponent.apply(x, { to: g }, OP_MOVE), y.clip.shadowView.update();
    }
  }
  onClipDblClick(e, t) {
    e.node.type === "scene" && this.showSceneBoard(e), this.editor.emit("dblclick", { target: e.node, event: t.event });
  }
  onClipResize(e, t) {
    this.relatedMove(true), this.constraint(e, t);
  }
  relatedMove(e = false) {
    this.root.creator().annotate(), Object.values(this.clips).map((t) => {
      !e && this.hasSelected(t.node) || t.view.update();
    });
  }
  hasSelected(e) {
    var t;
    return this.selected instanceof EditorClipGroup ? this.selected.contains(e) : ((t = this.selected) == null ? void 0 : t.id) === e.id;
  }
  constraint(e, t) {
    var y, x, g, _, T, E;
    if ((y = t.event) != null && y.shiftKey || !this.editor.opts.enableTrackConstraint) return;
    let r = e instanceof EditorClipGroup ? e.clips() : Array.isArray(e) ? e : [e];
    if (t.type === "move" && (r = r.filter(
      (b) => {
        var C;
        return ((C = b.node.parent) == null ? void 0 : C.type) !== TYPE_SPINE && b.node.type !== "trans";
      }
    )), r.length === 0)
      return this.view.hideConstraint();
    const a = this.root.creator().duration, s = [];
    this.markTime && s.push({
      cursor: this.view.cursor.mark,
      time: this.currentMarkTime()
    });
    for (const b of Object.values(this.clips))
      r.includes(b) || (s.push({ clip: b, time: b.node.absStartTime }), round$2(b.node.absEndTime, 3) < a && s.push({ clip: b, time: b.node.absEndTime }));
    if (s.length <= 0) return;
    let u = [];
    const l = t.type === "resize" ? [t.target] : ["start", "end"];
    for (const b of r) {
      const C = b.node.allNodes;
      for (const w of s)
        if (!(((x = b.node.parent) == null ? void 0 : x.type) === TYPE_SPINE && ((T = (_ = (g = w.clip) == null ? void 0 : g.node) == null ? void 0 : _.parent) == null ? void 0 : T.type) === TYPE_SPINE || C.includes((E = w.clip) == null ? void 0 : E.node)))
          for (const A of l) {
            const S = `proxy${ucfirst(A)}Time`;
            if (!b || !b[S]) continue;
            const F = w.time - b[S], M = w.cursor ? 0 : Math.abs(
              this.view.relativeRect(b.view).top - this.view.relativeRect(w.clip.view).top
            );
            u.push({
              at: Math.abs(F),
              dt: F,
              type: A,
              dy: M,
              cp: b,
              related: w
            });
          }
    }
    if (u = u.filter((b) => b.at > 1e-3), u.length === 0) return;
    u.sort(
      (b, C) => b.at.toFixed(3) !== C.at.toFixed(3) ? b.at - C.at : b.dy - C.dy
    );
    const { at: c, dt: d, type: f, cp: p, related: m } = u[0];
    if (c * this.scale < this.editor.opts.refLineRange) {
      if (t.type === "move")
        r.map((b) => {
          const C = b.proxyStartTime + d - b.node.parent.absStartTime;
          EditorClipComponent.apply(b.node, { to: { start: C } }, OP_MOVE), b.shadowView.update(), b.view.setStyle({ left: b.shadowView.style.left });
        }), this.relatedMove();
      else {
        if (t.type !== "resize") return;
        e.applyResize(f, f === "start" ? -d : d), this.relatedMove(true);
      }
      this.view.showConstraint(m);
    } else this.view.hideConstraint();
  }
  selectAll(e) {
    e && (this.editor.emit(SELECT), e.selectAll());
  }
  crop(e, t = null) {
    if (!this.cropNode) return;
    t = t || this.cursorTime;
    const r = {};
    e == "i" ? (r.cropStart = t, this.cropNode.cropEnd < r.cropStart && (r.cropEnd = this.cropNode.duration)) : (r.cropEnd = t, this.cropNode.cropStart > r.cropEnd && (r.cropStart = 0)), EditorClipComponent.apply(this.cropNode, { to: r }, OP_MOVE), this.cropNode.emit(CHANGING, { action: OP_END });
  }
  showCropMenu(e) {
    this.hideMenu();
    const t = this.cursorTime, r = [];
    r.push({
      title: localeEn.asStrart,
      keys: ["I"],
      click: (a) => this.crop("i", t)
    }), r.push({
      title: localeEn.asEnd,
      keys: ["O"],
      click: (a) => this.crop("o", t)
    }), this.menu = EditorMenuElement.create({
      parent: this.view.parentNode,
      menu: r,
      event: e
    });
  }
  showMenu(e) {
    var u, l, c;
    this.hideMenu();
    const t = {
      time: this.pointerTime(e),
      track: this.pointerTrack(e)
    }, r = [], a = this.selected, s = ((u = t.track) == null ? void 0 : u.clips) && ((l = t.track) == null ? void 0 : l.clips.length) > 0;
    if (r.push({
      title: localeEn.selectAll,
      enable: s,
      keys: ["Ctrl", "A"],
      click: (d) => this.selectAll(t.track)
    }), r.push({
      title: localeEn.cut,
      enable: !!a,
      keys: ["Ctrl", "X"],
      click: (d) => this.cut(a)
    }), r.push({
      title: localeEn.copy,
      enable: !!a,
      keys: ["Ctrl", "C"],
      click: (d) => {
        this.editor.copyNode = a;
      }
    }), r.push({
      title: localeEn.paste,
      enable: !!this.editor.copyNode || !!this.editor.cutNode,
      keys: ["Ctrl", "V"],
      click: (d) => this.paste(null, t)
    }), this.editor.opts.enableGroup && a instanceof EditorClipGroup && (r.push("-"), r.push({
      title: localeEn.combination,
      enable: a.canLock,
      click: (d) => a.lock()
    }), r.push({
      title: localeEn.ungroup,
      enable: a.canUnlock,
      click: (d) => a.unlock()
    })), a) {
      r.push("-"), r.push({
        title: localeEn.delete,
        keys: ["⌫"],
        click: (f) => this.delete(a)
      });
      const d = a.nodes ? Object.values(a.nodes).filter((f) => !f.active).length > 0 : !a.active;
      r.push({
        title: d ? localeEn.showFragment : localeEn.hiddenFragment,
        keys: ["V"],
        click: (f) => this.toggleEnable(a, d)
      }), ((c = this.editor.opts.menuItems) == null ? void 0 : c.length) > 0 && (r.push("-"), this.editor.opts.menuItems.map((f) => {
        let p = true;
        const m = this.filterNode(a, f.filter);
        m.length <= 0 || (f.enable !== void 0 && (p = this.filterNode(a, f.enable).length > 0), r.push({
          title: f.title,
          enable: p,
          click: () => {
            this.callOuterOp(f.action, m, t);
          }
        }));
      }));
    }
    this.menu = EditorMenuElement.create({
      parent: this.view.parentNode,
      menu: r,
      event: e
    });
  }
  hideMenu() {
    this.menu && this.menu.remove();
  }
  hasMenu() {
    return this.menu && this.menu.parentNode;
  }
  toggleEnable(e, t) {
    t === void 0 && (t = e.nodes ? Object.values(e.nodes).filter((a) => !a.active).length > 0 : !e.active);
    let r = false;
    e.nodes ? Object.values(e.nodes).map((a) => {
      a.active !== t && (EditorClipComponent.apply(a, { to: { active: t } }, OP_MOVE), r = true);
    }) : e.active !== t && (EditorClipComponent.apply(e, { to: { active: t } }, OP_MOVE), r = true), r && (this.reload(), e.emit(CHANGING, { action: OP_END }));
  }
  filterNode(e, t) {
    let r = e;
    if (e.nodes ? r = Object.values(e.nodes) : Array.isArray(e) || (r = [e]), typeof t != "function") {
      let a = t;
      return Array.isArray(a) || (a = [a]), r.every((s) => a.includes(s.type)) ? r : [];
    }
    return t(r) ? r : [];
  }
  callOuterOp(e, t, r) {
    this.editor.emit(e, { target: t, ...r });
  }
  showLoading() {
    this.loadingView && this.loadingView.parentNode === this.view.parentNode || (this.loadingView && this.loadingView.remove(), this.loadingView = document.createElement("div"), this.loadingView.classList.add("mirae-loading-bg"), this.loadingView.setAttribute("data-progress", ""), this.view.parentNode.append(this.loadingView), this.editor.emit("loading", { state: "start" }));
  }
  showProgress(e) {
    const t = Math.round(100 * e);
    this.loadingView && this.loadingView.parentNode && t && (this.loadingView.setAttribute("data-progress", `${t}%`), this.editor.emit("loading", { state: "progress", progress: e }));
  }
  hideLoading() {
    this.loadingView && this.loadingView.remove(), this.editor.emit("loading", { state: "end" });
  }
  scrollToVisible(e, t = true) {
    this.clips[e.id] && this.lock(
      100,
      () => {
        const r = this.clips[e.id].view;
        r.scrollToVisible({ top: true, smooth: true }), t && r.addClass("hover", typeof t == "number" ? t : 500);
      },
      "scroll"
    );
  }
  showSceneBoard(e) {
    this.hide(), this.sceneBoard = new Su2(e.node, this.container, this.editor), this.editor.board = this.sceneBoard, this.sceneBoard.showBackBtn(() => {
      this.sceneBoard.hide(), this.sceneBoard.destroy(), this.sceneBoard = null, this.show(), this.editor.board = this;
    });
  }
  showBackBtn(e) {
    setTimeout(() => {
      this.view.ruler.addBackBtn(e);
    }, 100);
  }
  show() {
    this.container.append(this.view), this.container.append(this.rulerView), this.bindEvents(true), this.bindBoardEvents(true);
  }
  hide() {
    this.hideMenu(), this.rulerView.remove(), this.view.hide(), this.bindEvents(false), this.bindBoardEvents(false);
  }
  currentMarkTime() {
    return this.markTime + this.root.absStartTime;
  }
  destroy() {
    this.bindBoardEvents(false), this.boardEvents = null, this.hideMenu(), this.loadingView && this.loadingView.remove(), this.rulerView && this.rulerView.remove(), this.view && this.view.remove(), Object.values(this.clips).map((e) => e.destroy()), Object.values(this.tracks).map((e) => e.destroy()), this.container = null, this.nodes = null, this.clips = null, this.root = null, this.view = null, this.ruler = null, this.cropNode = null, this.rulerView = null, this.loadingView = null, this.mouseEvent = null, this.bottomTrack = null, this.topTrack = null, this.menu = null, super.destroy();
  }
};
Ct(Su, "type", "board");
let EditorBoardComponent = Su;
const styleList$2 = createStyleList$1();
styleList$2.push([
  139,
  `
  .mirae-crop.origin[mira-editor-el] {
    border: 1px dotted var(--miraeBorderColor);
    box-sizing: content-box;
    margin: 0;
    padding: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    width: var(--width);
    height: var(--height);
    cursor: move;
    pointer-events: auto;
    transform: translate(var(--x), var(--y));
  }
  .mirae-crop.origin[mira-editor-el] img[mira-editor-el] {
    opacity: 0.3;
    width: 100%;
    height: 100%;
    pointer-events: none;
  }
  .mirae-crop.origin[mira-editor-el] .cropped[mira-editor-el] {
    border: 2px solid var(--miraeCropBorderColor);
    position: static;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    pointer-events: none;
    width: var(--width);
    height: var(--height);
    transform: translate(var(--x), var(--y));
  }
  .mirae-crop.origin[mira-editor-el] .mirae-grid-row[mira-editor-el] {
    display: flex;
    align-items: center;
    justify-content: center;
    position: static;
    width: 100%;
    height: 100%;
  }
  .mirae-crop.origin[mira-editor-el] .mirae-grid-row[mira-editor-el] .mirae-grid[mira-editor-el] {
    position: static;
    border: 0.5px solid rgba(255, 255, 255, 0.5);
    width: 100%;
    height: 100%;
    box-shadow: inset 0px 0px 2px 0px #666;
  }
  `,
  ""
]);
createStyleManager$1(styleList$2, createStyleOption$1());
styleList$2.locals && styleList$2.locals;
class EditorCropElement extends EditorMoveElement {
  setOpts(e) {
    return super.setOpts(e), e.canvas && (this.image = document.createElement("img"), this.image.setAttribute("mira-editor-el", ""), this.image.src = e.canvas.toDataURL(), this.canvas = e.canvas, this.appendChild(this.image)), this.origin = e.styleClass === "origin", this.node = this.parentNode.node, this.fit(), this;
  }
  updateImage() {
    this.image.src = this.canvas.toDataURL();
  }
  showGrid() {
    if (this.grid) return;
    this.grid = true;
    const e = (t, r) => {
      const a = document.createElement("div");
      return a.setAttribute("mira-editor-el", ""), a.classList.add(t), r.appendChild(a), a;
    };
    for (let t = 0; t < 3; t++) {
      const r = e("mirae-grid-row", this);
      for (let a = 0; a < 3; a++)
        e("mirae-grid", r);
    }
  }
  fit() {
    this.origin ? this.fitOrigin() : this.fitFrame();
  }
  metrics() {
    const e = this.parentNode, t = this.node, [r, a] = [t.material.width(), t.material.height()], [s, u] = t.getWH(), l = t.getFrame(), c = Math.max(s / l.w, u / l.h);
    return this.rotation = e.rotation, this.scale = e.scale, this.anchor = {
      x: 0,
      y: 0
    }, [l, r, a, c];
  }
  setFrame(e) {
    const t = this.parentNode;
    this.position = { x: e.x, y: e.y }, this.size = { width: e.w, height: e.h }, this.setStyleVars({
      "--x": e.x * t.scale + "px",
      "--y": e.y * t.scale + "px",
      "--width": e.w * t.scale + "px",
      "--height": e.h * t.scale + "px"
    });
  }
  fitFrame() {
    const [e, t, r, a] = this.metrics(), [s, u] = [a * e.w + 4, a * e.h + 4], l = -(0.5 * (t - e.w) - e.x) * a, c = -(0.5 * (r - e.h) - e.y) * a;
    this.setFrame({ x: l, y: c, w: s, h: u });
  }
  fitOrigin() {
    const [e, t, r, a] = this.metrics(), [s, u] = [a * t, a * r], l = (0.5 * (t - e.w) - e.x) * a, c = (0.5 * (r - e.h) - e.y) * a;
    this.setFrame({ x: l, y: c, w: s, h: u });
  }
  resize(e) {
    const t = e.size.width + this.size.width, r = e.size.height + this.size.height, a = e.position.x + this.position.x + 0.5 * e.size.width, s = e.position.y + this.position.y + 0.5 * e.size.height;
    this.setFrame({ x: a, y: s, w: t, h: r });
  }
  remove() {
    this.canvas = null, this.image = null, super.remove();
  }
}
Ct(EditorCropElement, "TAG", "mira-editor-crop"), Ct(EditorCropElement, "STYLE_CLASS", "mirae-crop");
EditorCropElement.register();
const {
  LEFT: leftBoundary,
  TOP: topCropCoord,
  RIGHT: rightBoundary,
  BOTTOM: bottomEdge
} = EditorResizeElement, _u = class _u2 extends EditorMoveComponent {
  constructor(e) {
    super(e), this.wrap(this.selector, "fit").after(() => {
      this.fit();
    }), this.timeupdate = () => {
      var t, r;
      (t = this._controls) != null && t.origin && ((r = this._controls) == null || r.origin.updateImage());
    }, e.on("timeupdate", this.timeupdate);
  }
  fit() {
    this._controls.origin && this._controls.cropped && (this._controls.origin.fit(), this._controls.cropped.fit(), this.updateShow(this.box), this.box.resize());
  }
  show(e) {
    return this;
  }
  controls() {
    if (this.node.cropMode !== "frame")
      return {};
    const e = {
      origin: {
        tag: EditorCropElement,
        canvas: this.node.material.canvas,
        styleClass: "origin"
      },
      originTopLeft: {
        box: "origin",
        pos: topCropCoord | leftBoundary,
        styleClass: "dot"
      },
      originTopRight: {
        box: "origin",
        pos: topCropCoord | rightBoundary,
        styleClass: "dot"
      },
      originBottomRight: {
        box: "origin",
        pos: bottomEdge | rightBoundary,
        styleClass: "dot"
      },
      originBottomLeft: {
        box: "origin",
        pos: bottomEdge | leftBoundary,
        styleClass: "dot"
      }
    }, t = {
      cropped: {
        tag: EditorCropElement,
        box: "origin",
        styleClass: "cropped"
      },
      left: {
        box: "cropped",
        pos: leftBoundary,
        styleClass: "ver"
      },
      right: {
        box: "cropped",
        pos: rightBoundary,
        styleClass: "ver"
      },
      top: {
        box: "cropped",
        pos: topCropCoord,
        styleClass: "hor"
      },
      bottom: {
        box: "cropped",
        pos: bottomEdge,
        styleClass: "hor"
      },
      topLeft: {
        box: "cropped",
        pos: topCropCoord | leftBoundary,
        styleClass: "dot"
      },
      topRight: {
        box: "cropped",
        pos: topCropCoord | rightBoundary,
        styleClass: "dot"
      },
      bottomRight: {
        box: "cropped",
        pos: bottomEdge | rightBoundary,
        styleClass: "dot"
      },
      bottomLeft: {
        box: "cropped",
        pos: bottomEdge | leftBoundary,
        styleClass: "dot"
      }
    };
    return this.selector.cropMode ? {
      origin: e.origin,
      ...t
    } : {
      ...e,
      ...t
    };
  }
  updateShow(e) {
    if (!this._controls.origin || !this._controls.cropped)
      return;
    const t = (this._controls.origin.size.width - this._controls.cropped.size.width) * 0.5, r = (this._controls.origin.size.height - this._controls.cropped.size.height) * 0.5, { x: a, y: s } = this._controls.cropped.position, u = {
      originTopLeft: [
        t + a,
        r + s
      ],
      originTopRight: [
        t - a,
        r + s
      ],
      originBottomRight: [
        t - a,
        r - s
      ],
      originBottomLeft: [
        t + a,
        r - s
      ]
    };
    for (const [l, c] of Object.entries(u))
      this._controls[l] && this._controls[l].show(
        norm2d(c) * e.scale > 10
      );
  }
  getDelta(e) {
    return e.target.constraint ? e.target.constraint(e.delta) : super.getDelta(e);
  }
  onMove(e) {
    var g, _, T, E;
    if (!this.canMove)
      return;
    const [t, r] = [
      this.node.material.width(),
      this.node.material.height()
    ], a = this.node.getFrame(), s = this.getDelta(e), u = e.target.styleClass === "origin", l = e.target.parentNode === this._controls.origin || u;
    if (this.box.rotation != 0) {
      const { x: b, y: C } = new Vector(
        s.position
      ).rotate(-this.box.rotation);
      s.position = {
        x: b,
        y: C
      };
    }
    const c = {
      x: ((g = s.position) == null ? void 0 : g.x) || 0,
      y: ((_ = s.position) == null ? void 0 : _.y) || 0,
      w: ((T = s.size) == null ? void 0 : T.width) || 0,
      h: ((E = s.size) == null ? void 0 : E.height) || 0
    }, d = {
      frame: c
    }, f = this._controls.cropped.size, p = this._controls.cropped.position, m = this._controls.origin.size;
    this.selector.cropMode && u ? (c.x = t * (p.x + c.x) / (m.width + c.w) - t * p.x / m.width, c.y = r * (p.y + c.y) / (m.height + c.h) - r * p.y / m.height, c.w = c.h = 0) : l ? (c.x = -(t * (p.x + c.x) / (m.width + c.w) - t * p.x / m.width), c.y = -(r * (p.y + c.y) / (m.height + c.h) - r * p.y / m.height), c.w = +(t * f.width / (m.width + c.w) - t * f.width / m.width), c.h = +(r * f.height / (m.height + c.h) - r * f.height / m.height)) : (c.x *= t / m.width, c.y *= r / m.height, c.w *= t / m.width, c.h *= r / m.height);
    const [y, x] = e.target.direction || [0, 0];
    if (a.x + c.x < 0) {
      if (!u && !(y > 0))
        return;
      c.x = -a.x;
    }
    if (a.y + c.y < 0) {
      if (!u && !(x > 0))
        return;
      c.y = -a.y;
    }
    if (a.x + a.w + c.x + c.w > t) {
      if (!u && !(y < 0))
        return;
      c.x = t - (a.x + a.w + c.w);
    }
    if (a.y + a.h + c.y + c.h > r) {
      if (!u && !(x < 0))
        return;
      c.y = r - (a.y + a.h + c.h);
    }
    if (this.selector.cropMode && u) {
      const b = (c.x + t * p.x / m.width) * m.width / t - p.x, C = (c.y + r * p.y / m.height) * m.height / r - p.y;
      if (d.position = {
        x: b,
        y: C
      }, this.box.rotation != 0) {
        const { x: w, y: A } = new Vector(
          d.position
        ).rotate(this.box.rotation);
        d.position = {
          x: w,
          y: A
        };
      }
    } else if (!l) {
      const b = e.target.constraint(
        e.delta,
        this.box.anchor
      );
      d.size = b.size, d.position = b.position;
    }
    _u2.apply(this.node, d), this.fit();
  }
  get canMove() {
    return this.node && this.box;
  }
  onMoveStart(e) {
    if (this.canMove)
      return this.node.emit(CHANGING, {
        action: `${this.constructor.type}start`
      }), this._controls.cropped.showGrid(), this;
  }
  onMoveEnd(e) {
    if (this.canMove)
      return this.node.emit(CHANGING, {
        action: `${this.constructor.type}end`
      }), this;
  }
  destroy() {
    return this.editor.off("timeupdate", this.timeupdate), this.timeupdate = null, super.destroy();
  }
};
Ct(_u, "type", "crop"), Ct(_u, "TAG", EditorResizeElement);
let EditorCropComponent = _u;
const xu = class xu2 extends EditorMoveComponent {
  show(e = true) {
    var t;
    return (t = this.editor.controls.move) != null && t.editMode && (e = false), this._controls.rotate && this._controls.rotate.show(e), this;
  }
  controls(e) {
    return this.node.conf.rotateDisable || this.node.cropMode ? {} : { rotate: { box: e.handleBox, styleClass: "handle" } };
  }
  updateShow(e) {
  }
  getDelta(e) {
    if (!this.boxCenter) {
      const { left: l, top: c } = this.editor.container.getBoundingClientRect();
      let { x: d, y: f } = this.box.position;
      d = d * this.box.scale + l, f = f * this.box.scale + c, this.boxCenter = { x: d, y: f };
    }
    const { x: t, y: r } = this.boxCenter, a = {
      x: e.position.x - t,
      y: e.position.y - r
    }, s = {
      x: a.x - e.delta.x,
      y: a.y - e.delta.y
    };
    let u = Math.acos(
      dot(s, a) / (norm2d(s) * norm2d(a))
    );
    return isNaN(u) ? { rotation: 0 } : (u *= cross(s, a) > 0 ? 1 : -1, { rotation: u });
  }
  onMove(e) {
    this.node && this.box && (xu2.apply(this.node, this.getDelta(e)), this.box.rotate(), this.toast(`${deg(this.node.getRotation())}°`, 3e3));
  }
  onMoveEnd(e) {
    super.onMoveEnd(e) && (this.boxCenter = null, this.toast("", 0));
  }
};
Ct(xu, "type", "rotate"), Ct(xu, "TAG", EditorRotateElement);
let EditorRotateComponent = xu;
var cropIcon = '"data:image/svg+xml,%3Csvg width=%2720%27 height=%2720%27 viewBox=%270 0 20 20%27 fill=%27none%27 xmlns=%27http://www.w3.org/2000/svg%27 x=%276%27 y=%276%27 aria-hidden=%27true%27%3E%3Cpath d=%27M6 2.5a.5.5 0 0 0-1 0V5H2.5a.5.5 0 0 0 0 1H5v6.5A2.5 2.5 0 0 0 7.5 15H14v2.5a.5.5 0 0 0 1 0V15h2.5a.5.5 0 0 0 0-1h-10A1.5 1.5 0 0 1 6 12.5v-10Zm8 5V13h1V7.5A2.5 2.5 0 0 0 12.5 5H7v1h5.5c.83 0 1.5.67 1.5 1.5Z%27 fill=%27%23000%27%3E%3C/path%3E%3C/svg%3E"', fitIcon = '"data:image/svg+xml,%3Csvg xmlns=%27http://www.w3.org/2000/svg%27 aria-hidden=%27true%27 width=%2720%27 height=%2720%27 viewBox=%270 0 20 20%27 fill=%27none%27%3E%3Cpath d=%27M4 6.5C4 6.43221 4.01349 6.36756 4.03794 6.30861C4.06198 6.25051 4.09744 6.19602 4.14433 6.14857L4.14857 6.14433C4.19602 6.09744 4.25051 6.06198 4.30861 6.03794C4.36756 6.01349 4.43221 6 4.5 6H6.5C6.77614 6 7 6.22386 7 6.5C7 6.77614 6.77614 7 6.5 7H5.70711L6.85355 8.14645C7.04882 8.34171 7.04882 8.65829 6.85355 8.85355C6.65829 9.04882 6.34171 9.04882 6.14645 8.85355L5 7.70711V8.5C5 8.77614 4.77614 9 4.5 9C4.22386 9 4 8.77614 4 8.5V6.5ZM4.03794 13.6914C4.01349 13.6324 4 13.5678 4 13.5V11.5C4 11.2239 4.22386 11 4.5 11C4.77614 11 5 11.2239 5 11.5V12.2929L6.14645 11.1464C6.34171 10.9512 6.65829 10.9512 6.85355 11.1464C7.04882 11.3417 7.04882 11.6583 6.85355 11.8536L5.70711 13H6.5C6.77614 13 7 13.2239 7 13.5C7 13.7761 6.77614 14 6.5 14H4.50049L4.497 14C4.37004 13.9992 4.24331 13.9504 4.14645 13.8536C4.09851 13.8056 4.06234 13.7504 4.03794 13.6914ZM15.6914 6.03794C15.7495 6.06198 15.804 6.09744 15.8514 6.14433L15.8557 6.14857C15.9026 6.19602 15.938 6.25051 15.9621 6.30861C15.9865 6.36756 16 6.43221 16 6.5V8.5C16 8.77614 15.7761 9 15.5 9C15.2239 9 15 8.77614 15 8.5V7.70711L13.8536 8.85355C13.6583 9.04882 13.3417 9.04882 13.1464 8.85355C12.9512 8.65829 12.9512 8.34171 13.1464 8.14645L14.2929 7H13.5C13.2239 7 13 6.77614 13 6.5C13 6.22386 13.2239 6 13.5 6H15.4999C15.5677 6 15.6324 6.01349 15.6914 6.03794ZM15.8514 13.8557C15.804 13.9026 15.7495 13.938 15.6914 13.9621C15.6324 13.9865 15.5678 14 15.5 14H13.5C13.2239 14 13 13.7761 13 13.5C13 13.2239 13.2239 13 13.5 13H14.2929L13.1464 11.8536C12.9512 11.6583 12.9512 11.3417 13.1464 11.1464C13.3417 10.9512 13.6583 10.9512 13.8536 11.1464L15 12.2929V11.5C15 11.2239 15.2239 11 15.5 11C15.7761 11 16 11.2239 16 11.5V13.5C16 13.5678 15.9865 13.6324 15.9621 13.6914C15.938 13.7495 15.9026 13.804 15.8557 13.8514L15.8514 13.8557ZM2 6C2 4.89543 2.89543 4 4 4H16C17.1046 4 18 4.89543 18 6V14C18 15.1046 17.1046 16 16 16H4C2.89543 16 2 15.1046 2 14V6ZM4 5C3.44772 5 3 5.44772 3 6V14C3 14.5523 3.44772 15 4 15H16C16.5523 15 17 14.5523 17 14V6C17 5.44772 16.5523 5 16 5H4Z%27 fill=%27currentColor%27%3E%3C/path%3E%3C/svg%3E"';
const styleList$1 = createStyleList$1();
styleList$1.push([
  143,
  `
  .mirae-fit.crop[mira-editor-el] {
    width: 32px;
    height: 32px;
    display: flex;
    align-items: center;
    justify-content: center;
    pointer-events: auto;
    z-index: 3;
    cursor: pointer;
    position: relative;
  }
  .mirae-fit.crop[mira-editor-el].hide {
    width: 0px;
    height: 0px;
    pointer-events: none;
  }
  .mirae-fit.crop[mira-editor-el]:after {
    width: 20px;
    height: 20px;
    content: "";
    transition-property: opacity, width, height;
    transition-duration: 0.3s;
    position: relative;
    border-radius: 10px;
    box-shadow: 0 0 5px 1px rgba(57, 76, 96, 0.15), 0 0 0 1px rgba(53, 71, 90, 0.2);
    opacity: 1;
    background: #FFF 2px no-repeat;
    background-size: 16px;
    z-index: 9;
    transform: rotate(var(--revert-rot));
    background-image: url(${cropIcon});
  }
  .mirae-fit.fit[mira-editor-el] {
    width: 32px;
    height: 32px;
    display: flex;
    align-items: center;
    justify-content: center;
    pointer-events: auto;
    z-index: 3;
    cursor: pointer;
    position: relative;
  }
  .mirae-fit.fit[mira-editor-el].hide {
    width: 0px;
    height: 0px;
    pointer-events: none;
  }
  .mirae-fit.fit[mira-editor-el]:after {
    width: 20px;
    height: 20px;
    content: "";
    transition-property: opacity, width, height;
    transition-duration: 0.3s;
    position: relative;
    border-radius: 10px;
    box-shadow: 0 0 5px 1px rgba(57, 76, 96, 0.15), 0 0 0 1px rgba(53, 71, 90, 0.2);
    opacity: 1;
    background: #FFF 2px no-repeat;
    background-size: 16px;
    z-index: 9;
    background-image: url(${fitIcon});
  }
  .left[mira-editor-el] .mirae-fit.fit[mira-editor-el],
  .right[mira-editor-el] .mirae-fit.fit[mira-editor-el] {
    transform: rotate(-90deg);
  }
  `,
  ""
]);
createStyleManager$1(styleList$1, createStyleOption$1());
styleList$1.locals && styleList$1.locals;
class EditorFitElement extends EditorMoveElement {
}
Ct(EditorFitElement, "TAG", "mira-editor-fit"), Ct(EditorFitElement, "STYLE_CLASS", "mirae-fit");
EditorFitElement.register();
const ts = class ts2 extends EditorMoveComponent {
  show(e = true) {
    return this._controls.fit && this._controls.fit.show(e && this.node.rotate === 0), this._controls.crop && this._controls.crop.show(e), this;
  }
  controls(e) {
    return !["video", "image"].includes(this.node.type) || this.node.conf.asMask || this.node.cropMode ? {} : {
      fit: { box: e.handleBox, styleClass: "fit" },
      crop: { box: e.handleBox, styleClass: "crop" }
    };
  }
  updateShow(e) {
    return this.show();
  }
  onMoveStart(e) {
  }
  onMove(e) {
  }
  onMoveEnd(e) {
    if (!(e.moved > 5) && this.node)
      if (e.target.hasClass("fit")) {
        let t = {};
        if (this.node.conf.width === "100vw" && this.node.conf.height === "100vh") {
          const a = this.node.material.width() / this.node.material.height();
          t = this.node.creator().width / this.node.creator().height > a ? { height: "100vh", width: "NULL" } : { width: "100vw", height: "NULL" };
        } else
          t = { width: "100vw", height: "100vh" };
        const r = {
          to: { ...t, x: "50vw", y: "50vh", "object-fit": "cover" }
        };
        ts2.apply(this.node, r, "resize"), this.node.emit(CHANGING, { action: OP_END }), this.box.resize();
      } else e.target.hasClass("crop") && this.node.emit(CROPFRAME);
  }
};
Ct(ts, "type", "fit"), Ct(ts, "TAG", EditorFitElement), Ct(ts, "CHG_HOOK", "setRotate");
let EditorFitComponent = ts;
const styleList = createStyleList$1();
styleList.push([
  149,
  `
  .mirae-constraint[mira-editor-el] {
      width: 100%;
      height: 100%;
      pointer-events: none;
      background: transparent !important;
      z-index: 9;
      text-align: center;
    }
    .mirae-line[mira-editor-el] {
      pointer-events: none;
      box-sizing: border-box;
      width: 0px;
      height: 0px;
      left: 0;
      top: 0;
      transform-origin: center;
      transform: translate(var(--x), var(--y));
    }
    .mirae-line[mira-editor-el].mirae-line-x {
      width: 1px;
      height: var(--len);
      border-left: 1px dashed var(--miraeRefLineColor);
    }
    .mirae-line[mira-editor-el].mirae-line-x.mirae-line-solid {
      border-left: 1px solid var(--miraeRefLineColor);
    }
    .mirae-line[mira-editor-el].mirae-line-y {
      height: 1px;
      width: var(--len);
      border-top: 1px dashed var(--miraeRefLineColor);
    }
    .mirae-line[mira-editor-el].mirae-line-y.mirae-line-solid {
      border-top: 1px solid var(--miraeRefLineColor);
    }
    .mirae-line[mira-editor-el].mirae-line-canvas {
      width: var(--width);
      height: var(--height);
      border: 1px solid var(--miraeRefLineColor);
    }
  `,
  ""
]);
createStyleManager$1(styleList, createStyleOption$1());
styleList.locals && styleList.locals;
class EditorLineElement extends CustomHtmlElementBase {
  init() {
    return this.addClass(this.constructor.STYLE_CLASS), super.init();
  }
  get opType() {
    return this.type === "x" ? "y" : "x";
  }
  range(e) {
    e = this.forceRange || e;
    const t = Math.floor(e[0] * this.scale), r = Math.ceil((e[1] - e[0]) * this.scale);
    return this.setStyleVars({
      [`--${this.opType}`]: `${t}px`,
      "--len": `${r}px`
    });
  }
  setOpts({ type: e, val: t, range: r, scale: a, key: s, canvas: u }) {
    if (this.scale = a, this.type = e, s === "canvas") {
      if (this.addClass(`${this.constructor.STYLE_CLASS}-solid`), t = t.toFixed(1), e === "x" && u.center.x.toFixed(1) !== t || e === "y" && u.center.y.toFixed(1) !== t)
        return this.showCanvasBounds({ val: t, range: r, canvas: u });
      this.forceRange = [0, 2 * u.center[this.opType]];
    } else s && this.addClass(`debug-${s}`);
    return this.setStyleVars({
      [`--${e}`]: `${Math.floor(t * this.scale)}px`
    }).range(r);
  }
  showCanvasBounds({ val: e, range: t, canvas: r }) {
    this.addClass(`${this.constructor.STYLE_CLASS}-canvas`);
    const a = {
      "--x": `${Math.floor(r.x * this.scale)}px`,
      "--y": `${Math.floor(r.y * this.scale)}px`,
      "--width": `${Math.ceil(r.width * this.scale + 1)}px`,
      "--height": `${Math.ceil(r.height * this.scale + 1)}px`
    };
    return this.forceRange = [r[this.type], 0], this.setStyleVars(a);
  }
  static create(e) {
    const { container: t, type: r } = e, a = `${this.STYLE_CLASS}-${r}`;
    return super.create(t).addClass(a).setOpts(e);
  }
}
Ct(EditorLineElement, "TAG", "mira-editor-line"), Ct(EditorLineElement, "STYLE_CLASS", "mirae-line");
EditorLineElement.register();
const drawingCanvas = "canvas", shiftKeys = ["Shift"];
class yControlState extends ComponentBase {
  constructor(e) {
    super(e), this.limit = e.opts.refLineRange, this.selector = e.controls.select, this.refBounds = {}, this._controls = {}, this.wrap(this.selector, "showSelect").after(
      (r, a) => {
        a && a.visible && a.getAnchor && (this.createProxyNode(a), this.updateConstraint());
      }
    );
    const t = this;
    for (const r of ["resize", "rotate", "move"])
      e.controls[r] && (this.wrap(e.controls[r], "onMoveStart").after(
        () => t.onMoveStart()
      ), this.wrap(e.controls[r], "onMove").before(
        (a) => [t.onMove(r, a[0])]
      ), this.wrap(e.controls[r], "onMoveEnd").after(
        () => t.onMoveEnd()
      ));
  }
  events() {
    return {
      keydown: this.onKeyDown(),
      keyup: this.onKeyUp(),
      [RESIZE]: this.onResize()
    };
  }
  onKeyDown() {
    return (e) => {
      Object.keys(EditorMoveComponent.KEY_MAP).includes(e.key) && (this.limit = this.scale), shiftKeys.includes(e.key) && (this.limit = this.scale);
    };
  }
  onKeyUp() {
    return (e) => {
      shiftKeys.includes(e.key) && (this.limit = this.editor.opts.refLineRange), this.lock(1e3, () => this.hideAll(), "hide");
    };
  }
  onResize() {
    return (e) => {
      this.container && this.container.remove(), this.container = null, this.lock(500, () => this.updateConstraint(), "resize");
    };
  }
  initContainer() {
    for (this.container || (this.container = document.createElement("div"), this.container.classList.add("mirae-constraint"), this.container.setAttribute("mira-editor-el", "")), this.container.parentNode !== this.selector.container && (this.container.remove(), this.selector.container.append(this.container)); this.container.firstChild; )
      this.container.removeChild(this.container.firstChild);
    this.refBounds = {}, this.scale = this.editor.scale;
  }
  onMoveStart() {
    this.ref = {};
  }
  onMove(e, t) {
    var a;
    if (!this.selected || !this.editor.opts.enableCanvasConstraint || (a = this.editor.controls.move) != null && a.editMode)
      return t;
    t.event.shiftKey ? this.limit = this.scale : this.limit = this.editor.opts.refLineRange;
    const r = this.editor.controls[e].getDelta(t);
    return ComponentBase.apply(this.selected, r, "proxy"), typeof this[e] == "function" && this[e].call(this, t, r), t;
  }
  onMoveEnd() {
    this.hideAll();
  }
  createProxyNode(e) {
    if (e.cropMode)
      return this.selected = null;
    if (this.selected && this.selected.destroy(), this.selected = VNode$1.from(e), this.editor.opts.debugCanvasConstraint) {
      const { container: t, scale: r } = this;
      this.debug_box && this.debug_box.remove(), this.debug_box = EditorBoxElement.create({
        node: this.selected,
        container: t,
        scale: r
      }).addClass("mirae-debug-box"), this.selected.on(CHANGING, () => this.debug_box.fit(r));
    }
  }
  updateConstraint() {
    this.initContainer();
    const e = this.selector.recordTarget();
    if (!e)
      return;
    const t = Array.isArray(e) ? e.map((a) => a.id) : [e.id], r = Object.values(this.editor.nodes).filter(
      (a) => !t.includes(a.id) && a.visible
    );
    for (const a of r)
      if (a.type === "creator") {
        const s = {
          w: a.getConf("width"),
          h: a.getConf("height")
        };
        this.canvas = this.refBounds.canvas = PositionUtils.from(s).expand(-this.editor.opts.canvasMarginRef);
      } else a.getAnchor && (this.refBounds[a.id] = EditorBoxElement.create({
        node: a
      }).bounds());
  }
  resize(e, t) {
    (!this._resizeTarget || this._resizeTarget != e.target) && (this._resizeTarget = e.target, this.createProxyNode(this.selector.selected), ComponentBase.apply(this.selected, t, "proxy"));
    const r = this.selected.bounds(), a = this.selector.selectedBox.bounds(), s = e.target.boundingConstraint(), u = {
      x: [MAX, null],
      y: [MAX, null]
    };
    for (const d of ["x", "y"]) {
      const f = `${d}s`, p = r[f].call(r);
      a[f].call(a);
      const m = p.map(
        (x, g) => s[d][g] ? x : MAX
      );
      if (m.filter((x) => x !== MAX).length === 0)
        continue;
      for (const [x, g] of Object.entries(
        this.refBounds
      )) {
        const _ = g[f].call(g), T = yControlState.minDist(m, _);
        T[0] < u[d][0] && (u[d] = [...T, x]);
      }
      const y = e.target.reverse(
        {
          [d]: u[d][0]
        },
        true
      );
      y ? u[d][0] = y.r : u[d][0] = MAX;
    }
    const l = u.x[0] < u.y[0] ? "x" : "y", c = u[l];
    this.stick({
      k: l,
      oriRect: a,
      rect: r,
      r: c,
      setEventDelta: (d, f, p) => {
        if (d === f)
          return e.delta = {
            x: 0,
            y: 0
          };
        const m = p === 0 ? -1 : 1, y = m * (f - d > 0 ? 1 : -1), x = e.target.reverse({
          [l]: m * Math.abs(f - d)
        });
        x && (e.delta = dmap(
          x,
          (g) => g * y
        ), this.hideLine(l === "x" ? "y" : "x"));
      }
    });
  }
  rotate(e) {
    const t = deg(this.selected.getRotation(), 2), r = this.selector.selected, a = Math.round(t / 90) * 90, s = a % 180 == 0 ? "x" : "y";
    if (Math.abs(t % 90) < this.limit * 0.5) {
      const u = `rot_${a}`;
      if (e.delta = {
        x: 0,
        y: 0
      }, !this.ref[s] || this.ref[s] !== u) {
        const l = rad(a), c = r.creator().currentTime / 1e3;
        r.setRotate(l), r.emit(CHANGING, {
          action: EditorRotateComponent.type,
          delta: l - r.getRotation(),
          time: c
        }), this.ref[s] = u;
        const d = this.selector.selectedBox.position, f = this.selected.bounds().expand(30);
        this.showLine("x", d.x, [f]), this.showLine("y", d.y, [f]);
      }
    } else this.ref[s] && (this.ref[s] = null, this.hideAll());
  }
  move(e) {
    if (!this.selected || !this.selector.selectedBox)
      return;
    const t = this.selected.bounds(), r = this.selector.selectedBox.bounds(), a = {
      x: [MAX, null],
      y: [MAX, null]
    };
    for (const [s, u] of Object.entries(
      this.refBounds
    )) {
      const { x: l, y: c } = yControlState.minDist(
        t,
        u
      );
      l[0] < a.x[0] && (a.x = [...l, s]), c[0] < a.y[0] && (a.y = [...c, s]);
    }
    for (const [s, u] of Object.entries(a)) {
      u[0] *= this.scale;
      const l = (c, d) => e.delta[s] = (d - c) * this.scale;
      this.stick({
        k: s,
        oriRect: r,
        rect: t,
        r: u,
        setEventDelta: l
      });
    }
  }
  stick({
    k: e,
    oriRect: t,
    rect: r,
    r: [a, s, u, l],
    setEventDelta: c
  }) {
    if (!this.ref)
      return;
    const d = (f, p, m, y) => {
      const x = `${f}s`, g = p < 0 ? 0 : t[x].call(t)[p], _ = m < 0 ? 0 : y[x].call(y)[m];
      return c(g, _, p, m), _;
    };
    if (a < this.limit) {
      const f = this.refBounds[l], p = `${s}_${u}_${l}`;
      let m;
      this.ref[e] && this.ref[e] === p ? m = d(e, -1, -1) : (m = d(
        e,
        s,
        u,
        f
      ), this.hideLine(e), this.ref[e] = p), this.showLine(
        e,
        m,
        [t, f],
        l === drawingCanvas ? drawingCanvas : null
      );
    } else this.ref[e] && (d(e, s, s, r), this.hideLine(e));
  }
  showLine(e, t, r, a = null) {
    const s = e === "x" ? "ys" : "xs", u = r.reduce(
      (c, d) => d[s].call(d, false).concat(c),
      []
    ), l = [Math.min(...u), Math.max(...u)];
    if (this._controls[e])
      this._controls[e].range(l);
    else {
      const {
        container: c,
        scale: d,
        canvas: f
      } = this;
      this._controls[e] = EditorLineElement.create({
        container: c,
        scale: d,
        type: e,
        val: t,
        range: l,
        key: a,
        canvas: f
      });
    }
    return this;
  }
  hideLine(e) {
    return this._controls[e] && this._controls[e].remove(), this._controls[e] = null, this.ref[e] = null, this;
  }
  hideAll() {
    Object.keys(this._controls).map((e) => this.hideLine(e));
  }
  remove() {
    this.hideAll(), this.container = null, this.debug_box && this.debug_box.remove(), this.debug_box = null;
  }
  static minDist(e, t) {
    if (e instanceof DOMRect && t instanceof DOMRect)
      return {
        x: this.minDist(e.xs(), t.xs()),
        y: this.minDist(e.ys(), t.ys())
      };
    if (Array.isArray(e) && Array.isArray(t)) {
      let r = [MAX, -1, -1];
      for (const [a, s] of e.entries())
        for (const [u, l] of t.entries()) {
          const c = Math.abs(s - l);
          c < r[0] && (r = [c, a, u]);
        }
      return r;
    }
  }
}
const controlClasses = [EditorSelectComponent, EditorMoveComponent, EditorResizeComponent, EditorRotateComponent, EditorCropComponent, EditorFitComponent, yControlState], EditorControls = {
  Select: EditorSelectComponent,
  Resize: EditorResizeComponent,
  Move: EditorMoveComponent,
  Rotate: EditorRotateComponent,
  Crop: EditorCropComponent,
  Fit: EditorFitComponent,
  Line: yControlState,
  MiraEditorBox: EditorBoxElement,
  MiraEditorMove: EditorMoveElement,
  MiraEditorResize: EditorResizeElement,
  MiraEditorRotate: EditorRotateElement,
  MiraEditorCrop: EditorCropElement,
  MiraEditorFit: EditorFitElement,
  MiraEditorLine: EditorLineElement,
  addControls: function(i2, e) {
    return controlClasses.filter(
      (t) => !Array.isArray(e) || e.includes(t) || e.includes(t.type)
    ).map((t) => (i2.controls[t.type.toLowerCase()] = new t(
      i2
    ), i2.controls[t.type.toLowerCase()]));
  }
}, { Select, Move, Rotate, Resize, Crop, addControls } = EditorControls, defaultOpts = {
  majorColor: "#FFFFFF",
  selectedColor: "#FFFFFF",
  // 默认选中颜色 #1FB0F9
  highlightColor: "#FFFFFF",
  cropColor: "#E33",
  refLineColor: "#F8DD0B",
  textSelectionColor: "#7FD4FF",
  textCursorColor: "#EFEFEF",
  types: {},
  refLineRange: 10,
  canvasMarginRef: 30,
  enableCanvasConstraint: true,
  enableTrackConstraint: true,
  menuItems: [],
  enableKeyboard: true,
  keyboardPlay: false,
  tapPlay: false,
  cover: false,
  enableCursorPreview: true,
  enableClipMark: false,
  enableGroup: true,
  enableDragChangeParent: true,
  followTimeMark: true,
  debugCanvasConstraint: false
}, defaultFileConfig = {
  gif: true,
  text: true,
  rect: true,
  image: true,
  video: true,
  richtext: true
}, UIInteraction = {
  get mctrlKey() {
    return this.ctrlKey || this.metaKey;
  }
};
let player, playerColor, cachedResource, playerTypes;
mixin$3({
  src: UIInteraction,
  dst: KeyboardEvent
});
mixin$3({
  src: UIInteraction,
  dst: MouseEvent
});
class Editor extends ExtendedEventEmitter {
  constructor(e) {
    if (super(), !(() => {
      if (player)
        return true;
      player = index$2, playerColor = player.utils.ColorUtil.color, cachedResource = player.utils.CacheUtil.cachedResource, player.utils.CacheUtil.cacheNode, playerTypes = player.TYPES;
      const { CanvasRenderer: r, WebGLRenderer: a, DisplayObject: s } = player.InkPaint;
      return r.registerPlugin("interaction", InteractionManager), a.registerPlugin("interaction", InteractionManager), mixin$3({
        src: interactiveTarget,
        dst: s
      }), true;
    })())
      throw new Error("player.js need loaded!");
    this.initOptions(e), this.initHistory(), this.enabled = false, this.queue = new TaskQueue(), this._keyHist = [], this.controls = {};
    const t = this.opts.previewContainer;
    if (!t.offsetWidth || !t.offsetHeight)
      throw new Error("player container null size!");
    this.playerWrapper = player.create(t, this.opts), this.player = this.playerWrapper.player, this.initEvents();
  }
  initEvents() {
    this.nodes = {}, this.nodeCbs = {}, this.nodeCbs[CHANGING] = (e) => this.emit(CHANGING, e), this.nodeCbs[HOVER] = (e) => this.emit(HOVER, e), this.nodeCbs[SELECT] = this.onSelect(), this.nodeCbs[CROPFRAME] = this.onCrop(), this.bodyCbs = {}, this.bodyCbs.keyup = this.onKeyUp(true), this.bodyCbs.keydown = this.onKeyDown(true), this.bodyCbs.mousemove = this.onMouseMove(true), this.bodyCbs.mouseout = this.onMouseMove(true), this.docCbs = {}, this.docCbs.click = this.onDocClick(), this.playerCbs = {}, this.playerCbs.emptied = () => this.disable(), this.playerCbs.pause = (e) => {
      this.enable(), this.emit("pause", e);
    }, this.playerCbs.ended = (e) => {
      this.enable(), this.emit("ended", e);
    }, this.playerCbs.playing = (e) => {
      this.disable(), this.controls.select && this.controls.select.hideAll(), this.emit("playing", e);
    }, this.playerCbs.timeupdate = (e) => {
      this.emit("timeupdate", e);
    }, this.playerCbs.resize = () => {
      this.initContainer(this.playerWrapper.container);
    }, this.playerCbs.canplay = (e) => {
      this.enable(), this.creator.setConf(
        "adjustPlaySpeed",
        navigator && navigator.userAgent.toLowerCase().includes("chrome".toLowerCase())
      );
      const t = this.opts.trackContainer;
      if (t) {
        if (!t.offsetWidth || !t.offsetHeight)
          throw new Error("track container null size!");
        this.initTrackBoard(this.opts.trackContainer);
      }
      this.emit("canplay", e), this.emit("ready", e);
    }, this.applyPlayerEvents(true);
  }
  initOptions(e) {
    this.opts = e || {};
    for (const [t, r] of Object.entries(defaultOpts))
      this.opts[t] === void 0 && (this.opts[t] = r);
    for (const [t, r] of Object.entries(defaultFileConfig))
      this.opts.types[t] === void 0 && (this.opts.types[t] = r);
    this.colors = {
      "--miraeBorderColor": playerColor(this.opts.majorColor, 100),
      "--miraeCropBorderColor": playerColor(this.opts.cropColor, 100),
      "--miraeSelBorderColor": playerColor(this.opts.selectedColor, 100),
      "--miraeRefLineColor": playerColor(this.opts.refLineColor, 100),
      "--miraeHighlightColor": playerColor(this.opts.highlightColor, 100)
    };
  }
  initHistory() {
    this._history = new History(this), this._history.on(History.EVENTS.change, (e) => {
      this.updateNodes(e.record);
      const { currentIndex: t } = this._history;
      this.emit(CHANGED, {
        ...e,
        currentIndex: t,
        action: e.record.action
      });
    }), this._history.on(History.EVENTS.undo, (e) => {
      this.updateNodes(e.record, true), this.emit(CHANGED, {
        ...e,
        action: e.type
      });
    }), this._history.on(History.EVENTS.redo, (e) => {
      this.updateNodes(e.record, false), this.emit(CHANGED, {
        ...e,
        action: e.type
      });
    });
  }
  initContainer(e) {
    for (const t of e.querySelectorAll(
      ".mira-editor"
    ))
      t !== this.container && e.removeChild(t);
    if (!this.container || this.container.parentElement !== e) {
      this.container && (this.parents = null, this.container.remove()), this.container = document.createElement("div"), this.container.classList.add("mira-editor"), this.container.setAttribute("mira-editor-el", "");
      for (const [t, r] of Object.entries(this.colors))
        this.container.style.setProperty(t, r);
      for (e.append(this.container), this.onCtrClick = this.onCanvasClick(), e.addEventListener("click", this.onCtrClick), this.parents = [e]; e = e.parentElement; )
        this.parents.push(e);
    }
    if (this.container.style.top = "-100%", this.container.style.width = this.player.canvasStyle.width, this.container.style.height = this.player.canvasStyle.height, this.container.style.margin = this.player.canvasStyle.margin, this.emit(RESIZE), this.player.opts.hideControls !== true) {
      const t = this.player.$refs.player;
      t.style.overflow = "visible";
      const r = t.querySelectorAll(".mirap-controls")[0];
      r.style.bottom = "-39px", r.style.background = "#333";
    }
  }
  initTrackBoard(e) {
    for (const t of e.querySelectorAll(".mira-editor"))
      t !== this.board && e.removeChild(t);
    (!this.board || this.board.container !== e) && (this.board && this.board.destroy(), this.board = new EditorBoardComponent(this.player.creator, e, this)), this.keyboardPlay || (this.keyboardPlay = (t) => {
      var a;
      if (!this.opts.enableKeyboard)
        return;
      const r = (a = this.controls) == null ? void 0 : a.select;
      t.key === " " && r && (r.locked("togglePlay") || (r.lock(300, null, "togglePlay"), this.playerWrapper.playing ? this.playerWrapper.pause() : this.enabled && this.playerWrapper.play()), t.preventDefault());
    }, document.body.addEventListener("keydown", this.keyboardPlay));
  }
  boardScale(e) {
    this.board.onScale(e);
  }
  log(...e) {
    this.player && this.player.log(...e);
  }
  error(...e) {
    console.error(...e);
  }
  get playing() {
    return this.playerWrapper.playing;
  }
  play() {
    this.playerWrapper.play();
  }
  pause() {
    this.playerWrapper.pause();
  }
  get preview() {
    return this.playerWrapper;
  }
  get scale() {
    return this.player && this.player.scale;
  }
  get duration() {
    return this.player.creator.duration;
  }
  get currentTime() {
    return this.player.opts.currentTime;
  }
  set currentTime(e) {
    if (this.currentTime.toFixed(3) !== e.toFixed(3))
      return this.board ? this.board.mark(e) : this.player.seek(e);
  }
  get spineTrack() {
    return this.board.tracks.find(
      (e) => e.type == TYPE_SPINE
    );
  }
  get creator() {
    return this.player.creator;
  }
  get canvas() {
    return this.creator.app.view;
  }
  toast(e, t) {
    this.player && this.player.toast(e, t);
  }
  dispatch(e) {
    this.enabled && this.emit(e.type, e);
  }
  updateNodes(e, t = false) {
    e.mapAttr((r, a) => {
      r && r.active && r.parent && (r.updateAnimations && r.updateAnimations(), r.allNodes.map(
        (s) => s.updateAnimations && s.updateAnimations()
      ));
    });
  }
  onMouseMove() {
    return (e) => {
      var t, r, a;
      this.enabled && (this.lastMouseEvent = e, this.emit("mousemove", e), (t = this.board) != null && t.withMulti && !e.mctrlKey && this.board.enableMulti(false), (a = (r = this.controls) == null ? void 0 : r.select) != null && a.withMulti && !e.mctrlKey && this.controls.select.enableMulti(false));
    };
  }
  enableKeyboard(e) {
    this.opts.enableKeyboard = e;
  }
  onKeyUp(e) {
    return (t) => {
      this.enabled && this.opts.enableKeyboard && this.emit(t.type, t);
    };
  }
  onKeyDown(e) {
    return (t) => {
      var s, u;
      if (!this.enabled || !this.opts.enableKeyboard)
        return;
      const r = `${t.key}`.toLowerCase();
      this._keyHist.push(r), this._keyHist.length > 30 && this._keyHist.splice(0, this._keyHist.length - 30), this._keyHist.join("").endsWith("showmethecode") ? (async () => {
        let l = await this.toJson();
        l = JSON.stringify(l, null, 2);
        try {
          navigator.clipboard.writeText(l), this.player.toast("source copied!");
        } catch {
        }
      })() : this._keyHist.join("").endsWith("showmetheversion") && this.player.toast(
        `E:${this.version} * P:${this.player.version}`,
        3e4
      );
      const a = `keyboard_${r}`;
      if ((s = this.controls.select) != null && s.locked(a))
        return t.preventDefault();
      if (r === "z" && t.mctrlKey)
        t.shiftKey ? this.redo() : this.undo();
      else if (r === "y" && t.mctrlKey)
        this.redo();
      else if (r !== "enter" || ((u = this.selected[0]) == null ? void 0 : u.cropMode) !== "frame" || this.controls.select.cropMode)
        if (r === "escape")
          this.board && this.board.hasMenu() ? this.board.hideMenu() : (this.emit(SELECT), this.board && this.board.escape());
        else {
          if (!["+", "-", "=", "_"].includes(r) || !this.board || this.responder !== "board")
            return this.emit(t.type, t);
          {
            let l = ["-", "_"].includes(r) ? -0.01 : 0.01;
            (t.mctrlKey || t.shiftKey) && (l *= 10), this.board.onScale(this.board.relativeScale + l);
          }
        }
      else
        this.setCropMode(false);
      this.controls.select.lock(100, null, a), t.preventDefault();
    };
  }
  applyPlayerEvents(e) {
    const t = this.playerWrapper;
    for (const [r, a] of Object.entries(this.playerCbs))
      e ? t.on(r, a) : t.off(r, a);
  }
  enable(e = null) {
    this.enabled = true, e = e || this.opts, this.apply({
      ...e,
      enable: true
    }), this.emit("enable", {
      enabled: true
    });
    for (const [t, r] of Object.entries(this.bodyCbs))
      document.body.addEventListener(t, r);
    for (const [t, r] of Object.entries(this.docCbs))
      document.addEventListener(t, r);
  }
  disable(e = null) {
    this.enabled = false, e = e || this.opts, this.apply({
      ...e,
      enable: false
    }), this.emit("enable", {
      enabled: false
    });
    for (const [t, r] of Object.entries(this.bodyCbs))
      document.body.removeEventListener(t, r);
    for (const [t, r] of Object.entries(this.docCbs))
      document.removeEventListener(t, r);
  }
  getActions(e, t) {
    return e && t ? !t.display || t.conf.asMask ? [] : ["base"] : null;
  }
  apply(e) {
    let { node: t, types: r, enable: a, recursive: s } = e;
    const u = a ? Interaction.bindActions : Interaction.unbindActions;
    if (t = t || this.player.creator, !t)
      return;
    const l = this.getActions(r, t);
    if (l !== null) {
      u(t, l);
      for (const [c, d] of Object.entries(this.nodeCbs))
        a && !t.listeners(c).includes(d) ? t.on(c, d) : a || t.off(c, d);
      a ? this.nodes[t.id] = t : delete this.nodes[t.id];
    }
    s !== false && t.children && t.children.length > 0 && t.children.map(
      (c) => this.apply({
        ...e,
        node: c
      })
    );
  }
  onCrop() {
    return (e) => {
      this.canCropFrame && this.selected[0] === e.target && this.setCropMode(true);
    };
  }
  onSelect() {
    return (e) => {
      var t;
      this.emit(SELECT, e), this.controls.select.lock(
        100,
        null,
        `select-${((t = e.target) == null ? void 0 : t.id) || "NULL"}`
      );
    };
  }
  onDocClick() {
    return (e) => {
      this.board && this.board.hideMenu();
    };
  }
  onCanvasClick() {
    return (e) => {
      this.controls.select.locked("select") || this.controls.select.lock(
        100,
        () => {
          this.emit(SELECT);
        },
        "select"
      );
    };
  }
  undo(e = 1, t = true) {
    t && this.controls.select.hideAll();
    const r = this._history.undo(e);
    t && r.some(
      (a) => [OP_ADD, OP_DELETE].includes(a.action)
    ) && this.emit(SELECT);
  }
  redo(e = 1, t = true) {
    t && this.controls.select.hideAll();
    const r = this._history.redo(e);
    t && r.some(
      (a) => [OP_ADD, OP_DELETE].includes(a.action)
    ) && this.emit(SELECT);
  }
  get history() {
    return this._history.records;
  }
  get currentHistoryIndex() {
    return this._history.currentIndex;
  }
  get selected() {
    var t, r;
    const e = this.board ? this.board.selected : (r = (t = this.controls) == null ? void 0 : t.select) == null ? void 0 : r.selected;
    return e && e.nodes ? Object.values(e.nodes) : e ? [e] : [];
  }
  appendHistory(e) {
    this._history.append(e);
  }
  hideSelect() {
    var e, t;
    (e = this.controls) != null && e.select && ((t = this.controls) == null || t.select.hideSelect()), this.board && this.board.hideSelect(), this.emit(SELECT);
  }
  async delNode(e, t = true, r = true) {
    var s;
    if (!this.enabled || !((s = this.controls) != null && s.select))
      return;
    let a;
    if (Array.isArray(e) ? a = e.map((u) => this.nodes[u.id]) : a = [this.nodes[e.id]], a[0] !== void 0)
      return await this.queue.enqueue(async () => {
        const u = new EditorGroup(a);
        u.addEventsTo(this, true), this.controls.select.delete(u, t, r);
        const l = this.controls.select.record;
        return u.addEventsTo(this, false), u.destroy(), t || (this.controls.select.record = null), l;
      });
  }
  dragAdd(e) {
    Array.isArray(e) || (e = [e]), this.dragNodes = [];
    for (const t of e) {
      if (!t || !t.type)
        continue;
      let r = playerTypes.node;
      t.type === "trans" && (r = playerTypes.trans), t.parent || (t.parent = this.creator);
      const a = new r(t);
      a.isVirtual = true, a.display = null, a.id = `vn_${a.id}`, this.dragNodes.push(a);
    }
  }
  async dragEnd() {
    var e;
    if (this.board.dragClips) {
      const t = this.board.dragClips.map((r) => {
        var s;
        const a = r.node.toJson();
        if (a.parent = r.node.parent, a.trackId = r.shadowTrack.id, ((s = r.node.parent) == null ? void 0 : s.type) === TYPE_SPINE) {
          delete a.start;
          const u = r.node.nextSibling;
          u && this.nodes[u.id] && (a.nextSibling = u);
        }
        return r.node.parent && r.node.parent.removeChild(r.node), r.node.destroy(), r.destroy(), a;
      });
      if (t.length && t[0].type) {
        this.hideSelect();
        let r = null;
        const a = [];
        for (const s of a.reverse()) {
          ((e = s.parent) == null ? void 0 : e.type) === TYPE_SPINE && !s.nextSibling && r && (s.nextSibling = r);
          const { node: u } = await this.addNode(
            s.type,
            s
          );
          r = u, a.push(u);
        }
        a.length > 0 && a[0].emit(SELECT, {
          action: "multi",
          nodes: a
        });
      }
    }
    this.dragCancel();
  }
  dragCancel() {
    var e;
    this.board.dragEnd(), (e = this.dragNodes) == null || e.map((t) => t.remove().destroy()), this.dragNodes = null;
  }
  async addNode(e, t, r = true, a = null) {
    if (!this.enabled)
      return false;
    if (e === "video" && (!Array.isArray(t) && !t.start && !t.parent || Array.isArray(t) && t.filter((s) => s.start || s.parent).length === 0)) {
      const s = this.creator.children.find(
        (u) => u.type === "spine"
      );
      s && !s.children.length && (Array.isArray(t) ? t.map((u) => {
        u.parent = s;
      }) : t.parent = s);
    }
    return await this.queue.enqueue(
      async () => this.add(e, t, r, a)
    );
  }
  async add(e, t, r = true, a = null) {
    var T, E, b, C, w, A, S, F, M, U, B, q, z;
    r && this.board && this.board.showLoading();
    const s = this.player.creator;
    if (Array.isArray(t)) {
      (T = this.board) == null || T.showProgress(0.01);
      const D = [], X = {};
      let k = 0;
      for (const P of t) {
        const G = typeof P == "object" && P.type ? P.type : e, {
          node: W,
          nodes: V,
          delta: K
        } = await this.add(G, P, false, (J) => {
          var ae;
          (ae = this.board) == null || ae.showProgress(
            k / t.length + J / t.length
          );
        });
        typeof P == "object" && (P.node = W), Array.isArray(V) ? V.map((J) => {
          D.push(J), K[J.id] && (X[J.id] = K[J.id]);
        }) : (D.push(V), X[W.id] = K), k++, (E = this.board) == null || E.showProgress(k / t.length);
      }
      const I = new Record(OP_ADD, D, X);
      return r && (this._history.append(I), (b = this.board) == null || b.hideLoading()), {
        nodes: D,
        delta: X,
        record: I
      };
    }
    a || (a = (D) => {
      var X;
      return (X = this.board) == null ? void 0 : X.showProgress(D);
    });
    const u = typeof t == "object" ? {
      ...t
    } : {};
    if (u.canvasWidth = s.width, u.canvasHeight = s.height, ["video", "image"].includes(e)) {
      if (typeof t == "string" && (u.src = t), !u.width && !u.height)
        if ((w = (C = u.userfile) == null ? void 0 : C.file) != null && w.width && ((S = (A = u.userfile) == null ? void 0 : A.file) != null && S.height)) {
          const D = ((M = (F = u.userfile) == null ? void 0 : F.file) == null ? void 0 : M.width) / ((B = (U = u.userfile) == null ? void 0 : U.file) == null ? void 0 : B.height);
          s.width / s.height > D ? u.height = "100vh" : u.width = "100vw";
        } else
          u.width = "100vw", u.height = "100vh";
      u.x === void 0 && (u.x = "50vw"), u.y === void 0 && (u.y = "50vh");
    }
    e === "audio" && typeof t == "string" && (u.src = t), e === "text" && (typeof t == "string" && (u.text = t), u.width || (u.width = "100vw"), u.x === void 0 && (u.x = "50vw"), u.y === void 0 && (u.y = "80vh"), u.fontSize || (u.fontSize = 30), u.fontFamily || (u.fontFamily = "https://mira-1255830993.cos.ap-shanghai.myqcloud.com/fonts/OPPOSansMedium.ttf"), u.stroke || (u.stroke = {
      color: "#000000",
      size: "10%"
    }), u.wrap = true);
    let l, c = s;
    if (u.parent && s.allNodes.includes(u.parent) && (c = u.parent), u.nextSibling && s.allNodes.includes(u.nextSibling) && (l = u.nextSibling, delete u.nextSibling), c !== s && (!((q = this.nodes[c.parent.id]) != null && q.children.includes(c)) || !Object.values(this.nodes).includes(c)))
      throw new Error("Make sure parent exists and is not Proxy!!!");
    u.type || (u.type = e), u.parent = c;
    const d = await this.player.genNode(u, (D) => {
      console.log("genNode", D);
    });
    u.trackId && (d.trackId = u.trackId, d.trackId === ((z = this.spineTrack) == null ? void 0 : z.id) && c.type !== TYPE_SPINE && (d.trackId = null));
    const f = d.allNodes;
    let p = 1;
    if (f.length) {
      p = 0;
      const D = 1 / f.length;
      for (const X of f)
        await X.preProcessing((k) => {
          a && a(
            0.3 + (p + D * k) * 0.6
          );
        }), p += D;
    }
    if (await d.preProcessing((D) => {
      a && a(0.9 + 0.1 * D);
    }), d.annotate(), await d.prepareMaterial(), f.length)
      for (const D of f)
        D.annotate(), await D.prepareMaterial();
    d.remove();
    const m = {
      parent: c
    };
    l && (m.nextSibling = l);
    let y = ViewComponentBase.apply(
      d,
      {
        to: m
      },
      OP_ADD
    ), x = d;
    c !== s && (y = {
      [d.id]: y,
      [c.id]: ViewComponentBase.apply(
        c,
        {
          to: {
            changed: true
          }
        },
        OP_CHANGE
      )
    }, x = [d, c]);
    const g = new Record(OP_ADD, x, y);
    r ? this._history.append(g) : this.updateNodes(g);
    const _ = {
      types: this.opts.types,
      recursive: true,
      enable: true
    };
    return this.apply({
      ..._,
      node: d
    }), d.emit(CHANGING, {
      action: OP_END
    }), r && this.board && this.board.hideLoading(), typeof t == "object" && (t.node = d), this.board && this.board.scrollToVisible(d), {
      node: d,
      nodes: x,
      delta: y,
      record: g
    };
  }
  async applyChange(e, t, r = true, a = OP_CHANGE) {
    return !!this.enabled && await this.queue.enqueue(async () => {
      let s = {};
      this.board && this.board.showLoading();
      let u = 0, l = 1;
      const c = async (f, p, m) => {
        var x;
        let y = false;
        if (cachedResource) {
          const g = ["text"], _ = {
            src: "cachedSrc",
            fontFamily: "cachedFontFamily"
          };
          for (const T of Object.keys(_)) {
            if (!((x = p[T]) != null && x.startsWith("http")) || !g.includes(f.type))
              continue;
            const { url: E } = await cachedResource(
              p[T],
              ({ total: b, loaded: C }) => {
                var w;
                (w = this.board) == null || w.showProgress(
                  u + C / (b * l)
                );
              }
            );
            p[_[T]] = E, y = true;
            break;
          }
        }
        return await ViewComponentBase.set(
          f,
          p,
          m,
          (g) => {
            var _;
            y || (_ = this.board) == null || _.showProgress(
              u + g / l
            );
          }
        );
      };
      if (Array.isArray(e)) {
        let f = 0;
        l = e.length;
        for (const p of e)
          u = f / l, f += 1, p && t[p == null ? void 0 : p.id] && (s[p.id] = await c(
            p,
            t[p.id],
            a
          ));
        s.time = e[0].absShowStartTime;
      } else {
        if (!(e != null && e.type)) {
          this.board && this.board.hideLoading();
          return;
        }
        s = await c(
          e,
          t,
          a
        ), s.time = e.absShowStartTime;
      }
      const d = new Record(
        a,
        e,
        s
      );
      return r ? this._history.append(d) : this.updateNodes(d), this.board && this.board.hideLoading(), this.controls.select && this.controls.select.lock(
        100,
        () => {
          this.controls.select.fit();
        },
        "fit"
      ), d;
    });
  }
  async split(e, t = null, r = true) {
    const a = this.nodes[e == null ? void 0 : e.id];
    return await this.queue.enqueue(async () => {
      let s, u = 0;
      if (Array.isArray(t) ? (s = t[0], u = t[1]) : Number.isFinite(t) ? s = t : s = this.board.currentMarkTime(), !a || !u && (!s || Math.min(
        s - a.absStartTime,
        a.absEndTime - s
      ) < 0.2))
        return false;
      this.board && this.board.showLoading();
      const l = await this.cloneNode(a), c = {
        parent: a.parent,
        active: true
      };
      a.conf.end && (c.end = "NULL"), c.duration = s - a.absStartTime, a.parent.isTrack && (c.nextSibling = a);
      const d = {};
      a.conf.end && (d.end = "NULL"), a.parent.isTrack || (d.start = a.startTime + c.duration + u), a.material && !a.loop && (d.ss = a.material.getStartOffset() + c.duration + u), d.duration = a.duration - c.duration - u;
      let f = [];
      for (const m of a.children)
        m.absStartTime < s && f.push(m.id);
      const p = [
        ...a.children,
        a,
        l
      ];
      c.duration > 0 && ViewComponentBase.apply(
        l,
        {
          to: c
        },
        OP_SPLIT,
        {
          relativeNodes: p
        }
      ), d.duration > 0 && ViewComponentBase.apply(
        a,
        {
          to: d
        },
        OP_SPLIT,
        {
          relativeNodes: p
        }
      );
      for (const m of a.children)
        if (f.includes(m.id))
          ViewComponentBase.apply(
            m,
            {
              to: {
                parent: l
              }
            },
            OP_SPLIT,
            {
              relativeNodes: p
            }
          );
        else {
          const y = m.startTime - c.duration - u;
          ViewComponentBase.apply(
            m,
            {
              to: {
                start: y
              }
            },
            OP_SPLIT,
            {
              relativeNodes: p
            }
          );
        }
      r && a.emit(CHANGING, {
        action: OP_END
      }), this.board && this.board.hideLoading();
    });
  }
  async load(e) {
    this.hideSelect(), this.disable(), this.applyPlayerEvents(false), this._history && this._history.destroy(), this._history = null, this.container = null, this.board && (this.board.view.remove(), this.board.destroy(), this.board = null), this.initHistory(), await this.playerWrapper.load(e), this.player = this.playerWrapper.player, this.initEvents();
  }
  resize(e, t) {
    this.player.creator.resize(e, t);
  }
  scrollToVisible(e, t = true) {
    this.board.scrollToVisible(e, t);
  }
  async cloneNode(e) {
    const t = {
      types: this.opts.types,
      recursive: false,
      enable: true
    }, r = new e.constructor({
      ...e.conf,
      refId: null,
      id: null
    });
    return r.parent = e.parent, e.cachedFontFamily && (r.cachedFontFamily = e.cachedFontFamily), r.copySourceId = e.id, r.trackId = e.trackId, await r.preProcessing(), r.annotate(), await r.prepareMaterial(), this.apply({
      ...t,
      node: r
    }), r.disable(), r.parent = null, r;
  }
  showLoading(e = null) {
    var t, r;
    (t = this.board) == null || t.showLoading(), e && ((r = this.board) == null || r.showProgress(e));
  }
  hideLoading() {
    var e;
    (e = this.board) == null || e.hideLoading();
  }
  enableKeyboard(e) {
    this.opts.enableKeyboard = !!e;
  }
  trackScale(e) {
    var t;
    (t = this.board) == null || t.autoScale(e);
  }
  addMenuItem(e, t, r) {
    var a;
    (a = this.opts).menuItems || (a.menuItems = []), this.opts.menuItems.push({
      action: e,
      title: t,
      filter: r
    });
  }
  removeMenuItem(e) {
    var t;
    (t = this.opts).menuItems && (t.menuItems = this.opts.menuItems.filter(
      (r) => r.action !== e
    ));
  }
  get canCropFrame() {
    if (this.selected.length !== 1 || !this.selected[0].setFrame)
      return false;
    const e = this.selected[0];
    return !e.conf["object-fit"] || e.conf["object-fit"] === "cover";
  }
  get splitMode() {
    return this.board.splitMode;
  }
  node(e) {
    const t = typeof e == "function" ? e : (a) => a.id === `${e}`, r = this.creator.allNodes.filter(t);
    return typeof e == "function" ? r : r[0];
  }
  setCropMode(e) {
    if (!this.canCropFrame)
      return;
    const t = this.controls.select, r = this.selected[0];
    t.hideSelect(), r.cropMode = !!e && "frame", setTimeout(() => {
      t.showSelect(r);
    }, 1);
  }
  setSplitMode(e) {
    e ? this.board.onKey("b", {
      type: "keydown"
    }) : this.board.escape();
  }
  async toJson() {
    return await this.queue.enqueue(async () => this.creator.toJson());
  }
  async toImage(e = 0, {
    width: t,
    height: r,
    format: a = "jpeg"
  } = {}) {
    return await this.queue.enqueue(async () => {
      let s;
      for (; !s; )
        s = await this.creator.getPreview(e, {
          width: t,
          height: r,
          format: a
        }), await (0, TimeUtils$1.sleep)(300);
      return s;
    });
  }
  fit() {
    this.playerWrapper && this.playerWrapper.fit();
  }
  destroy() {
    this.disable(), Object.values(this.controls).map(
      (e) => e.destroy()
    ), this.controls = null, this.container && this.onCtrClick && (this.onCtrClick && this.container.parentNode.removeEventListener("click", this.onCtrClick), this.container.remove()), this.container = null, this.board && (this.board.view.remove(), this.board.destroy(), this.board = null), this._history && this._history.destroy(), this._history = null, this.keyboardPlay && (document.body.removeEventListener("keydown", this.keyboardPlay), this.keyboardPlay = null), this.playerWrapper && (this.applyPlayerEvents(false), this.playerCbs = null, this.playerWrapper.destroy(), this.playerWrapper = null, this.player = null), this.lastMouseEvent = null;
  }
  get version() {
    return VERSION$1;
  }
}
const index = {
  actions: Interaction.plugins,
  create: (i2) => {
    const e = new Editor(i2);
    return addControls(e), e;
  }
};
const _hoisted_1 = { class: "card imagen-box" };
const _sfc_main$1 = {
  __name: "index",
  setup(__props) {
    const fileStore = useFileStore();
    const menuStore = useMenuStore();
    const { selectFiles, outPutFormat } = storeToRefs(fileStore);
    const { showPage } = storeToRefs(menuStore);
    const outPutFormRef = ref$3();
    const headerRef = ref$3();
    const validateForm = async () => {
      console.log("validateForm");
      let flag = await outPutFormRef.value.validateForm().catch((err) => err);
      if (flag) {
        headerRef.value.combinVideo();
      }
    };
    const playerWrapper = ref$3(null);
    const playerRef = ref$3(null);
    const tracksRef = ref$3(null);
    const player2 = ref$3(null);
    watch(selectFiles, async (newVal) => {
      console.log(newVal, "selectFiles");
      let temVal = newVal[newVal.length - 1];
      let tempChild = {
        type: "video",
        loop: false,
        audio: false,
        src: temVal.filepath,
        name: temVal.name,
        children: [],
        "x": "50vw",
        "y": "50vh",
        "height": "100vh"
      };
      if (player2.value && Object.keys(player2.value.nodes).length > 2) {
        player2.value.add("video", tempChild);
      } else {
        jsonData2.value.children = [tempChild];
        await player2.value.load(jsonData2);
      }
    }, { deep: true });
    const jsonData2 = reactive({
      previewContainer: playerRef.value,
      trackContainer: tracksRef.value,
      hideControls: true,
      hideMiniBar: true,
      value: {
        "type": "canvas",
        "width": outPutFormat.value.width,
        "height": outPutFormat.value.height,
        "refId": "hehgeigashopg4mn",
        "name": "Composite",
        // "author": "ZhaoJun",
        "children": []
      }
    });
    const initPlayer = (width, height) => {
      const opts2 = {
        value: {
          "type": "canvas",
          "width": width,
          "height": height,
          "name": "Composite",
          "children": fileStore.selectFiles.map((item) => {
            return {
              type: "video",
              loop: false,
              audio: false,
              src: item.filepath,
              name: item.name,
              children: [],
              "x": "50vw",
              "y": "50vh",
              "height": "100vh"
            };
          })
        },
        previewContainer: playerRef.value,
        trackContainer: tracksRef.value,
        hideControls: true,
        hideMiniBar: true
      };
      player2.value = index.create(opts2);
      fileStore.setPlayerInstance(player2.value);
      player2.value.on("select", function(e) {
        var _a, _b;
        console.log("监听editor选中元素的变化", e);
        if (e.target) {
          console.log(e.target);
          console.log((_a = e.target) == null ? void 0 : _a.toJson());
          fileStore.setSelectClip((_b = e.target) == null ? void 0 : _b.conf);
        } else {
          fileStore.setSelectClip({});
        }
      });
    };
    onMounted(() => {
      let width = 1280;
      let height = 720;
      if (playerWrapper.value) {
        let scale = outPutFormat.value.width / outPutFormat.value.height;
        if (playerWrapper.value.offsetHeight > outPutFormat.value.height) {
          height = outPutFormat.value.height;
          width = outPutFormat.value.width;
        } else {
          height = playerWrapper.value.offsetHeight;
          width = playerWrapper.value.offsetHeight * scale;
        }
        playerRef.value.style.width = width + "px";
        playerRef.value.style.height = height + "px";
      }
      showPage.value && initPlayer(width, height);
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1, [
        createVNode(unref(script$1), {
          style: { "height": "100vh" },
          layout: "vertical",
          dt: { "background": "#262626" },
          pt: {
            root: { class: "split-container" },
            gutter: { class: "split-gutter" }
          }
        }, {
          default: withCtx(() => [
            createVNode(unref(script$2), {
              class: "flex",
              size: 8,
              minSize: 8
            }, {
              default: withCtx(() => [
                createVNode(_sfc_main$5, {
                  ref_key: "headerRef",
                  ref: headerRef,
                  onValidateForm: validateForm
                }, null, 512)
              ]),
              _: 1
            }),
            createVNode(unref(script$2), {
              size: 70,
              minSize: 70
            }, {
              default: withCtx(() => [
                createVNode(unref(script$1), { pt: {
                  gutter: { class: "split-gutter" }
                } }, {
                  default: withCtx(() => [
                    createVNode(unref(script$2), {
                      class: "flex",
                      size: 20,
                      minSize: 20
                    }, {
                      default: withCtx(() => [
                        createVNode(_sfc_main$2)
                      ]),
                      _: 1
                    }),
                    createVNode(unref(script$2), {
                      class: "flex items-center justify-center",
                      size: 60,
                      minSize: 60
                    }, {
                      default: withCtx(() => [
                        createBaseVNode("div", {
                          ref_key: "playerWrapper",
                          ref: playerWrapper,
                          class: "w-full h-full flex justify-center",
                          style: { "background-color": "#262626", "align-items": "center" }
                        }, [
                          createBaseVNode("div", {
                            ref_key: "playerRef",
                            ref: playerRef,
                            class: "player"
                          }, null, 512)
                        ], 512)
                      ]),
                      _: 1
                    }),
                    createVNode(unref(script$2), {
                      class: "flex",
                      size: 20,
                      minSize: 20
                    }, {
                      default: withCtx(() => [
                        createVNode(outPutForm, {
                          ref_key: "outPutFormRef",
                          ref: outPutFormRef
                        }, null, 512)
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                })
              ]),
              _: 1
            }),
            createVNode(unref(script$2), {
              class: "flex",
              size: 22,
              minSize: 22
            }, {
              default: withCtx(() => [
                createBaseVNode("div", {
                  ref_key: "tracksRef",
                  ref: tracksRef,
                  class: "tracks"
                }, null, 512)
              ]),
              _: 1
            })
          ]),
          _: 1
        })
      ]);
    };
  }
};
const imgenBox = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["__scopeId", "data-v-6302cf21"]]);
const _sfc_main = /* @__PURE__ */ defineComponent({
  __name: "App",
  setup(__props) {
    const menuStore = useMenuStore();
    const fileStore = useFileStore();
    useToast();
    const { showPage } = storeToRefs(menuStore);
    const checked = showPage;
    const switchRef = ref$3(null);
    const switchChange = (_) => {
      menuStore.changeShow(true);
    };
    let originHost = window.location.origin + "/view?filename=";
    const updateMessage = (message) => {
      console.log("updateMessage", message);
      fileStore.clearFiles();
      let file = {
        filepath: `${originHost}${message.addr}`,
        name: message.addr
      };
      fileStore.addFile(file);
      console.log("fileStore.setOutFormat", fileStore.selectFiles);
      fileStore.setOutFormat("height", message.height);
      fileStore.setOutFormat("width", message.width);
      fileStore.setOutFormat("imageLen", message.imageLen);
      fileStore.setOutFormat("fps", message.fps);
      menuStore.changeShow(true);
    };
    function chainCallback(object, property, callback) {
      if (object == void 0) {
        console.error("Tried to add callback to non-existant object");
        return;
      }
      if (property in object && object[property]) {
        const callback_orig = object[property];
        object[property] = function() {
          const r = callback_orig.apply(this, arguments);
          callback.apply(this, arguments);
          return r;
        };
      } else {
        object[property] = callback;
      }
    }
    const addUploadWidget = function(nodeType, nodeData, type2, icon) {
      chainCallback(nodeType.prototype, "onNodeCreated", function(...arg) {
        this.addWidget("button", "preview", "image", () => {
          if (sessionStorage.getItem("Montagen-output")) {
            console.log("window.sessionStorage.getItem", sessionStorage.getItem("Montagen-output"));
            updateMessage(JSON.parse(sessionStorage.getItem("Montagen-output")));
          }
          menuStore.changeShow(true);
        });
      });
    };
    let tempNodeType = null;
    const init2 = () => {
      if (switchRef.value) {
        switchRef.value.style.display = "none";
        app$1.registerExtension({
          name: "EasymskPage",
          setup(ui) {
            console.log("onUIReady", ui);
            window.myUI = ui;
          },
          async beforeRegisterNodeDef(nodeType, nodeData, app2) {
            if ((nodeData == null ? void 0 : nodeData.name) == "MontagenImagesPreview") {
              tempNodeType = nodeType;
              addUploadWidget(tempNodeType);
              chainCallback(nodeType.prototype, "onExecuted", async function(message) {
                console.log("onExecuted 函数执行成功后返回的数据", message);
                if (message == null ? void 0 : message.videos) {
                  sessionStorage.setItem("Montagen-output", JSON.stringify(message.videos[0]));
                }
              });
            }
          }
        });
      }
    };
    onMounted(() => {
      try {
        init2();
      } catch (e) {
      }
    });
    return (_ctx, _cache) => {
      const _directive_tooltip = Tooltip;
      return openBlock(), createElementBlock(Fragment, null, [
        unref(checked) ? (openBlock(), createBlock(imgenBox, { key: 0 })) : createCommentVNode("", true),
        withDirectives((openBlock(), createElementBlock("div", {
          ref_key: "switchRef",
          ref: switchRef,
          class: "cursor-pointer text-center",
          onClick: switchChange
        }, [
          createVNode(unref(script$3), {
            src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAAAXNSR0IArs4c6QAAAixJREFUaEPtmkuSgjAQhrtB76E30ZvoWsfHbmqwyqFKpmbnY3CtcxK9iRxEyFSkgoQRITFAsHRnEZL++k8/CCDU/Ic1tx+eC2A4W3YIMXYI0NJRGQLgGQTtn6/RntnHKTC0NgcA0tHReGYThdg64/ZNgIG1Punq/bhTXWccOZ5TIA7Q8IP26nvqsRsH1mqHgL3wPx5dZ9RNKjV5X7bOprljKiLBflxuNj4cZ5yi+zHouovp8Z7yQ2tN2HUpgLyLvn1segTJji6WlDtuIL9dbzuEH/8gAJ2sShUeVoACVKmCEoAqVVAGUJUKwgA0gxDDj7IQlyGIOb/WCzwC+nYyg2BgtgIk8ygtI9gAwb9MQ8exoL/kt7R1iXEQykI6F7NcafQJAPBuYSkf8Nri5FIgWYnLN5hfUTiIXwCKJStcAfosQW3OaspkuQoF4Bs4sm/6xI53srJGK2/m0gzhm7ywC0WEX3cx/lRhPJ2jUAWSAMxolSCVAPAgQf+R+KgU4AoiHx9aALCnNJn40AZANj60A4hvq60z6WdlK40BwGv6QTerbmgMQPa1VCCsEflTq14KINiiVVoPAAnDWXBXCiC6XW5lpEoA6t0LPbBdSlcg/jxAT64bvt/PyutZhSt5vdAtdOnXZ8tO4wyeasNLCWJRb8qML1wBGaNE7nkBiHiriLHCChRhhKo5U48W6/Ca9XL2lPaW8nI4xZ39q/KZmnlutSTP9amBGj+VO0vtFfgDiSO5TwE1Yj4AAAAASUVORK5CYII=",
            width: "20"
          })
        ])), [
          [_directive_tooltip, "open MontagenEditor"]
        ])
      ], 64);
    };
  }
});
const ComfyUIPreset = definePreset(index$3, {
  semantic: {
    primary: index$3["primitive"].blue
  }
});
const maskpage = document.createElement("div");
maskpage.id = "comfyui-maskpage";
maskpage.style.cssText = `
  position: relative;
  z-index: 1100;
`;
document.body.append(maskpage);
const app = createApp(_sfc_main);
for (const [key2, component] of Object.entries(ElementPlusIconsVue)) {
  app.component(key2, component);
}
app.use(PrimeVue, {
  theme: {
    preset: ComfyUIPreset,
    options: {
      prefix: "p",
      cssLayer: {
        name: "primevue",
        order: "primevue, tailwind-utilities"
      },
      // This is a workaround for the issue with the dark mode selector
      // https://github.com/primefaces/primevue/issues/5515
      darkModeSelector: ".dark-theme, :root:has(.dark-theme)"
    }
  }
});
app.directive("tooltip", Tooltip);
app.use(ConfirmationService);
app.use(ToastService);
app.use(DialogService);
app.use(createPinia());
app.mount("#" + maskpage.id);
